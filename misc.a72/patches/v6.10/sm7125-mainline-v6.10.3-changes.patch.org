created via: https://github.com/sm7125-mainline/linux/compare/d29de02effd4e8816333582ed8230d41e14a73dc...41d7598f1709e9e747edc67cd7618d7f193099d9.diff

this is from the sm7125-mainline tree and the version closest to v6.10 (the
linux-6.10.3 branch) to maybe use as a reference for bringing the map22v
a52/a72 from v6.10 to v6.12

diff --git a/Documentation/devicetree/bindings/sound/qcom,wcd937x-sdw.yaml b/Documentation/devicetree/bindings/sound/qcom,wcd937x-sdw.yaml
new file mode 100644
index 00000000000000..d3cf8f59cb2326
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/qcom,wcd937x-sdw.yaml
@@ -0,0 +1,91 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/sound/qcom,wcd937x-sdw.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Qualcomm SoundWire Slave devices on WCD9370/WCD9375
+
+maintainers:
+  - Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
+
+description: |
+  Qualcomm WCD9370/WCD9375 Codec is a standalone Hi-Fi audio codec IC.
+  It has RX and TX Soundwire slave devices. This bindings is for the
+  slave devices.
+
+properties:
+  compatible:
+    const: sdw20217010a00
+
+  reg:
+    maxItems: 1
+
+  qcom,tx-port-mapping:
+    description: |
+      Specifies static port mapping between device and host tx ports.
+      In the order of the device port index which are adc1_port, adc23_port,
+      dmic03_mbhc_port, dmic46_port.
+      Supports maximum 4 tx soundwire ports.
+
+      WCD9370 TX Port 1 (ADC1)               <=> SWR2 Port 2
+      WCD9370 TX Port 2 (ADC2, 3)            <=> SWR2 Port 2
+      WCD9370 TX Port 3 (DMIC0,1,2,3 & MBHC) <=> SWR2 Port 3
+      WCD9370 TX Port 4 (DMIC4,5,6,7)        <=> SWR2 Port 4
+
+    $ref: /schemas/types.yaml#/definitions/uint32-array
+    minItems: 4
+    maxItems: 4
+    items:
+      enum: [1, 2, 3, 4]
+
+  qcom,rx-port-mapping:
+    description: |
+      Specifies static port mapping between device and host rx ports.
+      In the order of device port index which are hph_port, clsh_port,
+      comp_port, lo_port, dsd port.
+      Supports maximum 5 rx soundwire ports.
+
+      WCD9370 RX Port 1 (HPH_L/R)       <==>    SWR1 Port 1 (HPH_L/R)
+      WCD9370 RX Port 2 (CLSH)          <==>    SWR1 Port 2 (CLSH)
+      WCD9370 RX Port 3 (COMP_L/R)      <==>    SWR1 Port 3 (COMP_L/R)
+      WCD9370 RX Port 4 (LO)            <==>    SWR1 Port 4 (LO)
+      WCD9370 RX Port 5 (DSD_L/R)       <==>    SWR1 Port 5 (DSD)
+
+    $ref: /schemas/types.yaml#/definitions/uint32-array
+    minItems: 5
+    maxItems: 5
+    items:
+      enum: [1, 2, 3, 4, 5]
+
+required:
+  - compatible
+  - reg
+
+additionalProperties: false
+
+examples:
+  - |
+    soundwire@3210000 {
+        reg = <0x03210000 0x2000>;
+        #address-cells = <2>;
+        #size-cells = <0>;
+        wcd937x_rx: codec@0,4 {
+            compatible = "sdw20217010a00";
+            reg = <0 4>;
+            qcom,rx-port-mapping = <1 2 3 4 5>;
+        };
+    };
+
+    soundwire@3230000 {
+        reg = <0x03230000 0x2000>;
+        #address-cells = <2>;
+        #size-cells = <0>;
+        wcd937x_tx: codec@0,3 {
+            compatible = "sdw20217010a00";
+            reg = <0 3>;
+            qcom,tx-port-mapping = <2 2 3 4>;
+        };
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/sound/qcom,wcd937x.yaml b/Documentation/devicetree/bindings/sound/qcom,wcd937x.yaml
new file mode 100644
index 00000000000000..f94203798f24b3
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/qcom,wcd937x.yaml
@@ -0,0 +1,82 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/sound/qcom,wcd937x.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Qualcomm WCD9370/WCD9375 Audio Codec
+
+maintainers:
+  - Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
+
+description:
+  Qualcomm WCD9370/WCD9375 Codec is a standalone Hi-Fi audio codec IC.
+  It has RX and TX Soundwire slave devices.
+
+allOf:
+  - $ref: dai-common.yaml#
+  - $ref: qcom,wcd93xx-common.yaml#
+
+properties:
+  compatible:
+    oneOf:
+      - const: qcom,wcd9370-codec
+      - items:
+          - const: qcom,wcd9375-codec
+          - const: qcom,wcd9370-codec
+
+  vdd-px-supply:
+    description: A reference to the 1.8V I/O supply
+
+required:
+  - compatible
+  - vdd-px-supply
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+    codec {
+        compatible = "qcom,wcd9370-codec";
+        pinctrl-names = "default", "sleep";
+        pinctrl-0 = <&wcd_reset_n>;
+        pinctrl-1 = <&wcd_reset_n_sleep>;
+        reset-gpios = <&tlmm 83 GPIO_ACTIVE_LOW>;
+        vdd-buck-supply = <&vreg_l17b_1p8>;
+        vdd-rxtx-supply = <&vreg_l18b_1p8>;
+        vdd-px-supply = <&vreg_l18b_1p8>;
+        vdd-mic-bias-supply = <&vreg_bob>;
+        qcom,micbias1-microvolt = <1800000>;
+        qcom,micbias2-microvolt = <1800000>;
+        qcom,micbias3-microvolt = <1800000>;
+        qcom,micbias4-microvolt = <1800000>;
+        qcom,rx-device = <&wcd937x_rx>;
+        qcom,tx-device = <&wcd937x_tx>;
+        #sound-dai-cells = <1>;
+    };
+
+    /* ... */
+
+    soundwire@3210000 {
+        reg = <0x03210000 0x2000>;
+        #address-cells = <2>;
+        #size-cells = <0>;
+        wcd937x_rx: codec@0,4 {
+            compatible = "sdw20217010a00";
+            reg = <0 4>;
+            qcom,rx-port-mapping = <1 2 3 4 5>;
+        };
+    };
+
+    soundwire@3230000 {
+        reg = <0x03230000 0x2000>;
+        #address-cells = <2>;
+        #size-cells = <0>;
+        wcd937x_tx: codec@0,3 {
+            compatible = "sdw20217010a00";
+            reg = <0 3>;
+            qcom,tx-port-mapping = <1 2 3 4>;
+        };
+    };
+...
diff --git a/arch/arm64/boot/dts/qcom/Makefile b/arch/arm64/boot/dts/qcom/Makefile
index f63abb43e9fed4..061437e4388966 100644
--- a/arch/arm64/boot/dts/qcom/Makefile
+++ b/arch/arm64/boot/dts/qcom/Makefile
@@ -214,8 +214,12 @@ dtb-$(CONFIG_ARCH_QCOM)	+= sm6125-sony-xperia-seine-pdx201.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm6125-xiaomi-laurel-sprout.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm6350-sony-xperia-lena-pdx213.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm6375-sony-xperia-murray-pdx225.dtb
-dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-xiaomi-curtana.dtb
-dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-xiaomi-joyeuse.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-xiaomi-curtana-huaxing.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-xiaomi-curtana-tianma.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-xiaomi-gram-huaxing.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-xiaomi-gram-tianma.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-xiaomi-joyeuse-huaxing.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-xiaomi-joyeuse-tianma.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm7225-fairphone-fp4.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8150-hdk.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8150-microsoft-surface-duo.dtb
diff --git a/arch/arm64/boot/dts/qcom/pm6150.dtsi b/arch/arm64/boot/dts/qcom/pm6150.dtsi
index 6de6ed562d97ce..b514834e2943d4 100644
--- a/arch/arm64/boot/dts/qcom/pm6150.dtsi
+++ b/arch/arm64/boot/dts/qcom/pm6150.dtsi
@@ -130,6 +130,22 @@
 				reg = <ADC5_DIE_TEMP>;
 				label = "die_temp";
 			};
+
+			bat_therm@4a {
+				reg = <ADC5_BAT_THERM_100K_PU>;
+				label = "bat_therm";
+				qcom,ratiometric;
+				qcom,hw-settle-time = <200>;
+				qcom,pre-scaling = <1 1>;
+			};
+
+			bat_id@4b {
+				reg = <ADC5_BAT_ID_100K_PU>;
+				label = "bat_id";
+				qcom,ratiometric;
+				qcom,hw-settle-time = <200>;
+				qcom,pre-scaling = <1 1>;
+			};
 		};
 
 		pm6150_adc_tm: adc-tm@3500 {
@@ -142,6 +158,18 @@
 			status = "disabled";
 		};
 
+		pm6150_qgauge: qgauge@4800 {
+			compatible = "qcom,pm6150-qg";
+			reg = <0x4800>;
+
+			io-channels = <&pm6150_adc ADC5_BAT_THERM_100K_PU>,
+				      <&pm6150_adc ADC5_BAT_ID_100K_PU>;
+			io-channel-names = "batt-therm",
+					   "batt-id";
+
+			status = "disabled";
+		};
+
 		pm6150_rtc: rtc@6000 {
 			compatible = "qcom,pm8941-rtc";
 			reg = <0x6000>, <0x6100>;
diff --git a/arch/arm64/boot/dts/qcom/sc7180.dtsi b/arch/arm64/boot/dts/qcom/sc7180.dtsi
index 9ab0c98cac0547..15e3ef790fe106 100644
--- a/arch/arm64/boot/dts/qcom/sc7180.dtsi
+++ b/arch/arm64/boot/dts/qcom/sc7180.dtsi
@@ -5,6 +5,7 @@
  * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  */
 
+#include <dt-bindings/clock/qcom,camcc-sc7180.h>
 #include <dt-bindings/clock/qcom,dispcc-sc7180.h>
 #include <dt-bindings/clock/qcom,gcc-sc7180.h>
 #include <dt-bindings/clock/qcom,gpucc-sc7180.h>
@@ -2123,6 +2124,54 @@
 				pins = "gpio63", "gpio64", "gpio65", "gpio66";
 				function = "mi2s_2";
 			};
+
+			cci0_default: cci0-default-state {
+				/* SDA, SCL */
+				pins = "gpio17", "gpio18";
+				function = "cci_i2c";
+				drive-strength = <2>;
+				bias-pull-up;
+			};
+
+			cci0_sleep: cci0-sleep-state {
+				/* SDA, SCL */
+				pins = "gpio17", "gpio18";
+				function = "cci_i2c";
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+
+			cci1_default: cci1-default-state {
+				/* SDA, SCL */
+				pins = "gpio19", "gpio20";
+				function = "cci_i2c";
+				drive-strength = <2>;
+				bias-pull-up;
+			};
+
+			cci1_sleep: cci1-sleep-state {
+				/* SDA, SCL */
+				pins = "gpio19", "gpio20";
+				function = "cci_i2c";
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+
+			cci2_default: cci2-default-state {
+				/* SDA, SCL */
+				pins = "gpio27", "gpio28";
+				function = "cci_i2c";
+				drive-strength = <2>;
+				bias-pull-up;
+			};
+
+			cci2_sleep: cci2-sleep-state {
+				/* SDA, SCL */
+				pins = "gpio27", "gpio28";
+				function = "cci_i2c";
+				drive-strength = <2>;
+				bias-pull-down;
+			};
 		};
 
 		remoteproc_mpss: remoteproc@4080000 {
@@ -3150,6 +3199,230 @@
 			qcom,bcm-voters = <&apps_bcm_voter>;
 		};
 
+		camss: camss@acb3000 {
+			compatible = "qcom,sc7180-camss";
+
+			reg = <0 0xacb3000 0 0x1000>,
+				  <0 0xacba000 0 0x1000>,
+				  <0 0xacc8000 0 0x1000>,
+				  <0 0xac65000 0 0x1000>,
+				  <0 0xac66000 0 0x1000>,
+				  <0 0xac67000 0 0x1000>,
+				  <0 0xac68000 0 0x1000>,
+				  <0 0xacaf000 0 0x4000>,
+				  <0 0xacb6000 0 0x4000>,
+				  <0 0xacc4000 0 0x4000>;
+
+			reg-names = "csid0",
+						"csid1",
+						"csid2",
+						"csiphy0",
+						"csiphy1",
+						"csiphy2",
+						"csiphy3",
+						"vfe0",
+						"vfe1",
+						"vfe_lite";
+
+			clocks = <&camcc CAM_CC_CAMNOC_AXI_CLK>,
+					 <&camcc CAM_CC_CPAS_AHB_CLK>,
+					 <&camcc CAM_CC_IFE_0_CSID_CLK>,
+					 <&camcc CAM_CC_IFE_1_CSID_CLK>,
+					 <&camcc CAM_CC_IFE_LITE_CSID_CLK>,
+					 <&camcc CAM_CC_CSIPHY0_CLK>,
+					 <&camcc CAM_CC_CSI0PHYTIMER_CLK>,
+					 <&camcc CAM_CC_CSIPHY1_CLK>,
+					 <&camcc CAM_CC_CSI1PHYTIMER_CLK>,
+					 <&camcc CAM_CC_CSIPHY2_CLK>,
+					 <&camcc CAM_CC_CSI2PHYTIMER_CLK>,
+					 <&camcc CAM_CC_CSIPHY3_CLK>,
+					 <&camcc CAM_CC_CSI3PHYTIMER_CLK>,
+					 <&gcc GCC_CAMERA_AHB_CLK>,
+					 <&gcc GCC_CAMERA_HF_AXI_CLK>,
+					 <&camcc CAM_CC_SOC_AHB_CLK>,
+					 <&camcc CAM_CC_IFE_0_AXI_CLK>,
+					 <&camcc CAM_CC_IFE_0_CLK>,
+					 <&camcc CAM_CC_IFE_0_CPHY_RX_CLK>,
+					 <&camcc CAM_CC_IFE_1_AXI_CLK>,
+					 <&camcc CAM_CC_IFE_1_CLK>,
+					 <&camcc CAM_CC_IFE_1_CPHY_RX_CLK>,
+					 <&camcc CAM_CC_IFE_LITE_CLK>,
+					 <&camcc CAM_CC_IFE_LITE_CPHY_RX_CLK>;
+
+			clock-names = "camnoc_axi",
+						  "cpas_ahb",
+						  "csi0",
+						  "csi1",
+						  "csi2",
+						  "csiphy0",
+						  "csiphy0_timer",
+						  "csiphy1",
+						  "csiphy1_timer",
+						  "csiphy2",
+						  "csiphy2_timer",
+						  "csiphy3",
+						  "csiphy3_timer",
+						  "gcc_camera_ahb",
+						  "gcc_camera_axi",
+						  "soc_ahb",
+						  "vfe0_axi",
+						  "vfe0",
+						  "vfe0_cphy_rx",
+						  "vfe1_axi",
+						  "vfe1",
+						  "vfe1_cphy_rx",
+						  "vfe_lite",
+						  "vfe_lite_cphy_rx";
+
+			interrupts = <GIC_SPI 464 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 466 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 473 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 477 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 478 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 479 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 461 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 465 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 467 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 472 IRQ_TYPE_LEVEL_HIGH>;
+
+			interrupt-names = "csid0",
+							  "csid1",
+							  "csid2",
+							  "csiphy0",
+							  "csiphy1",
+							  "csiphy2",
+							  "csiphy3",
+							  "vfe0",
+							  "vfe1",
+							  "vfe_lite";
+
+			iommus = <&apps_smmu 0x820 0x0>,
+					 <&apps_smmu 0x840 0x0>,
+					 <&apps_smmu 0x860 0x0>;
+
+			interconnects = <&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_CAMERA_CFG 0>,
+					<&camnoc_virt MASTER_CAMNOC_HF0_UNCOMP 0 &camnoc_virt SLAVE_CAMNOC_UNCOMP 0>,
+					<&camnoc_virt MASTER_CAMNOC_HF1_UNCOMP 0 &camnoc_virt SLAVE_CAMNOC_UNCOMP 0>,
+					<&camnoc_virt MASTER_CAMNOC_SF_UNCOMP 0 &camnoc_virt SLAVE_CAMNOC_UNCOMP 0>;
+			interconnect-names = "cam_ahb",
+					     "cam_hf_0_camnoc",
+					     "cam_hf_1_camnoc",
+					     "cam_sf_camnoc";
+
+			power-domains = <&camcc IFE_0_GDSC>,
+							<&camcc IFE_1_GDSC>,
+							<&camcc TITAN_TOP_GDSC>;
+
+			power-domain-names = "ife0", "ife1", "top";
+
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+				};
+
+				port@1 {
+					reg = <1>;
+				};
+
+				port@2 {
+					reg = <2>;
+				};
+
+				port@3 {
+					reg = <3>;
+				};
+			};
+		};
+
+		cci0: cci@ac4a000 {
+			compatible = "qcom,sc7180-cci", "qcom,msm8996-cci";
+			reg = <0 0x0ac4a000 0 0x1000>;
+			interrupts = <GIC_SPI 468 IRQ_TYPE_EDGE_RISING>;
+			power-domains = <&camcc TITAN_TOP_GDSC>;
+
+			clocks = <&camcc CAM_CC_CAMNOC_AXI_CLK>,
+				 <&camcc CAM_CC_SOC_AHB_CLK>,
+				 <&camcc CAM_CC_SLOW_AHB_CLK_SRC>,
+				 <&camcc CAM_CC_CPAS_AHB_CLK>,
+				 <&camcc CAM_CC_CCI_0_CLK>,
+				 <&camcc CAM_CC_CCI_0_CLK_SRC>;
+			clock-names = "camnoc_axi",
+				      "soc_ahb",
+				      "slow_ahb_src",
+				      "cpas_ahb",
+				      "cci",
+				      "cci_src";
+
+			pinctrl-0 = <&cci0_default &cci1_default>;
+			pinctrl-1 = <&cci0_sleep &cci1_sleep>;
+			pinctrl-names = "default", "sleep";
+
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			cci0_i2c0: i2c-bus@0 {
+				reg = <0>;
+				clock-frequency = <1000000>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+
+			cci0_i2c1: i2c-bus@1 {
+				reg = <1>;
+				clock-frequency = <1000000>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+		};
+
+		cci1: cci@ac4b000 {
+			compatible = "qcom,sc7180-cci", "qcom,msm8996-cci";
+			reg = <0 0x0ac4b000 0 0x1000>;
+			interrupts = <GIC_SPI 462 IRQ_TYPE_EDGE_RISING>;
+			power-domains = <&camcc TITAN_TOP_GDSC>;
+
+			clocks = <&camcc CAM_CC_CAMNOC_AXI_CLK>,
+				<&camcc CAM_CC_SOC_AHB_CLK>,
+				<&camcc CAM_CC_SLOW_AHB_CLK_SRC>,
+				<&camcc CAM_CC_CPAS_AHB_CLK>,
+				<&camcc CAM_CC_CCI_1_CLK>,
+				<&camcc CAM_CC_CCI_1_CLK_SRC>;
+			clock-names = "camnoc_axi",
+				"soc_ahb",
+				"slow_ahb_src",
+				"cpas_ahb",
+				"cci",
+				"cci_src";
+
+			pinctrl-0 = <&cci2_default>;
+			pinctrl-1 = <&cci2_sleep>;
+			pinctrl-names = "default", "sleep";
+
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			cci1_i2c0: i2c-bus@0 {
+				reg = <0>;
+				clock-frequency = <1000000>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+
+			cci1_i2c1: i2c-bus@1 {
+				reg = <1>;
+				clock-frequency = <1000000>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+		};
+
 		camcc: clock-controller@ad00000 {
 			compatible = "qcom,sc7180-camcc";
 			reg = <0 0x0ad00000 0 0x10000>;
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-common.dtsi b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-common.dtsi
index 29289fa41b1344..933e98b3270c73 100644
--- a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-common.dtsi
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-common.dtsi
@@ -8,7 +8,11 @@
 #include <dt-bindings/arm/qcom,ids.h>
 #include <dt-bindings/firmware/qcom,scm.h>
 #include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/dma/qcom-gpi.h>
 #include <dt-bindings/regulator/qcom,rpmh-regulator.h>
+#include <dt-bindings/usb/pd.h>
+#include <dt-bindings/sound/qcom,q6asm.h>
+#include <dt-bindings/input/ti-drv2624.h>
 #include "sm7125.dtsi"
 #include "pm6150.dtsi"
 #include "pm6150l.dtsi"
@@ -25,16 +29,21 @@
 		#address-cells = <2>;
 		#size-cells = <2>;
 		ranges;
+	};
 
-		framebuffer@9c000000 {
-			compatible = "simple-framebuffer";
-			reg = <0x0 0x9c000000 0x0 (1080 * 2400 * 4)>;
-			width = <1080>;
-			height = <2400>;
-			stride = <(1080 * 4)>;
-			format = "a8r8g8b8";
-			clocks = <&gcc GCC_DISP_HF_AXI_CLK>;
-		};
+	aliases {
+		bluetooth0 = &bluetooth;
+		hsuart0 = &uart3;
+		wifi0 = &wifi;
+	};
+	
+	battery: battery {
+		compatible = "simple-battery";
+		
+		charge-full-design-microamp-hours = <5020000>;
+
+		voltage-min-design-microvolt = <3400000>;
+		voltage-max-design-microvolt = <4400000>;
 	};
 
 	gpio_keys: gpio-keys {
@@ -108,6 +117,44 @@
 			qcom,vmid = <QCOM_SCM_VMID_MSS_MSA>;
 		};
 	};
+
+	wcd937x: codec {
+        compatible = "qcom,wcd9375-codec";
+
+        reset-gpios = <&tlmm 58 GPIO_ACTIVE_HIGH>;
+
+        pinctrl-names = "default", "sleep";
+        pinctrl-0 = <&wcd_reset_n>;
+        pinctrl-1 = <&wcd_reset_n_sleep>;
+
+        vdd-buck-supply = <&vreg_l15a_1p8>;
+        vdd-rxtx-supply = <&vreg_l10a_1p8>;
+        vdd-px-supply = <&vreg_l10a_1p8>;
+        vdd-mic-bias-supply = <&vreg_bob>;
+
+        qcom,micbias1-microvolt = <1800000>;
+        qcom,micbias2-microvolt = <1800000>;
+        qcom,micbias3-microvolt = <1800000>;
+        qcom,micbias4-microvolt = <1800000>;
+		qcom,mbhc-buttons-vthreshold-microvolt = <75000 150000 237000 500000 500000 500000 500000 500000>;
+        qcom,mbhc-headset-vthreshold-microvolt = <1700000>;
+		qcom,mbhc-headphone-vthreshold-microvolt = <50000>;
+        qcom,rx-device = <&wcd_rx>;
+        qcom,tx-device = <&wcd_tx>;
+
+        #sound-dai-cells = <1>;
+    };
+};
+
+&pm6150l_gpios {
+	panel_reset_pins: panel-reset{
+		pins = "gpio3";
+		function = "func1";
+		qcom,drive-strength = <2>;
+		power-source = <0>;
+		bias-disable;
+		output-low;
+	};
 };
 
 &apps_rsc {
@@ -328,9 +375,121 @@
 	};
 };
 
-&dispcc {
-	/* HACK: disable until a panel driver is ready to retain simplefb */
-	status = "disabled";
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	vdda-supply = <&vreg_l3c_1p23>;
+	status = "okay";
+
+	panel: panel@0 {
+		reg = <0>;
+
+		vddio-supply = <&vreg_l18a_3p0>;
+
+		reset-gpios = <&pm6150l_gpios 3 GPIO_ACTIVE_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&panel_reset_pins &panel_te_pin>;
+
+		backlight = <&pm6150l_wled>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	remote-endpoint = <&panel_in>;
+	data-lanes = <0 1 2 3>;
+};
+
+&mdss_dsi0_phy {
+	status = "okay";
+};
+
+// Because miatoll uses SM7125-AB with reduced gpu frequencies
+/delete-node/ &gpu_opp_table;
+&gpu {
+	gpu_opp_table: opp-table {
+		compatible = "operating-points-v2";
+
+		opp-750000000 {
+			opp-hz = /bits/ 64 <750000000>;
+			opp-level = <RPMH_REGULATOR_LEVEL_NOM_L1>;
+			opp-peak-kBps = <7216000>;
+			opp-supported-hw = <0x08>;
+		};
+
+		opp-650000000 {
+			opp-hz = /bits/ 64 <650000000>;
+			opp-level = <RPMH_REGULATOR_LEVEL_NOM_L1>;
+			opp-peak-kBps = <7216000>;
+			opp-supported-hw = <0x08>;
+		};
+
+		opp-565000000 {
+			opp-hz = /bits/ 64 <565000000>;
+			opp-level = <RPMH_REGULATOR_LEVEL_NOM>;
+			opp-peak-kBps = <5412000>;
+			opp-supported-hw = <0x08>;
+		};
+
+		opp-430000000 {
+			opp-hz = /bits/ 64 <430000000>;
+			opp-level = <RPMH_REGULATOR_LEVEL_SVS_L1>;
+			opp-peak-kBps = <5412000>;
+			opp-supported-hw = <0x08>;
+		};
+
+		opp-355000000 {
+			opp-hz = /bits/ 64 <355000000>;
+			opp-level = <RPMH_REGULATOR_LEVEL_SVS>;
+			opp-peak-kBps = <3072000>;
+			opp-supported-hw = <0x08>;
+		};
+
+		opp-267000000 {
+			opp-hz = /bits/ 64 <267000000>;
+			opp-level = <RPMH_REGULATOR_LEVEL_LOW_SVS>;
+			opp-peak-kBps = <3072000>;
+			opp-supported-hw = <0x08>;
+		};
+
+		opp-180000000 {
+			opp-hz = /bits/ 64 <180000000>;
+			opp-level = <RPMH_REGULATOR_LEVEL_MIN_SVS>;
+			opp-peak-kBps = <1804000>;
+			opp-supported-hw = <0x08>;
+		};
+	};
+
+	zap-shader {
+		firmware-name = "qcom/sm7125/miatoll/a615_zap.mbn";
+		memory-region = <&gpu_mem>;
+	};
+};
+
+&ipa {
+	firmware-name = "qcom/sm7125/miatoll/ipa_fws.mbn";
+	memory-region = <&ipa_fw_mem>;
+	status = "okay";
+};
+
+&pm6150l_wled {
+	qcom,cabc;
+	qcom,cabc-sel = <1>;
+	qcom,num-strings = <3>;
+	status = "okay";
+};
+
+&pm6150_qgauge {
+	monitored-battery = <&battery>;
+	status = "okay";
 };
 
 &pm6150_resin {
@@ -342,6 +501,83 @@
 	status = "okay";
 };
 
+&pm6150_typec {
+	vdd-vbus-supply = <&pm6150_vbus>;
+	vdd-pdphy-supply = <&vreg_l17a_3p1>;
+	status = "okay";
+
+	connector {
+		compatible = "usb-c-connector";
+
+		power-role = "source";
+		data-role = "dual";
+		self-powered;
+
+		source-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_DUAL_ROLE |
+				PDO_FIXED_USB_COMM | PDO_FIXED_DATA_SWAP)>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				pm6150_role_switch_in: endpoint {
+					remote-endpoint = <&usb_1_dwc3_hs>;
+				};
+			};
+		};
+	};
+};
+
+&pm6150_vbus {
+	regulator-min-microamp = <500000>;
+	regulator-max-microamp = <3000000>;
+	status = "okay";
+};
+
+&wifi {
+	status = "okay";
+
+	vdd-0.8-cx-mx-supply = <&vreg_l9a_0p664>;
+	vdd-1.8-xo-supply = <&vreg_l1c_1p8>;
+	vdd-1.3-rfa-supply = <&vreg_l2c_1p3>;
+	vdd-3.3-ch0-supply = <&vreg_l10c_3p3>;
+	vdd-3.3-ch1-supply = <&vreg_l11c_3p3>;
+};
+
+&qupv3_id_0 {
+	status = "okay";
+};
+
+&qupv3_id_1 {
+	status = "okay";
+};
+
+&gpi_dma0 {
+	status = "okay";
+};
+
+&gpi_dma1 {
+	status = "okay";
+};
+
+&remoteproc_adsp {
+	memory-region = <&adsp_mem>;
+	firmware-name = "qcom/sm7125/miatoll/adsp.mbn";
+	status = "okay";
+};
+
+&remoteproc_cdsp {
+	firmware-name = "qcom/sm7125/miatoll/cdsp.mbn";
+	status = "okay";
+};
+
+&remoteproc_mpss {
+	firmware-name = "qcom/sm7125/miatoll/modem.mbn";
+	status = "okay";
+};
+
 &sdhc_2 {
 	cd-gpios = <&tlmm 69 GPIO_ACTIVE_HIGH>;
 	pinctrl-names = "default","sleep";
@@ -408,6 +644,347 @@
 			drive-strength = <2>;
 		};
 	};
+
+	qup_uart3_sleep: qup-uart3-sleep-state {
+		pinmux {
+			pins = "gpio38", "gpio39",
+				"gpio40", "gpio41";
+			function = "gpio";
+		};
+
+		pinconf-cts {
+			/*
+			 * Configure a pull-down on CTS to match the pull of
+			 * the Bluetooth module.
+			 */
+			pins = "gpio38";
+			bias-pull-down;
+		};
+
+		pinconf-rts {
+			/*
+			 * Configure pull-down on RTS. As RTS is active low
+			 * signal, pull it low to indicate the BT SoC that it
+			 * can wakeup the system anytime from suspend state by
+			 * pulling RX low (by sending wakeup bytes).
+			 */
+			pins = "gpio39";
+			bias-pull-down;
+		};
+
+		pinconf-tx {
+			/*
+			 * Configure pull-up on TX when it isn't actively driven
+			 * to prevent BT SoC from receiving garbage during sleep.
+			 */
+			pins = "gpio40";
+			bias-pull-up;
+		};
+
+		pinconf-rx {
+			/*
+			 * Configure a pull-up on RX. This is needed to avoid
+			 * garbage data when the TX pin of the Bluetooth module
+			 * is floating which may cause spurious wakeups.
+			 */
+			pins = "gpio41";
+			bias-pull-up;
+		};
+	};
+	
+	ts_reset_active: ts-reset-active-state {
+		pins = "gpio8";
+		function = "gpio";
+		drive-strength = <16>;
+		bias-pull-up;
+	};
+
+	ts_reset_suspend: ts-reset-suspend-state {
+		pins = "gpio8";
+		function = "gpio";
+		drive-strength = <16>;
+		bias-disable;
+		output-high;
+	};
+
+	ts_int_active: ts-int-active-state {
+		pins = "gpio9";
+		function = "gpio";
+		drive-strength = <16>;
+		bias-pull-up;
+	};
+
+	ts_int_suspend: ts-int-suspend-state {
+		pins = "gpio9";
+		function = "gpio";
+		drive-strength = <16>;
+		input-enable;
+		bias-disable;
+	};
+
+	panel_te_pin: panel-te {
+		mux {
+			pins = "gpio10";
+			function = "mdp_vsync";
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	ter_mi2s_active: ter-mi2s-active-state {
+		pins = "gpio63", "gpio64", "gpio65", "gpio66";
+		function = "mi2s_2";
+	};
+
+	wcd_reset_n: wcd-reset-n-state {
+		pins = "gpio58";
+		function = "gpio";
+		drive-strength = <8>;
+	};
+
+	wcd_reset_n_sleep: wcd-reset-n-sleep-state {
+		pins = "gpio58";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+};
+
+&i2c4 {
+	status = "okay";
+	clock-frequency = <100000>;
+
+	dmas = <&gpi_dma0 0 4 QCOM_GPI_I2C>,
+			<&gpi_dma0 1 4 QCOM_GPI_I2C>;
+	dma-names = "tx", "rx";
+
+	drv2624: haptics@5a {
+		compatible = "ti,drv2624";
+		reg = <0x5a>;
+		reset-gpios = <&tlmm 52 GPIO_ACTIVE_HIGH>;
+		mode = <DRV2624_LRA_MODE>;
+		lra-frequency = <205>;
+		vib-rated-mv = <2500>;
+		vib-overdrive-mv = <4000>;
+	};
+};
+
+&i2c9 {
+	status = "okay";
+	clock-frequency = <100000>;
+
+	dmas = <&gpi_dma1 0 3 QCOM_GPI_I2C>,
+			<&gpi_dma1 1 3 QCOM_GPI_I2C>;
+	dma-names = "tx", "rx";
+
+	tas2562: codec@4c {
+			compatible = "ti,tas2562";
+			reg = <0x4c>;
+			#sound-dai-cells = <0>;
+			interrupt-parent = <&tlmm>;
+			interrupts = <33 0>;
+			shutdown-gpios = <&tlmm 51 0>;
+			ti,vmon-slot-no = <2>;
+			ti,imon-slot-no = <0>;
+	};
+};
+
+&spi11 {
+	status = "okay";
+	clock-frequency = <8000000>;
+
+	dmas = <&gpi_dma1 0 5 QCOM_GPI_SPI>,
+		<&gpi_dma1 1 5 QCOM_GPI_SPI>;
+	dma-names = "tx", "rx";
+
+	touchscreen: touchscreen@0 {
+		reg = <0>;
+
+		spi-max-frequency = <8000000>;
+
+		pinctrl-0 = <&ts_int_active &ts_reset_active>;
+		pinctrl-1 = <&ts_int_suspend &ts_reset_suspend>;
+		pinctrl-names = "default", "sleep";
+		
+		irq-gpio = <&tlmm 9 IRQ_TYPE_EDGE_FALLING>;
+
+		vio-supply = <&vreg_l18a_3p0>;
+
+		panel = <&panel>;
+	};
+};
+
+&sound {
+	compatible = "qcom,sm8250-sndcard";
+	pinctrl-0 = <&ter_mi2s_active>;
+	pinctrl-names = "default";
+	model = "XiaomiRedmi9s";
+	audio-routing =
+		"IN1_HPHL", "HPHL_OUT",
+		"IN2_HPHR", "HPHR_OUT",
+		"AMIC1", "MIC BIAS1",
+		"AMIC2", "MIC BIAS2",
+		"AMIC3", "MIC BIAS3",
+		"TX SWR_ADC0", "ADC1_OUTPUT",
+		"TX SWR_ADC2", "ADC2_OUTPUT";
+
+	mm1-dai-link {
+		link-name = "MultiMedia1";
+		cpu {
+			sound-dai = <&q6asmdai MSM_FRONTEND_DAI_MULTIMEDIA1>;
+		};
+	};
+
+	mm2-dai-link {
+		link-name = "MultiMedia2";
+		cpu {
+			sound-dai = <&q6asmdai MSM_FRONTEND_DAI_MULTIMEDIA2>;
+		};
+	};
+
+	mm3-dai-link {
+		link-name = "MultiMedia3";
+		cpu {
+			sound-dai = <&q6asmdai MSM_FRONTEND_DAI_MULTIMEDIA3>;
+		};
+	};
+
+	i2s-dai-link {
+		link-name = "I2S Playback";
+		cpu {
+			sound-dai = <&q6afedai TERTIARY_MI2S_RX>;
+		};
+
+		platform {
+			sound-dai = <&q6routing>;
+		};
+
+		codec {
+			sound-dai = <&tas2562>;
+		};
+	};
+
+	wcd-playback-dai-link {
+		link-name = "WCD Playback";
+		cpu {
+			sound-dai = <&q6afedai RX_CODEC_DMA_RX_0>;
+		};
+
+		codec {
+			sound-dai = <&wcd937x 0>, <&swr1 0>, <&rxmacro 0>;
+		};
+
+		platform {
+			sound-dai = <&q6routing>;
+		};
+	};
+
+	wcd-capture-dai-link {
+		link-name = "WCD Capture";
+		cpu {
+			sound-dai = <&q6afedai TX_CODEC_DMA_TX_3>;
+		};
+
+		codec {
+			sound-dai = <&wcd937x 1>, <&swr2 0>, <&txmacro 0>;
+		};
+
+		platform {
+			sound-dai = <&q6routing>;
+		};
+	};
+};
+
+&swr1 {
+	status = "okay";
+
+	wcd_rx: codec@0,4 {
+		compatible = "sdw20217010a00";
+		reg = <0 4>;
+
+		qcom,rx-port-mapping = <1 2 3 4 5>;
+	};
+};
+
+&swr2 {
+	status = "okay";
+	wcd_tx: codec@0,3 {
+		compatible = "sdw20217010a00";
+		reg = <0 3>;
+
+		qcom,tx-port-mapping = <2 3 4 5>;
+	};
+};
+
+&q6afedai {
+	dai@113 {
+		reg = <RX_CODEC_DMA_RX_0>;
+	};
+
+	dai@120 {
+		reg = <TX_CODEC_DMA_TX_3>;
+	};
+
+	qi2s@127 {
+		reg = <TERTIARY_MI2S_RX>;
+		qcom,sd-lines = <0>;
+	};
+};
+
+&q6asmdai {
+	dai@0 {
+		reg = <0>;
+	};
+
+	dai@1 {
+		reg = <1>;
+	};
+
+	dai@2 {
+		reg = <2>;
+	};
+};
+
+&qfprom {
+	vcc-supply = <&vreg_l11a_1p8>;
+};
+
+&rxmacro {
+	status = "okay";
+};
+
+&txmacro {
+	status = "okay";
+};
+
+&vamacro {
+	qcom,dmic-sample-rate = <600000>;
+	status = "okay";
+};
+
+&uart3 {
+	/delete-property/interrupts;
+	interrupts-extended = <&intc GIC_SPI 604 IRQ_TYPE_LEVEL_HIGH>,
+				<&tlmm 41 IRQ_TYPE_EDGE_FALLING>;
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-1 = <&qup_uart3_sleep>;
+
+	status = "okay";
+
+	bluetooth: bluetooth {
+		compatible = "qcom,wcn3991-bt";
+
+		local-bd-address = [ 00 00 EF BE AD DE ];
+
+		vddio-supply = <&vreg_l10a_1p8>;
+		vddxo-supply = <&vreg_l1c_1p8>;
+		vddrf-supply = <&vreg_l2c_1p3>;
+		vddch0-supply = <&vreg_l10c_3p3>;
+		swctrl-gpios = <&tlmm 73 GPIO_ACTIVE_HIGH>;
+
+		max-speed = <3200000>;
+	};
 };
 
 &ufs_mem_hc {
@@ -430,11 +1007,16 @@
 };
 
 &usb_1_dwc3 {
-	dr_mode = "peripheral";
+	dr_mode = "otg";
+	usb-role-switch;
 	maximum-speed = "high-speed";
 	status = "okay";
 };
 
+&usb_1_dwc3_hs {
+	remote-endpoint = <&pm6150_role_switch_in>;
+};
+
 &usb_1_hsphy {
 	vdd-supply = <&vreg_l4a_0p88>;
 	vdda-phy-dpdm-supply = <&vreg_l17a_3p1>;
@@ -447,3 +1029,8 @@
 	vdda-pll-supply = <&vreg_l3c_1p23>;
 	status = "okay";
 };
+
+&venus {
+	firmware-name = "qcom/sm7125/miatoll/venus.mbn";
+	status = "okay";
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana-huaxing.dts b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana-huaxing.dts
new file mode 100644
index 00000000000000..99550ca0e16c12
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana-huaxing.dts
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023, Joe Mason <buddyjojo06@outlook.com>
+ */
+
+/dts-v1/;
+
+#include "sm7125-xiaomi-curtana.dtsi"
+
+/ {
+	model = "Xiaomi Redmi Note 9S (Huaxing)";
+	compatible = "xiaomi,curtana", "qcom,sm7125";
+};
+
+&panel { compatible = "mdss,ft8756-huaxing"; };
+&touchscreen {
+	compatible = "focaltech,ft8756-spi";
+	firmware-name = "focaltech_ts_fw_huaxing.bin";
+	reset-gpio = <&tlmm 8 GPIO_ACTIVE_LOW>;
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana-tianma.dts b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana-tianma.dts
new file mode 100644
index 00000000000000..373b65c202f18c
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana-tianma.dts
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023, Joe Mason <buddyjojo06@outlook.com>
+ */
+
+/dts-v1/;
+
+#include "sm7125-xiaomi-curtana.dtsi"
+
+/ {
+	model = "Xiaomi Redmi Note 9S (Tianma)";
+	compatible = "xiaomi,curtana", "qcom,sm7125";
+};
+
+&panel { compatible = "mdss,nt36675-tianma"; };
+&touchscreen { 
+	compatible = "novatek,nt36xxx-spi"; 
+	firmware-name = "novatek_ts_tianma_fw.bin";
+	reset-gpio = <&tlmm 8 GPIO_ACTIVE_HIGH>;
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana.dts b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana.dtsi
similarity index 74%
rename from arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana.dts
rename to arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana.dtsi
index 12f517a8492c37..f019b5b84f4269 100644
--- a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana.dts
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana.dtsi
@@ -8,9 +8,6 @@
 #include "sm7125-xiaomi-common.dtsi"
 
 / {
-	model = "Xiaomi Redmi Note 9S";
-	compatible = "xiaomi,curtana", "qcom,sm7125";
-
 	/* required for bootloader to select correct board */
 	qcom,board-id = <0x20022 1>;
-};
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram-huaxing.dts b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram-huaxing.dts
new file mode 100644
index 00000000000000..8471e34b758ac5
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram-huaxing.dts
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023, Joe Mason <buddyjojo06@outlook.com>
+ */
+
+/dts-v1/;
+
+#include "sm7125-xiaomi-gram.dtsi"
+
+/ {
+	model = "Xiaomi POCO M2 Pro (Huaxing)";
+	compatible = "xiaomi,gram", "qcom,sm7125";
+};
+
+&panel { compatible = "mdss,ft8756-huaxing"; };
+&touchscreen {
+	compatible = "focaltech,ft8756-spi";
+	firmware-name = "focaltech_ts_fw_huaxing.bin";
+	reset-gpio = <&tlmm 8 GPIO_ACTIVE_LOW>;
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram-tianma.dts b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram-tianma.dts
new file mode 100644
index 00000000000000..f3be53ad8e578f
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram-tianma.dts
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023, Joe Mason <buddyjojo06@outlook.com>
+ */
+
+/dts-v1/;
+
+#include "sm7125-xiaomi-gram.dtsi"
+
+/ {
+	model = "Xiaomi POCO M2 Pro (Tianma)";
+	compatible = "xiaomi,gram", "qcom,sm7125";
+};
+
+&panel { compatible = "mdss,nt36675-tianma"; };
+&touchscreen { 
+	compatible = "novatek,nt36xxx-spi"; 
+	firmware-name = "novatek_ts_tianma_fw.bin";
+	reset-gpio = <&tlmm 8 GPIO_ACTIVE_HIGH>;
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram.dtsi b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram.dtsi
new file mode 100644
index 00000000000000..0a527f48373377
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram.dtsi
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023, Joe Mason <buddyjojo06@outlook.com>
+ */
+
+/dts-v1/;
+
+#include "sm7125-xiaomi-common.dtsi"
+
+/ {
+	/* required for bootloader to select correct board */
+	qcom,board-id = <0x60022 1>;
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse-huaxing.dts b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse-huaxing.dts
new file mode 100644
index 00000000000000..e41841d5dadbf0
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse-huaxing.dts
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021, The Linux Foundation. All rights reserved.
+ */
+
+/dts-v1/;
+
+#include "sm7125-xiaomi-joyeuse.dtsi"
+
+/ {
+	model = "Xiaomi Redmi Note 9 Pro (Global, Huaxing)";
+	compatible = "xiaomi,joyeuse", "qcom,sm7125";
+};
+
+&panel { compatible = "mdss,ft8756-huaxing"; };
+&touchscreen {
+	compatible = "focaltech,ft8756-spi";
+	firmware-name = "focaltech_ts_fw_huaxing.bin";
+	reset-gpio = <&tlmm 8 GPIO_ACTIVE_LOW>;
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse-tianma.dts b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse-tianma.dts
new file mode 100644
index 00000000000000..754455da6633f9
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse-tianma.dts
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021, The Linux Foundation. All rights reserved.
+ */
+
+/dts-v1/;
+
+#include "sm7125-xiaomi-joyeuse.dtsi"
+
+/ {
+	model = "Xiaomi Redmi Note 9 Pro (Global, Tianma)";
+	compatible = "xiaomi,joyeuse", "qcom,sm7125";
+};
+
+&panel { compatible = "mdss,nt36675-tianma"; };
+&touchscreen { 
+	compatible = "novatek,nt36xxx-spi"; 
+	firmware-name = "novatek_ts_tianma_fw.bin";
+	reset-gpio = <&tlmm 8 GPIO_ACTIVE_HIGH>;
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse.dts b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse.dtsi
similarity index 72%
rename from arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse.dts
rename to arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse.dtsi
index e010d195750936..8d6d8cff8821f6 100644
--- a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse.dts
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse.dtsi
@@ -8,9 +8,6 @@
 #include "sm7125-xiaomi-common.dtsi"
 
 / {
-	model = "Xiaomi Redmi Note 9 Pro (Global)";
-	compatible = "xiaomi,joyeuse", "qcom,sm7125";
-
 	/* required for bootloader to select correct board */
 	qcom,board-id = <0x50022 1>;
 };
diff --git a/arch/arm64/boot/dts/qcom/sm7125.dtsi b/arch/arm64/boot/dts/qcom/sm7125.dtsi
index 12dd72859a433b..8e1f36aca4f791 100644
--- a/arch/arm64/boot/dts/qcom/sm7125.dtsi
+++ b/arch/arm64/boot/dts/qcom/sm7125.dtsi
@@ -4,6 +4,8 @@
  */
 
 #include "sc7180.dtsi"
+#include <dt-bindings/clock/qcom,sm8250-lpass-aoncc.h>
+#include <dt-bindings/clock/qcom,sm8250-lpass-audiocc.h>
 
 /* SM7125 uses Kryo 465 instead of Kryo 468 */
 &CPU0 { compatible = "qcom,kryo465"; };
@@ -14,3 +16,435 @@
 &CPU5 { compatible = "qcom,kryo465"; };
 &CPU6 { compatible = "qcom,kryo465"; };
 &CPU7 { compatible = "qcom,kryo465"; };
+
+&soc {
+	wsamacro: codec@62640000 {
+		compatible = "qcom,sm8250-lpass-wsa-macro";
+		reg = <0 0x62640000 0 0x1000>;
+		status = "disabled";
+		clocks = <&audiocc LPASS_CDC_WSA_MCLK>,
+				<&audiocc LPASS_CDC_WSA_NPL>,
+				<&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&lpass_aoncc LPASS_CDC_VA_MCLK>,
+				<&vamacro>;
+
+		clock-names = "mclk", "npl", "macro", "dcodec", "va", "fsgen";
+
+		#clock-cells = <0>;
+		clock-frequency = <19200000>;
+		clock-output-names = "mclk";
+		#sound-dai-cells = <1>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&wsa_swr_active>;
+	};
+
+	swr0: soundwire-controller@62650000 {
+		reg = <0 0x62650000 0 0x2000>;
+		compatible = "qcom,soundwire-v1.5.1";
+		status = "disabled";
+		interrupts = <GIC_SPI 295 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&wsamacro>;
+		clock-names = "iface";
+
+		qcom,din-ports = <2>;
+		qcom,dout-ports = <6>;
+
+		qcom,ports-sinterval-low =	/bits/ 8 <0x07 0x1f 0x3f 0x07 0x1f 0x3f 0x0f 0x0f>;
+		qcom,ports-offset1 =		/bits/ 8 <0x01 0x02 0x0c 0x06 0x12 0x0d 0x07 0x0a>;
+		qcom,ports-offset2 =		/bits/ 8 <0xff 0x00 0x1f 0xff 0x00 0x1f 0x00 0x00>;
+		qcom,ports-block-pack-mode =	/bits/ 8 <0x0 0x0 0x1 0x0 0x0 0x1 0x0 0x0>;
+
+		#sound-dai-cells = <1>;
+		#address-cells = <2>;
+		#size-cells = <0>;
+	};
+
+	audiocc: clock-controller@62700000 {
+		compatible = "qcom,sm8250-lpass-audiocc";
+		reg = <0 0x62700000 0 0x30000>;
+		#clock-cells = <1>;
+		clocks = <&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+			<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+			<&q6afecc LPASS_CLK_ID_TX_CORE_MCLK LPASS_CLK_ATTRIBUTE_COUPLE_NO>;
+		clock-names = "core", "audio", "bus";
+	};
+
+	vamacro: codec@62770000 {
+		compatible = "qcom,sm8250-lpass-va-macro";
+		reg = <0 0x62770000 0 0x1000>;
+		status = "disabled";
+		clocks = <&lpass_aoncc LPASS_CDC_VA_MCLK>,
+			<&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+			<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>;
+
+		clock-names = "mclk", "macro", "dcodec";
+
+		#clock-cells = <0>;
+		clock-frequency = <9600000>;
+		clock-output-names = "fsgen";
+		#sound-dai-cells = <1>;
+	};
+
+	rxmacro: rxmacro@62600000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&rx_swr_active>;
+		compatible = "qcom,sm8250-lpass-rx-macro";
+		reg = <0 0x62600000 0 0x1000>;
+		status = "disabled";
+
+		clocks = <&q6afecc LPASS_CLK_ID_TX_CORE_MCLK LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&q6afecc LPASS_CLK_ID_TX_CORE_NPL_MCLK LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&vamacro>;
+
+		clock-names = "mclk", "npl", "macro", "dcodec", "fsgen";
+
+		#clock-cells = <0>;
+		clock-frequency = <9600000>;
+		clock-output-names = "mclk";
+		#sound-dai-cells = <1>;
+	};
+
+	swr1: soundwire-controller@62610000 {
+		reg = <0 0x62610000 0 0x2000>;
+		compatible = "qcom,soundwire-v1.5.1";
+		status = "disabled";
+		interrupts = <GIC_SPI 297 IRQ_TYPE_LEVEL_HIGH>;
+
+		clocks = <&rxmacro>;
+		clock-names = "iface";
+		label = "RX";
+
+		qcom,din-ports = <0>;
+		qcom,dout-ports = <5>;
+		qcom,ports-sinterval-low =	/bits/ 8 <0x03 0x1F 0x1F 0x07 0x00>;
+		qcom,ports-offset1 =		/bits/ 8 <0x00 0x00 0x0B 0x01 0x00>;
+		qcom,ports-offset2 =		/bits/ 8 <0x00 0x00 0x0B 0x00 0x00>;
+		qcom,ports-hstart =		/bits/ 8 <0xFF 0x03 0xFF 0xFF 0xFF>;
+		qcom,ports-hstop =		/bits/ 8 <0xFF 0x06 0xFF 0xFF 0xFF>;
+		qcom,ports-word-length =	/bits/ 8 <0x01 0x07 0x04 0xFF 0xFF>;
+		qcom,ports-block-pack-mode =	/bits/ 8 <0xFF 0x00 0x01 0xFF 0xFF>;
+		qcom,ports-block-group-count =	/bits/ 8 <0xFF 0xFF 0xFF 0xFF 0x00>;
+		qcom,ports-lane-control =	/bits/ 8 <0x01 0x00 0x00 0x00 0x00>;
+
+		#sound-dai-cells = <1>;
+		#address-cells = <2>;
+		#size-cells = <0>;
+	};
+
+	txmacro: txmacro@62620000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&tx_swr_active>;
+		compatible = "qcom,sm8250-lpass-tx-macro";
+		reg = <0 0x62620000 0 0x1000>;
+		status = "disabled";
+
+		clocks = <&q6afecc LPASS_CLK_ID_TX_CORE_MCLK LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&q6afecc LPASS_CLK_ID_TX_CORE_NPL_MCLK LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&vamacro>;
+
+		clock-names = "mclk", "npl", "macro", "dcodec", "fsgen";
+
+		#clock-cells = <0>;
+		clock-frequency = <9600000>;
+		clock-output-names = "mclk";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		#sound-dai-cells = <1>;
+	};
+
+	swr2: soundwire-controller@62630000 {
+		reg = <0 0x62630000 0 0x2000>;
+		compatible = "qcom,soundwire-v1.5.1";
+		status = "disabled";
+		interrupts = <GIC_SPI 296 IRQ_TYPE_LEVEL_HIGH>;
+
+		clocks = <&txmacro>;
+		clock-names = "iface";
+		label = "TX";
+
+		qcom,din-ports = <5>;
+		qcom,dout-ports = <0>;
+		qcom,ports-sinterval-low =	/bits/ 8 <0xFF 0x01 0x01 0x03 0x03>;
+		qcom,ports-offset1 =		/bits/ 8 <0xFF 0x01 0x00 0x02 0x00>;
+		qcom,ports-offset2 =		/bits/ 8 <0xFF 0x00 0x00 0x00 0x00>;
+		qcom,ports-block-pack-mode =	/bits/ 8 <0xFF 0xFF 0xFF 0xFF 0xFF>;
+		qcom,ports-hstart =		/bits/ 8 <0xFF 0xFF 0xFF 0xFF 0xFF>;
+		qcom,ports-hstop =		/bits/ 8 <0xFF 0xFF 0xFF 0xFF 0xFF>;
+		qcom,ports-word-length =	/bits/ 8 <0xFF 0xFF 0xFF 0xFF 0xFF>;
+		qcom,ports-block-group-count =	/bits/ 8 <0xFF 0xFF 0xFF 0xFF 0xFF>;
+		qcom,ports-lane-control =	/bits/ 8 <0xFF 0x00 0x01 0x00 0x01>;
+		qcom,port-offset = <1>;
+
+		#sound-dai-cells = <1>;
+		#address-cells = <2>;
+		#size-cells = <0>;
+	};
+
+	lpass_aoncc: clock-controller@62780000 {
+		compatible = "qcom,sm8250-lpass-aoncc";
+		reg = <0 0x62780000 0 0x40000>;
+		#clock-cells = <1>;
+		clocks = <&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+			<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+			<&q6afecc LPASS_CLK_ID_TX_CORE_NPL_MCLK LPASS_CLK_ATTRIBUTE_COUPLE_NO>;
+		clock-names = "core", "audio", "bus";
+	};
+
+	lpass_tlmm: pinctrl@627c0000 {
+		compatible = "qcom,sm7125-lpass-lpi-pinctrl", "qcom,sc7280-lpass-lpi-pinctrl";
+		reg = <0 0x627c0000 0x0 0x20000>,
+				<0 0x62950000 0x0 0x10000>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		gpio-ranges = <&lpass_tlmm 0 0 15>;
+
+		clocks = <&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+			<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>;
+		clock-names = "core", "audio";
+
+		i2s1_active: i2s1-active-pins {
+			clk {
+				pins = "gpio6";
+				function = "i2s1_clk";
+				drive-strength = <8>;
+				bias-disable;
+				output-high;
+			};
+			ws {
+				pins = "gpio7";
+				function = "i2s1_ws";
+				drive-strength = <8>;
+				bias-disable;
+				output-high;
+			};
+			data {
+				pins = "gpio8", "gpio9";
+				function = "i2s1_data";
+				drive-strength = <8>;
+				bias-disable;
+				output-high;
+			};
+		};
+
+		wsa_swr_active: wsa-swr-active-pins {
+			clk {
+				pins = "gpio10";
+				function = "wsa_swr_clk";
+				drive-strength = <10>;
+				slew-rate = <3>;
+				bias-disable;
+			};
+
+			data {
+				pins = "gpio11";
+				function = "wsa_swr_data";
+				drive-strength = <10>;
+				slew-rate = <3>;
+				bias-bus-hold;
+
+			};
+		};
+
+		rx_swr_active: rx_swr-active-pins {
+			clk {
+				pins = "gpio3";
+				function = "swr_rx_clk";
+				drive-strength = <10>;
+				slew-rate = <3>;
+				bias-disable;
+			};
+			data {
+				pins = "gpio4", "gpio5";
+				function = "swr_rx_data";
+				drive-strength = <10>;
+				slew-rate = <3>;
+				bias-bus-hold;
+			};
+		};
+
+		tx_swr_active: tx_swr-active-pins {
+			clk {
+				pins = "gpio0";
+				function = "swr_tx_clk";
+				drive-strength = <10>;
+				slew-rate = <3>;
+				bias-disable;
+			};
+			data {
+				pins = "gpio1", "gpio2", "gpio14";
+				function = "swr_tx_data";
+				drive-strength = <10>;
+				slew-rate = <3>;
+				bias-bus-hold;
+			};
+		};
+	};
+
+	sound: sound {
+	};
+	
+	remoteproc_cdsp: remoteproc@8300000 {
+		compatible = "qcom,sm7125-cdsp-pas", "qcom,sm6350-cdsp-pas";
+		reg = <0 0x08300000 0 0x10000>;
+
+		interrupts-extended = <&intc GIC_SPI 578 IRQ_TYPE_LEVEL_HIGH>,
+						<&cdsp_smp2p_in 0 IRQ_TYPE_EDGE_RISING>,
+						<&cdsp_smp2p_in 1 IRQ_TYPE_EDGE_RISING>,
+						<&cdsp_smp2p_in 2 IRQ_TYPE_EDGE_RISING>,
+						<&cdsp_smp2p_in 3 IRQ_TYPE_EDGE_RISING>;
+		interrupt-names = "wdog", "fatal", "ready",
+					"handover", "stop-ack";
+
+		clocks = <&rpmhcc RPMH_CXO_CLK>;
+		clock-names = "xo";
+
+		power-domains = <&rpmhpd SC7180_CX>,
+				<&rpmhpd SC7180_MX>;
+		power-domain-names = "cx", "mx";
+
+		memory-region = <&cdsp_mem>;
+
+		qcom,qmp = <&aoss_qmp>;
+
+		qcom,smem-states = <&cdsp_smp2p_out 0>;
+		qcom,smem-state-names = "stop";
+
+		status = "disabled";
+
+		glink-edge {
+			interrupts = <GIC_SPI 574 IRQ_TYPE_EDGE_RISING>;
+			label = "cdsp";
+			qcom,remote-pid = <5>;
+			mboxes = <&apss_shared 4>;
+
+			fastrpc {
+				compatible = "qcom,fastrpc";
+				qcom,glink-channels = "fastrpcglink-apps-dsp";
+				label = "cdsp";
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				compute-cb@1 {
+					compatible = "qcom,fastrpc-compute-cb";
+					reg = <1>;
+					iommus = <&apps_smmu 0x1401 0x20>;
+				};
+
+				compute-cb@2 {
+					compatible = "qcom,fastrpc-compute-cb";
+					reg = <2>;
+					iommus = <&apps_smmu 0x1402 0x20>;
+				};
+
+				compute-cb@3 {
+					compatible = "qcom,fastrpc-compute-cb";
+					reg = <3>;
+					iommus = <&apps_smmu 0x1403 0x20>;
+				};
+
+				compute-cb@4 {
+					compatible = "qcom,fastrpc-compute-cb";
+					reg = <4>;
+					iommus = <&apps_smmu 0x1404 0x20>;
+				};
+
+				compute-cb@5 {
+					compatible = "qcom,fastrpc-compute-cb";
+					reg = <5>;
+					iommus = <&apps_smmu 0x1405 0x20>;
+				};
+
+				compute-cb@6 {
+					compatible = "qcom,fastrpc-compute-cb";
+					reg = <6>;
+					iommus = <&apps_smmu 0x1406 0x20>;
+				};
+
+				compute-cb@7 {
+					compatible = "qcom,fastrpc-compute-cb";
+					reg = <7>;
+					iommus = <&apps_smmu 0x1407 0x20>;
+				};
+
+				compute-cb@8 {
+					compatible = "qcom,fastrpc-compute-cb";
+					reg = <8>;
+					iommus = <&apps_smmu 0x1408 0x20>;
+				};
+
+				/* note: secure cb9 in downstream */
+			};
+		};
+	};
+
+    gpi_dma0: dma-controller@800000  {
+		compatible = "qcom,sm6350-gpi-dma";
+		reg = <0 0x00800000 0 0x60000>;
+		interrupts = <GIC_SPI 244 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 245 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 246 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 247 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 248 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 249 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 250 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 251 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 252 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 253 IRQ_TYPE_LEVEL_HIGH>;
+		dma-channels = <10>;
+		dma-channel-mask = <0x1f>;
+		iommus = <&apps_smmu 0x56 0x0>;
+		#dma-cells = <3>;
+		status = "disabled";
+	};
+
+	gpi_dma1: dma-controller@a00000 {
+		compatible = "qcom,sm6350-gpi-dma";
+		reg = <0 0x00a00000 0 0x60000>;
+		interrupts = <GIC_SPI 645 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 646 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 647 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 648 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 649 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 650 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 651 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 652 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 653 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 654 IRQ_TYPE_LEVEL_HIGH>;
+		dma-channels = <10>;
+		dma-channel-mask = <0x3f>;
+		iommus = <&apps_smmu 0x4d6 0x0>;
+		#dma-cells = <3>;
+		status = "disabled";
+	};
+};
+
+&remoteproc_adsp {
+	glink-edge {
+		fastrpc {
+			qcom,non-secure-domain;
+		};
+	};
+};
+
+&usb_1_dwc3 {
+    ports {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        port@0 {
+            reg = <0>;
+            usb_1_dwc3_hs: endpoint { };
+        };
+
+        port@1 {
+            reg = <1>;
+            usb_1_dwc3_ss: endpoint { };
+        };
+    };
+};
\ No newline at end of file
diff --git a/arch/arm64/configs/sm7125.config b/arch/arm64/configs/sm7125.config
new file mode 100644
index 00000000000000..4404478f31d654
--- /dev/null
+++ b/arch/arm64/configs/sm7125.config
@@ -0,0 +1,794 @@
+# Qualcomm Snapdragon SM7125 config fragment
+CONFIG_LOCALVERSION="-sm7125"
+# CONFIG_LOCALVERSION_AUTO is not set
+
+# Common for SM7125 devices
+CONFIG_BATTERY_QCOM_QG=m
+
+# Redmi Note 9S / Redmi Note 9 Pro (Global)
+CONFIG_DRM_PANEL_HUAXING_FT8756=m
+CONFIG_DRM_PANEL_TIANMA_NT36675=m
+CONFIG_SND_SOC_TAS2562=m
+CONFIG_TOUCHSCREEN_NT36XXX_SPI=m
+CONFIG_TOUCHSCREEN_FT8756=m
+CONFIG_VIDEO_OV8856=m
+CONFIG_INPUT_DRV2624_HAPTICS=m
+
+# SM7125 SoC
+CONFIG_INTERCONNECT_QCOM_OSM_L3=y
+CONFIG_INTERCONNECT_QCOM_SC7180=y
+CONFIG_PINCTRL_SC7180=y
+CONFIG_SC_GPUCC_7180=y
+CONFIG_SC_CAMCC_7180=y
+CONFIG_SC_DISPCC_7180=y
+CONFIG_SC_GCC_7180=y
+CONFIG_SC_VIDEOCC_7180=y
+
+# Qualcomm SoC drivers
+CONFIG_QCOM_LLCC=y
+CONFIG_QCOM_OCMEM=y
+CONFIG_QCOM_RMTFS_MEM=y
+CONFIG_QCOM_SOCINFO=y
+CONFIG_QCOM_APR=y
+
+# Console ramoops & USB debug
+CONFIG_PSTORE=y
+CONFIG_PSTORE_CONSOLE=y
+CONFIG_PSTORE_PMSG=y
+CONFIG_PSTORE_RAM=y
+CONFIG_U_SERIAL_CONSOLE=y
+
+# Remoteproc
+CONFIG_SLIMBUS=y
+CONFIG_SLIM_QCOM_CTRL=y
+CONFIG_SLIM_QCOM_NGD_CTRL=y
+CONFIG_REMOTEPROC_CDEV=y
+
+# Graphics
+CONFIG_FB_SIMPLE=y
+CONFIG_DRM=y
+CONFIG_DRM_DISPLAY_HELPER=y
+CONFIG_DRM_MSM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_QCOM_WLED=m
+
+# Power management
+CONFIG_PM_AUTOSLEEP=y
+CONFIG_PM_WAKELOCKS=y
+
+# I2C system bus drivers
+CONFIG_I2C_QCOM_GENI=y
+
+# SPI Master Controller Drivers
+CONFIG_SPI_QCOM_GENI=y
+
+# DMA Devices
+CONFIG_QCOM_GPI_DMA=y
+
+# Input Device Drivers
+#CONFIG_INPUT_UINPUT=m
+
+# Generic Driver Options
+CONFIG_UEVENT_HELPER=y
+
+# MMC/SD/SDIO Host Controller Drivers
+CONFIG_SCSI_UFS_QCOM=y
+
+# PHY Subsystem
+CONFIG_PHY_QCOM_QMP=y
+CONFIG_PHY_QCOM_QMP_COMBO=y
+CONFIG_PHY_QCOM_QMP_UFS=y
+CONFIG_PHY_QCOM_QMP_USB=y
+CONFIG_PHY_QCOM_QUSB2=y
+CONFIG_PHY_QCOM_USB_HS=y
+CONFIG_PHY_QCOM_USB_SNPS_FEMTO_V2=y
+CONFIG_PHY_QCOM_USB_SS=y
+
+# USB
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+# USB Type-C 
+CONFIG_TYPEC=y
+CONFIG_TYPEC_TCPM=y
+CONFIG_TYPEC_QCOM_PMIC=y
+
+# REGULATOR
+CONFIG_REGULATOR_QCOM_USB_VBUS=y
+CONFIG_REGULATOR_VCTRL=n
+
+# Bluetooth device drivers
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=m
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HS=y
+CONFIG_BT_LE=y
+
+# HID
+CONFIG_HID_BATTERY_STRENGTH=y
+CONFIG_HIDRAW=y
+
+# HID/Input
+CONFIG_HID_GENERIC=m
+CONFIG_UHID=m
+CONFIG_USB_HID=m
+CONFIG_INPUT_EVDEV=y
+CONFIG_BT_HIDP=m
+CONFIG_INPUT_JOYDEV=m
+
+# Sound
+CONFIG_SND_SOC_WCD937X_SDW=m
+CONFIG_SND_SOC_LPASS_RX_MACRO=m
+CONFIG_SND_SOC_LPASS_TX_MACRO=m
+CONFIG_PINCTRL_SC7280_LPASS_LPI=m
+CONFIG_CLK_GFM_LPASS_SM8250=m
+
+# LED Triggers
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_ACTIVITY=y
+
+# libcamera
+CONFIG_DMABUF_HEAPS_CMA=y
+CONFIG_DMABUF_HEAPS=y
+CONFIG_DMABUF_HEAPS=y
+CONFIG_DMA_CMA=y
+CONFIG_CMA=y
+CONFIG_CMA_SIZE_MBYTES=256
+
+# Misc useful things
+CONFIG_POWER_RESET_QCOM_PON=y
+CONFIG_SCHED_CLUSTER=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_BLK_DEV_RAM=y
+
+# Needed for mounting userdata on android
+CONFIG_QFMT_V2=y
+
+# Anbox
+CONFIG_BRIDGE_NETFILTER=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX_DIAG=y
+CONFIG_NETLINK_DIAG=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_SQUASHFS_XATTR=y
+CONFIG_SQUASHFS_LZ4=y
+CONFIG_SQUASHFS_LZO=y
+CONFIG_SQUASHFS_XZ=y
+
+# Waydroid
+CONFIG_PSI=y
+
+# WLAN
+CONFIG_QRTR=y
+
+# WLAN debugging
+CONFIG_ATH10K_DEBUG=y
+CONFIG_ATH10K_DEBUGFS=y
+CONFIG_ATH10K_SPECTRAL=y
+
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_PRIO=y
+CONFIG_NET_SCH_MULTIQ=y
+
+# Debugging stuff
+CONFIG_STACKTRACE=y
+
+# Firmware loading
+CONFIG_FW_LOADER_COMPRESS=y
+CONFIG_FW_LOADER_COMPRESS_XZ=n
+CONFIG_FW_LOADER_COMPRESS_ZSTD=y
+
+#pmOS Related
+CONFIG_VT=y
+CONFIG_CRYPTO_XTS=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_DM_CRYPT=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_BINFMT_MISC=m
+
+CONFIG_NF_TABLES=m
+CONFIG_NF_TABLES_INET=y
+CONFIG_NFT_CT=m
+CONFIG_NFT_COUNTER=m
+CONFIG_NFT_LOG=m
+CONFIG_NFT_LIMIT=m
+CONFIG_NFT_MASQ=m
+CONFIG_NFT_NAT=m
+CONFIG_NFT_REJECT=m
+CONFIG_NF_TABLES_IPV4=y
+CONFIG_NF_TABLES_IPV6=y
+
+CONFIG_WIREGUARD=m
+CONFIG_DRM_GUD=m
+
+# pmos containers kconfig
+CONFIG_CGROUP_FREEZER=y
+CONFIG_NETFILTER_XT_MATCH_IPVS=m
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_DUMMY=m
+CONFIG_BLK_DEV_THROTTLING=y
+CONFIG_NET_CLS_CGROUP=m
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_VS=m
+CONFIG_IP_VS_NFCT=y
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_RR=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_DM_THIN_PROVISIONING=y
+CONFIG_VXLAN=m
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_IPVLAN=m
+
+# pmOS ZRAM kconfig
+CONFIG_ZSMALLOC=m
+CONFIG_ZSMALLOC_STAT=y
+CONFIG_ZRAM=m
+CONFIG_ZRAM_MEMORY_TRACKING=y
+CONFIG_CRYPTO_LZ4=m
+CONFIG_LZ4_COMPRESS=m
+CONFIG_CRYPTO_LZO=m
+CONFIG_CRYPTO_ZSTD=m
+
+# pmOS iwd kconfig
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+CONFIG_KEY_DH_OPERATIONS=y
+CONFIG_CRYPTO_KPP=y
+CONFIG_PKCS8_PRIVATE_KEY_PARSER=y
+
+# LEDs
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_CLASS_FLASH=y
+CONFIG_LEDS_QCOM_FLASH=y
+
+#Sony PlayStation controllers
+CONFIG_HID_SONY=m
+CONFIG_SONY_FF=y
+
+# Disable all unrelated stuffs afaik
+CONFIG_ACPI=n
+CONFIG_VIRTUALIZATION=n
+CONFIG_PSTORE_DEFLATE_COMPRESS=n
+CONFIG_HIBERNATION=n
+CONFIG_FW_LOADER_USER_HELPER=n
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=n
+CONFIG_BLK_DEV_NVME=n
+CONFIG_ATA=n
+CONFIG_MTD=n
+CONFIG_SRAM=n
+CONFIG_MEGARAID_SAS=n
+CONFIG_EEPROM_AT25=n
+CONFIG_SCSI_MPT3SAS=n
+CONFIG_BLK_DEV_MD=n
+CONFIG_DM_MIRROR=n
+CONFIG_DM_ZERO=n
+CONFIG_EXT2_FS=n
+CONFIG_EXT3_FS=n
+CONFIG_BTRFS_FS=n
+CONFIG_USB_DWC2=n
+CONFIG_USB_CHIPIDEA=n
+CONFIG_USB_MUSB_HDRC=n
+CONFIG_USB_ISP1760=n
+CONFIG_USB_HSIC_USB3503=n
+CONFIG_USB_NET_PLUSB=n
+CONFIG_TYPEC_FUSB302=n
+CONFIG_TYPEC_MUX_NB7VPQ904M=n
+CONFIG_EXTCON_PTN5150=n
+CONFIG_REALTEK_PHY=n
+CONFIG_NET_VENDOR_NI=n
+CONFIG_NET_9P=n
+CONFIG_CAN=n
+CONFIG_BNX2X=n
+CONFIG_MACB=n
+CONFIG_IGB=n
+CONFIG_IGBVF=n
+CONFIG_SMC91X=n
+CONFIG_MLX4_EN=n
+CONFIG_MLX5_CORE=n
+CONFIG_STMMAC_ETH=n
+CONFIG_ATL1C=n
+CONFIG_BRCMFMAC=n
+CONFIG_WL18XX=n
+CONFIG_WLCORE=n
+CONFIG_ATH10K_PCI=n
+CONFIG_NET_SCH_CBS=n
+CONFIG_NET_SCH_ETF=n
+CONFIG_NET_SCH_TAPRIO=n
+CONFIG_NET_SCH_MQPRIO=n
+CONFIG_NET_CLS_BASIC=n
+CONFIG_NET_CLS_FLOWER=n
+CONFIG_NET_CLS_ACT=n
+CONFIG_NET_ACT_GACT=n
+CONFIG_NET_ACT_MIRRED=n
+CONFIG_NET_ACT_GATE=n
+CONFIG_MDIO_BUS_MUX_MMIOREG=n
+CONFIG_MDIO_BUS_MUX_MULTIPLEXER=n
+CONFIG_GPIO_AGGREGATOR=n
+CONFIG_GPIO_DWAPB=n
+CONFIG_COMMON_CLK_XGENE=n
+CONFIG_TCG_TPM=n
+CONFIG_BATTERY_SBS=n
+CONFIG_THUNDER_NIC_BGX=n
+CONFIG_THUNDER_NIC_RGX=n
+CONFIG_MDIO_THUNDER=n
+CONFIG_HW_RANDOM_CAVIUM=n
+CONFIG_EEPROM_AT24=n
+CONFIG_NET_DSA=n
+CONFIG_VITESSE_PHY=n
+CONFIG_PCI_PASID=n
+CONFIG_UACCE=n
+CONFIG_NOP_USB_XCEIV=n
+CONFIG_SURFACE_PLATFORMS=n
+CONFIG_USB_CONN_GPIO=n
+CONFIG_MICREL_PHY=n
+CONFIG_COMMON_CLK_VC5=n
+CONFIG_CRYPTO_DEV_CCREE=n
+CONFIG_SND_SIMPLE_CARD=n
+CONFIG_SND_SIMPLE_CARD_UTILS=n
+CONFIG_SND_AUDIO_GRAPH_CARD=n
+CONFIG_TYPEC_HD3SS3220=n
+CONFIG_COMMON_CLK_CS2000_CP=n
+CONFIG_PL330_DMA=n
+CONFIG_NET_VENDOR_SOCIONEXT=n
+
+# Disable Native drivers
+CONFIG_SENSORS_ARM_SCPI=n
+CONFIG_SENSORS_LM90=n
+CONFIG_SENSORS_INA2XX=n
+CONFIG_SENSORS_LM75=n
+CONFIG_SENSORS_PWM_FAN=n
+CONFIG_SENSORS_INA3221=n
+CONFIG_SENSORS_ISL29018=n
+
+# Disable Batteries
+CONFIG_BATTERY_QCOM_BATTMGR=n
+CONFIG_BATTERY_MAX17042=n
+
+# Disable Chargers
+CONFIG_CHARGER_BQ25890=n
+CONFIG_CHARGER_BQ25980=n
+CONFIG_CHARGER_RK817=n
+
+# Disable MII PHY device drivers
+CONFIG_AQUANTIA_PHY=n
+CONFIG_MICROSEMI_PHY=n
+
+# Disable Multiplexer I2C Chip support
+CONFIG_I2C_MUX_PCA954x=n
+
+# Disable pressure sensors
+CONFIG_MPL3115=n
+
+# Disable Display Panels
+CONFIG_DRM_PANEL_BOE_TV101WUM_NL6=n
+CONFIG_DRM_PANEL_ILITEK_ILI9882T=n
+CONFIG_DRM_PANEL_LVDS=n
+CONFIG_DRM_PANEL_MANTIX_MLAF057WE51=n
+CONFIG_DRM_PANEL_RAYDIUM_RM67191=n
+CONFIG_DRM_PANEL_SITRONIX_ST7703=n
+CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA=n
+CONFIG_DRM_PANEL_VISIONOX_VTDR6130=n
+
+# Disable I2C GPIO expanders
+CONFIG_GPIO_MAX732X=n
+CONFIG_GPIO_PCA953X=n
+
+# Disable Backlight & LCD device support
+CONFIG_BACKLIGHT_LP855X=n
+
+# Disable IR I2C driver auto-selected by 'Autoselect ancillary drivers'
+CONFIG_VIDEO_IMX219=n
+CONFIG_VIDEO_IMX412=n
+CONFIG_VIDEO_OV5640=n
+CONFIG_VIDEO_OV5645=n
+
+# Disable Common SoC Audio options for Freescale CPUs:
+CONFIG_SND_SOC_FSL_ASRC=n
+CONFIG_SND_SOC_FSL_SAI=n
+CONFIG_SND_SOC_FSL_AUDMIX=n
+CONFIG_SND_SOC_FSL_SPDIF=n
+CONFIG_SND_SOC_FSL_MICFIL=n
+
+# Disable Input Device Drivers
+CONFIG_KEYBOARD_ADC=n
+CONFIG_KEYBOARD_GPIO_POLLED=n
+CONFIG_MOUSE_ELAN_I2C=n
+CONFIG_TOUCHSCREEN_ATMEL_MXT=n
+CONFIG_TOUCHSCREEN_GOODIX=n
+CONFIG_TOUCHSCREEN_ELAN=n
+CONFIG_TOUCHSCREEN_EDT_FT5X06=n
+
+# Disable I2C RTC drivers
+CONFIG_RTC_DRV_DS1307=n
+CONFIG_RTC_DRV_RK808=n
+CONFIG_RTC_DRV_HYM8563=n
+CONFIG_RTC_DRV_ISL1208=n
+CONFIG_RTC_DRV_PCF85063=n
+CONFIG_RTC_DRV_PCF85363=n
+CONFIG_RTC_DRV_PCF8563=n
+CONFIG_RTC_DRV_M41T80=n
+CONFIG_RTC_DRV_BQ32K=n
+CONFIG_RTC_DRV_RX8581=n
+CONFIG_RTC_DRV_RV3028=n
+CONFIG_RTC_DRV_RV8803=n
+
+# Disable SPI and I2C RTC drivers
+CONFIG_RTC_DRV_DS3232=n
+CONFIG_RTC_DRV_PCF2127=n
+
+# Disable on-CPU RTC drivers
+CONFIG_RTC_DRV_PL031=n
+
+# Disable ARM errata workarounds via the alternatives framework
+CONFIG_CAVIUM_ERRATUM_22375=n
+CONFIG_CAVIUM_ERRATUM_23144=n
+CONFIG_CAVIUM_ERRATUM_23154=n
+CONFIG_CAVIUM_ERRATUM_27456=n
+CONFIG_CAVIUM_ERRATUM_30115=n
+CONFIG_CAVIUM_TX2_ERRATUM_219=n
+CONFIG_FUJITSU_ERRATUM_010001=n
+CONFIG_HISILICON_ERRATUM_161600802=n
+CONFIG_NVIDIA_CARMEL_CNP_ERRATUM=n
+CONFIG_ROCKCHIP_ERRATUM_3588001=n
+CONFIG_SOCIONEXT_SYNQUACER_PREITS=n
+
+# Disable platforms
+CONFIG_ARCH_ACTIONS=n
+CONFIG_ARCH_SUNXI=n
+CONFIG_ARCH_ALPINE=n
+CONFIG_ARCH_APPLE=n
+CONFIG_ARCH_BCM=n
+CONFIG_ARCH_BCM2835=n
+CONFIG_ARCH_BCM_IPROC=n
+CONFIG_ARCH_BCMBCA=n
+CONFIG_ARCH_BRCMSTB=n
+CONFIG_ARCH_BERLIN=n
+CONFIG_ARCH_BITMAIN=n
+CONFIG_ARCH_EXYNOS=n
+CONFIG_ARCH_SPARX5=n
+CONFIG_ARCH_K3=n
+CONFIG_ARCH_LG1K=n
+CONFIG_ARCH_HISI=n
+CONFIG_ARCH_KEEMBAY=n
+CONFIG_ARCH_MEDIATEK=n
+CONFIG_ARCH_MESON=n
+CONFIG_ARCH_MVEBU=n
+CONFIG_ARCH_NXP=n
+CONFIG_ARCH_LAYERSCAPE=n
+CONFIG_ARCH_MXC=n
+CONFIG_ARCH_S32=n
+CONFIG_ARCH_MA35=n
+CONFIG_ARCH_NPCM=n
+CONFIG_ARCH_REALTEK=n
+CONFIG_ARCH_RENESAS=n
+CONFIG_ARCH_ROCKCHIP=n
+CONFIG_ARCH_SEATTLE=n
+CONFIG_ARCH_INTEL_SOCFPGA=n
+CONFIG_ARCH_STM32=n
+CONFIG_ARCH_SYNQUACER=n
+CONFIG_ARCH_TEGRA=n
+CONFIG_ARCH_SPRD=n
+CONFIG_ARCH_THUNDER=n
+CONFIG_ARCH_THUNDER2=n
+CONFIG_ARCH_UNIPHIER=n
+CONFIG_ARCH_VEXPRESS=n
+CONFIG_ARCH_VISCONTI=n
+CONFIG_ARCH_XGENE=n
+CONFIG_ARCH_ZYNQMP=n
+
+# Disable PCI controller drivers
+CONFIG_PCIE_ALTERA=n
+CONFIG_PCI_HOST_THUNDER_PEM=n
+CONFIG_PCI_HOST_THUNDER_ECAM=n
+CONFIG_PCI_XGENE=n
+
+# Disable DesignWare-based PCIe controllers
+CONFIG_PCI_MESON=n
+CONFIG_PCI_HISI=n
+CONFIG_PCIE_KIRIN=n
+
+CONFIG_HIX5HD2_GMAC=n
+CONFIG_HNS_DSAF=n
+CONFIG_HNS_ENET=n
+CONFIG_HNS3=n
+
+# Disable serial drivers
+CONFIG_SERIAL_XILINX_PS_UART=n
+CONFIG_SERIAL_FSL_LPUART=n
+CONFIG_SERIAL_FSL_LINFLEXUART=n
+
+# Disable I2C system bus drivers (mostly embedded / system-on-chip)
+CONFIG_I2C_DESIGNWARE_PLATFORM=n
+CONFIG_I2C_RK3X=n
+
+# Disable SPI Master Controller Drivers
+CONFIG_SPI_CADENCE_QUADSPI=n
+CONFIG_SPI_DESIGNWARE=n
+CONFIG_SPI_PL022=n
+
+# Disable pinctrls
+CONFIG_PINCTRL_RK805=n
+CONFIG_PINCTRL_IPQ5018=n
+CONFIG_PINCTRL_IPQ5332=n
+CONFIG_PINCTRL_IPQ8074=n
+CONFIG_PINCTRL_IPQ6018=n
+CONFIG_PINCTRL_IPQ9574=n
+CONFIG_PINCTRL_MSM8916=n
+CONFIG_PINCTRL_MSM8953=n
+CONFIG_PINCTRL_MSM8976=n
+CONFIG_PINCTRL_MSM8994=n
+CONFIG_PINCTRL_MSM8996=n
+CONFIG_PINCTRL_MSM8998=n
+CONFIG_PINCTRL_QCM2290=n
+CONFIG_PINCTRL_QCS404=n
+CONFIG_PINCTRL_QDU1000=n
+CONFIG_PINCTRL_SA8775P=n
+CONFIG_PINCTRL_SM7150=n
+CONFIG_PINCTRL_SC7280=n
+CONFIG_PINCTRL_SC8180X=n
+CONFIG_PINCTRL_SC8280XP=n
+CONFIG_PINCTRL_SDM660=n
+CONFIG_PINCTRL_SDM670=n
+CONFIG_PINCTRL_SDM845=n
+CONFIG_PINCTRL_SDX75=n
+CONFIG_PINCTRL_SM4450=n
+CONFIG_PINCTRL_SM6115=n
+CONFIG_PINCTRL_SM6125=n
+CONFIG_PINCTRL_SM6350=n
+CONFIG_PINCTRL_SM6375=n
+CONFIG_PINCTRL_SM8150=n
+CONFIG_PINCTRL_SM8250=n
+CONFIG_PINCTRL_SM8350=n
+CONFIG_PINCTRL_SM8450=n
+CONFIG_PINCTRL_SM8550=n
+CONFIG_PINCTRL_SM8650=n
+CONFIG_PINCTRL_X1E80100=n
+CONFIG_PINCTRL_SM6115_LPASS_LPI=n
+CONFIG_PINCTRL_SM8250_LPASS_LPI=n
+CONFIG_PINCTRL_SM8350_LPASS_LPI=n
+CONFIG_PINCTRL_SM8450_LPASS_LPI=n
+CONFIG_PINCTRL_SC8280XP_LPASS_LPI=n
+CONFIG_PINCTRL_SM8550_LPASS_LPI=n
+CONFIG_PINCTRL_SM8650_LPASS_LPI=n
+
+# Disable clock drivers
+CONFIG_CLK_X1E80100_CAMCC=n
+CONFIG_CLK_X1E80100_DISPCC=n
+CONFIG_CLK_X1E80100_GCC=n
+CONFIG_CLK_X1E80100_GPUCC=n
+CONFIG_CLK_X1E80100_TCSRCC=n
+CONFIG_QCOM_CLK_APCS_MSM8916=n
+CONFIG_QCOM_CLK_APCC_MSM8996=n
+CONFIG_IPQ_GCC_5018=n
+CONFIG_IPQ_GCC_5332=n
+CONFIG_IPQ_GCC_6018=n
+CONFIG_IPQ_GCC_8074=n
+CONFIG_IPQ_GCC_9574=n
+CONFIG_MSM_GCC_8916=n
+CONFIG_MSM_MMCC_8994=n
+CONFIG_MSM_GCC_8994=n
+CONFIG_MSM_GCC_8996=n
+CONFIG_MSM_MMCC_8996=n
+CONFIG_MSM_GCC_8998=n
+CONFIG_MSM_MMCC_8998=n
+CONFIG_QCM_GCC_2290=n
+CONFIG_QCM_DISPCC_2290=n
+CONFIG_QCS_GCC_404=n
+CONFIG_QDU_GCC_1000=n
+CONFIG_SC_CAMCC_8280XP=n
+CONFIG_SC_DISPCC_8280XP=n
+CONFIG_SA_GCC_8775P=n
+CONFIG_SA_GPUCC_8775P=n
+CONFIG_SC_GCC_7150=n
+CONFIG_SC_GCC_7280=n
+CONFIG_SC_GCC_8180X=n
+CONFIG_SC_GCC_8280XP=n
+CONFIG_SC_GPUCC_8280XP=n
+CONFIG_SC_LPASSCC_8280XP=n
+CONFIG_SDM_CAMCC_845=n
+CONFIG_SDM_GCC_845=n
+CONFIG_SDM_GPUCC_845=n
+CONFIG_SDM_VIDEOCC_845=n
+CONFIG_SDM_DISPCC_845=n
+CONFIG_SDM_LPASSCC_845=n
+CONFIG_SDX_GCC_75=n
+CONFIG_SM_CAMCC_8250=n
+CONFIG_SM_DISPCC_6115=n
+CONFIG_SM_DISPCC_8250=n
+CONFIG_SM_DISPCC_8450=n
+CONFIG_SM_DISPCC_8550=n
+CONFIG_SM_GCC_6115=n
+CONFIG_SM_GCC_8150=n
+CONFIG_SM_GCC_8250=n
+CONFIG_SM_GCC_8350=n
+CONFIG_SM_GCC_8450=n
+CONFIG_SM_GCC_8550=n
+CONFIG_SM_GCC_8650=n
+CONFIG_SM_GPUCC_6115=n
+CONFIG_SM_GPUCC_8150=n
+CONFIG_SM_GPUCC_8250=n
+CONFIG_SM_GPUCC_8450=n
+CONFIG_SM_GPUCC_8550=n
+CONFIG_SM_GPUCC_8650=n
+CONFIG_SM_TCSRCC_8550=n
+CONFIG_SM_TCSRCC_8650=n
+CONFIG_SM_VIDEOCC_8250=n
+
+# Disable interconnect drivers
+CONFIG_INTERCONNECT_QCOM_MSM8916=n
+CONFIG_INTERCONNECT_QCOM_MSM8996=n
+CONFIG_INTERCONNECT_QCOM_QCM2290=n
+CONFIG_INTERCONNECT_QCOM_QCS404=n
+CONFIG_INTERCONNECT_QCOM_SA8775P=n
+CONFIG_INTERCONNECT_QCOM_SM7150=n
+CONFIG_INTERCONNECT_QCOM_SC7280=n
+CONFIG_INTERCONNECT_QCOM_SC8180X=n
+CONFIG_INTERCONNECT_QCOM_SC8280XP=n
+CONFIG_INTERCONNECT_QCOM_SDM845=n
+CONFIG_INTERCONNECT_QCOM_SDX75=n
+CONFIG_INTERCONNECT_QCOM_SM8150=n
+CONFIG_INTERCONNECT_QCOM_SM8250=n
+CONFIG_INTERCONNECT_QCOM_SM8350=n
+CONFIG_INTERCONNECT_QCOM_SM8450=n
+CONFIG_INTERCONNECT_QCOM_SM8550=n
+CONFIG_INTERCONNECT_QCOM_SM8650=n
+CONFIG_INTERCONNECT_QCOM_X1E80100=n
+
+# Disable memory mapped GPIO drivers
+CONFIG_GPIO_ALTERA=n
+CONFIG_GPIO_MB86S7X=n
+CONFIG_GPIO_PL061=n
+CONFIG_GPIO_WCD934X=n
+CONFIG_GPIO_XGENE=n
+
+# Disable Virtual GPIO drivers
+CONFIG_POWER_RESET_XGENE=n
+CONFIG_POWER_RESET_SYSCON=n
+CONFIG_GNSS_MTK_SERIAL=n
+
+# Disable Watchdog Device Drivers
+CONFIG_ARM_SP805_WATCHDOG=n
+CONFIG_ARM_SBSA_WATCHDOG=n
+CONFIG_DW_WATCHDOG=n
+CONFIG_ARM_SMC_WATCHDOG=n
+
+# Disable Multifunction device drivers
+CONFIG_MFD_BD9571MWV=n
+CONFIG_MFD_AXP20X_I2C=n
+CONFIG_MFD_HI6421_PMIC=n
+CONFIG_MFD_MAX77620=n
+CONFIG_MFD_MT6360=n
+CONFIG_MFD_MT6397=n
+CONFIG_MFD_RK8XX=n
+CONFIG_MFD_SEC_CORE=n
+CONFIG_MFD_TI_AM335X_TSCADC=n
+CONFIG_MFD_TPS65219=n
+CONFIG_MFD_TPS6594_I2C=n
+CONFIG_MFD_WM8994=n
+CONFIG_MFD_ROHM_BD718XX=n
+CONFIG_MFD_WCD934X=n
+
+CONFIG_REGULATOR_FAN53555=n
+CONFIG_REGULATOR_MAX8973=n
+CONFIG_REGULATOR_MP8859=n
+CONFIG_REGULATOR_MT6315=n
+CONFIG_REGULATOR_MT6360=n
+CONFIG_REGULATOR_PCA9450=n
+CONFIG_REGULATOR_PF8X00=n
+CONFIG_REGULATOR_PFUZE100=n
+CONFIG_REGULATOR_RAA215300=n
+CONFIG_REGULATOR_RK808=n
+CONFIG_REGULATOR_TPS65132=n
+CONFIG_REGULATOR_TPS65219=n
+
+# Disable media device types
+CONFIG_MEDIA_ANALOG_TV_SUPPORT=n
+CONFIG_MEDIA_DIGITAL_TV_SUPPORT=n
+CONFIG_MEDIA_SDR_SUPPORT=n
+
+# Disable I2C encoder or helper chips
+CONFIG_DRM_I2C_NXP_TDA998X=n
+
+# Disable ARM devices
+CONFIG_DRM_MALI_DISPLAY=n
+CONFIG_DRM_KOMEDA=n
+
+# Disable DRM Drivers
+CONFIG_DRM_NOUVEAU=n
+
+# Disable display Interface Bridges
+CONFIG_DRM_LONTIUM_LT8912B=n
+CONFIG_DRM_LONTIUM_LT9611=n
+CONFIG_DRM_LONTIUM_LT9611UXC=n
+CONFIG_DRM_ITE_IT66121=n
+CONFIG_DRM_NWL_MIPI_DSI=n
+CONFIG_DRM_PARADE_PS8640=n
+CONFIG_DRM_SAMSUNG_DSIM=n
+CONFIG_DRM_SII902X=n
+CONFIG_DRM_THINE_THC63LVD1024=n
+CONFIG_DRM_TOSHIBA_TC358768=n
+CONFIG_DRM_TI_TFP410=n
+CONFIG_DRM_TI_SN65DSI83=n
+CONFIG_DRM_TI_SN65DSI86=n
+CONFIG_DRM_ANALOGIX_ANX7625=n
+CONFIG_DRM_I2C_ADV7511=n
+CONFIG_DRM_CDNS_MHDP8546=n
+
+CONFIG_DRM_ETNAVIV=n
+CONFIG_DRM_HISI_HIBMC=n
+CONFIG_DRM_HISI_KIRIN=n
+CONFIG_DRM_PL111=n
+CONFIG_DRM_LIMA=n
+CONFIG_DRM_PANFROST=n
+
+# Disable CODEC drivers
+CONFIG_SND_SOC_ADAU7002=n
+CONFIG_SND_SOC_AK4613=n
+CONFIG_SND_SOC_DA7213=n
+CONFIG_SND_SOC_ES7134=n
+CONFIG_SND_SOC_ES7241=n
+CONFIG_SND_SOC_ES8316=n
+CONFIG_SND_SOC_GTM601=n
+CONFIG_SND_SOC_MAX98357A=n
+CONFIG_SND_SOC_MAX98927=n
+CONFIG_SND_SOC_MSM8916_WCD_ANALOG=n
+CONFIG_SND_SOC_MSM8916_WCD_DIGITAL=n
+CONFIG_SND_SOC_PCM3168A_I2C=n
+CONFIG_SND_SOC_RK817=n
+CONFIG_SND_SOC_RL6231=n
+CONFIG_SND_SOC_RT5640=n
+CONFIG_SND_SOC_RT5659=n
+CONFIG_SND_SOC_RT5663=n
+CONFIG_SND_SOC_RT5682=n
+CONFIG_SND_SOC_SGTL5000=n
+CONFIG_SND_SOC_TAS2552=n
+CONFIG_SND_SOC_TAS571X=n
+CONFIG_SND_SOC_TLV320AIC31XX=n
+CONFIG_SND_SOC_TLV320AIC32X4=n
+CONFIG_SND_SOC_TLV320AIC3X=n
+CONFIG_SND_SOC_TS3A227E=n
+CONFIG_SND_SOC_WCD9335=n
+CONFIG_SND_SOC_WCD934X=n
+CONFIG_SND_SOC_WCD938X=n
+CONFIG_SND_SOC_WM8524=n
+CONFIG_SND_SOC_WM8904=n
+CONFIG_SND_SOC_WM8960=n
+CONFIG_SND_SOC_WM8962=n
+CONFIG_SND_SOC_WM8978=n
+CONFIG_SND_SOC_WSA881X=n
+CONFIG_SND_SOC_MT6358=n
+CONFIG_SND_SOC_NAU8822=n
+
+# Disable USB Host Controller Drivers
+CONFIG_USB_XHCI_PCI_RENESAS=n
+
+# Disable MMC/SD/SDIO Host Controller Drivers
+CONFIG_MMC_SDHCI_OF_ARASAN=n
+CONFIG_MMC_SDHCI_CADENCE=n
+CONFIG_MMC_SDHCI_F_SDH30=n
+CONFIG_MMC_DW_EXYNOS=n
+CONFIG_MMC_DW_HI3798CV200=n
+CONFIG_MMC_DW_K3=n
+CONFIG_MMC_MTK=n
+CONFIG_MMC_SDHCI_XENON=n
+CONFIG_MMC_SDHCI_AM654=n
+
+CONFIG_FSL_EDMA=n
+CONFIG_MV_XOR_V2=n
+CONFIG_COMMON_CLK_RK808=n
+CONFIG_FSL_RCPM=n
+CONFIG_ARCH_R9A07G044=n
+CONFIG_MAX9611=n
+CONFIG_NVMEM_RMEM=n
+CONFIG_FPGA=n
\ No newline at end of file
diff --git a/drivers/cpufreq/cpufreq-dt-platdev.c b/drivers/cpufreq/cpufreq-dt-platdev.c
index c74dd1e01e0d68..9d324799275c2e 100644
--- a/drivers/cpufreq/cpufreq-dt-platdev.c
+++ b/drivers/cpufreq/cpufreq-dt-platdev.c
@@ -165,6 +165,7 @@ static const struct of_device_id blocklist[] __initconst = {
 	{ .compatible = "qcom,sm6115", },
 	{ .compatible = "qcom,sm6350", },
 	{ .compatible = "qcom,sm6375", },
+	{ .compatible = "qcom,sm7125", },
 	{ .compatible = "qcom,sm7225", },
 	{ .compatible = "qcom,sm8150", },
 	{ .compatible = "qcom,sm8250", },
diff --git a/drivers/gpu/drm/msm/adreno/adreno_device.c b/drivers/gpu/drm/msm/adreno/adreno_device.c
index c3703a51287b46..f1c0acc7a4e368 100644
--- a/drivers/gpu/drm/msm/adreno/adreno_device.c
+++ b/drivers/gpu/drm/msm/adreno/adreno_device.c
@@ -333,10 +333,13 @@ static const struct adreno_info gpulist[] = {
 		.inactive_period = DRM_MSM_INACTIVE_PERIOD,
 		.quirks = ADRENO_QUIRK_HAS_CACHED_COHERENT,
 		.init = a6xx_gpu_init,
+		.zapfw = "a615_zap.mbn",
+		.hwcg = a615_hwcg,
 		.speedbins = ADRENO_SPEEDBINS(
 			{ 0,   0 },
 			{ 169, 1 },
 			{ 174, 2 },
+			{ 159, 3 },
 		),
 	}, {
 		.machine = "qcom,sm4350",
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 2ae0eb0638f325..1439dd5cf89186 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -126,6 +126,14 @@ config DRM_PANEL_FEIYANG_FY07024DI26A30D
 	  Say Y if you want to enable support for panels based on the
 	  Feiyang FY07024DI26A30-D MIPI-DSI interface.
 
+config DRM_PANEL_HUAXING_FT8756
+	tristate "Huaxing FT8756 DSI panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y here if you want to enable support for the Huaxing FT8756 DSI panel.
+
 config DRM_PANEL_DSI_CM
 	tristate "Generic DSI command mode panels"
 	depends on OF
@@ -459,6 +467,14 @@ config DRM_PANEL_NOVATEK_NT36672E
 	  LCD panel module. The panel has a resolution of 1080x2408 and uses 24 bit
 	  RGB per pixel.
 
+config DRM_PANEL_TIANMA_NT36675
+	tristate "Tianma NT36675 DSI panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y here if you want to enable support for the Tianma NT36675 DSI panel.
+
 config DRM_PANEL_NOVATEK_NT39016
 	tristate "Novatek NT39016 RGB/SPI panel"
 	depends on OF && SPI
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index f0203f6e02f447..dc48eace2e1e7b 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -15,6 +15,7 @@ obj-$(CONFIG_DRM_PANEL_EBBG_FT8719) += panel-ebbg-ft8719.o
 obj-$(CONFIG_DRM_PANEL_ELIDA_KD35T133) += panel-elida-kd35t133.o
 obj-$(CONFIG_DRM_PANEL_FEIXIN_K101_IM2BA02) += panel-feixin-k101-im2ba02.o
 obj-$(CONFIG_DRM_PANEL_FEIYANG_FY07024DI26A30D) += panel-feiyang-fy07024di26a30d.o
+obj-$(CONFIG_DRM_PANEL_HUAXING_FT8756) += panel-ft8756-huaxing.o
 obj-$(CONFIG_DRM_PANEL_HIMAX_HX83112A) += panel-himax-hx83112a.o
 obj-$(CONFIG_DRM_PANEL_HIMAX_HX8394) += panel-himax-hx8394.o
 obj-$(CONFIG_DRM_PANEL_ILITEK_IL9322) += panel-ilitek-ili9322.o
@@ -45,6 +46,7 @@ obj-$(CONFIG_DRM_PANEL_NOVATEK_NT35950) += panel-novatek-nt35950.o
 obj-$(CONFIG_DRM_PANEL_NOVATEK_NT36523) += panel-novatek-nt36523.o
 obj-$(CONFIG_DRM_PANEL_NOVATEK_NT36672A) += panel-novatek-nt36672a.o
 obj-$(CONFIG_DRM_PANEL_NOVATEK_NT36672E) += panel-novatek-nt36672e.o
+obj-$(CONFIG_DRM_PANEL_TIANMA_NT36675) += panel-nt36675-tianma.o
 obj-$(CONFIG_DRM_PANEL_NOVATEK_NT39016) += panel-novatek-nt39016.o
 obj-$(CONFIG_DRM_PANEL_MANTIX_MLAF057WE51) += panel-mantix-mlaf057we51.o
 obj-$(CONFIG_DRM_PANEL_OLIMEX_LCD_OLINUXINO) += panel-olimex-lcd-olinuxino.o
diff --git a/drivers/gpu/drm/panel/panel-ft8756-huaxing.c b/drivers/gpu/drm/panel/panel-ft8756-huaxing.c
new file mode 100644
index 00000000000000..b2addd0348dc70
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-ft8756-huaxing.c
@@ -0,0 +1,283 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct ft8756_huaxing {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct ft8756_huaxing *to_ft8756_huaxing(struct drm_panel *panel)
+{
+	return container_of(panel, struct ft8756_huaxing, panel);
+}
+
+static void ft8756_huaxing_reset(struct ft8756_huaxing *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(4000, 5000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int ft8756_huaxing_on(struct ft8756_huaxing *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x87, 0x56, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x87, 0x56);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0xca,
+			       0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+			       0x80, 0x80, 0x80, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_dcs_write_seq(dsi, 0xca,
+			       0xfe, 0xff, 0x66, 0xf6, 0xff, 0x66, 0xfb, 0xff,
+			       0x32);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x00b8);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xb5);
+	mipi_dsi_dcs_write_seq(dsi, 0xca, 0x04);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(90);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(5000, 6000);
+
+	return 0;
+}
+
+static int ft8756_huaxing_off(struct ft8756_huaxing *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(150);
+
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf7, 0x5a, 0xa5, 0x95, 0x27);
+
+	return 0;
+}
+
+static int ft8756_huaxing_prepare(struct drm_panel *panel)
+{
+	struct ft8756_huaxing *ctx = to_ft8756_huaxing(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	ft8756_huaxing_reset(ctx);
+
+	ret = ft8756_huaxing_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int ft8756_huaxing_unprepare(struct drm_panel *panel)
+{
+	struct ft8756_huaxing *ctx = to_ft8756_huaxing(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = ft8756_huaxing_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode ft8756_huaxing_mode = {
+	.clock = (1080 + 20 + 4 + 20) * (2400 + 8 + 4 + 32) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 20,
+	.hsync_end = 1080 + 20 + 4,
+	.htotal = 1080 + 20 + 4 + 20,
+	.vdisplay = 2400,
+	.vsync_start = 2400 + 8,
+	.vsync_end = 2400 + 8 + 4,
+	.vtotal = 2400 + 8 + 4 + 32,
+	.width_mm = 83,
+	.height_mm = 147,
+};
+
+static int ft8756_huaxing_get_modes(struct drm_panel *panel,
+				    struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &ft8756_huaxing_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs ft8756_huaxing_panel_funcs = {
+	.prepare = ft8756_huaxing_prepare,
+	.unprepare = ft8756_huaxing_unprepare,
+	.get_modes = ft8756_huaxing_get_modes,
+};
+
+static int ft8756_huaxing_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct ft8756_huaxing *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "vddio");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get vddio regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO;
+
+	drm_panel_init(&ctx->panel, dev, &ft8756_huaxing_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void ft8756_huaxing_remove(struct mipi_dsi_device *dsi)
+{
+	struct ft8756_huaxing *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id ft8756_huaxing_of_match[] = {
+	{ .compatible = "mdss,ft8756-huaxing" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ft8756_huaxing_of_match);
+
+static struct mipi_dsi_driver ft8756_huaxing_driver = {
+	.probe = ft8756_huaxing_probe,
+	.remove = ft8756_huaxing_remove,
+	.driver = {
+		.name = "panel-ft8756-huaxing",
+		.of_match_table = ft8756_huaxing_of_match,
+	},
+};
+module_mipi_dsi_driver(ft8756_huaxing_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for ft8756 video mode dsi huaxing panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/panel-nt36675-tianma.c b/drivers/gpu/drm/panel/panel-nt36675-tianma.c
new file mode 100644
index 00000000000000..c737cedc6743db
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-nt36675-tianma.c
@@ -0,0 +1,324 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct nt36675_tianma {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct nt36675_tianma *to_nt36675_tianma(struct drm_panel *panel)
+{
+	return container_of(panel, struct nt36675_tianma, panel);
+}
+
+static void nt36675_tianma_reset(struct nt36675_tianma *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int nt36675_tianma_on(struct nt36675_tianma *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0x03, 0x1e, 0x0a, 0x04, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x00);
+
+	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set tear on: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x00b8);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x27);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_VSYNC_TIMING, 0x25);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x23);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0a, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0x0b, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0x0c, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0x0d, 0x2a);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x50);
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x95);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0x68);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x0b);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PARTIAL_ROWS, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PARTIAL_COLUMNS, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x32, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x33, 0xfe);
+	mipi_dsi_dcs_write_seq(dsi, 0x34, 0xfd);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0xfa);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0xf6);
+	mipi_dsi_dcs_write_seq(dsi, 0x37, 0xf2);
+	mipi_dsi_dcs_write_seq(dsi, 0x38, 0xf0);
+	mipi_dsi_dcs_write_seq(dsi, 0x39, 0xee);
+
+	ret = mipi_dsi_dcs_set_pixel_format(dsi, 0xec);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set pixel format: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0xea);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_3D_CONTROL, 0xe8);
+	mipi_dsi_dcs_write_seq(dsi, 0x3f, 0xe7);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_VSYNC_TIMING, 0xe6);
+	mipi_dsi_dcs_write_seq(dsi, 0x41, 0xe5);
+	mipi_dsi_dcs_write_seq(dsi, 0xa0, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(80);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(5000, 6000);
+
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x27);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x3f, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x43, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x10);
+
+	return 0;
+}
+
+static int nt36675_tianma_off(struct nt36675_tianma *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x10);
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(140);
+
+	return 0;
+}
+
+static int nt36675_tianma_prepare(struct drm_panel *panel)
+{
+	struct nt36675_tianma *ctx = to_nt36675_tianma(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	nt36675_tianma_reset(ctx);
+
+	ret = nt36675_tianma_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int nt36675_tianma_unprepare(struct drm_panel *panel)
+{
+	struct nt36675_tianma *ctx = to_nt36675_tianma(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = nt36675_tianma_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode nt36675_tianma_mode = {
+	.clock = (1080 + 20 + 4 + 22) * (2400 + 10 + 2 + 30) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 20,
+	.hsync_end = 1080 + 20 + 4,
+	.htotal = 1080 + 20 + 4 + 22,
+	.vdisplay = 2400,
+	.vsync_start = 2400 + 10,
+	.vsync_end = 2400 + 10 + 2,
+	.vtotal = 2400 + 10 + 2 + 30,
+	.width_mm = 83,
+	.height_mm = 147,
+};
+
+static int nt36675_tianma_get_modes(struct drm_panel *panel,
+				    struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &nt36675_tianma_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs nt36675_tianma_panel_funcs = {
+	.prepare = nt36675_tianma_prepare,
+	.unprepare = nt36675_tianma_unprepare,
+	.get_modes = nt36675_tianma_get_modes,
+};
+
+static int nt36675_tianma_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct nt36675_tianma *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "vddio");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get vddio regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &nt36675_tianma_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void nt36675_tianma_remove(struct mipi_dsi_device *dsi)
+{
+	struct nt36675_tianma *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id nt36675_tianma_of_match[] = {
+	{ .compatible = "mdss,nt36675-tianma" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, nt36675_tianma_of_match);
+
+static struct mipi_dsi_driver nt36675_tianma_driver = {
+	.probe = nt36675_tianma_probe,
+	.remove = nt36675_tianma_remove,
+	.driver = {
+		.name = "panel-nt36675-tianma",
+		.of_match_table = nt36675_tianma_of_match,
+	},
+};
+module_mipi_dsi_driver(nt36675_tianma_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for nt36675 video mode dsi tianma panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/adc/qcom-spmi-adc5.c b/drivers/iio/adc/qcom-spmi-adc5.c
index 9b69f40beed8ea..44722f252217f0 100644
--- a/drivers/iio/adc/qcom-spmi-adc5.c
+++ b/drivers/iio/adc/qcom-spmi-adc5.c
@@ -543,6 +543,8 @@ static const struct adc5_channels adc5_chans_pmic[ADC5_MAX_CHANNEL] = {
 					SCALE_HW_CALIB_DEFAULT)
 	[ADC5_XO_THERM_100K_PU]	= ADC5_CHAN_TEMP("xo_therm", 0,
 					SCALE_HW_CALIB_XOTHERM)
+	[ADC5_BAT_THERM_100K_PU] = ADC5_CHAN_TEMP("bat_therm", 0,
+					SCALE_HW_CALIB_THERM_100K_PULLUP)
 	[ADC5_BAT_ID_100K_PU]	= ADC5_CHAN_TEMP("bat_id", 0,
 					SCALE_HW_CALIB_DEFAULT)
 	[ADC5_AMUX_THM1_100K_PU] = ADC5_CHAN_TEMP("amux_thm1_100k_pu", 0,
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 6ba984d7f0b186..d25e72644c6051 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -869,6 +869,18 @@ config INPUT_DRV260X_HAPTICS
 	  To compile this driver as a module, choose M here: the
 	  module will be called drv260x-haptics.
 
+config INPUT_DRV2624_HAPTICS
+	tristate "TI DRV2624 haptics support"
+	depends on INPUT && I2C
+	depends on GPIOLIB || COMPILE_TEST
+	select INPUT_FF_MEMLESS
+	select REGMAP_I2C
+	help
+	  Say Y to enable support for the TI DRV2624 haptics driver.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called drv2624-haptics.
+
 config INPUT_DRV2665_HAPTICS
 	tristate "TI DRV2665 haptics support"
 	depends on INPUT && I2C
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 04296a4abe8e87..32929cde697641 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_INPUT_DA9055_ONKEY)	+= da9055_onkey.o
 obj-$(CONFIG_INPUT_DA9063_ONKEY)	+= da9063_onkey.o
 obj-$(CONFIG_INPUT_E3X0_BUTTON)		+= e3x0-button.o
 obj-$(CONFIG_INPUT_DRV260X_HAPTICS)	+= drv260x.o
+obj-$(CONFIG_INPUT_DRV2624_HAPTICS)	+= drv2624.o
 obj-$(CONFIG_INPUT_DRV2665_HAPTICS)	+= drv2665.o
 obj-$(CONFIG_INPUT_DRV2667_HAPTICS)	+= drv2667.o
 obj-$(CONFIG_INPUT_GPIO_BEEPER)		+= gpio-beeper.o
diff --git a/drivers/input/misc/drv2624.c b/drivers/input/misc/drv2624.c
new file mode 100644
index 00000000000000..1e0ccff1e9677f
--- /dev/null
+++ b/drivers/input/misc/drv2624.c
@@ -0,0 +1,444 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * drv2624 haptics driver
+ *
+ * Copyright (c) 2016 Texas Instruments Inc.
+ * Copyright (c) 2024 Vitalii Skorkin <nikroksm@mail.ru>
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+
+#include <dt-bindings/input/ti-drv2624.h>
+
+#define DRV2624_ID							0x00
+#define DRV2624_MODE						0x07
+#define DRV2624_CONTROL1					0x08
+#define DRV2624_GO							0x0c
+#define DRV2624_CONTROL2					0x0d
+#define DRV2624_RTP_INPUT					0x0e
+#define DRV2624_RATED_VOLTAGE				0x1f
+#define DRV2624_OVERDRIVE_CLAMP				0x20
+#define DRV2624_DRIVE_TIME					0x27
+#define DRV2624_OPENLOOP_PERIOD_H			0x2e
+#define DRV2624_OPENLOOP_PERIOD_L			0x2f
+
+/* Mode register */
+#define DRV2624_PINFUNC_MASK				0x0c
+#define DRV2624_PINFUNC_INT					0x02
+#define DRV2624_PINFUNC_SHIFT				0x02
+#define DRV2624_MODE_MASK					0x03
+#define DRV2624_MODE_RTP					0x00
+#define DRV2624_MODE_WAVEFORM				0x01
+#define DRV2624_MODE_DIAGNOSTIC				0x02
+#define DRV2624_MODE_CALIBRATION			0x03
+
+/* Control1 register */
+#define DRV2624_ACTUATOR_MASK				0x80
+#define DRV2624_ACTUATOR_SHIFT				0x07
+#define DRV2624_LOOP_MASK					0x40
+#define DRV2624_LOOP_SHIFT					0x06
+#define DRV2624_AUTOBRK_OK_MASK				0x10
+#define DRV2624_AUTOBRK_OK_ENABLE			0x10
+#define DRV2624_AUTO_BRK_INTO_STBY_MASK		(0x01 << 3)
+#define DRV2624_STBY_MODE_WITH_AUTO_BRAKE	(0x01 << 3)
+#define DRV2624_REMOVE_STBY_MODE            0x00
+
+/* Control2 register */
+#define DRV2624_LIB_MASK					0x80
+#define DRV2624_LIB_SHIFT					0x07
+
+/* Drive Time register */
+#define DRV2624_DRIVE_TIME_MASK				0x1f
+#define DRV2624_MINFREQ_SEL_45HZ			0x01
+#define DRV2624_MINFREQ_SEL_MASK			0x80
+#define DRV2624_MINFREQ_SEL_SHIFT			0x07
+
+struct drv2624_data {
+	struct input_dev *input_dev;
+	struct i2c_client *client;
+	struct regmap *regmap;
+	struct work_struct work;
+	struct gpio_desc *reset_gpio;
+	u8 magnitude;
+	u32 mode;
+	u32 lra_frequency;
+	int rated_voltage;
+	int overdrive_voltage;
+};
+
+/*
+ * Rated and Overdriver Voltages:
+ * Calculated using the formula r = v * 255 / 5.6
+ * where r is what will be written to the register
+ * and v is the rated or overdriver voltage of the actuator
+ */
+static int drv2624_calculate_voltage(unsigned int voltage)
+{
+	return (voltage * 255 / 5600);
+}
+
+static void drv2624_worker(struct work_struct *work)
+{
+	struct drv2624_data *haptics = container_of(work, struct drv2624_data, work);
+	int error;
+
+	error = regmap_write(haptics->regmap,
+					DRV2624_RTP_INPUT, haptics->magnitude);
+	if (error) {
+		dev_err(&haptics->client->dev,
+			"Failed to set magnitude: %d\n", error);
+		return;
+	}
+}
+
+static int drv2624_haptics_play(struct input_dev *input, void *data,
+				struct ff_effect *effect)
+{
+	struct drv2624_data *haptics = input_get_drvdata(input);
+
+	/* Scale u16 magnitude into u8 register value */
+	if (effect->u.rumble.strong_magnitude > 0)
+		haptics->magnitude = effect->u.rumble.strong_magnitude >> 8;
+	else if (effect->u.rumble.weak_magnitude > 0)
+		haptics->magnitude = effect->u.rumble.weak_magnitude >> 8;
+	else
+		haptics->magnitude = 0;
+
+	if (haptics->magnitude > 0x7f)
+		haptics->magnitude = 0x7f;
+
+	schedule_work(&haptics->work);
+
+	return 0;
+}
+
+static int drv2624_open(struct input_dev *input)
+{
+	struct drv2624_data *haptics = input_get_drvdata(input);
+	int error;
+
+	error = regmap_update_bits(haptics->regmap,
+			     DRV2624_MODE, DRV2624_MODE_MASK, DRV2624_MODE_RTP);
+	if (error) {
+		dev_err(&haptics->client->dev,
+			"Failed to set mode: %d\n", error);
+		return error;
+	}
+
+	error = regmap_write(haptics->regmap,
+					DRV2624_RTP_INPUT, 0x0);
+	if (error) {
+		dev_err(&haptics->client->dev,
+			"Failed to set magnitude: %d\n", error);
+		return error;
+	}
+
+	error = regmap_write(haptics->regmap, DRV2624_GO, 1);
+	if (error) {
+		dev_err(&haptics->client->dev,
+			"Failed to write GO register: %d\n",
+			error);
+		return error;
+	}
+
+	return error;
+}
+
+static void drv2624_close(struct input_dev *input)
+{
+	struct drv2624_data *haptics = input_get_drvdata(input);
+	int error;
+	unsigned int cal_buf;
+
+	cancel_work_sync(&haptics->work);
+
+	error = regmap_write(haptics->regmap, DRV2624_GO, 0);
+	if (error) {
+		dev_err(&haptics->client->dev,
+			"Failed to write GO register: %d\n",
+			error);
+		return;
+	}
+
+	do {
+		usleep_range(15000, 15500);
+		error = regmap_read(haptics->regmap, DRV2624_GO, &cal_buf);
+		if (error) {
+			dev_err(&haptics->client->dev,
+				"Failed to read GO register: %d\n",
+				error);
+			return;
+		}
+	} while (cal_buf == 0);
+}
+
+static int drv2624_init(struct drv2624_data *haptics)
+{
+	int error;
+	unsigned int drive_time;
+	unsigned short open_loop_period;
+	unsigned int cal_buf;
+
+	error = regmap_update_bits(haptics->regmap, DRV2624_MODE,
+		DRV2624_PINFUNC_MASK, DRV2624_PINFUNC_INT << DRV2624_PINFUNC_SHIFT);
+	if (error) {
+		dev_err(&haptics->client->dev,
+			"Failed to write DRV2624_MODE register: %d\n",
+			error);
+		return error;
+	}
+
+	error = regmap_update_bits(haptics->regmap, DRV2624_CONTROL1,
+		DRV2624_ACTUATOR_MASK | DRV2624_LOOP_MASK | DRV2624_AUTOBRK_OK_MASK,
+		(haptics->mode << DRV2624_ACTUATOR_SHIFT) |
+		(1 << DRV2624_LOOP_SHIFT) | DRV2624_AUTOBRK_OK_ENABLE);
+	if (error) {
+		dev_err(&haptics->client->dev,
+			"Failed to write DRV2624_CONTROL1 register: %d\n",
+			error);
+		return error;
+	}
+
+	if(haptics->mode == DRV2624_ERM_MODE) {
+		error = regmap_update_bits(haptics->regmap, DRV2624_CONTROL2,
+			DRV2624_LIB_MASK, 0x01);
+		if (error) {
+			dev_err(&haptics->client->dev,
+				"Failed to write DRV2624_CONTROL2 register: %d\n",
+				error);
+			return error;
+		}
+	}
+
+	error = regmap_write(haptics->regmap,
+			     DRV2624_RATED_VOLTAGE, haptics->rated_voltage);
+	if (error) {
+		dev_err(&haptics->client->dev,
+			"Failed to write DRV2624_RATED_VOLTAGE register: %d\n",
+			error);
+		return error;
+	}
+
+	error = regmap_write(haptics->regmap,
+			     DRV2624_OVERDRIVE_CLAMP, haptics->overdrive_voltage);
+	if (error) {
+		dev_err(&haptics->client->dev,
+			"Failed to write DRV2624_OVERDRIVE_CLAMP register: %d\n",
+			error);
+		return error;
+	}
+
+	if(haptics->mode == DRV2624_LRA_MODE) {
+		drive_time = 5 * (1000 - haptics->lra_frequency) / haptics->lra_frequency;
+		open_loop_period = (unsigned short)(1000000000 / (24619 * haptics->lra_frequency));
+
+		if(haptics->lra_frequency < 125)
+			drive_time |= (DRV2624_MINFREQ_SEL_45HZ << DRV2624_MINFREQ_SEL_SHIFT);
+
+		error = regmap_update_bits(haptics->regmap,
+					DRV2624_DRIVE_TIME, DRV2624_DRIVE_TIME_MASK |
+					DRV2624_MINFREQ_SEL_MASK, drive_time);
+		if (error) {
+			dev_err(&haptics->client->dev,
+				"Failed to write DRV2624_DRIVE_TIME register: %d\n",
+				error);
+			return error;
+		}
+
+		error = regmap_update_bits(haptics->regmap, DRV2624_OPENLOOP_PERIOD_H,
+					0x03, (open_loop_period & 0x0300) >> 8);
+		if (error) {
+			dev_err(&haptics->client->dev,
+				"Failed to write DRV2624_OPENLOOP_PERIOD_H register: %d\n",
+				error);
+			return error;
+		}
+
+		error = regmap_write(haptics->regmap, DRV2624_OPENLOOP_PERIOD_L,
+					open_loop_period & 0x00ff);
+		if (error) {
+			dev_err(&haptics->client->dev,
+				"Failed to write DRV2624_OPENLOOP_PERIOD_L register: %d\n",
+				error);
+			return error;
+		}
+	}
+
+	error = regmap_update_bits(haptics->regmap,
+			     DRV2624_MODE, DRV2624_MODE_MASK, DRV2624_MODE_CALIBRATION);
+	if (error) {
+		dev_err(&haptics->client->dev,
+			"Failed to set mode: %d\n", error);
+		return error;
+	}
+
+	error = regmap_write(haptics->regmap, DRV2624_GO, 1);
+	if (error) {
+		dev_err(&haptics->client->dev,
+			"Failed to write GO register: %d\n",
+			error);
+		return error;
+	}
+
+	do {
+		usleep_range(15000, 15500);
+		error = regmap_read(haptics->regmap, DRV2624_GO, &cal_buf);
+		if (error) {
+			dev_err(&haptics->client->dev,
+				"Failed to read GO register: %d\n",
+				error);
+			return error;
+		}
+	} while (cal_buf == 1);
+
+	return 0;
+}
+
+static const struct regmap_config drv2624_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.cache_type = REGCACHE_NONE,
+};
+
+static int drv2624_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct drv2624_data *haptics;
+	u32 voltage;
+	int error;
+
+	haptics = devm_kzalloc(dev, sizeof(*haptics), GFP_KERNEL);
+	if (!haptics)
+		return -ENOMEM;
+
+	error = device_property_read_u32(dev, "mode", &haptics->mode);
+	if (error) {
+		dev_err(dev, "Can't fetch 'mode' property: %d\n", error);
+		return error;
+	}
+
+	if (haptics->mode < DRV2624_ERM_MODE ||
+	    haptics->mode > DRV2624_LRA_MODE) {
+		dev_err(dev, "Vibrator mode is invalid: %i\n", haptics->mode);
+		return -EINVAL;
+	}
+
+	if(haptics->mode == DRV2624_LRA_MODE) {
+		error = device_property_read_u32(dev, "lra-frequency", &haptics->lra_frequency);
+		if (error) {
+			dev_err(dev, "Can't fetch 'lra-frequency' property: %d\n", error);
+			return error;
+		}
+
+		if(haptics->lra_frequency < 45 || haptics->lra_frequency > 300) {
+			dev_err(dev, "Property 'lra-frequency' is out of range\n");
+			return -EINVAL;
+		}
+	}
+
+	error = device_property_read_u32(dev, "vib-rated-mv", &voltage);
+	if (error) {
+		dev_err(dev, "Can't fetch 'vib-rated-mv' property: %d\n", error);
+		return error;
+	}
+
+	haptics->rated_voltage = drv2624_calculate_voltage(voltage);
+
+	error = device_property_read_u32(dev, "vib-overdrive-mv", &voltage);
+	if (error) {
+		dev_err(dev, "Can't fetch 'vib-overdrive-mv' property: %d\n", error);
+		return error;
+	}
+
+	haptics->overdrive_voltage = drv2624_calculate_voltage(voltage);
+
+	haptics->reset_gpio = devm_gpiod_get_optional(dev, "reset",
+						       GPIOD_OUT_HIGH);
+	if (IS_ERR(haptics->reset_gpio))
+		return PTR_ERR(haptics->reset_gpio);
+
+	gpiod_set_value(haptics->reset_gpio, 0);
+	usleep_range(5000, 5500);
+	gpiod_set_value(haptics->reset_gpio, 1);
+	usleep_range(5000, 5500);
+
+	haptics->input_dev = devm_input_allocate_device(dev);
+	if (!haptics->input_dev) {
+		dev_err(dev, "Failed to allocate input device\n");
+		return -ENOMEM;
+	}
+
+	haptics->input_dev->name = "drv2624_haptics";
+	haptics->input_dev->dev.parent = client->dev.parent;
+	haptics->input_dev->open = drv2624_open;
+	haptics->input_dev->close = drv2624_close;
+	input_set_drvdata(haptics->input_dev, haptics);
+	input_set_capability(haptics->input_dev, EV_FF, FF_RUMBLE);
+
+	error = input_ff_create_memless(haptics->input_dev, NULL,
+					drv2624_haptics_play);
+	if (error) {
+		dev_err(dev, "input_ff_create() failed: %d\n", error);
+		return error;
+	}
+
+	INIT_WORK(&haptics->work, drv2624_worker);
+
+	haptics->client = client;
+	i2c_set_clientdata(client, haptics);
+
+	haptics->regmap = devm_regmap_init_i2c(client, &drv2624_regmap_config);
+	if (IS_ERR(haptics->regmap)) {
+		error = PTR_ERR(haptics->regmap);
+		dev_err(dev, "Failed to allocate register map: %d\n", error);
+		return error;
+	}
+
+	error = drv2624_init(haptics);
+	if (error) {
+		dev_err(dev, "Device init failed: %d\n", error);
+		return error;
+	}
+
+	error = input_register_device(haptics->input_dev);
+	if (error) {
+		dev_err(dev, "couldn't register input device: %d\n", error);
+		return error;
+	}
+
+	return 0;
+}
+
+static const struct i2c_device_id drv2624_id[] = {
+	{ "drv2624" },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, drv2624_id);
+
+static const struct of_device_id drv2624_of_match[] = {
+	{ .compatible = "ti,drv2624", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, drv2624_of_match);
+
+static struct i2c_driver drv2624_driver = {
+	.probe		= drv2624_probe,
+	.driver		= {
+		.name	= "drv2624-haptics",
+		.of_match_table = drv2624_of_match,
+	},
+	.id_table = drv2624_id,
+};
+module_i2c_driver(drv2624_driver);
+
+MODULE_DESCRIPTION("TI DRV2624 haptics driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Vitalii Skorkin <nikroksm@mail.ru>");
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index c821fe3ee794e3..211f5735c95c76 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -705,6 +705,19 @@ config TOUCHSCREEN_IMAGIS
 	  To compile this driver as a module, choose M here: the
 	  module will be called imagis.
 
+config TOUCHSCREEN_NT36XXX_SPI
+	tristate "Novatek NT36XXX In-Cell SPI touchscreen controller"
+	depends on SPI_MASTER
+	select REGMAP
+        help
+          Say Y here if you have a Novatek NT36xxx series In-Cell
+          touchscreen connected to your system over SPI.
+
+          If unsure, say N.
+
+          To compile this driver as a module, choose M here: the
+          module will be called nt36xxx_ts_spi.
+
 config TOUCHSCREEN_IMX6UL_TSC
 	tristate "Freescale i.MX6UL touchscreen controller"
 	depends on ((OF && GPIOLIB) || COMPILE_TEST) && HAS_IOMEM
@@ -1002,6 +1015,19 @@ config TOUCHSCREEN_MX25
 	  To compile this driver as a module, choose M here: the
 	  module will be called fsl-imx25-tcq.
 
+config TOUCHSCREEN_FT8756
+	tristate "Focaltech FT8756 SPI touchscreen controller"
+	depends on SPI_MASTER
+	select REGMAP
+        help
+          Say Y here if you have a Focaltech FT8756
+          touchscreen connected to your system over SPI.
+
+          If unsure, say N.
+
+          To compile this driver as a module, choose M here: the
+          module will be called ft8756.
+
 config TOUCHSCREEN_MC13783
 	tristate "Freescale MC13783 touchscreen input driver"
 	depends on MFD_MC13XXX
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index a81cb5aa21a5b9..7838202ec87d33 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -7,6 +7,7 @@
 
 wm97xx-ts-y := wm97xx-core.o
 goodix_ts-y := goodix.o goodix_fwupload.o
+nt36xxx_spi_ts-y := nt36xxx_spi.o nt36xxx_core.o
 
 obj-$(CONFIG_TOUCHSCREEN_88PM860X)	+= 88pm860x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_AD7877)	+= ad7877.o
@@ -62,6 +63,7 @@ obj-$(CONFIG_TOUCHSCREEN_LPC32XX)	+= lpc32xx_ts.o
 obj-$(CONFIG_TOUCHSCREEN_MAX11801)	+= max11801_ts.o
 obj-$(CONFIG_TOUCHSCREEN_MXS_LRADC)     += mxs-lradc-ts.o
 obj-$(CONFIG_TOUCHSCREEN_MX25)		+= fsl-imx25-tcq.o
+obj-$(CONFIG_TOUCHSCREEN_FT8756)		+= ft8756.o
 obj-$(CONFIG_TOUCHSCREEN_MC13783)	+= mc13783_ts.o
 obj-$(CONFIG_TOUCHSCREEN_MCS5000)	+= mcs5000_ts.o
 obj-$(CONFIG_TOUCHSCREEN_MELFAS_MIP4)	+= melfas_mip4.o
@@ -71,6 +73,7 @@ obj-$(CONFIG_TOUCHSCREEN_MSG2638)	+= msg2638.o
 obj-$(CONFIG_TOUCHSCREEN_MTOUCH)	+= mtouch.o
 obj-$(CONFIG_TOUCHSCREEN_MK712)		+= mk712.o
 obj-$(CONFIG_TOUCHSCREEN_NOVATEK_NVT_TS)	+= novatek-nvt-ts.o
+obj-$(CONFIG_TOUCHSCREEN_NT36XXX_SPI)	+= nt36xxx_spi_ts.o
 obj-$(CONFIG_TOUCHSCREEN_HP600)		+= hp680_ts_input.o
 obj-$(CONFIG_TOUCHSCREEN_HP7XX)		+= jornada720_ts.o
 obj-$(CONFIG_TOUCHSCREEN_IPAQ_MICRO)	+= ipaq-micro-ts.o
diff --git a/drivers/input/touchscreen/ft8756.c b/drivers/input/touchscreen/ft8756.c
new file mode 100644
index 00000000000000..da415de2de867c
--- /dev/null
+++ b/drivers/input/touchscreen/ft8756.c
@@ -0,0 +1,923 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Driver for Focaltech FT8756 touchscreen
+ *
+ * Copyright (c) 2012-2019, FocalTech Systems, Ltd.
+ * Copyright (C) 2020 XiaoMi, Inc.
+ * Copyright (C) 2024 Nikroks <www.github.com/N1kroks>
+ *
+ */
+
+#include <asm/unaligned.h>
+#include <linux/input/mt.h>
+#include <linux/input/touchscreen.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <drm/drm_panel.h>
+#include <linux/pm_runtime.h>
+#include <linux/devm-helpers.h>
+#include <linux/regulator/consumer.h>
+#include <linux/firmware.h>
+
+/* Misc */
+#define FT8756_NUM_SUPPLIES 3
+#define FT8756_MAX_RETRIES	3
+
+#define DATA_CRC_EN 0x20
+#define WRITE_CMD   0x00
+#define READ_CMD    (0x80 | DATA_CRC_EN)
+
+#define CS_HIGH_DELAY 150
+
+/* Touch info */
+#define TOUCH_DEFAULT_MAX_WIDTH  1080
+#define TOUCH_DEFAULT_MAX_HEIGHT 2400
+#define TOUCH_MAX_FINGER_NUM	 10
+#define TOUCH_MAX_PRESSURE	     255
+
+#define FT8756_CMD_START1  0x55
+#define FT8756_CMD_START2  0xAA
+#define FT8756_CMD_READ_ID 0x90
+
+#define FT8756_ROMBOOT_CMD_SET_PRAM_ADDR     0xAD
+#define FT8756_ROMBOOT_CMD_SET_PRAM_ADDR_LEN 3
+#define FT8756_ROMBOOT_CMD_WRITE             0xAE
+#define FT8756_ROMBOOT_CMD_START_APP         0x08
+#define FT8756_PRAM_SADDR                    0x000000
+#define FT8756_DRAM_SADDR                    0xD00000
+
+#define FT8756_ROMBOOT_CMD_ECC        0xCC
+#define FT8756_ROMBOOT_CMD_ECC_LEN    6
+#define FT8756_ECC_FINISH_TIMEOUT     100
+#define FT8756_ROMBOOT_CMD_ECC_FINISH 0xCE
+#define FT8756_ROMBOOT_CMD_ECC_READ   0xCD
+
+#define FT8756_REG_POWER_MODE       0xA5
+#define FT8756_REG_POWER_MODE_SLEEP 0x03
+
+#define FT8756_APP_INFO_OFFSET 0x100
+
+/* Point data length */
+#define POINT_DATA_LEN 62
+
+static struct drm_panel_follower_funcs ft8756_panel_follower_funcs;
+
+struct ft8756_abs_object {
+	u16 x;
+	u16 y;
+	u16 p;
+	u8 area;
+};
+
+struct ft8756_ts {
+	struct regmap *regmap;
+
+	struct input_dev *input;
+	struct regulator_bulk_data *supplies;
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *irq_gpio;
+	int irq;
+	struct device *dev;
+
+#define FT8756_STATUS_SUSPEND			BIT(0)
+#define FT8756_STATUS_DOWNLOAD_COMPLETE	BIT(1)
+#define FT8756_STATUS_DOWNLOAD_RECOVER	BIT(2)
+	unsigned int status;
+
+	struct touchscreen_properties prop;
+	struct ft8756_abs_object abs_obj;
+
+	struct drm_panel_follower panel_follower;
+
+	struct delayed_work work;
+
+	struct firmware fw_entry; /* containing request fw data */
+	const char *firmware_path;
+};
+
+/*
+ * this function is nearly direct copy from vendor source
+*/
+static int ft8756_spi_write(void *dev, const void *data, size_t len)
+{
+	struct spi_device *spi = to_spi_device((struct device *)dev);
+    int ret;
+    u32 datalen = len - 1;
+    u32 txlen = 0;
+    u8 *txBuf = devm_kzalloc(dev, len + 9, GFP_KERNEL);
+    if (!txBuf)
+		return -ENOMEM;
+    u8 *rxBuf = devm_kzalloc(dev, len + 9, GFP_KERNEL);
+    if (!rxBuf)
+		return -ENOMEM;
+
+    txBuf[txlen++] = ((u8*)data)[0];
+    txBuf[txlen++] = WRITE_CMD;
+    txBuf[txlen++] = (datalen >> 8) & 0xFF;
+    txBuf[txlen++] = datalen & 0xFF;
+
+    if (datalen > 0) {
+        txlen += 3; // dummy byte
+        memcpy(&txBuf[txlen], data + 1, datalen);
+        txlen += datalen;
+    }
+
+	struct spi_message	msg;
+	struct spi_transfer xfer = {
+		.tx_buf = txBuf,
+		.rx_buf = rxBuf,
+		.len = txlen,
+	};
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfer, &msg);
+
+    for(int i = 0; i < FT8756_MAX_RETRIES; i++) {
+        ret = spi_sync(spi, &msg);
+        if(ret) {
+            dev_err(dev, "transfer error: %d", ret);
+            usleep_range(CS_HIGH_DELAY, CS_HIGH_DELAY + 100);
+            continue;
+        }
+        if ((rxBuf[3] &0xA0) == 0) {
+            break;
+        } else {
+            dev_err(dev, "Failed to write data status: 0x%X", rxBuf[3]);
+            ret = -EIO;
+            usleep_range(CS_HIGH_DELAY, CS_HIGH_DELAY + 100);
+        }
+    }
+
+    usleep_range(CS_HIGH_DELAY, CS_HIGH_DELAY + 100);
+	return ret;
+}
+
+/*
+ * this function is nearly direct copy from vendor source
+*/
+static int ft8756_spi_read(void *dev, const void *reg_buf, size_t reg_size, void *val_buf, size_t val_size)
+{
+	struct spi_device *spi = to_spi_device((struct device *)dev);
+    int ret, i, j;
+    u32 txlen = 0;
+    u8 *txBuf = devm_kzalloc(dev, 4, GFP_KERNEL);
+    if (!txBuf)
+		return -ENOMEM;
+    u8 *rxBuf = devm_kzalloc(dev, val_size + 9, GFP_KERNEL);
+    if (!rxBuf)
+		return -ENOMEM;
+    u32 dp = 0;
+    u16 crc = 0xFFFF;
+
+    txBuf[txlen++] = ((u8*)reg_buf)[0];
+    txBuf[txlen++] = READ_CMD;
+    txBuf[txlen++] = (val_size >> 8) & 0xFF;
+    txBuf[txlen++] = val_size & 0xFF;
+    dp = txlen + 3;
+    txlen = dp + val_size;
+    if(txBuf[1] & DATA_CRC_EN)
+        txlen += 2;
+
+    struct spi_message	msg;
+	struct spi_transfer xfer = {
+		.tx_buf = txBuf,
+		.rx_buf = rxBuf,
+		.len = txlen,
+	};
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfer, &msg);
+
+    for(i = 0; i < FT8756_MAX_RETRIES; i++) {
+        ret = spi_sync(spi, &msg);
+        if(ret) {
+            dev_err(dev, "transfer error: %d", ret);
+            usleep_range(CS_HIGH_DELAY, CS_HIGH_DELAY + 100);
+            continue;
+        }
+        if ((rxBuf[3] & 0xA0) == 0) {
+            memcpy(val_buf, &rxBuf[dp], val_size);
+            if(txBuf[1] & DATA_CRC_EN) {
+                for(j = 0; j < (txlen - dp - 2); j++) {
+                    crc ^= rxBuf[dp + j];
+                    for(u8 k = 0; k < 8; k++)
+                        crc = crc & 1 ? (crc >> 1) ^ 0x8408 : crc >> 1;
+                }
+                u16 crc_read = (u16) (rxBuf[txlen - 1] << 8) + rxBuf[txlen - 2];
+                if (crc != crc_read) {
+                    dev_err(dev, "crc error: 0x%02x expected, got 0x%02x", crc, crc_read);
+                    usleep_range(CS_HIGH_DELAY, CS_HIGH_DELAY + 100);
+                    continue;
+                }
+            }
+            break;
+        } else {
+            dev_err(dev, "Failed to read data status: 0x%X", rxBuf[3]);
+            ret = -EIO;
+            usleep_range(CS_HIGH_DELAY, CS_HIGH_DELAY + 100);
+        }
+    }
+
+    usleep_range(CS_HIGH_DELAY, CS_HIGH_DELAY + 100);
+	return ret;
+}
+
+const struct regmap_config ft8756_regmap_config_32bit = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.read = ft8756_spi_read,
+	.write = ft8756_spi_write,
+
+	.zero_flag_mask = true, /* this is needed to make sure addr is not write_masked */
+	.cache_type = REGCACHE_NONE,
+};
+
+static void ft8756_disable_regulators(void *data)
+{
+	struct ft8756_ts *ts = data;
+
+	regulator_bulk_disable(FT8756_NUM_SUPPLIES, ts->supplies);
+}
+
+static void ft8756_reset(struct ft8756_ts *ts)
+{
+	gpiod_set_value_cansleep(ts->reset_gpio, 1);
+    msleep(1);
+	gpiod_set_value_cansleep(ts->reset_gpio, 0);
+    msleep(200);
+}
+
+static int ft8756_check_chip_id(struct ft8756_ts *ts)
+{
+    u16 chip_id = 0;
+    int ret;
+
+    ft8756_reset(ts);
+
+    ret = regmap_write(ts->regmap, FT8756_CMD_START1, FT8756_CMD_START2);
+    if (ret)
+        goto exit;
+
+    msleep(15);
+
+    ret = regmap_raw_read(ts->regmap, FT8756_CMD_READ_ID, &chip_id, 2);
+    chip_id = cpu_to_be16(chip_id);
+    if (chip_id != 0x8756 || ret) {
+        dev_err(ts->dev, "Chip ID mismatch: expected 0x%x, got 0x%x", 0x8756, chip_id);
+        ret = -ENODEV;
+        goto exit;
+    }
+
+exit:
+    return ret;
+}
+
+static int ft8756_input_dev_config(struct ft8756_ts *ts)
+{
+	struct device *dev = ts->dev;
+	int ret;
+
+    /* Allocate memory for the input device structure */
+	ts->input = devm_input_allocate_device(dev);
+	if (!ts->input)
+		return -ENOMEM;
+
+	/* Set the device-specific data to the allocated input device structure */
+	input_set_drvdata(ts->input, ts);
+
+    /* Set physical path for the input device */
+	ts->input->phys = devm_kasprintf(dev, GFP_KERNEL,
+				     "%s/input0", dev_name(dev));
+	if (!ts->input->phys)
+		return -ENOMEM;
+
+	/* Set input device properties */
+	ts->input->name = "Focaltech FT8756 Touchscreen";
+	ts->input->dev.parent = dev;
+
+    /* Set absolute parameters for touch events */
+	input_set_abs_params(ts->input, ABS_MT_PRESSURE, 0, 255, 0, 0);
+	input_set_abs_params(ts->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+
+	/* Set absolute parameters for touch position */
+	input_set_abs_params(ts->input, ABS_MT_POSITION_X, 0,
+						 TOUCH_DEFAULT_MAX_WIDTH - 1, 0, 0);
+	input_set_abs_params(ts->input, ABS_MT_POSITION_Y, 0,
+						TOUCH_DEFAULT_MAX_HEIGHT - 1, 0, 0);
+
+    /* Parse touchscreen properties */
+	touchscreen_parse_properties(ts->input, true, &ts->prop);
+
+	/* Check if the maximum x-coordinate is valid */
+	WARN_ON(ts->prop.max_x < 1);
+
+    /* Initialize multitouch slots for the input device */
+	ret = input_mt_init_slots(ts->input, TOUCH_MAX_FINGER_NUM,
+				  INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);
+	if (ret) {
+		dev_err(dev, "Cannot init MT slots (%d)\n", ret);
+		return ret;
+	}
+
+	/* Register the input device */
+	ret = input_register_device(ts->input);
+	if (ret) {
+		dev_err(dev, "Failed to register input device: %d\n",
+			ret);
+		return ret;
+	}
+
+    return 0;
+}
+
+static void ft8756_report(struct ft8756_ts *ts)
+{
+    struct ft8756_abs_object* obj = &ts->abs_obj;
+	struct input_dev *input = ts->input;
+	u8 input_id = 0;
+    u8 point[POINT_DATA_LEN] = { 0 };
+    unsigned int base = 0;
+    int ret, i;
+
+    ret = regmap_raw_read(ts->regmap, 0x01, point, POINT_DATA_LEN);
+    if (ret < 0) {
+		dev_err(ts->dev,
+			"Cannot read touch point data: %d\n", ret);
+		goto exit;
+	}
+
+    for(i = 0; i < 6; i++) {
+        if((point[i] != 0xEF && point[i] != 0xFF))
+            break;
+
+        ts->status |= FT8756_STATUS_DOWNLOAD_RECOVER;
+        goto exit;
+    }
+
+    for(i = 0; i < TOUCH_MAX_FINGER_NUM; i++) {
+        base = 6 * i;
+        input_id = point[base + 4] >> 4;
+        if (input_id >= 10)
+            continue;
+
+        if ((point[base + 2] >> 6) == 0x0 || (point[base + 2] >> 6) == 0x2) {
+            obj->x = ((point[base + 2] & 0xF) << 8) + (point[base + 3] & 0xFF);
+            obj->y = ((point[base + 4] & 0xF) << 8) + (point[base + 5] & 0xFF);
+
+            if ((obj->x > ts->prop.max_x) ||
+                (obj->y > ts->prop.max_y))
+                continue;
+
+            obj->p = point[base + 6];
+            obj->area = point[base + 7] >> 4;
+
+            if (obj->area == 0)
+                obj->area = 1;
+
+            if (obj->p > TOUCH_MAX_PRESSURE)
+                obj->p = TOUCH_MAX_PRESSURE;
+
+            if (obj->p == 0)
+                obj->p = 1;
+
+            input_mt_slot(input, input_id);
+            input_mt_report_slot_state(input,
+                            MT_TOOL_FINGER, true);
+            touchscreen_report_pos(input, &ts->prop,
+                        obj->x,
+                        obj->y, true);
+
+            input_report_abs(input, ABS_MT_TOUCH_MAJOR, obj->area);
+            input_report_abs(input, ABS_MT_PRESSURE, obj->p);
+        }
+    }
+
+	input_mt_sync_frame(input);
+
+	input_sync(input);
+
+exit:
+    return;
+}
+
+static irqreturn_t ft8756_irq_handler(int irq, void *dev_id)
+{
+	struct ft8756_ts *ts = dev_id;
+
+    disable_irq_nosync(ts->irq);
+
+    ft8756_report(ts);
+
+    enable_irq(ts->irq);
+
+    if (ts->status & FT8756_STATUS_DOWNLOAD_RECOVER) {
+		ts->status &= ~FT8756_STATUS_DOWNLOAD_RECOVER;
+		schedule_delayed_work(&ts->work, 40000);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int ft8756_enter_boot(struct ft8756_ts *ts) {
+    u16 chip_id = 0;
+    int ret;
+
+    ft8756_reset(ts);
+    mdelay(8);
+
+    ret = regmap_write(ts->regmap, FT8756_CMD_START1, 0x0);
+    if (ret)
+        goto exit;
+
+    msleep(15);
+
+    ret = regmap_raw_read(ts->regmap, FT8756_CMD_READ_ID, &chip_id, 2);
+    chip_id = cpu_to_be16(chip_id);
+    if (chip_id != 0x8756 || ret) {
+        dev_err(ts->dev, "Chip ID mismatch: expected 0x%x, got 0x%x", 0x8756, chip_id);
+        ret = -ENODEV;
+        goto exit;
+    }
+
+exit:
+    return ret;
+}
+
+static int ft8756_calc_ecc(struct ft8756_ts *ts, const u32 addr, u32 size, u16* ecc_value) {
+    int ret, i;
+    u8 cmd[FT8756_ROMBOOT_CMD_ECC_LEN] = { 0 };
+	u8 value[2] = { 0 };
+
+	cmd[0] = (u8)(((addr) >> 16) & 0xFF);
+	cmd[1] = (u8)(((addr) >> 8) & 0xFF);
+	cmd[2] = (u8)((addr) & 0xFF);
+	cmd[3] = (u8)(((size) >> 16) & 0xFF);
+	cmd[4] = (u8)(((size) >> 8) & 0xFF);
+	cmd[5] = (u8)((size) & 0xFF);
+
+    ret = regmap_raw_write(ts->regmap, FT8756_ROMBOOT_CMD_ECC, &cmd, FT8756_ROMBOOT_CMD_ECC_LEN);
+    if (ret) {
+        dev_err(ts->dev, "Failed to calc ecc: %d", ret);
+        goto exit;
+    }
+    msleep(2);
+
+    for(i = 0; i < FT8756_ECC_FINISH_TIMEOUT; i++) {
+        ret = regmap_raw_read(ts->regmap, FT8756_ROMBOOT_CMD_ECC_FINISH, value, 1);
+        if (ret) {
+            dev_err(ts->dev, "ECC Finish command failed: %d", ret);
+            goto exit;
+        }
+        if (value[0] == 0xA5)
+            break;
+        msleep(1);
+    }
+    if (i >= FT8756_ECC_FINISH_TIMEOUT) {
+        dev_err(ts->dev, "Timeout while waiting for ECC calculation to complete");
+        ret = -EIO;
+        goto exit;
+    }
+
+    ret = regmap_raw_read(ts->regmap, FT8756_ROMBOOT_CMD_ECC_READ, value, 2);
+    if (ret) {
+        dev_err(ts->dev, "Failed to read ECC: %d", ret);
+        goto exit;
+    }
+    *ecc_value = ((u16)(value[0] << 8) + value[1]) & 0x0000FFFF;
+
+exit:
+    return ret;
+}
+
+static int ft8756_dpram_write(struct ft8756_ts *ts, const u8* fwdata, u32 fwsize, bool wpram) {
+    int offset, packet_number, packet_remainder, packet_length, addr, ret, i, j, k;
+    u32 packet_size = (32 * 1024 - 16);
+    u32 base_addr = wpram ? FT8756_PRAM_SADDR : FT8756_DRAM_SADDR;
+    u16 eccTP, ecc;
+    u8 *cmd;
+
+    cmd = devm_kzalloc(ts->dev, packet_size + 7, GFP_KERNEL);
+    if (cmd == NULL) {
+		dev_err(ts->dev, "%s: kzalloc for cmd failed!\n", __func__);
+		return -ENOMEM;
+	}
+
+    packet_number = fwsize / packet_size;
+    packet_remainder = fwsize % packet_size;
+    if (packet_remainder > 0)
+        packet_number++;
+
+    packet_length = packet_size;
+    for(i = 0; i < packet_number; i++) {
+        offset = i * packet_size;
+		addr = offset + base_addr;
+        if ((i == (packet_number - 1)) && packet_remainder)
+            packet_length = packet_remainder;
+
+		cmd[0] = (u8)(((addr) >> 16) & 0xFF);
+		cmd[1] = (u8)(((addr) >> 8) & 0xFF);
+		cmd[2] = (u8)((addr) & 0xFF);
+        ret = regmap_raw_write(ts->regmap, FT8756_ROMBOOT_CMD_SET_PRAM_ADDR, cmd, FT8756_ROMBOOT_CMD_SET_PRAM_ADDR_LEN);
+        if (ret) {
+		    dev_err(ts->dev, "Failed to set pram address: %d", ret);
+            goto exit;
+        }
+
+        memcpy(cmd, fwdata + offset, packet_length);
+
+        ret = regmap_bulk_write(ts->regmap, FT8756_ROMBOOT_CMD_WRITE, cmd, packet_length);
+        if (ret) {
+		    dev_err(ts->dev, "%s: failed write to pram\n", __func__);
+            goto exit;
+        }
+
+        ecc = 0;
+
+        for(j = 0; j < packet_length; j += 2) {
+            ecc ^= (fwdata[j + offset] << 8) | (fwdata[j + offset + 1]);
+            for(k = 0; k < 16; k++)
+                ecc = ecc & 1 ? (u16) ((ecc >> 1) ^ ((1 << 15) + (1 << 10) + (1 << 3))) : ecc >> 1;
+        }
+
+        ret = ft8756_calc_ecc(ts, offset, packet_length, &eccTP);
+        if (ret)
+            goto exit;
+
+        if(ecc != eccTP) {
+            dev_err(ts->dev, "ECC error: 0x%02x expected, got 0x%02x", ecc, eccTP);
+            ret = -EIO;
+            goto exit;
+        }
+    }
+
+exit:
+    return ret;
+}
+
+static void _ft8756_download_firmware(struct ft8756_ts *ts) {
+	const struct firmware *fw_entry;
+    int ret;
+
+    if (ts->fw_entry.data)
+		goto upload;
+
+    ret = request_firmware(&fw_entry, ts->firmware_path, ts->dev);
+	if (ret) {
+		dev_err(ts->dev, "failed to request fw: %s\n", ts->firmware_path);
+		goto exit;
+	}
+
+    /*
+	 * must allocate in DMA buffer otherwise fail spi tx DMA
+	 * so we need to manage our own fw struct
+	 * pm_resume need to re-upload fw for FT8756 IC
+	 */
+	ts->fw_entry.data = devm_kmemdup(ts->dev, fw_entry->data, fw_entry->size, GFP_KERNEL | GFP_DMA);
+
+    if (!ts->fw_entry.data) {
+		dev_err(ts->dev, "Failed to allocate fw data\n");
+		goto exit;
+	}
+
+	ts->fw_entry.size = fw_entry->size;
+
+	WARN_ON(ts->fw_entry.data[0] != fw_entry->data[0]);
+
+    release_firmware(fw_entry);
+
+upload:
+    ret = ft8756_enter_boot(ts);
+    if (ret) {
+		dev_err(ts->dev, "Failed to enter boot mode\n");
+		goto release_fw;
+    }
+
+    {
+        u16 code_len = ((u16)ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 0] << 8) + ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 1];
+        u16 code_len_n = ((u16)ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 2] << 8) + ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 3];
+        if ((code_len + code_len_n) != 0xFFFF) {
+            dev_err(ts->dev, "PRAM code length is invalid");
+            goto release_fw;
+        }
+
+        ret = ft8756_dpram_write(ts, ts->fw_entry.data, code_len * 2, true);
+        if (ret) {
+            dev_err(ts->dev, "Failed to write to PRAM: %d", ret);
+            goto release_fw;
+        }
+    }
+
+    {
+        u16 code_len = ((u16)ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 0x8] << 8) + ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 0x9];
+        u16 code_len_n = ((u16)ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 0xA] << 8) + ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 0xB];
+        if ((code_len + code_len_n) != 0xFFFF) {
+            dev_err(ts->dev, "DRAM code length is invalid");
+            goto release_fw;
+        }
+
+	    u32 PramAppSize = ((u32)(((u16)ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 0] << 8) + ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 1])) * 2;
+
+        ret = ft8756_dpram_write(ts, ts->fw_entry.data + PramAppSize, code_len * 2, false);
+        if (ret) {
+            dev_err(ts->dev, "Failed to write to DRAM: %d", ret);
+            goto release_fw;
+        }
+    }
+
+    ret = regmap_write(ts->regmap, FT8756_ROMBOOT_CMD_START_APP, 0x0);
+    if (ret) {
+        dev_err(ts->dev, "Failed to start FW: %d", ret);
+        goto exit;
+    }
+
+    ts->status |= FT8756_STATUS_DOWNLOAD_COMPLETE;
+	dev_info(ts->dev, "Touch IC FW loaded successfully");
+    goto exit;
+
+release_fw:
+	kfree(ts->fw_entry.data);
+	ts->fw_entry.data = NULL;
+	ts->fw_entry.size = 0;
+exit:
+    return;
+}
+
+static void ft8756_download_firmware(struct work_struct *work) {
+    struct ft8756_ts *ts = container_of(work, struct ft8756_ts, work.work);
+
+    /* Disable power management runtime for the device */
+	pm_runtime_disable(ts->dev);
+
+	/* Disable the touch screen IRQ to prevent further interrupts */
+	disable_irq_nosync(ts->irq);
+
+	/* Cancel any pending delayed work */
+	cancel_delayed_work(&ts->work);
+
+    _ft8756_download_firmware(ts);
+
+    /* Enable touch screen IRQ and power management runtime */
+    enable_irq(ts->irq);
+	pm_runtime_enable(ts->dev);
+
+	/* If the download is not complete, reschedule the delayed work after 4000ms */
+    if (!(ts->status & FT8756_STATUS_DOWNLOAD_COMPLETE)) {
+		cancel_delayed_work(&ts->work);
+		schedule_delayed_work(&ts->work, 4000);
+	}
+}
+
+static int ft8756_spi_probe(struct spi_device *spi)
+{
+	struct device *dev = &spi->dev;
+	struct regmap_config *regmap_config;
+	size_t max_size;
+	int ret = 0;
+
+    dev_info(dev, "enter %s", __func__);
+
+    /* Allocate memory for the touchscreen data structure */
+    struct ft8756_ts *ts = devm_kzalloc(dev, sizeof(struct ft8756_ts), GFP_KERNEL);
+	if (!ts)
+		return -ENOMEM;
+
+	/* Set SPI mode and bits per word, and perform SPI setup */
+    spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	ret = spi_setup(spi);
+	if (ret)
+		return ret;
+
+    /* Allocate and copy the default regmap configuration */
+    regmap_config = devm_kmemdup(dev, &ft8756_regmap_config_32bit,
+				     sizeof(*regmap_config), GFP_KERNEL);
+	if (!regmap_config) {
+		dev_err(dev, "memdup regmap_config fail\n");
+		return -ENOMEM;
+	}
+
+    /* Calculate the maximum raw read and write sizes based on SPI transfer size */
+	max_size = spi_max_transfer_size(spi);
+	regmap_config->max_raw_read = max_size - 9;
+	regmap_config->max_raw_write = max_size - 9;
+
+	/* Initialize the regmap using the provided configuration */
+    ts->regmap = devm_regmap_init(dev, NULL, spi, regmap_config);
+	if (IS_ERR(ts->regmap))
+		return PTR_ERR(ts->regmap);
+
+    /* Set the device-specific data to the allocated structure */
+	dev_set_drvdata(dev, ts);
+
+    ts->dev = dev;
+    ts->irq = spi->irq;
+
+    /* Allocate memory for GPIO supplies */
+	ts->supplies = devm_kcalloc(dev, FT8756_NUM_SUPPLIES,
+				    sizeof(*ts->supplies), GFP_KERNEL);
+    if (!ts->supplies)
+		return -ENOMEM;
+
+    /* Get and configure the optional reset GPIO */
+	ts->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ts->reset_gpio))
+		return PTR_ERR(ts->reset_gpio);
+
+	gpiod_set_consumer_name(ts->reset_gpio, "ft8756 reset");
+
+    /* Get and configure the optional IRQ GPIO */
+	ts->irq_gpio = devm_gpiod_get_optional(dev, "irq", GPIOD_IN);
+	if (IS_ERR(ts->irq_gpio))
+		return PTR_ERR(ts->irq_gpio);
+
+    /* If IRQ is not specified, try to obtain it from the IRQ GPIO */
+	if (ts->irq <= 0) {
+		ts->irq = gpiod_to_irq(ts->irq_gpio);
+		if (ts->irq <= 0) {
+			dev_err(dev, "either need irq or irq-gpio specified in devicetree node!\n");
+			return -EINVAL;
+		}
+
+		dev_info(ts->dev, "Interrupts GPIO: %#x\n", ts->irq); // todo change to dbg
+	}
+
+	gpiod_set_consumer_name(ts->irq_gpio, "ft8756 irq");
+
+    /* If the device follows a DRM panel, skip regulator initialization */
+	if (drm_is_panel_follower(dev))
+		goto skip_regulators;
+
+    ts->supplies[0].supply = "vio";
+	ts->supplies[1].supply = "lab";
+	ts->supplies[2].supply = "ibb";
+	ret = devm_regulator_bulk_get(dev,
+				      FT8756_NUM_SUPPLIES,
+				      ts->supplies);
+	if (ret)
+		return dev_err_probe(dev, ret,
+				     "Cannot get supplies: %d\n", ret);
+
+	ret = regulator_bulk_enable(FT8756_NUM_SUPPLIES, ts->supplies);
+	if (ret)
+		return ret;
+
+
+	/* Delay for regulators to stabilize */
+	usleep_range(10000, 11000);
+
+	ret = devm_add_action_or_reset(dev, ft8756_disable_regulators, ts);
+	if (ret)
+		return ret;
+
+skip_regulators:
+    ret = ft8756_check_chip_id(ts);
+    if (ret)
+        return ret;
+
+    /* Parse the firmware path from the device tree */
+	ret = of_property_read_string(dev->of_node, "firmware-name", &ts->firmware_path);
+	if (ret) {
+		dev_err(dev, "Failed to read firmware-name property\n");
+		return ret;
+	}
+
+    ret = ft8756_input_dev_config(ts);
+	if (ret) {
+        dev_err(dev, "failed set input device: %d\n", ret);
+        return ret;
+	}
+
+    /* Request threaded IRQ for touch screen interrupts */
+	ret = devm_request_threaded_irq(dev, ts->irq, NULL, ft8756_irq_handler,
+			 IRQ_TYPE_EDGE_RISING | IRQF_ONESHOT, dev_name(dev), ts);
+	if (ret) {
+        dev_err(dev, "request irq failed: %d\n", ret);
+        return ret;
+	}
+
+    /* Set up delayed work for firmware download */
+	devm_delayed_work_autocancel(dev, &ts->work, ft8756_download_firmware);
+
+	/* Schedule the delayed work */
+	schedule_delayed_work(&ts->work, 0);
+
+    /* If the device follows a DRM panel, configure panel follower */
+	if (drm_is_panel_follower(dev)) {
+		ts->panel_follower.funcs = &ft8756_panel_follower_funcs;
+		devm_drm_panel_add_follower(dev, &ts->panel_follower);
+	}
+
+	dev_info(dev, "FT8756 touchscreen initialized\n");
+    return 0;
+}
+
+static int __maybe_unused ft8756_internal_pm_suspend(struct device *dev)
+{
+	struct ft8756_ts *ts = dev_get_drvdata(dev);
+	int ret = 0;
+
+	ts->status |= FT8756_STATUS_SUSPEND;
+
+	cancel_delayed_work_sync(&ts->work);
+
+	regmap_write(ts->regmap, FT8756_REG_POWER_MODE_SLEEP, FT8756_REG_POWER_MODE_SLEEP);
+	if (ret)
+		dev_err(ts->dev, "Cannot enter sleep!\n");
+	return 0;
+}
+
+static int __maybe_unused ft8756_pm_suspend(struct device *dev)
+{
+	struct ft8756_ts *ts = dev_get_drvdata(dev);
+	int ret=0;
+
+	if (drm_is_panel_follower(dev))
+		return 0;
+
+	disable_irq_nosync(ts->irq);
+
+	ret = ft8756_internal_pm_suspend(dev);
+	return ret;
+}
+
+static int __maybe_unused ft8756_internal_pm_resume(struct device *dev)
+{
+	struct ft8756_ts *ts = dev_get_drvdata(dev);
+
+	/* some how reduced some kind of cpu, but remove checking should no harm */
+	if (ts->status & FT8756_STATUS_SUSPEND)
+		schedule_delayed_work(&ts->work, 0);
+
+	ts->status &= ~FT8756_STATUS_SUSPEND;
+
+	return 0;
+}
+
+static int __maybe_unused ft8756_pm_resume(struct device *dev)
+{
+	struct ft8756_ts *ts = dev_get_drvdata(dev);
+	int ret=0;
+
+	if (drm_is_panel_follower(dev))
+		return 0;
+
+	enable_irq(ts->irq);
+
+	ret = ft8756_internal_pm_resume(dev);
+	return ret;
+}
+
+EXPORT_GPL_SIMPLE_DEV_PM_OPS(ft8756_pm_ops,
+			     ft8756_pm_suspend,
+			     ft8756_pm_resume);
+
+static int panel_prepared(struct drm_panel_follower *follower)
+{
+	struct ft8756_ts *ts = container_of(follower, struct ft8756_ts, panel_follower);
+
+	if (ts->status & FT8756_STATUS_SUSPEND)
+		enable_irq(ts->irq);
+
+	return ft8756_internal_pm_resume(ts->dev);
+}
+
+static int panel_unpreparing(struct drm_panel_follower *follower)
+{
+	struct ft8756_ts *ts = container_of(follower, struct ft8756_ts, panel_follower);
+
+	ts->status |= FT8756_STATUS_SUSPEND;
+
+	disable_irq(ts->irq);
+
+	return ft8756_internal_pm_suspend(ts->dev);
+}
+
+static struct drm_panel_follower_funcs ft8756_panel_follower_funcs = {
+	.panel_prepared = panel_prepared,
+	.panel_unpreparing = panel_unpreparing,
+};
+
+static const struct spi_device_id ft8756_spi_ids[] = {
+	{ "ft8756-spi", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, ft8756_spi_ids);
+
+static struct spi_driver ft8756_spi_driver = {
+	.driver = {
+		.name   = "ft8756-spi",
+		.pm = pm_sleep_ptr(&ft8756_pm_ops),
+	},
+	.probe = ft8756_spi_probe,
+	.id_table = ft8756_spi_ids,
+};
+module_spi_driver(ft8756_spi_driver);
+
+MODULE_DESCRIPTION("FT8756 touchscreen driver");
+MODULE_AUTHOR("Nikroks <nikroksm@mail.ru>");
+MODULE_LICENSE("GPL");
\ No newline at end of file
diff --git a/drivers/input/touchscreen/nt36xxx.h b/drivers/input/touchscreen/nt36xxx.h
new file mode 100644
index 00000000000000..d953d4c3b35c1a
--- /dev/null
+++ b/drivers/input/touchscreen/nt36xxx.h
@@ -0,0 +1,136 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2010 - 2017 Novatek, Inc.
+ * Copyright (C) 2020 AngeloGioacchino Del Regno <kholk11@gmail.com>
+ * Copyright (C) 2023 99degree <www.github.com/99degree>
+ */
+
+#ifndef NT36XXX_H
+#define NT36XXX_H
+
+#define NT36XXX_INPUT_DEVICE_NAME	"Novatek NT36XXX Touch Sensor"
+#define MAX_SPI_FREQ_HZ 8000000
+
+/* FW Param address */
+#define NT36XXX_FW_ADDR		0x01
+
+#define NT36XXX_TRANSFER_LEN	(63*1024)
+
+/* due to extra framework layer, the transfer trunk is as small as
+ * 128 otherwize dma error happened, all routed to spi_sync()
+*/
+
+/* Number of bytes for chip identification */
+#define NT36XXX_ID_LEN_MAX	6
+
+/* Touch info */
+#define TOUCH_DEFAULT_MAX_WIDTH  1080
+#define TOUCH_DEFAULT_MAX_HEIGHT 2246
+#define TOUCH_MAX_FINGER_NUM	 10
+#define TOUCH_MAX_PRESSURE	 1000
+
+/* Point data length */
+#define POINT_DATA_LEN		65
+
+/* Misc */
+#define NT36XXX_NUM_SUPPLIES	 2
+#define NT36XXX_MAX_RETRIES	 5
+#define NT36XXX_MAX_FW_RST_RETRY 50
+
+enum nt36xxx_chips {
+        NT36525_IC = 0x40,
+        NT36672A_IC,
+        NT36676F_IC,
+        NT36772_IC,
+        NT36675_IC,
+        NT36870_IC,
+        NTMAX_IC,
+};
+
+enum nt36xxx_cmds {
+	NT36XXX_CMD_ENTER_SLEEP = 0x11,
+	NT36XXX_CMD_BOOTLOADER_RESET = 0x69,
+};
+
+enum nt36xxx_events {
+        NT36XXX_EVT_REPORT              = 0x00,
+        NT36XXX_EVT_CRC                 = 0x35,
+        NT36XXX_EVT_HOST_CMD            = 0x50,
+        NT36XXX_EVT_HS_OR_SUBCMD        = 0x51, /* Handshake or subcommand byte */
+        NT36XXX_EVT_RESET_COMPLETE      = 0x60,
+        NT36XXX_EVT_FWINFO              = 0x78,
+        NT36XXX_EVT_READ_PID            = 0x80,
+        NT36XXX_EVT_PROJECTID           = 0x9a, /* Excess 0x80 write bit, messed trouble, ignored */
+};
+
+enum nt36xxx_fw_state {
+        NT36XXX_STATE_INIT = 0xa0,              /* IC Reset */
+        NT36XXX_STATE_REK = 0xa1,               /* ReK baseline */
+        NT36XXX_STATE_REK_FINISH = 0xa2,        /* Baseline is ready */
+        NT36XXX_STATE_NORMAL_RUN = 0xa3,        /* Firmware is running */
+        NT36XXX_STATE_MAX = 0xaf
+};
+
+struct nt36xxx_ts;
+
+struct nvt_fw_parse_data {
+	uint8_t partition;
+	uint8_t ilm_dlm_num;
+};
+
+struct nvt_ts_bin_map {
+	char name[12];
+	uint32_t bin_addr;
+	uint32_t sram_addr;
+	uint32_t size;
+	uint32_t crc;
+	uint32_t loaded;
+};
+
+struct nvt_ts_hw_info {
+	uint8_t carrier_system;
+	uint8_t hw_crc;
+};
+
+struct nt36xxx_abs_object {
+	u16 x;
+	u16 y;
+	u16 z;
+	u8 tm;
+};
+
+struct nt36xxx_fw_info {
+	u8 fw_ver;
+	u8 x_num;
+	u8 y_num;
+	u8 max_buttons;
+	u16 abs_x_max;
+	u16 abs_y_max;
+	u16 nvt_pid;
+};
+
+struct nt36xxx_chip_data {
+	const u32 *mmap;
+	const struct regmap_config *config;
+
+	unsigned int abs_x_max;
+	unsigned int abs_y_max;
+	unsigned int max_button;
+	const struct input_id *id;
+};
+
+struct nt36xxx_trim_table {
+	u8 id[NT36XXX_ID_LEN_MAX];
+	u8 mask[NT36XXX_ID_LEN_MAX];
+	enum nt36xxx_chips mapid;
+	uint8_t carrier_system;
+	uint8_t hw_crc;
+};
+
+int nt36xxx_probe(struct device *dev, int irq, const struct input_id *id,
+			struct regmap *regmap);
+
+extern const struct dev_pm_ops nt36xxx_pm_ops;
+extern const u32 nt36675_memory_maps[];
+
+#endif
diff --git a/drivers/input/touchscreen/nt36xxx_core.c b/drivers/input/touchscreen/nt36xxx_core.c
new file mode 100644
index 00000000000000..9a5ea045c8d74e
--- /dev/null
+++ b/drivers/input/touchscreen/nt36xxx_core.c
@@ -0,0 +1,1220 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Driver for Novatek NT36xxx series touchscreens
+ *
+ * Copyright (C) 2010 - 2018 Novatek, Inc.
+ * Copyright (C) 2020 XiaoMi, Inc.
+ * Copyright (C) 2020 AngeloGioacchino Del Regno <kholk11@gmail.com>
+ * Copyright (C) 2023 99degree <www.github.com/99degree>
+ *
+ * Based on nt36xxx.c i2c driver from AngeloGioacchino Del Regno
+ */
+
+#include <asm/byteorder.h>
+#include <asm/unaligned.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/gpio/consumer.h>
+#include <linux/input/mt.h>
+#include <linux/input/touchscreen.h>
+#include <linux/interrupt.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/printk.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/device.h>
+#include <linux/devm-helpers.h>
+#include <drm/drm_panel.h>
+#include <linux/irqnr.h>
+
+#include "nt36xxx.h"
+
+/* Main mmap to spi addr */
+enum {
+	MMAP_BASELINE_ADDR,
+	MMAP_BASELINE_BTN_ADDR,
+	MMAP_BLD_CRC_EN_ADDR,
+	MMAP_BLD_DES_ADDR,
+	MMAP_BLD_ILM_DLM_CRC_ADDR,
+	MMAP_BLD_LENGTH_ADDR,
+	MMAP_BOOT_RDY_ADDR,
+	MMAP_DIFF_BTN_PIPE0_ADDR,
+	MMAP_DIFF_BTN_PIPE1_ADDR,
+	MMAP_DIFF_PIPE0_ADDR,
+	MMAP_DIFF_PIPE1_ADDR,
+	MMAP_DLM_DES_ADDR,
+	MMAP_DLM_LENGTH_ADDR,
+	MMAP_DMA_CRC_EN_ADDR,
+	MMAP_DMA_CRC_FLAG_ADDR,
+	MMAP_ENG_RST_ADDR,
+	MMAP_EVENT_BUF_ADDR,
+	MMAP_G_DLM_CHECKSUM_ADDR,
+	MMAP_G_ILM_CHECKSUM_ADDR,
+	MMAP_ILM_DES_ADDR,
+	MMAP_ILM_LENGTH_ADDR,
+	MMAP_POR_CD_ADDR,
+	MMAP_RAW_BTN_PIPE0_ADDR,
+	MMAP_RAW_BTN_PIPE1_ADDR,
+	MMAP_RAW_PIPE0_ADDR,
+	MMAP_RAW_PIPE1_ADDR,
+	MMAP_READ_FLASH_CHECKSUM_ADDR,
+	MMAP_RW_FLASH_DATA_ADDR,
+	MMAP_R_DLM_CHECKSUM_ADDR,
+	MMAP_R_ILM_CHECKSUM_ADDR,
+	MMAP_SPI_RD_FAST_ADDR,
+	MMAP_SWRST_N8_ADDR,
+
+	/* below are magic numbers in source code */
+	MMAP_MAGIC_NUMBER_0X1F64E_ADDR,
+
+	/* this addr is not specific to */
+	MMAP_TOP_ADDR,
+	MMAP_MAX_ADDR = MMAP_TOP_ADDR,
+} nt36xxx_ts_mem_map;
+
+static struct drm_panel_follower_funcs nt36xxx_panel_follower_funcs;
+
+struct nt36xxx_ts {
+	struct regmap *regmap;
+
+	struct input_dev *input;
+	struct regulator_bulk_data *supplies;
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *irq_gpio;
+	int irq;
+	struct device *dev;
+
+	struct mutex lock;
+
+#define NT36XXX_STATUS_SUSPEND			BIT(0)
+#define NT36XXX_STATUS_DOWNLOAD_COMPLETE	BIT(1)
+#define NT36XXX_STATUS_DOWNLOAD_RECOVER		BIT(2)
+	unsigned int status;
+
+	struct touchscreen_properties prop;
+	struct nt36xxx_fw_info fw_info;
+	struct nt36xxx_abs_object abs_obj;
+
+	struct drm_panel_follower panel_follower;
+
+	struct delayed_work work;
+
+	/* this is a duplicate with nt36xxx_chip_data and since the address might
+	 * change in boot/init/download stages so make it a copy of initial map and
+	 * update accordingly
+	 */
+	u32 *mmap;
+	u32 mmap_data[MMAP_MAX_ADDR];
+
+	struct nvt_fw_parse_data fw_data;
+	struct nvt_ts_bin_map *bin_map;
+
+	uint8_t hw_crc;
+
+	struct firmware fw_entry; /* containing request fw data */
+	const char *firmware_path;
+	const struct nt36xxx_chip_data *data;
+};
+
+static const struct nt36xxx_trim_table trim_id_table[] = {
+#if 0
+	/* TODO: port and test all related module */
+	{
+		.id = { 0x0A, 0xFF, 0xFF, 0x72, 0x66, 0x03 },
+		.mask = { 1, 0, 0, 1, 1, 1 },
+		.mapid = NT36672A_IC,
+	},
+	{
+		.id = { 0x55, 0x00, 0xFF, 0x00, 0x00, 0x00 },
+		.mask = { 1, 1, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0x55, 0x72, 0xFF, 0x00, 0x00, 0x00 },
+		.mask = { 1, 1, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xAA, 0x00, 0xFF, 0x00, 0x00, 0x00 },
+		.mask = { 1, 1, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xAA, 0x72, 0xFF, 0x00, 0x00, 0x00 },
+		.mask = { 1, 1, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xFF, 0xFF, 0xFF, 0x72, 0x67, 0x03 },
+		.mask = { 0, 0, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xFF, 0xFF, 0xFF, 0x70, 0x66, 0x03 },
+		.mask = { 0, 0, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xFF, 0xFF, 0xFF, 0x70, 0x67, 0x03 },
+		.mask = { 0, 0, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xFF, 0xFF, 0xFF, 0x72, 0x66, 0x03 },
+		.mask = { 0, 0, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xFF, 0xFF, 0xFF, 0x25, 0x65, 0x03 },
+		.mask = { 0, 0, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xFF, 0xFF, 0xFF, 0x70, 0x68, 0x03 },
+		.mask = { 0, 0, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xFF, 0xFF, 0xFF, 0x76, 0x66, 0x03 },
+		.mask = { 0, 0, 0, 1, 1, 1 },
+		.mapid = NT36676F_IC,
+	},
+#endif
+	{
+		.id = { 0xFF, 0xFF, 0xFF, 0x75, 0x66, 0x03 },
+		.mask = { 0, 0, 0, 1, 1, 1 },
+		.mapid = NT36675_IC,
+		.hw_crc = 2,  /* 3Bytes */
+	},
+	{
+		.id = { 0x0C, 0xFF, 0xFF, 0x72, 0x66, 0x03 },
+		.mask = { 1, 0, 0, 1, 1, 1 },
+		.mapid = NT36675_IC,
+		.hw_crc = 2,  /* 3Bytes */
+	},
+	{ },
+};
+
+const u32 nt36675_memory_maps[] = {
+	[MMAP_EVENT_BUF_ADDR] = 0x22D00,
+	[MMAP_RAW_PIPE0_ADDR] = 0x24000,
+	[MMAP_RAW_PIPE1_ADDR] = 0x24000,
+	[MMAP_BASELINE_ADDR] = 0x21B90,
+	[MMAP_DIFF_PIPE0_ADDR] = 0x20C60,
+	[MMAP_DIFF_PIPE1_ADDR] = 0x24C60,
+	[MMAP_READ_FLASH_CHECKSUM_ADDR] = 0x24000,
+	[MMAP_RW_FLASH_DATA_ADDR] = 0x24002,
+	[MMAP_BOOT_RDY_ADDR] = 0x3F10D,
+	[MMAP_BLD_LENGTH_ADDR] = 0x3F138,
+	[MMAP_ILM_LENGTH_ADDR] = 0x3F118,
+	[MMAP_DLM_LENGTH_ADDR] = 0x3F130,
+	[MMAP_BLD_DES_ADDR] = 0x3F114,
+	[MMAP_ILM_DES_ADDR] = 0x3F128,
+	[MMAP_DLM_DES_ADDR] = 0x3F12C,
+	[MMAP_G_ILM_CHECKSUM_ADDR] = 0x3F100,
+	[MMAP_G_DLM_CHECKSUM_ADDR] = 0x3F104,
+	[MMAP_R_ILM_CHECKSUM_ADDR] = 0x3F120,
+	[MMAP_R_DLM_CHECKSUM_ADDR] = 0x3F124,
+	[MMAP_BLD_CRC_EN_ADDR] = 0x3F30E,
+	[MMAP_DMA_CRC_EN_ADDR] = 0x3F136,
+	[MMAP_BLD_ILM_DLM_CRC_ADDR] = 0x3F133,
+	[MMAP_DMA_CRC_FLAG_ADDR] = 0x3F134,
+
+	/* below are specified by dts), so it might change by project-based */
+	[MMAP_SPI_RD_FAST_ADDR] = 0x03F310,
+	[MMAP_SWRST_N8_ADDR] = 0x03F0FE,
+
+	[MMAP_ENG_RST_ADDR] = 0x7FFF80,
+	[MMAP_MAGIC_NUMBER_0X1F64E_ADDR] = 0x1F64E,
+
+	[MMAP_TOP_ADDR] = 0xffffff,
+};
+
+void _debug_irq(struct nt36xxx_ts *ts, int line){
+	struct irq_desc *desc;
+	desc = irq_data_to_desc( irq_get_irq_data(ts->irq));
+	dev_info(ts->dev, "%d irq_desc depth=%d", line, desc->depth );
+}
+
+#define debug_irq(a) _debug_irq(a, __LINE__)
+
+static int nt36xxx_eng_reset_idle(struct nt36xxx_ts *ts)
+{
+	int ret;
+
+	if(!ts) {
+		dev_err(ts->dev, "%s %s empty", __func__, "nt36xxx_ts");
+		return -EINVAL;
+	}
+
+	if(!ts->mmap) {
+		dev_err(ts->dev, "%s %s empty", __func__, "ts->mmap");
+		return -EINVAL;
+	}
+
+	if(ts->mmap[MMAP_ENG_RST_ADDR] == 0) {
+		dev_err(ts->dev, "%s %s empty", __func__, "MMAP_ENG_RST_ADDR");
+		return -EINVAL;
+	}
+
+	/* HACK to output something without read */
+	ret = regmap_write(ts->regmap, ts->mmap[MMAP_ENG_RST_ADDR],
+					   0x5a);
+	if (ret) {
+		dev_err(ts->dev, "%s regmap write error\n", __func__);
+		return ret;
+	}
+
+	/* Wait until the MCU resets the fw state */
+	usleep_range(15000, 16000);
+
+	/* seemed not long enough */
+	msleep(30);
+	return ret;
+}
+
+/**
+ * nt36xxx_bootloader_reset - Reset MCU to bootloader
+ * @ts: Main driver structure
+ *
+ * Return: Always zero for success, negative number for error
+ */
+static int nt36xxx_bootloader_reset(struct nt36xxx_ts *ts)
+{
+	int ret = 0;
+
+	//in spi version, need to set page to SWRST_N8_ADDR
+	if (ts->mmap[MMAP_SWRST_N8_ADDR]) {
+		ret = regmap_write(ts->regmap, ts->mmap[MMAP_SWRST_N8_ADDR],
+			   NT36XXX_CMD_BOOTLOADER_RESET);
+		if (ret)
+			return ret;
+	} else {
+		pr_info("plz make sure MMAP_SWRST_N8_ADDR is set!\n");
+		return -EINVAL;
+	}
+
+	/* MCU has to reboot from bootloader: this is the typical boot time */
+	msleep(35);
+
+	if (ts->mmap[MMAP_SPI_RD_FAST_ADDR]) {
+		ret = regmap_write(ts->regmap, ts->mmap[MMAP_SPI_RD_FAST_ADDR], 0);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+/**
+ * nt36xxx_check_reset_state - Check the boot state during reset
+ * @ts: Main driver structure
+ * @fw_state: Enumeration containing firmware states
+ *
+ * Return: Always zero for success, negative number for error
+ */
+static int nt36xxx_check_reset_state(struct nt36xxx_ts *ts,
+				     enum nt36xxx_fw_state fw_state)
+{
+	u8 buf[8] = { 0 };
+	int ret = 0, retry = NT36XXX_MAX_FW_RST_RETRY;
+
+	do {
+		ret = regmap_raw_read(ts->regmap, ts->mmap[MMAP_EVENT_BUF_ADDR]
+				 | NT36XXX_EVT_RESET_COMPLETE, buf, 6);
+		if (likely(ret == 0) &&
+		    (buf[1] >= fw_state) &&
+		    (buf[1] <= NT36XXX_STATE_MAX)) {
+			ret = 0;
+			break;
+		}
+		usleep_range(10000, 11000);
+	} while (--retry);
+
+	if (!retry) {
+		dev_err(ts->dev, "Firmware reset failed.\n");
+		ret = -EBUSY;
+	}
+
+	return ret;
+}
+
+/**
+ * nt36xxx_report - Report touch events
+ * @ts: Main driver structure
+ *
+ * Return: Always zero for success, negative number for error
+ */
+static void nt36xxx_report(struct nt36xxx_ts *ts)
+{
+	struct nt36xxx_abs_object *obj = &ts->abs_obj;
+	struct input_dev *input = ts->input;
+	u8 input_id = 0;
+	u8 point[POINT_DATA_LEN + 1] = { 0 };
+	unsigned int ppos = 0;
+	int i, ret, finger_cnt = 0;
+	uint8_t press_id[TOUCH_MAX_FINGER_NUM] = {0};
+
+	ret = regmap_raw_read(ts->regmap, ts->mmap[MMAP_EVENT_BUF_ADDR],
+				point, sizeof(point));
+	if (ret < 0) {
+		dev_err(ts->dev,
+			"Cannot read touch point data: %d\n", ret);
+		goto xfer_error;
+	}
+
+	/* wdt recovery and esd check */
+	for (i = 0; i < 7; i++) {
+		if ((point[i] != 0xFD) && (point[i] != 0xFE) && (point[i] != 0x77)) {
+			break;
+		}
+
+		cancel_delayed_work(&ts->work);
+		schedule_delayed_work(&ts->work, 100);
+		goto xfer_error;
+	}
+
+	for (i = 0; i < TOUCH_MAX_FINGER_NUM; i++) {
+		ppos = 6 * i + 1;
+		input_id = point[ppos + 0] >> 3;
+
+		if ((input_id == 0) || (input_id > TOUCH_MAX_FINGER_NUM)) {
+			continue;
+		}
+
+		if (((point[ppos] & 0x07) == 0x01) ||
+		    ((point[ppos] & 0x07) == 0x02)) {
+			obj->x = (point[ppos + 1] << 4) +
+				 (point[ppos + 3] >> 4);
+			obj->y = (point[ppos + 2] << 4) +
+				 (point[ppos + 3] & 0xf);
+
+			if ((obj->x > ts->prop.max_x) ||
+			    (obj->y > ts->prop.max_y))
+				continue;
+
+			obj->tm = point[ppos + 4];
+			if (obj->tm == 0)
+				obj->tm = 1;
+
+			obj->z = point[ppos + 5];
+			if (i < 2) {
+				obj->z += point[i + 63] << 8;
+				if (obj->z > TOUCH_MAX_PRESSURE)
+					obj->z = TOUCH_MAX_PRESSURE;
+			}
+
+			if (obj->z == 0)
+				obj->z = 1;
+
+			press_id[input_id - 1] = 1;
+
+			input_mt_slot(input, input_id - 1);
+			input_mt_report_slot_state(input,
+						   MT_TOOL_FINGER, true);
+			touchscreen_report_pos(input, &ts->prop,
+						obj->x,
+						obj->y, true);
+
+			input_report_abs(input, ABS_MT_TOUCH_MAJOR, obj->tm);
+			input_report_abs(input, ABS_MT_PRESSURE, obj->z);
+
+			finger_cnt++;
+		}
+	}
+
+	input_mt_sync_frame(input);
+
+	input_sync(input);
+
+xfer_error:
+	return;
+}
+
+static irqreturn_t nt36xxx_irq_handler(int irq, void *dev_id)
+{
+	struct nt36xxx_ts *ts = dev_id;
+
+	if (!ts->mmap)
+		goto exit;
+
+	disable_irq_nosync(ts->irq);
+
+	nt36xxx_report(ts);
+
+	enable_irq(ts->irq);
+
+exit:
+	if (ts->status & NT36XXX_STATUS_DOWNLOAD_RECOVER) {
+		ts->status &= ~NT36XXX_STATUS_DOWNLOAD_RECOVER;
+		schedule_delayed_work(&ts->work, 40000);
+	}
+
+	return IRQ_HANDLED;
+}
+
+
+/**
+ * nt36xxx_chip_version_init - Detect Novatek NT36xxx family IC
+ * @ts: Main driver structure
+ *
+ * This function reads the ChipID from the IC and sets the right
+ * memory map for the detected chip.
+ *
+ * Return: Always zero for success, negative number for error
+ */
+static int nt36xxx_chip_version_init(struct nt36xxx_ts *ts)
+{
+	u8 buf[32] = { 0 };
+	int retry = NT36XXX_MAX_RETRIES;
+	int sz = sizeof(trim_id_table) / sizeof(struct nt36xxx_trim_table);
+	int i, list, mapid, ret;
+
+	ret = nt36xxx_bootloader_reset(ts);
+	if (ret) {
+		dev_err(ts->dev, "Can't reset the nvt IC\n");
+		return ret;
+	}
+
+	do {
+		ret = regmap_raw_read(ts->regmap, ts->mmap[MMAP_MAGIC_NUMBER_0X1F64E_ADDR], buf, 7);
+
+		if (ret)
+			continue;
+
+		dev_dbg(ts->dev, "%s buf[0]=0x%02X, buf[1]=0x%02X, buf[2]=0x%02X, buf[3]=0x%02X, buf[4]=0x%02X, buf[5]=0x%02X, buf[6]=0x%02X sz=%d\n",
+			__func__, buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], sz);
+
+		/* Compare read chip id with trim list */
+		for (list = 0; list < sz; list++) {
+
+			/* Compare each not masked byte */
+			for (i = 0; i < NT36XXX_ID_LEN_MAX; i++) {
+				if (trim_id_table[list].mask[i] &&
+				    buf[i + 1] != trim_id_table[list].id[i])
+					break;
+			}
+
+			/* found and match with mask */
+			if (i == NT36XXX_ID_LEN_MAX) {
+				mapid = trim_id_table[list].mapid;
+				ret = 0;
+				ts->hw_crc = trim_id_table[list].hw_crc;
+
+				if (mapid == 0) {
+					dev_info(ts->dev, "NVT touch IC hw not found i=%d list=%d\n", i, list);
+					ret = -ENOENT;
+					goto exit;
+				}
+
+				WARN_ON(ts->hw_crc < 1);
+
+				dev_dbg(ts->dev, "hw crc support=%d\n", ts->hw_crc);
+
+				dev_info(ts->dev, "This is NVT touch IC, %x, mapid %d", *(int*)&buf[4], mapid);
+				return 0;
+			}
+
+			ret = -ENOENT;
+		}
+
+		usleep_range(10000, 11000);
+	} while (--retry);
+
+exit:
+	return ret;
+}
+
+/*
+ * this function is nearly direct copy from vendor source
+*/
+static int32_t nvt_bin_header_parser(struct device *dev, int hw_crc, const u8 *fwdata, size_t fwsize, struct nvt_ts_bin_map **bin_map_ptr, uint8_t *partition_ptr, uint8_t ilm_dlm_num)
+{
+	uint8_t list = 0;
+	uint32_t pos = 0x00;
+	uint32_t end = 0x00;
+	uint8_t info_sec_num = 0;
+	uint8_t ovly_sec_num = 0;
+	uint8_t ovly_info = 0;
+	uint8_t partition;
+	struct nvt_ts_bin_map *bin_map;
+
+	/* Find the header size */
+	end = fwdata[0] + (fwdata[1] << 8) + (fwdata[2] << 16) + (fwdata[3] << 24);
+	pos = 0x30;	// info section start at 0x30 offset
+	while (pos < end) {
+		info_sec_num ++;
+		pos += 0x10;	/* each header info is 16 bytes */
+	}
+
+	/*
+	 * Find the DLM OVLY section
+	 * [0:3] Overlay Section Number
+	 * [4]   Overlay Info
+	 */
+	ovly_info = (fwdata[0x28] & 0x10) >> 4;
+	ovly_sec_num = (ovly_info) ? (fwdata[0x28] & 0x0F) : 0;
+
+	/*
+	 * calculate all partition number
+	 * ilm_dlm_num (ILM & DLM) + ovly_sec_num + info_sec_num
+	 */
+	*partition_ptr = partition = ilm_dlm_num + ovly_sec_num + info_sec_num;
+	dev_dbg(dev, "ovly_info = %d, ilm_dlm_num = %d, ovly_sec_num = %d, info_sec_num = %d, partition = %d\n",
+			ovly_info, ilm_dlm_num, ovly_sec_num, info_sec_num, partition);
+
+	/* allocated memory for header info */
+	*bin_map_ptr = bin_map = (struct nvt_ts_bin_map *)devm_kzalloc(dev, (partition + 1) * sizeof(struct nvt_ts_bin_map), GFP_KERNEL);
+	if(bin_map == NULL) {
+		dev_err(dev, "kzalloc for bin_map failed!\n");
+		return -ENOMEM;
+	}
+
+
+	for (list = 0; list < partition; list++) {
+		/*
+		 * [1] parsing ILM & DLM header info
+		 * bin_addr : sram_addr : size (12-bytes)
+		 * crc located at 0x18 & 0x1C
+		 */
+		if (list < ilm_dlm_num) {
+			memcpy(&bin_map[list].bin_addr, &(fwdata[0 + list*12]), 4);
+			memcpy(&bin_map[list].sram_addr, &(fwdata[4 + list*12]), 4);
+			memcpy(&bin_map[list].size, &(fwdata[8 + list*12]), 4);
+			memcpy(&bin_map[list].crc, &(fwdata[0x18 + list*4]), 4);
+
+			if (!hw_crc) {
+				dev_err(dev, "%s %d sw-crc not support", __func__, __LINE__);
+				return -EINVAL;
+			}
+
+			if (list == 0)
+				sprintf(bin_map[list].name, "ILM");
+			else if (list == 1)
+				sprintf(bin_map[list].name, "DLM");
+		}
+
+		/*
+		 * [2] parsing others header info
+		 * sram_addr : size : bin_addr : crc (16-bytes)
+		 */
+		if ((list >= ilm_dlm_num) && (list < (ilm_dlm_num + info_sec_num))) {
+
+			/* others partition located at 0x30 offset */
+			pos = 0x30 + (0x10 * (list - ilm_dlm_num));
+
+			memcpy(&bin_map[list].sram_addr, &(fwdata[pos]), 4);
+			memcpy(&bin_map[list].size, &(fwdata[pos+4]), 4);
+			memcpy(&bin_map[list].bin_addr, &(fwdata[pos+8]), 4);
+			memcpy(&bin_map[list].crc, &(fwdata[pos+12]), 4);
+
+			if (!hw_crc) {
+				dev_info(dev, "ok, hw_crc not presents!");
+				return -EINVAL;
+			}
+
+			/* detect header end to protect parser function */
+			if ((bin_map[list].bin_addr == 0) && (bin_map[list].size != 0)) {
+				sprintf(bin_map[list].name, "Header");
+			} else {
+				sprintf(bin_map[list].name, "Info-%d", (list - ilm_dlm_num));
+			}
+		}
+
+		/*
+		 * [3] parsing overlay section header info
+		 * sram_addr : size : bin_addr : crc (16-bytes)
+		 */
+		if (list >= (ilm_dlm_num + info_sec_num)) {
+			/* overlay info located at DLM (list = 1) start addr */
+			pos = bin_map[1].bin_addr + (0x10 * (list- ilm_dlm_num - info_sec_num));
+
+			memcpy(&bin_map[list].sram_addr, &(fwdata[pos]), 4);
+			memcpy(&bin_map[list].size, &(fwdata[pos+4]), 4);
+			memcpy(&bin_map[list].bin_addr, &(fwdata[pos+8]), 4);
+			memcpy(&bin_map[list].crc, &(fwdata[pos+12]), 4);
+
+			if (!hw_crc) {
+				dev_err(dev, "%s %d sw_crc not support", __func__, __LINE__);
+				return -EINVAL;
+			}
+
+			sprintf(bin_map[list].name, "Overlay-%d", (list- ilm_dlm_num - info_sec_num));
+		}
+
+		/* BIN size error detect */
+		if ((bin_map[list].bin_addr + bin_map[list].size) > fwsize) {
+			dev_err(dev, "access range (0x%08X to 0x%08X) is larger than bin size!\n",
+					bin_map[list].bin_addr, bin_map[list].bin_addr + bin_map[list].size);
+			return -EINVAL;
+		}
+
+		dev_dbg(dev, "[%d][%s] SRAM (0x%08X), SIZE (0x%08X), BIN (0x%08X), CRC (0x%08X)\n",
+			      list, bin_map[list].name,
+			      bin_map[list].sram_addr, bin_map[list].size,  bin_map[list].bin_addr, bin_map[list].crc);
+	}
+
+	return 0;
+}
+
+static int32_t nt36xxx_download_firmware_hw_crc(struct nt36xxx_ts *ts) {
+	uint32_t list = 0;
+	uint32_t bin_addr, sram_addr, size;
+	struct nvt_ts_bin_map *bin_map = ts->bin_map;
+
+	nt36xxx_bootloader_reset(ts);
+
+	for (list = 0; list < ts->fw_data.partition; list++) {
+		int j;
+
+		/* initialize variable */
+		sram_addr = bin_map[list].sram_addr;
+		size = bin_map[list].size;
+		bin_addr = bin_map[list].bin_addr;
+
+		/* ignore reserved partition (Reserved Partition size is zero) */
+		if (!size) {
+			dev_dbg(ts->dev, "found empty part %d. skipping ", list);
+			continue;
+		} else {
+			size = size + 1;
+			dev_dbg(ts->dev, "found useful part %d. size 0x%x ", list, size);
+		}
+
+		bin_map[list].loaded = 1;
+
+		if (size / NT36XXX_TRANSFER_LEN)
+			dev_dbg(ts->dev, "%s %d paged write [%s] 0x%x, window 0x%x, residue 0x%x",
+					__func__, __LINE__, bin_map[list].name, size,
+					NT36XXX_TRANSFER_LEN, size % NT36XXX_TRANSFER_LEN);
+
+		for (j = 0; j < size; j += NT36XXX_TRANSFER_LEN) {
+			int window_size = ((size - j) / NT36XXX_TRANSFER_LEN) ? NT36XXX_TRANSFER_LEN :
+						((size - j) % NT36XXX_TRANSFER_LEN);
+
+			regmap_bulk_write(ts->regmap, sram_addr + j, &ts->fw_entry.data[bin_addr + j],
+							 window_size);
+		}
+
+	}
+
+	return 0;
+}
+
+static void _nt36xxx_boot_download_firmware(struct nt36xxx_ts *ts) {
+	int i, ret, retry = 0;
+	size_t fw_need_write_size = 0;
+	const struct firmware *fw_entry;
+	u8 val[8 * 4] = {0};
+
+	WARN_ON(ts->hw_crc != 2);
+
+	/* supposed we need to load once and use many time */
+	if (ts->fw_entry.data)
+		goto upload;
+
+	ret = request_firmware(&fw_entry, ts->firmware_path, ts->dev);
+	if (ret) {
+		dev_err(ts->dev, "request fw fail name=%s\n", ts->firmware_path);
+		goto exit;
+	}
+
+	/*
+	 * must allocate in DMA buffer otherwise fail spi tx DMA
+	 * so we need to manage our own fw struct
+	 * pm_resume need to re-upload fw for NT36675 IC
+	 *
+	 */
+	ts->fw_entry.data = devm_kmemdup(ts->dev, fw_entry->data, fw_entry->size, GFP_KERNEL | GFP_DMA);
+
+	release_firmware(fw_entry);
+
+	if (!ts->fw_entry.data) {
+		dev_err(ts->dev, "memdup fw_data fail\n");
+		goto exit;
+	}
+	ts->fw_entry.size = fw_entry->size;
+
+	WARN_ON(ts->fw_entry.data[0] != fw_entry->data[0]);
+
+	for (i = (ts->fw_entry.size / 4096); i > 0; i--) {
+		if (strncmp(&ts->fw_entry.data[i * 4096 - 3], "NVT", 3) == 0) {
+			fw_need_write_size = i * 4096;
+			break;
+		}
+
+		if (strncmp(&ts->fw_entry.data[i * 4096 - 3], "MOD", 3) == 0) {
+			fw_need_write_size = i * 4096;
+			break;
+		}
+	}
+
+	if (fw_need_write_size == 0) {
+		dev_err(ts->dev, "fw parsing error\n");
+		goto release_fw;
+	}
+
+	if (*(ts->fw_entry.data + (fw_need_write_size - 4096)) + *(ts->fw_entry.data +
+						((fw_need_write_size - 4096) + 1)) != 0xFF) {
+		dev_err(ts->dev, "bin file FW_VER + FW_VER_BAR should be 0xFF!");
+		dev_err(ts->dev, "FW_VER=0x%02X, FW_VER_BAR=0x%02X\n",
+					*(ts->fw_entry.data+(fw_need_write_size - 4096)),
+					*(ts->fw_entry.data+(fw_need_write_size - 4096 + 1)));
+		goto release_fw;
+	}
+
+	ts->fw_data.ilm_dlm_num = 2;
+
+	ret = nvt_bin_header_parser(ts->dev, ts->hw_crc, ts->fw_entry.data, ts->fw_entry.size,
+			&ts->bin_map, &ts->fw_data.partition, ts->fw_data.ilm_dlm_num);
+	if (ret) {
+		if(ret != -ENOMEM)
+			goto release_fw_buf;
+		goto release_fw;
+	}
+
+upload:
+	if (ts->hw_crc) {
+		ret = nt36xxx_download_firmware_hw_crc(ts);
+		if (ret) {
+			dev_err(ts->dev, "nt36xxx_download_firmware_hw_crc fail!");
+			goto release_fw_buf;
+		}
+
+	} else {
+		dev_err(ts->dev, "non-hw_crc model is not support yet!");
+		goto release_fw_buf;
+	}
+
+	/* set ilm & dlm reg bank */
+	for (i = 0; i < ts->fw_data.partition; i++) {
+		if (0 == strncmp(ts->bin_map[i].name, "ILM", 3)) {
+			regmap_raw_write(ts->regmap, ts->mmap[MMAP_ILM_DES_ADDR], &ts->bin_map[i].sram_addr, 3);
+			regmap_raw_write(ts->regmap, ts->mmap[MMAP_ILM_LENGTH_ADDR], &ts->bin_map[i].size, 3);
+
+			/* crc > 1 then len = 4, crc = 1 then len = 3 */
+			regmap_raw_write(ts->regmap, ts->mmap[MMAP_G_ILM_CHECKSUM_ADDR], &ts->bin_map[i].crc,
+						sizeof(ts->bin_map[i].crc));
+		}
+		if (0 == strncmp(ts->bin_map[i].name, "DLM", 3)) {
+			regmap_raw_write(ts->regmap, ts->mmap[MMAP_DLM_DES_ADDR], &ts->bin_map[i].sram_addr, 3);
+			regmap_raw_write(ts->regmap, ts->mmap[MMAP_DLM_LENGTH_ADDR], &ts->bin_map[i].size, 3);
+
+			/* crc > 1 then len = 4, crc = 1 then len = 3 */
+			regmap_raw_write(ts->regmap, ts->mmap[MMAP_G_DLM_CHECKSUM_ADDR], &ts->bin_map[i].crc,
+						sizeof(ts->bin_map[i].crc));
+		}
+	}
+
+	/* nvt_bld_crc_enable() */
+	/* crc enable */
+	regmap_raw_read(ts->regmap, ts->mmap[MMAP_BLD_CRC_EN_ADDR], val, 1);
+
+	val[0] |= 1 << 7;
+	regmap_raw_write(ts->regmap, ts->mmap[MMAP_BLD_CRC_EN_ADDR], val, 1);
+
+	/* enable fw crc */
+	val[0] = 0;
+	regmap_raw_write(ts->regmap, ts->mmap[MMAP_EVENT_BUF_ADDR] | NT36XXX_EVT_RESET_COMPLETE, val, 1);
+
+	val[0] = 0xae;
+	regmap_raw_write(ts->regmap, ts->mmap[MMAP_EVENT_BUF_ADDR] | NT36XXX_EVT_HOST_CMD, val, 1);
+
+	/* nvt_boot_ready() */
+	/* Set Boot Ready Bit */
+	val[0] = 0x1;
+	regmap_raw_write(ts->regmap, ts->mmap[MMAP_BOOT_RDY_ADDR], val, 1);
+
+	/* old logic 5ms, retention to 10ms */
+	usleep_range(10000, 11000);
+
+	/* nvt_check_fw_reset_state() */
+	ret = nt36xxx_check_reset_state(ts, NT36XXX_STATE_INIT);
+	if (ret)
+		goto release_fw_buf;
+
+check_fw:
+	/* nvt_get_fw_info() */
+	ret = regmap_raw_read(ts->regmap, ts->mmap[MMAP_EVENT_BUF_ADDR] | NT36XXX_EVT_FWINFO, val, 16);
+	if (ret)
+		goto release_fw_buf;
+
+	dev_dbg(ts->dev, "Get default fw_ver=%d, max_x=%d, max_y=%d\n",
+				val[2], ts->prop.max_x, ts->prop.max_y);
+
+	if (val[0] != 0xff && retry < 5) {
+		dev_err(ts->dev, "FW info is broken! fw_ver=0x%02X, ~fw_ver=0x%02X\n", val[1], val[2]);
+		retry++;
+		goto check_fw;
+	}
+
+	dev_info(ts->dev, "Touch IC fw loaded ok");
+
+	ts->status |= NT36XXX_STATUS_DOWNLOAD_COMPLETE;
+	goto exit;
+
+release_fw_buf:
+	kfree(ts->bin_map);
+	ts->bin_map = NULL;
+release_fw:
+	kfree(ts->fw_entry.data);
+	ts->fw_entry.data = NULL;
+	ts->fw_entry.size = 0;
+exit:
+	return;
+}
+
+/*yell*/
+static void nt36xxx_download_firmware(struct work_struct *work) {
+	struct nt36xxx_ts *ts = container_of(work, struct nt36xxx_ts, work.work);
+	int ret;
+
+	/* Disable power management runtime for the device */
+	pm_runtime_disable(ts->dev);
+
+	/* Disable the touch screen IRQ to prevent further interrupts */
+	disable_irq_nosync(ts->irq);
+
+	/* Cancel any pending delayed work */
+	cancel_delayed_work(&ts->work);
+
+	/* Check and configure the touch screen chip after disabling interrupts */
+	ret = nt36xxx_eng_reset_idle(ts);
+	if (ret) {
+		dev_err(ts->dev, "Failed to check chip version\n");
+		goto skip;
+	}
+
+	/* Set memory maps for the specific chip version */
+	ret = nt36xxx_chip_version_init(ts);
+	if (ret) {
+		dev_err(ts->dev, "Failed to check chip version\n");
+		goto skip;
+	}
+
+	/* Download firmware using the internal function */
+	_nt36xxx_boot_download_firmware(ts);
+
+skip:
+	/* Enable touch screen IRQ and power management runtime */
+	enable_irq(ts->irq);
+	pm_runtime_enable(ts->dev);
+
+	/* If the download is not complete, reschedule the delayed work after 4000ms */
+	if (!(ts->status & NT36XXX_STATUS_DOWNLOAD_COMPLETE)) {
+		cancel_delayed_work(&ts->work);
+		schedule_delayed_work(&ts->work, 4000);
+	}
+}
+
+static void nt36xxx_disable_regulators(void *data)
+{
+	struct nt36xxx_ts *ts = data;
+
+	regulator_bulk_disable(NT36XXX_NUM_SUPPLIES, ts->supplies);
+}
+
+static int nt36xxx_input_dev_config(struct nt36xxx_ts *ts, const struct input_id *id)
+{
+	struct device *dev = ts->dev;
+	int ret;
+
+	/* Allocate memory for the input device structure */
+	ts->input = devm_input_allocate_device(dev);
+	if (!ts->input)
+		return -ENOMEM;
+
+	/* Set the device-specific data to the allocated input device structure */
+	input_set_drvdata(ts->input, ts);
+
+	/* Set physical path for the input device */
+	ts->input->phys = devm_kasprintf(dev, GFP_KERNEL,
+				     "%s/input0", dev_name(dev));
+	if (!ts->input->phys)
+		return -ENOMEM;
+
+	/* Set input device properties */
+	ts->input->name = "Novatek NT36XXX Touchscreen";
+	ts->input->dev.parent = dev;
+	ts->input->id = *id;
+
+	/* Set absolute parameters for touch events */
+	input_set_abs_params(ts->input, ABS_MT_PRESSURE, 0,
+						 TOUCH_MAX_PRESSURE, 0, 0);
+	input_set_abs_params(ts->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+
+	/* Set absolute parameters for touch position */
+	input_set_abs_params(ts->input, ABS_MT_POSITION_X, 0,
+						 ts->data->abs_x_max - 1, 0, 0);
+	input_set_abs_params(ts->input, ABS_MT_POSITION_Y, 0,
+						 ts->data->abs_y_max - 1, 0, 0);
+
+	/* Parse touchscreen properties */
+	touchscreen_parse_properties(ts->input, true, &ts->prop);
+
+	/* Check if the maximum x-coordinate is valid */
+	WARN_ON(ts->prop.max_x < 1);
+
+	/* Initialize multitouch slots for the input device */
+	ret = input_mt_init_slots(ts->input, TOUCH_MAX_FINGER_NUM,
+				  INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);
+	if (ret) {
+		dev_err(dev, "Cannot init MT slots (%d)\n", ret);
+		return ret;
+	}
+
+	/* Register the input device */
+	ret = input_register_device(ts->input);
+	if (ret) {
+		dev_err(dev, "Failed to register input device: %d\n",
+			ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int nt36xxx_probe(struct device *dev, int irq, const struct input_id *id,
+			struct regmap *regmap)
+{
+	const struct nt36xxx_chip_data *chip_data;
+	int ret;
+
+	/* Allocate memory for the touchscreen data structure */
+	struct nt36xxx_ts *ts = devm_kzalloc(dev, sizeof(struct nt36xxx_ts), GFP_KERNEL);
+	if (!ts)
+		return -ENOMEM;
+
+	/* Set the device-specific data to the allocated structure */
+	dev_set_drvdata(dev, ts);
+
+	/* Retrieve chip-specific data from the device tree */
+	chip_data = of_device_get_match_data(dev);
+	if(!chip_data)
+		return -EINVAL;
+
+	/* Initialize the touchscreen structure with relevant data */
+	ts->dev = dev;
+	ts->regmap = regmap;
+	ts->irq = irq;
+
+	ts->data = chip_data;
+	memcpy(ts->mmap_data, chip_data->mmap, sizeof(ts->mmap_data));
+	ts->mmap = ts->mmap_data;
+
+	/* Allocate memory for GPIO supplies */
+	ts->supplies = devm_kcalloc(dev, NT36XXX_NUM_SUPPLIES,
+				    sizeof(*ts->supplies), GFP_KERNEL);
+	if (!ts->supplies)
+		return -ENOMEM;
+
+	/* Get and configure the optional reset GPIO */
+	ts->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ts->reset_gpio))
+		return PTR_ERR(ts->reset_gpio);
+
+	gpiod_set_consumer_name(ts->reset_gpio, "nt36xxx reset");
+
+	/* Get and configure the optional IRQ GPIO */
+	ts->irq_gpio = devm_gpiod_get_optional(dev, "irq", GPIOD_IN);
+	if (IS_ERR(ts->irq_gpio))
+		return PTR_ERR(ts->irq_gpio);
+
+	/* If IRQ is not specified, try to obtain it from the IRQ GPIO */
+	if (irq <= 0) {
+		ts->irq = gpiod_to_irq(ts->irq_gpio);
+		if (ts->irq <=0) {
+			dev_err(dev, "either need irq or irq-gpio specified in devicetree node!\n");
+			return -EINVAL;
+		}
+
+		dev_dbg(ts->dev, "Interrupts GPIO: %#x\n", ts->irq);
+	}
+
+	gpiod_set_consumer_name(ts->irq_gpio, "nt36xxx irq");
+
+	/* If the device follows a DRM panel, skip regulator initialization */
+	if (drm_is_panel_follower(dev))
+		goto skip_regulators;
+
+	/* These supplies are optional, also shared with LCD panel */
+	ts->supplies[0].supply = "vdd";
+	ts->supplies[1].supply = "vio";
+	ret = devm_regulator_bulk_get(dev,
+				      NT36XXX_NUM_SUPPLIES,
+				      ts->supplies);
+	if (ret)
+		return dev_err_probe(dev, ret,
+				     "Cannot get supplies: %d\n", ret);
+
+	ret = regulator_bulk_enable(NT36XXX_NUM_SUPPLIES, ts->supplies);
+	if (ret)
+		return ret;
+
+	/* Delay for regulators to stabilize */
+	usleep_range(10000, 11000);
+
+	ret = devm_add_action_or_reset(dev, nt36xxx_disable_regulators, ts);
+	if (ret)
+		return ret;
+
+skip_regulators:
+	/* Initialize mutex for synchronization */
+	mutex_init(&ts->lock);
+
+	/* Check and configure the touch screen chip */
+	ret = nt36xxx_eng_reset_idle(ts);
+	if (ret) {
+		dev_err(dev, "Failed to check chip version\n");
+		return ret;
+	}
+
+	/* Set memory maps for the specific chip version */
+	ret = nt36xxx_chip_version_init(ts);
+	if (ret) {
+		dev_err(dev, "Failed to check chip version\n");
+		return ret;
+	}
+
+	/* Parse the firmware path from the device tree */
+	ret = of_property_read_string(dev->of_node, "firmware-name", &ts->firmware_path);
+	if (ret) {
+		dev_err(dev, "Failed to read firmware-name property\n");
+		return ret;
+	}
+
+	/* opy the const mmap into drvdata */
+	memcpy(ts->mmap_data, ts->data->mmap, sizeof(ts->mmap_data));
+	ts->mmap = ts->mmap_data;
+
+	ret = nt36xxx_input_dev_config(ts, ts->data->id);
+	if (ret) {
+			dev_err(dev, "failed set input device: %d\n", ret);
+			return ret;
+	}
+
+	/* Request threaded IRQ for touch screen interrupts */
+	ret = devm_request_threaded_irq(dev, ts->irq, NULL, nt36xxx_irq_handler,
+			 IRQ_TYPE_EDGE_RISING | IRQF_ONESHOT, dev_name(dev), ts);
+	if (ret) {
+			dev_err(dev, "request irq failed: %d\n", ret);
+			return ret;
+	}
+
+	/* Set up delayed work for firmware download */
+	devm_delayed_work_autocancel(dev, &ts->work, nt36xxx_download_firmware);
+
+	/* Schedule the delayed work */
+	schedule_delayed_work(&ts->work, 0);
+
+	/* If the device follows a DRM panel, configure panel follower */
+	if (drm_is_panel_follower(dev)) {
+		ts->panel_follower.funcs = &nt36xxx_panel_follower_funcs;
+		devm_drm_panel_add_follower(dev, &ts->panel_follower);
+	}
+
+	dev_info(dev, "Novatek touchscreen initialized\n");
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(nt36xxx_probe);
+
+static int __maybe_unused nt36xxx_internal_pm_suspend(struct device *dev)
+{
+	struct nt36xxx_ts *ts = dev_get_drvdata(dev);
+	int ret = 0;
+
+	ts->status |= NT36XXX_STATUS_SUSPEND;
+
+	cancel_delayed_work_sync(&ts->work);
+
+	if (ts->mmap[MMAP_EVENT_BUF_ADDR]) {
+		ret = regmap_write(ts->regmap, ts->mmap[MMAP_EVENT_BUF_ADDR], NT36XXX_CMD_ENTER_SLEEP);
+	}
+
+	if (ret)
+		dev_err(ts->dev, "Cannot enter suspend!\n");
+	return 0;
+}
+
+static int __maybe_unused nt36xxx_pm_suspend(struct device *dev)
+{
+	struct nt36xxx_ts *ts = dev_get_drvdata(dev);
+	int ret=0;
+
+	if (drm_is_panel_follower(dev))
+		return 0;
+
+	disable_irq_nosync(ts->irq);
+
+	ret = nt36xxx_internal_pm_suspend(dev);
+	return ret;
+}
+
+static int __maybe_unused nt36xxx_internal_pm_resume(struct device *dev)
+{
+	struct nt36xxx_ts *ts = dev_get_drvdata(dev);
+
+	/* some how reduced some kind of cpu, but remove checking should no harm */
+	if(ts->status & NT36XXX_STATUS_SUSPEND)
+		schedule_delayed_work(&ts->work, 0);
+
+	ts->status &= ~NT36XXX_STATUS_SUSPEND;
+
+	return 0;
+}
+
+static int __maybe_unused nt36xxx_pm_resume(struct device *dev)
+{
+	struct nt36xxx_ts *ts = dev_get_drvdata(dev);
+	int ret=0;
+
+	if (drm_is_panel_follower(dev))
+		return 0;
+
+	enable_irq(ts->irq);
+
+	ret = nt36xxx_internal_pm_resume(dev);
+	return ret;
+}
+
+EXPORT_GPL_SIMPLE_DEV_PM_OPS(nt36xxx_pm_ops,
+			     nt36xxx_pm_suspend,
+			     nt36xxx_pm_resume);
+
+static int panel_prepared(struct drm_panel_follower *follower)
+{
+	struct nt36xxx_ts *ts = container_of(follower, struct nt36xxx_ts, panel_follower);
+
+	if (ts->status & NT36XXX_STATUS_SUSPEND)
+		enable_irq(ts->irq);
+
+	/* supposed to clear the flag, but leave to internal_pm_resume
+	for greater purpose */
+	/* ts->status &= ~NT36XXX_STATUS_SUSPEND; */
+
+	return nt36xxx_internal_pm_resume(ts->dev);
+}
+
+static int panel_unpreparing(struct drm_panel_follower *follower)
+{
+	struct nt36xxx_ts *ts = container_of(follower, struct nt36xxx_ts, panel_follower);
+
+	ts->status |= NT36XXX_STATUS_SUSPEND;
+
+	disable_irq(ts->irq);
+
+	return nt36xxx_internal_pm_suspend(ts->dev);
+}
+
+static struct drm_panel_follower_funcs nt36xxx_panel_follower_funcs = {
+	.panel_prepared = panel_prepared,
+	.panel_unpreparing = panel_unpreparing,
+};
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("NT36XXX Touchscreen driver");
+MODULE_AUTHOR("AngeloGioacchino Del Regno <kholk11@gmail.com>");
+MODULE_AUTHOR("99degree <www.github.com/99degree>");
diff --git a/drivers/input/touchscreen/nt36xxx_spi.c b/drivers/input/touchscreen/nt36xxx_spi.c
new file mode 100644
index 00000000000000..b26a57f6b32d4c
--- /dev/null
+++ b/drivers/input/touchscreen/nt36xxx_spi.c
@@ -0,0 +1,204 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * NT36XXX SPI Touchscreen Driver
+ *
+ * Copyright (C) 2020 - 2021 Goodix, Inc.
+ * Copyright (C) 2023 Linaro Ltd.
+ * Copyright (C) 2023 99degree <www.github.com/99degree>
+ *
+ * Based on goodix_ts_berlin driver.
+ */
+#include <asm/unaligned.h>
+#include <linux/input/touchscreen.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+
+#include "nt36xxx.h"
+
+#define SPI_READ_PREFIX_LEN	1
+#define SPI_WRITE_PREFIX_LEN	1
+
+#define DEBUG 0
+
+/*
+ * there are two kinds of spi read/write:
+ * 	(a)spi_read()/spi_write()/spi_write_then_read(),
+ * 	(b)and the spi_sync itself.
+ *
+ * we have to choose one and stick together, cross-use otherwise caused problem.
+ * the addressing mode is | 0xff 0xXX 0xYY | 0xZ1 ... data1...| 0xZ2 ...data2... | ...
+ * 	0xXX is bit[23..16]
+ * 	0xYY is bit[15..7]
+ * above describe a 'page select' ops
+ * 	0xZ1 is bit[7..0], addr for read ops
+ *	0xZ2 is bit[7..0] | 0x80, addr for write ops
+ * there is no restriction on the read write order.
+*/
+static int nt36xxx_spi_write(void *dev, const void *data,
+                                   size_t len)
+{
+	struct spi_device *spi = to_spi_device((struct device *)dev);
+	int32_t ret;
+
+	u8 addr[4] = { 0xff, *(u32 *)data >> 15, *(u32 *)data >> 7,  (*(u32 *)data & 0x7f) | 0x80};
+
+	memcpy((void *)data, addr, 4);
+
+	dev_dbg(dev, "%s len=0x%lx", __func__, len);
+
+	spi_write(spi, data, 3);
+	ret = spi_write(spi, (u8 *)data + 3, len - 3);
+	if (ret)
+		dev_err(dev, "transfer err %d\n ", ret);
+	else if (DEBUG) {
+
+		print_hex_dump(KERN_INFO, __func__, DUMP_PREFIX_OFFSET,
+			16, 1, data, 3, true);
+
+		print_hex_dump(KERN_INFO, __func__, DUMP_PREFIX_OFFSET,
+			16, 1, data + 3, (len - 3) > 0x20 ? 0x20 : len - 3 , true);
+	}
+
+	return ret;
+}
+
+static int nt36xxx_spi_read(void *dev, const void *reg_buf,
+                                  size_t reg_size, void *val_buf,
+                                  size_t val_size)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	int ret;
+	u8 addr[4] = { 0xff, *(u32 *)reg_buf >> 15, *(u32 *)reg_buf >> 7,  *(u32 *)reg_buf & 0x7f };
+
+	ret = spi_write(spi, addr, 3);
+	if (ret) {
+		dev_err(dev, "transfer0 err %s %d ret=%d", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	ret = spi_write_then_read(spi, &addr[3] , 1, val_buf, val_size);
+	if (ret) {
+		dev_err(dev, "transfer1 err %s %d ret=%d", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	if (DEBUG) {
+		print_hex_dump(KERN_INFO, __func__, DUMP_PREFIX_OFFSET,
+			16, 1, addr, 3, true);
+
+		print_hex_dump(KERN_INFO, __func__, DUMP_PREFIX_OFFSET,
+			16, 1, addr, (val_size) > 0x20 ? 0x20 : val_size % 0x20 , true);
+
+		print_hex_dump(KERN_INFO, __func__, DUMP_PREFIX_OFFSET,
+			16, 1, val_buf, (val_size > 0x20) ? 0x20 : val_size % 0x20 , true);
+	}
+
+	return ret;
+}
+
+const struct regmap_config nt36xxx_regmap_config_32bit = {
+	.name = "nt36xxx_hw",
+	.reg_bits = 32,
+	.val_bits = 8,
+	.read = nt36xxx_spi_read,
+	.write = nt36xxx_spi_write,
+
+	.max_raw_read = NT36XXX_TRANSFER_LEN + 8,
+	.max_raw_write = NT36XXX_TRANSFER_LEN + 8,
+
+	.zero_flag_mask = true, /* this is needed to make sure addr is not write_masked */
+	.cache_type = REGCACHE_NONE,
+};
+
+static const struct input_id nt36xxx_spi_input_id = {
+	.bustype = BUS_SPI,
+};
+
+static int nt36xxx_spi_probe(struct spi_device *spi)
+{
+	struct regmap_config *regmap_config;
+	struct regmap *regmap;
+	size_t max_size;
+	int ret = 0;
+
+	/* Debug log indicating entry into the probe function */
+	dev_dbg(&spi->dev, "%s %d", __func__, __LINE__);
+
+	/* Allocate and copy the default regmap configuration */
+	regmap_config = devm_kmemdup(&spi->dev, &nt36xxx_regmap_config_32bit,
+				     sizeof(*regmap_config), GFP_KERNEL);
+	if (!regmap_config) {
+		dev_err(&spi->dev, "memdup regmap_config fail\n");
+		return -ENOMEM;
+	}
+
+	/* Set SPI mode and bits per word, and perform SPI setup */
+	spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	ret = spi_setup(spi);
+	if (ret) {
+		dev_err(&spi->dev, "SPI setup error %d\n", ret);
+		return ret;
+	}
+
+	/* Ensure SPI CLK frequency does not exceed the maximum specified frequency */
+	if (spi->max_speed_hz > MAX_SPI_FREQ_HZ) {
+		dev_err(&spi->dev, "SPI CLK %d Hz?\n", spi->max_speed_hz);
+		return -EINVAL;
+	}
+
+	/* Calculate the maximum raw read and write sizes based on SPI transfer size */
+	max_size = spi_max_transfer_size(spi);
+	regmap_config->max_raw_read = max_size - SPI_READ_PREFIX_LEN;
+	regmap_config->max_raw_write = max_size - SPI_WRITE_PREFIX_LEN;
+
+	/* Initialize the regmap using the provided configuration */
+	regmap = devm_regmap_init(&spi->dev, NULL, spi, regmap_config);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	/* Call the main probe function for nt36xxx devices */
+	return nt36xxx_probe(&spi->dev, spi->irq,
+				   &nt36xxx_spi_input_id, regmap);
+}
+
+const struct nt36xxx_chip_data novatek_nt36xxx = {
+	.config = &nt36xxx_regmap_config_32bit,
+	.mmap = nt36675_memory_maps,
+	.abs_x_max = 1080,
+	.abs_y_max = 2400,
+	.id = &nt36xxx_spi_input_id,
+};
+
+static const struct spi_device_id nt36xxx_spi_ids[] = {
+	{ "nt36xxx-spi", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, nt36xxx_spi_ids);
+
+static const struct of_device_id nt36xxx_spi_of_match[] = {
+	{ .compatible = "novatek,nt36xxx-spi", .data = &novatek_nt36xxx, },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, nt36xxx_spi_of_match);
+
+static struct spi_driver nt36xxx_spi_driver = {
+	.driver = {
+		.name   = "nt36xxx-spi",
+		.of_match_table = nt36xxx_spi_of_match,
+		.pm = pm_sleep_ptr(&nt36xxx_pm_ops),
+	},
+	.probe = nt36xxx_spi_probe,
+	.id_table = nt36xxx_spi_ids,
+};
+module_spi_driver(nt36xxx_spi_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("NT36XXX SPI Touchscreen driver");
+MODULE_AUTHOR("Neil Armstrong <neil.armstrong@linaro.org>");
+MODULE_AUTHOR("99degree <www.github.com/99degree>");
diff --git a/drivers/media/i2c/ov8856.c b/drivers/media/i2c/ov8856.c
index 6ffe10e57b5b14..e8458cb4bb5d01 100644
--- a/drivers/media/i2c/ov8856.c
+++ b/drivers/media/i2c/ov8856.c
@@ -2174,9 +2174,10 @@ static int ov8856_get_format(struct v4l2_subdev *sd,
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
 		fmt->format = *v4l2_subdev_state_get_format(sd_state,
 							    fmt->pad);
-	else
+	else {
+		fmt->format.code = ov8856_mbus_codes[ov8856->cur_mbus_index];
 		ov8856_update_pad_format(ov8856, ov8856->cur_mode, &fmt->format);
-
+	}
 	mutex_unlock(&ov8856->mutex);
 
 	return 0;
diff --git a/drivers/media/platform/qcom/camss/Makefile b/drivers/media/platform/qcom/camss/Makefile
index 0d4389ab312d1e..e636968a1126cd 100644
--- a/drivers/media/platform/qcom/camss/Makefile
+++ b/drivers/media/platform/qcom/camss/Makefile
@@ -19,5 +19,6 @@ qcom-camss-objs += \
 		camss-vfe-gen1.o \
 		camss-vfe.o \
 		camss-video.o \
+		camss-format.o \
 
 obj-$(CONFIG_VIDEO_QCOM_CAMSS) += qcom-camss.o
diff --git a/drivers/media/platform/qcom/camss/camss-csid-4-1.c b/drivers/media/platform/qcom/camss/camss-csid-4-1.c
index dd49a40e6a7047..c9586142050291 100644
--- a/drivers/media/platform/qcom/camss/camss-csid-4-1.c
+++ b/drivers/media/platform/qcom/camss/camss-csid-4-1.c
@@ -45,128 +45,6 @@
 #define CAMSS_CSID_TG_DT_n_CGG_1(n)	(0x0b0 + 0xc * (n))
 #define CAMSS_CSID_TG_DT_n_CGG_2(n)	(0x0b4 + 0xc * (n))
 
-static const struct csid_format csid_formats[] = {
-	{
-		MEDIA_BUS_FMT_UYVY8_1X16,
-		DATA_TYPE_YUV422_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		2,
-	},
-	{
-		MEDIA_BUS_FMT_VYUY8_1X16,
-		DATA_TYPE_YUV422_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		2,
-	},
-	{
-		MEDIA_BUS_FMT_YUYV8_1X16,
-		DATA_TYPE_YUV422_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		2,
-	},
-	{
-		MEDIA_BUS_FMT_YVYU8_1X16,
-		DATA_TYPE_YUV422_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		2,
-	},
-	{
-		MEDIA_BUS_FMT_SBGGR8_1X8,
-		DATA_TYPE_RAW_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGBRG8_1X8,
-		DATA_TYPE_RAW_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGRBG8_1X8,
-		DATA_TYPE_RAW_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SRGGB8_1X8,
-		DATA_TYPE_RAW_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SBGGR10_1X10,
-		DATA_TYPE_RAW_10BIT,
-		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
-		10,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGBRG10_1X10,
-		DATA_TYPE_RAW_10BIT,
-		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
-		10,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGRBG10_1X10,
-		DATA_TYPE_RAW_10BIT,
-		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
-		10,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SRGGB10_1X10,
-		DATA_TYPE_RAW_10BIT,
-		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
-		10,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SBGGR12_1X12,
-		DATA_TYPE_RAW_12BIT,
-		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
-		12,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGBRG12_1X12,
-		DATA_TYPE_RAW_12BIT,
-		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
-		12,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGRBG12_1X12,
-		DATA_TYPE_RAW_12BIT,
-		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
-		12,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SRGGB12_1X12,
-		DATA_TYPE_RAW_12BIT,
-		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
-		12,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_Y10_1X10,
-		DATA_TYPE_RAW_10BIT,
-		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
-		10,
-		1,
-	},
-};
-
 static void csid_configure_stream(struct csid_device *csid, u8 enable)
 {
 	struct csid_testgen_config *tg = &csid->testgen;
@@ -174,7 +52,7 @@ static void csid_configure_stream(struct csid_device *csid, u8 enable)
 
 	if (enable) {
 		struct v4l2_mbus_framefmt *input_format;
-		const struct csid_format *format;
+		const struct csid_format_info *format;
 		u8 vc = 0; /* Virtual Channel 0 */
 		u8 cid = vc * 4; /* id of Virtual Channel and Data Type set */
 		u8 dt_shift;
@@ -184,7 +62,8 @@ static void csid_configure_stream(struct csid_device *csid, u8 enable)
 			u32 num_lines, num_bytes_per_line;
 
 			input_format = &csid->fmt[MSM_CSID_PAD_SRC];
-			format = csid_get_fmt_entry(csid->formats, csid->nformats,
+			format = csid_get_fmt_entry(csid->res->formats->formats,
+						    csid->res->formats->nformats,
 						    input_format->code);
 			num_bytes_per_line = input_format->width * format->bpp * format->spp / 8;
 			num_lines = input_format->height;
@@ -211,7 +90,8 @@ static void csid_configure_stream(struct csid_device *csid, u8 enable)
 			struct csid_phy_config *phy = &csid->phy;
 
 			input_format = &csid->fmt[MSM_CSID_PAD_SINK];
-			format = csid_get_fmt_entry(csid->formats, csid->nformats,
+			format = csid_get_fmt_entry(csid->res->formats->formats,
+						    csid->res->formats->nformats,
 						    input_format->code);
 
 			val = phy->lane_cnt - 1;
@@ -311,8 +191,6 @@ static u32 csid_src_pad_code(struct csid_device *csid, u32 sink_code,
 
 static void csid_subdev_init(struct csid_device *csid)
 {
-	csid->formats = csid_formats;
-	csid->nformats = ARRAY_SIZE(csid_formats);
 	csid->testgen.modes = csid_testgen_modes;
 	csid->testgen.nmodes = CSID_PAYLOAD_MODE_NUM_SUPPORTED_GEN1;
 }
diff --git a/drivers/media/platform/qcom/camss/camss-csid-4-7.c b/drivers/media/platform/qcom/camss/camss-csid-4-7.c
index 6b26e036294e4c..08578a1436885b 100644
--- a/drivers/media/platform/qcom/camss/camss-csid-4-7.c
+++ b/drivers/media/platform/qcom/camss/camss-csid-4-7.c
@@ -44,156 +44,6 @@
 #define CAMSS_CSID_TG_DT_n_CGG_1(n)	(0x0b8 + 0xc * (n))
 #define CAMSS_CSID_TG_DT_n_CGG_2(n)	(0x0bc + 0xc * (n))
 
-static const struct csid_format csid_formats[] = {
-	{
-		MEDIA_BUS_FMT_UYVY8_1X16,
-		DATA_TYPE_YUV422_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		2,
-	},
-	{
-		MEDIA_BUS_FMT_VYUY8_1X16,
-		DATA_TYPE_YUV422_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		2,
-	},
-	{
-		MEDIA_BUS_FMT_YUYV8_1X16,
-		DATA_TYPE_YUV422_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		2,
-	},
-	{
-		MEDIA_BUS_FMT_YVYU8_1X16,
-		DATA_TYPE_YUV422_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		2,
-	},
-	{
-		MEDIA_BUS_FMT_SBGGR8_1X8,
-		DATA_TYPE_RAW_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGBRG8_1X8,
-		DATA_TYPE_RAW_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGRBG8_1X8,
-		DATA_TYPE_RAW_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SRGGB8_1X8,
-		DATA_TYPE_RAW_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SBGGR10_1X10,
-		DATA_TYPE_RAW_10BIT,
-		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
-		10,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGBRG10_1X10,
-		DATA_TYPE_RAW_10BIT,
-		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
-		10,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGRBG10_1X10,
-		DATA_TYPE_RAW_10BIT,
-		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
-		10,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SRGGB10_1X10,
-		DATA_TYPE_RAW_10BIT,
-		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
-		10,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SBGGR12_1X12,
-		DATA_TYPE_RAW_12BIT,
-		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
-		12,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGBRG12_1X12,
-		DATA_TYPE_RAW_12BIT,
-		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
-		12,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGRBG12_1X12,
-		DATA_TYPE_RAW_12BIT,
-		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
-		12,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SRGGB12_1X12,
-		DATA_TYPE_RAW_12BIT,
-		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
-		12,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SBGGR14_1X14,
-		DATA_TYPE_RAW_14BIT,
-		DECODE_FORMAT_UNCOMPRESSED_14_BIT,
-		14,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGBRG14_1X14,
-		DATA_TYPE_RAW_14BIT,
-		DECODE_FORMAT_UNCOMPRESSED_14_BIT,
-		14,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGRBG14_1X14,
-		DATA_TYPE_RAW_14BIT,
-		DECODE_FORMAT_UNCOMPRESSED_14_BIT,
-		14,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SRGGB14_1X14,
-		DATA_TYPE_RAW_14BIT,
-		DECODE_FORMAT_UNCOMPRESSED_14_BIT,
-		14,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_Y10_1X10,
-		DATA_TYPE_RAW_10BIT,
-		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
-		10,
-		1,
-	},
-};
-
 static void csid_configure_stream(struct csid_device *csid, u8 enable)
 {
 	struct csid_testgen_config *tg = &csid->testgen;
@@ -203,7 +53,7 @@ static void csid_configure_stream(struct csid_device *csid, u8 enable)
 
 	if (enable) {
 		struct v4l2_mbus_framefmt *input_format;
-		const struct csid_format *format;
+		const struct csid_format_info *format;
 		u8 vc = 0; /* Virtual Channel 0 */
 		u8 cid = vc * 4; /* id of Virtual Channel and Data Type set */
 		u8 dt_shift;
@@ -213,7 +63,8 @@ static void csid_configure_stream(struct csid_device *csid, u8 enable)
 			u32 num_bytes_per_line, num_lines;
 
 			input_format = &csid->fmt[MSM_CSID_PAD_SRC];
-			format = csid_get_fmt_entry(csid->formats, csid->nformats,
+			format = csid_get_fmt_entry(csid->res->formats->formats,
+						    csid->res->formats->nformats,
 						    input_format->code);
 			num_bytes_per_line = input_format->width * format->bpp * format->spp / 8;
 			num_lines = input_format->height;
@@ -240,7 +91,8 @@ static void csid_configure_stream(struct csid_device *csid, u8 enable)
 			struct csid_phy_config *phy = &csid->phy;
 
 			input_format = &csid->fmt[MSM_CSID_PAD_SINK];
-			format = csid_get_fmt_entry(csid->formats, csid->nformats,
+			format = csid_get_fmt_entry(csid->res->formats->formats,
+						    csid->res->formats->nformats,
 						    input_format->code);
 
 			val = phy->lane_cnt - 1;
@@ -387,8 +239,6 @@ static u32 csid_src_pad_code(struct csid_device *csid, u32 sink_code,
 
 static void csid_subdev_init(struct csid_device *csid)
 {
-	csid->formats = csid_formats;
-	csid->nformats = ARRAY_SIZE(csid_formats);
 	csid->testgen.modes = csid_testgen_modes;
 	csid->testgen.nmodes = CSID_PAYLOAD_MODE_NUM_SUPPORTED_GEN1;
 }
diff --git a/drivers/media/platform/qcom/camss/camss-csid-gen2.c b/drivers/media/platform/qcom/camss/camss-csid-gen2.c
index b11de4797ccaef..e1c757933e2733 100644
--- a/drivers/media/platform/qcom/camss/camss-csid-gen2.c
+++ b/drivers/media/platform/qcom/camss/camss-csid-gen2.c
@@ -176,306 +176,171 @@
 #define		TPG_COLOR_BOX_CFG_MODE		0
 #define		TPG_COLOR_BOX_PATTERN_SEL	2
 
-static const struct csid_format csid_formats[] = {
-	{
-		MEDIA_BUS_FMT_UYVY8_1X16,
-		DATA_TYPE_YUV422_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		2,
-	},
-	{
-		MEDIA_BUS_FMT_VYUY8_1X16,
-		DATA_TYPE_YUV422_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		2,
-	},
-	{
-		MEDIA_BUS_FMT_YUYV8_1X16,
-		DATA_TYPE_YUV422_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		2,
-	},
-	{
-		MEDIA_BUS_FMT_YVYU8_1X16,
-		DATA_TYPE_YUV422_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		2,
-	},
-	{
-		MEDIA_BUS_FMT_SBGGR8_1X8,
-		DATA_TYPE_RAW_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGBRG8_1X8,
-		DATA_TYPE_RAW_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGRBG8_1X8,
-		DATA_TYPE_RAW_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SRGGB8_1X8,
-		DATA_TYPE_RAW_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SBGGR10_1X10,
-		DATA_TYPE_RAW_10BIT,
-		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
-		10,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGBRG10_1X10,
-		DATA_TYPE_RAW_10BIT,
-		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
-		10,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGRBG10_1X10,
-		DATA_TYPE_RAW_10BIT,
-		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
-		10,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SRGGB10_1X10,
-		DATA_TYPE_RAW_10BIT,
-		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
-		10,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_Y8_1X8,
-		DATA_TYPE_RAW_8BIT,
-		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
-		8,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_Y10_1X10,
-		DATA_TYPE_RAW_10BIT,
-		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
-		10,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SBGGR12_1X12,
-		DATA_TYPE_RAW_12BIT,
-		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
-		12,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGBRG12_1X12,
-		DATA_TYPE_RAW_12BIT,
-		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
-		12,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGRBG12_1X12,
-		DATA_TYPE_RAW_12BIT,
-		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
-		12,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SRGGB12_1X12,
-		DATA_TYPE_RAW_12BIT,
-		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
-		12,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SBGGR14_1X14,
-		DATA_TYPE_RAW_14BIT,
-		DECODE_FORMAT_UNCOMPRESSED_14_BIT,
-		14,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGBRG14_1X14,
-		DATA_TYPE_RAW_14BIT,
-		DECODE_FORMAT_UNCOMPRESSED_14_BIT,
-		14,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SGRBG14_1X14,
-		DATA_TYPE_RAW_14BIT,
-		DECODE_FORMAT_UNCOMPRESSED_14_BIT,
-		14,
-		1,
-	},
-	{
-		MEDIA_BUS_FMT_SRGGB14_1X14,
-		DATA_TYPE_RAW_14BIT,
-		DECODE_FORMAT_UNCOMPRESSED_14_BIT,
-		14,
-		1,
-	},
-};
-
-static void __csid_configure_stream(struct csid_device *csid, u8 enable, u8 vc)
+static void __csid_configure_rx(struct csid_device *csid,
+				struct csid_phy_config *phy, int vc)
 {
-	struct csid_testgen_config *tg = &csid->testgen;
-	u32 val;
-	u32 phy_sel = 0;
 	u8 lane_cnt = csid->phy.lane_cnt;
-	/* Source pads matching RDI channels on hardware. Pad 1 -> RDI0, Pad 2 -> RDI1, etc. */
-	struct v4l2_mbus_framefmt *input_format = &csid->fmt[MSM_CSID_PAD_FIRST_SRC + vc];
-	const struct csid_format *format = csid_get_fmt_entry(csid->formats, csid->nformats,
-							      input_format->code);
+	int val;
 
 	if (!lane_cnt)
 		lane_cnt = 4;
 
-	if (!tg->enabled)
-		phy_sel = csid->phy.csiphy_id;
-
-	if (enable) {
-		/*
-		 * DT_ID is a two bit bitfield that is concatenated with
-		 * the four least significant bits of the five bit VC
-		 * bitfield to generate an internal CID value.
-		 *
-		 * CSID_RDI_CFG0(vc)
-		 * DT_ID : 28:27
-		 * VC    : 26:22
-		 * DT    : 21:16
-		 *
-		 * CID   : VC 3:0 << 2 | DT_ID 1:0
-		 */
-		u8 dt_id = vc & 0x03;
-
-		if (tg->enabled) {
-			/* configure one DT, infinite frames */
-			val = vc << TPG_VC_CFG0_VC_NUM;
-			val |= INTELEAVING_MODE_ONE_SHOT << TPG_VC_CFG0_LINE_INTERLEAVING_MODE;
-			val |= 0 << TPG_VC_CFG0_NUM_FRAMES;
-			writel_relaxed(val, csid->base + CSID_TPG_VC_CFG0);
-
-			val = 0x740 << TPG_VC_CFG1_H_BLANKING_COUNT;
-			val |= 0x3ff << TPG_VC_CFG1_V_BLANKING_COUNT;
-			writel_relaxed(val, csid->base + CSID_TPG_VC_CFG1);
-
-			writel_relaxed(0x12345678, csid->base + CSID_TPG_LFSR_SEED);
-
-			val = (input_format->height & 0x1fff) << TPG_DT_n_CFG_0_FRAME_HEIGHT;
-			val |= (input_format->width & 0x1fff) << TPG_DT_n_CFG_0_FRAME_WIDTH;
-			writel_relaxed(val, csid->base + CSID_TPG_DT_n_CFG_0(0));
-
-			val = format->data_type << TPG_DT_n_CFG_1_DATA_TYPE;
-			writel_relaxed(val, csid->base + CSID_TPG_DT_n_CFG_1(0));
-
-			val = (tg->mode - 1) << TPG_DT_n_CFG_2_PAYLOAD_MODE;
-			val |= 0xBE << TPG_DT_n_CFG_2_USER_SPECIFIED_PAYLOAD;
-			val |= format->decode_format << TPG_DT_n_CFG_2_ENCODE_FORMAT;
-			writel_relaxed(val, csid->base + CSID_TPG_DT_n_CFG_2(0));
-
-			writel_relaxed(0, csid->base + CSID_TPG_COLOR_BARS_CFG);
-
-			writel_relaxed(0, csid->base + CSID_TPG_COLOR_BOX_CFG);
-		}
+	val = (lane_cnt - 1) << CSI2_RX_CFG0_NUM_ACTIVE_LANES;
+	val |= phy->lane_assign << CSI2_RX_CFG0_DL0_INPUT_SEL;
+	val |= phy->csiphy_id << CSI2_RX_CFG0_PHY_NUM_SEL;
+	writel_relaxed(val, csid->base + CSID_CSI2_RX_CFG0);
 
-		val = 1 << RDI_CFG0_BYTE_CNTR_EN;
-		val |= 1 << RDI_CFG0_FORMAT_MEASURE_EN;
-		val |= 1 << RDI_CFG0_TIMESTAMP_EN;
-		/* note: for non-RDI path, this should be format->decode_format */
-		val |= DECODE_FORMAT_PAYLOAD_ONLY << RDI_CFG0_DECODE_FORMAT;
-		val |= format->data_type << RDI_CFG0_DATA_TYPE;
-		val |= vc << RDI_CFG0_VIRTUAL_CHANNEL;
-		val |= dt_id << RDI_CFG0_DT_ID;
-		writel_relaxed(val, csid->base + CSID_RDI_CFG0(vc));
+	val = 1 << CSI2_RX_CFG1_PACKET_ECC_CORRECTION_EN;
+	if (vc > 3)
+		val |= 1 << CSI2_RX_CFG1_VC_MODE;
+	val |= 1 << CSI2_RX_CFG1_MISR_EN;
+	writel_relaxed(val, csid->base + CSID_CSI2_RX_CFG1);
+}
 
-		/* CSID_TIMESTAMP_STB_POST_IRQ */
-		val = 2 << RDI_CFG1_TIMESTAMP_STB_SEL;
-		writel_relaxed(val, csid->base + CSID_RDI_CFG1(vc));
+static void __csid_ctrl_rdi(struct csid_device *csid, int enable, u8 rdi)
+{
+	int val;
 
-		val = 1;
-		writel_relaxed(val, csid->base + CSID_RDI_FRM_DROP_PERIOD(vc));
+	if (enable)
+		val = HALT_CMD_RESUME_AT_FRAME_BOUNDARY << RDI_CTRL_HALT_CMD;
+	else
+		val = HALT_CMD_HALT_AT_FRAME_BOUNDARY << RDI_CTRL_HALT_CMD;
+	writel_relaxed(val, csid->base + CSID_RDI_CTRL(rdi));
+}
 
-		val = 0;
-		writel_relaxed(val, csid->base + CSID_RDI_FRM_DROP_PATTERN(vc));
+static void __csid_configure_testgen(struct csid_device *csid, u8 enable, u8 vc)
+{
+	struct csid_testgen_config *tg = &csid->testgen;
+	struct v4l2_mbus_framefmt *input_format = &csid->fmt[MSM_CSID_PAD_FIRST_SRC + vc];
+	const struct csid_format_info *format = csid_get_fmt_entry(csid->res->formats->formats,
+								   csid->res->formats->nformats,
+								   input_format->code);
+	u8 lane_cnt = csid->phy.lane_cnt;
+	u32 val;
 
-		val = 1;
-		writel_relaxed(val, csid->base + CSID_RDI_IRQ_SUBSAMPLE_PERIOD(vc));
+	if (!lane_cnt)
+		lane_cnt = 4;
 
-		val = 0;
-		writel_relaxed(val, csid->base + CSID_RDI_IRQ_SUBSAMPLE_PATTERN(vc));
+	/* configure one DT, infinite frames */
+	val = vc << TPG_VC_CFG0_VC_NUM;
+	val |= INTELEAVING_MODE_ONE_SHOT << TPG_VC_CFG0_LINE_INTERLEAVING_MODE;
+	val |= 0 << TPG_VC_CFG0_NUM_FRAMES;
+	writel_relaxed(val, csid->base + CSID_TPG_VC_CFG0);
 
-		val = 1;
-		writel_relaxed(val, csid->base + CSID_RDI_RPP_PIX_DROP_PERIOD(vc));
+	val = 0x740 << TPG_VC_CFG1_H_BLANKING_COUNT;
+	val |= 0x3ff << TPG_VC_CFG1_V_BLANKING_COUNT;
+	writel_relaxed(val, csid->base + CSID_TPG_VC_CFG1);
 
-		val = 0;
-		writel_relaxed(val, csid->base + CSID_RDI_RPP_PIX_DROP_PATTERN(vc));
+	writel_relaxed(0x12345678, csid->base + CSID_TPG_LFSR_SEED);
 
-		val = 1;
-		writel_relaxed(val, csid->base + CSID_RDI_RPP_LINE_DROP_PERIOD(vc));
+	val = (input_format->height & 0x1fff) << TPG_DT_n_CFG_0_FRAME_HEIGHT;
+	val |= (input_format->width & 0x1fff) << TPG_DT_n_CFG_0_FRAME_WIDTH;
+	writel_relaxed(val, csid->base + CSID_TPG_DT_n_CFG_0(0));
 
-		val = 0;
-		writel_relaxed(val, csid->base + CSID_RDI_RPP_LINE_DROP_PATTERN(vc));
+	val = format->data_type << TPG_DT_n_CFG_1_DATA_TYPE;
+	writel_relaxed(val, csid->base + CSID_TPG_DT_n_CFG_1(0));
 
-		val = 0;
-		writel_relaxed(val, csid->base + CSID_RDI_CTRL(vc));
+	val = (tg->mode - 1) << TPG_DT_n_CFG_2_PAYLOAD_MODE;
+	val |= 0xBE << TPG_DT_n_CFG_2_USER_SPECIFIED_PAYLOAD;
+	val |= format->decode_format << TPG_DT_n_CFG_2_ENCODE_FORMAT;
+	writel_relaxed(val, csid->base + CSID_TPG_DT_n_CFG_2(0));
 
-		val = readl_relaxed(csid->base + CSID_RDI_CFG0(vc));
-		val |=  1 << RDI_CFG0_ENABLE;
-		writel_relaxed(val, csid->base + CSID_RDI_CFG0(vc));
-	}
+	writel_relaxed(0, csid->base + CSID_TPG_COLOR_BARS_CFG);
 
-	if (tg->enabled) {
-		val = enable << TPG_CTRL_TEST_EN;
-		val |= 1 << TPG_CTRL_FS_PKT_EN;
-		val |= 1 << TPG_CTRL_FE_PKT_EN;
-		val |= (lane_cnt - 1) << TPG_CTRL_NUM_ACTIVE_LANES;
-		val |= 0x64 << TPG_CTRL_CYCLES_BETWEEN_PKTS;
-		val |= 0xA << TPG_CTRL_NUM_TRAIL_BYTES;
-		writel_relaxed(val, csid->base + CSID_TPG_CTRL);
-	}
+	writel_relaxed(0, csid->base + CSID_TPG_COLOR_BOX_CFG);
 
-	val = (lane_cnt - 1) << CSI2_RX_CFG0_NUM_ACTIVE_LANES;
-	val |= csid->phy.lane_assign << CSI2_RX_CFG0_DL0_INPUT_SEL;
-	val |= phy_sel << CSI2_RX_CFG0_PHY_NUM_SEL;
-	writel_relaxed(val, csid->base + CSID_CSI2_RX_CFG0);
+	val = enable << TPG_CTRL_TEST_EN;
+	val |= 1 << TPG_CTRL_FS_PKT_EN;
+	val |= 1 << TPG_CTRL_FE_PKT_EN;
+	val |= (lane_cnt - 1) << TPG_CTRL_NUM_ACTIVE_LANES;
+	val |= 0x64 << TPG_CTRL_CYCLES_BETWEEN_PKTS;
+	val |= 0xA << TPG_CTRL_NUM_TRAIL_BYTES;
+	writel_relaxed(val, csid->base + CSID_TPG_CTRL);
+}
 
-	val = 1 << CSI2_RX_CFG1_PACKET_ECC_CORRECTION_EN;
-	if (vc > 3)
-		val |= 1 << CSI2_RX_CFG1_VC_MODE;
-	val |= 1 << CSI2_RX_CFG1_MISR_EN;
-	writel_relaxed(val, csid->base + CSID_CSI2_RX_CFG1);
+static void __csid_configure_rdi_stream(struct csid_device *csid, u8 enable, u8 vc)
+{
+	/* Source pads matching RDI channels on hardware. Pad 1 -> RDI0, Pad 2 -> RDI1, etc. */
+	struct v4l2_mbus_framefmt *input_format = &csid->fmt[MSM_CSID_PAD_FIRST_SRC + vc];
+	const struct csid_format_info *format = csid_get_fmt_entry(csid->res->formats->formats,
+								   csid->res->formats->nformats,
+								   input_format->code);
+	u32 val;
 
-	if (enable)
-		val = HALT_CMD_RESUME_AT_FRAME_BOUNDARY << RDI_CTRL_HALT_CMD;
-	else
-		val = HALT_CMD_HALT_AT_FRAME_BOUNDARY << RDI_CTRL_HALT_CMD;
+	/*
+	 * DT_ID is a two bit bitfield that is concatenated with
+	 * the four least significant bits of the five bit VC
+	 * bitfield to generate an internal CID value.
+	 *
+	 * CSID_RDI_CFG0(vc)
+	 * DT_ID : 28:27
+	 * VC    : 26:22
+	 * DT    : 21:16
+	 *
+	 * CID   : VC 3:0 << 2 | DT_ID 1:0
+	 */
+	u8 dt_id = vc & 0x03;
+
+	val = 1 << RDI_CFG0_BYTE_CNTR_EN;
+	val |= 1 << RDI_CFG0_FORMAT_MEASURE_EN;
+	val |= 1 << RDI_CFG0_TIMESTAMP_EN;
+	/* note: for non-RDI path, this should be format->decode_format */
+	val |= DECODE_FORMAT_PAYLOAD_ONLY << RDI_CFG0_DECODE_FORMAT;
+	val |= format->data_type << RDI_CFG0_DATA_TYPE;
+	val |= vc << RDI_CFG0_VIRTUAL_CHANNEL;
+	val |= dt_id << RDI_CFG0_DT_ID;
+	writel_relaxed(val, csid->base + CSID_RDI_CFG0(vc));
+
+	/* CSID_TIMESTAMP_STB_POST_IRQ */
+	val = 2 << RDI_CFG1_TIMESTAMP_STB_SEL;
+	writel_relaxed(val, csid->base + CSID_RDI_CFG1(vc));
+
+	val = 1;
+	writel_relaxed(val, csid->base + CSID_RDI_FRM_DROP_PERIOD(vc));
+
+	val = 0;
+	writel_relaxed(val, csid->base + CSID_RDI_FRM_DROP_PATTERN(vc));
+
+	val = 1;
+	writel_relaxed(val, csid->base + CSID_RDI_IRQ_SUBSAMPLE_PERIOD(vc));
+
+	val = 0;
+	writel_relaxed(val, csid->base + CSID_RDI_IRQ_SUBSAMPLE_PATTERN(vc));
+
+	val = 1;
+	writel_relaxed(val, csid->base + CSID_RDI_RPP_PIX_DROP_PERIOD(vc));
+
+	val = 0;
+	writel_relaxed(val, csid->base + CSID_RDI_RPP_PIX_DROP_PATTERN(vc));
+
+	val = 1;
+	writel_relaxed(val, csid->base + CSID_RDI_RPP_LINE_DROP_PERIOD(vc));
+
+	val = 0;
+	writel_relaxed(val, csid->base + CSID_RDI_RPP_LINE_DROP_PATTERN(vc));
+
+	val = 0;
 	writel_relaxed(val, csid->base + CSID_RDI_CTRL(vc));
+
+	val = readl_relaxed(csid->base + CSID_RDI_CFG0(vc));
+	val |=  enable << RDI_CFG0_ENABLE;
+	writel_relaxed(val, csid->base + CSID_RDI_CFG0(vc));
 }
 
 static void csid_configure_stream(struct csid_device *csid, u8 enable)
 {
+	struct csid_testgen_config *tg = &csid->testgen;
 	u8 i;
 	/* Loop through all enabled VCs and configure stream for each */
 	for (i = 0; i < MSM_CSID_MAX_SRC_STREAMS; i++)
-		if (csid->phy.en_vc & BIT(i))
-			__csid_configure_stream(csid, enable, i);
+		if (csid->phy.en_vc & BIT(i)) {
+			if (tg->enabled)
+				__csid_configure_testgen(csid, enable, i);
+
+			__csid_configure_rdi_stream(csid, enable, i);
+			__csid_configure_rx(csid, &csid->phy, i);
+			__csid_ctrl_rdi(csid, enable, i);
+		}
 }
 
 static int csid_configure_testgen_pattern(struct csid_device *csid, s32 val)
@@ -612,8 +477,6 @@ static u32 csid_src_pad_code(struct csid_device *csid, u32 sink_code,
 
 static void csid_subdev_init(struct csid_device *csid)
 {
-	csid->formats = csid_formats;
-	csid->nformats = ARRAY_SIZE(csid_formats);
 	csid->testgen.modes = csid_testgen_modes;
 	csid->testgen.nmodes = CSID_PAYLOAD_MODE_NUM_SUPPORTED_GEN2;
 }
diff --git a/drivers/media/platform/qcom/camss/camss-csid.c b/drivers/media/platform/qcom/camss/camss-csid.c
index eb27d69e89a161..858db5d4ca75c3 100644
--- a/drivers/media/platform/qcom/camss/camss-csid.c
+++ b/drivers/media/platform/qcom/camss/camss-csid.c
@@ -45,6 +45,450 @@ const char * const csid_testgen_modes[] = {
 	NULL
 };
 
+static const struct csid_format_info formats_4_1[] = {
+	{
+		MEDIA_BUS_FMT_UYVY8_1X16,
+		DATA_TYPE_YUV422_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		2,
+	},
+	{
+		MEDIA_BUS_FMT_VYUY8_1X16,
+		DATA_TYPE_YUV422_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		2,
+	},
+	{
+		MEDIA_BUS_FMT_YUYV8_1X16,
+		DATA_TYPE_YUV422_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		2,
+	},
+	{
+		MEDIA_BUS_FMT_YVYU8_1X16,
+		DATA_TYPE_YUV422_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		2,
+	},
+	{
+		MEDIA_BUS_FMT_SBGGR8_1X8,
+		DATA_TYPE_RAW_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGBRG8_1X8,
+		DATA_TYPE_RAW_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGRBG8_1X8,
+		DATA_TYPE_RAW_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SRGGB8_1X8,
+		DATA_TYPE_RAW_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SBGGR10_1X10,
+		DATA_TYPE_RAW_10BIT,
+		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
+		10,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGBRG10_1X10,
+		DATA_TYPE_RAW_10BIT,
+		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
+		10,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGRBG10_1X10,
+		DATA_TYPE_RAW_10BIT,
+		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
+		10,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SRGGB10_1X10,
+		DATA_TYPE_RAW_10BIT,
+		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
+		10,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SBGGR12_1X12,
+		DATA_TYPE_RAW_12BIT,
+		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
+		12,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGBRG12_1X12,
+		DATA_TYPE_RAW_12BIT,
+		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
+		12,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGRBG12_1X12,
+		DATA_TYPE_RAW_12BIT,
+		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
+		12,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SRGGB12_1X12,
+		DATA_TYPE_RAW_12BIT,
+		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
+		12,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_Y10_1X10,
+		DATA_TYPE_RAW_10BIT,
+		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
+		10,
+		1,
+	},
+};
+
+static const struct csid_format_info formats_4_7[] = {
+	{
+		MEDIA_BUS_FMT_UYVY8_1X16,
+		DATA_TYPE_YUV422_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		2,
+	},
+	{
+		MEDIA_BUS_FMT_VYUY8_1X16,
+		DATA_TYPE_YUV422_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		2,
+	},
+	{
+		MEDIA_BUS_FMT_YUYV8_1X16,
+		DATA_TYPE_YUV422_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		2,
+	},
+	{
+		MEDIA_BUS_FMT_YVYU8_1X16,
+		DATA_TYPE_YUV422_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		2,
+	},
+	{
+		MEDIA_BUS_FMT_SBGGR8_1X8,
+		DATA_TYPE_RAW_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGBRG8_1X8,
+		DATA_TYPE_RAW_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGRBG8_1X8,
+		DATA_TYPE_RAW_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SRGGB8_1X8,
+		DATA_TYPE_RAW_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SBGGR10_1X10,
+		DATA_TYPE_RAW_10BIT,
+		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
+		10,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGBRG10_1X10,
+		DATA_TYPE_RAW_10BIT,
+		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
+		10,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGRBG10_1X10,
+		DATA_TYPE_RAW_10BIT,
+		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
+		10,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SRGGB10_1X10,
+		DATA_TYPE_RAW_10BIT,
+		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
+		10,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SBGGR12_1X12,
+		DATA_TYPE_RAW_12BIT,
+		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
+		12,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGBRG12_1X12,
+		DATA_TYPE_RAW_12BIT,
+		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
+		12,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGRBG12_1X12,
+		DATA_TYPE_RAW_12BIT,
+		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
+		12,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SRGGB12_1X12,
+		DATA_TYPE_RAW_12BIT,
+		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
+		12,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SBGGR14_1X14,
+		DATA_TYPE_RAW_14BIT,
+		DECODE_FORMAT_UNCOMPRESSED_14_BIT,
+		14,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGBRG14_1X14,
+		DATA_TYPE_RAW_14BIT,
+		DECODE_FORMAT_UNCOMPRESSED_14_BIT,
+		14,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGRBG14_1X14,
+		DATA_TYPE_RAW_14BIT,
+		DECODE_FORMAT_UNCOMPRESSED_14_BIT,
+		14,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SRGGB14_1X14,
+		DATA_TYPE_RAW_14BIT,
+		DECODE_FORMAT_UNCOMPRESSED_14_BIT,
+		14,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_Y10_1X10,
+		DATA_TYPE_RAW_10BIT,
+		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
+		10,
+		1,
+	},
+};
+
+static const struct csid_format_info formats_gen2[] = {
+	{
+		MEDIA_BUS_FMT_UYVY8_1X16,
+		DATA_TYPE_YUV422_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		2,
+	},
+	{
+		MEDIA_BUS_FMT_VYUY8_1X16,
+		DATA_TYPE_YUV422_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		2,
+	},
+	{
+		MEDIA_BUS_FMT_YUYV8_1X16,
+		DATA_TYPE_YUV422_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		2,
+	},
+	{
+		MEDIA_BUS_FMT_YVYU8_1X16,
+		DATA_TYPE_YUV422_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		2,
+	},
+	{
+		MEDIA_BUS_FMT_SBGGR8_1X8,
+		DATA_TYPE_RAW_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGBRG8_1X8,
+		DATA_TYPE_RAW_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGRBG8_1X8,
+		DATA_TYPE_RAW_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SRGGB8_1X8,
+		DATA_TYPE_RAW_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SBGGR10_1X10,
+		DATA_TYPE_RAW_10BIT,
+		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
+		10,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGBRG10_1X10,
+		DATA_TYPE_RAW_10BIT,
+		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
+		10,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGRBG10_1X10,
+		DATA_TYPE_RAW_10BIT,
+		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
+		10,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SRGGB10_1X10,
+		DATA_TYPE_RAW_10BIT,
+		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
+		10,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_Y8_1X8,
+		DATA_TYPE_RAW_8BIT,
+		DECODE_FORMAT_UNCOMPRESSED_8_BIT,
+		8,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_Y10_1X10,
+		DATA_TYPE_RAW_10BIT,
+		DECODE_FORMAT_UNCOMPRESSED_10_BIT,
+		10,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SBGGR12_1X12,
+		DATA_TYPE_RAW_12BIT,
+		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
+		12,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGBRG12_1X12,
+		DATA_TYPE_RAW_12BIT,
+		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
+		12,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGRBG12_1X12,
+		DATA_TYPE_RAW_12BIT,
+		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
+		12,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SRGGB12_1X12,
+		DATA_TYPE_RAW_12BIT,
+		DECODE_FORMAT_UNCOMPRESSED_12_BIT,
+		12,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SBGGR14_1X14,
+		DATA_TYPE_RAW_14BIT,
+		DECODE_FORMAT_UNCOMPRESSED_14_BIT,
+		14,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGBRG14_1X14,
+		DATA_TYPE_RAW_14BIT,
+		DECODE_FORMAT_UNCOMPRESSED_14_BIT,
+		14,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SGRBG14_1X14,
+		DATA_TYPE_RAW_14BIT,
+		DECODE_FORMAT_UNCOMPRESSED_14_BIT,
+		14,
+		1,
+	},
+	{
+		MEDIA_BUS_FMT_SRGGB14_1X14,
+		DATA_TYPE_RAW_14BIT,
+		DECODE_FORMAT_UNCOMPRESSED_14_BIT,
+		14,
+		1,
+	},
+};
+
+const struct csid_formats csid_formats_4_1 = {
+	.nformats = ARRAY_SIZE(formats_4_1),
+	.formats = formats_4_1
+};
+
+const struct csid_formats csid_formats_4_7 = {
+	.nformats = ARRAY_SIZE(formats_4_7),
+	.formats = formats_4_7
+};
+
+const struct csid_formats csid_formats_gen2 = {
+	.nformats = ARRAY_SIZE(formats_gen2),
+	.formats = formats_gen2
+};
+
 u32 csid_find_code(u32 *codes, unsigned int ncodes,
 		   unsigned int match_format_idx, u32 match_code)
 {
@@ -65,9 +509,9 @@ u32 csid_find_code(u32 *codes, unsigned int ncodes,
 	return codes[0];
 }
 
-const struct csid_format *csid_get_fmt_entry(const struct csid_format *formats,
-					     unsigned int nformats,
-					     u32 code)
+const struct csid_format_info *csid_get_fmt_entry(const struct csid_format_info *formats,
+						  unsigned int nformats,
+						  u32 code)
 {
 	unsigned int i;
 
@@ -87,12 +531,12 @@ const struct csid_format *csid_get_fmt_entry(const struct csid_format *formats,
 static int csid_set_clock_rates(struct csid_device *csid)
 {
 	struct device *dev = csid->camss->dev;
-	const struct csid_format *fmt;
+	const struct csid_format_info *fmt;
 	s64 link_freq;
 	int i, j;
 	int ret;
 
-	fmt = csid_get_fmt_entry(csid->formats, csid->nformats,
+	fmt = csid_get_fmt_entry(csid->res->formats->formats, csid->res->formats->nformats,
 				 csid->fmt[MSM_CSIPHY_PAD_SINK].code);
 	link_freq = camss_get_link_freq(&csid->subdev.entity, fmt->bpp,
 					csid->phy.lane_cnt);
@@ -158,7 +602,6 @@ static int csid_set_power(struct v4l2_subdev *sd, int on)
 	struct csid_device *csid = v4l2_get_subdevdata(sd);
 	struct camss *camss = csid->camss;
 	struct device *dev = camss->dev;
-	struct vfe_device *vfe = &camss->vfe[csid->id];
 	int ret = 0;
 
 	if (on) {
@@ -167,7 +610,7 @@ static int csid_set_power(struct v4l2_subdev *sd, int on)
 		 * switching on the CSID. Do so unconditionally, as there is no
 		 * drawback in following the same powering order on older SoCs.
 		 */
-		ret = vfe_get(vfe);
+		ret = csid->res->parent_dev_ops->get(camss, csid->id);
 		if (ret < 0)
 			return ret;
 
@@ -202,7 +645,7 @@ static int csid_set_power(struct v4l2_subdev *sd, int on)
 
 		enable_irq(csid->irq);
 
-		ret = csid->ops->reset(csid);
+		ret = csid->res->hw_ops->reset(csid);
 		if (ret < 0) {
 			disable_irq(csid->irq);
 			camss_disable_clocks(csid->nclocks, csid->clock);
@@ -212,14 +655,14 @@ static int csid_set_power(struct v4l2_subdev *sd, int on)
 			return ret;
 		}
 
-		csid->ops->hw_version(csid);
+		csid->res->hw_ops->hw_version(csid);
 	} else {
 		disable_irq(csid->irq);
 		camss_disable_clocks(csid->nclocks, csid->clock);
 		regulator_bulk_disable(csid->num_supplies,
 				       csid->supplies);
 		pm_runtime_put_sync(dev);
-		vfe_put(vfe);
+		csid->res->parent_dev_ops->put(camss, csid->id);
 	}
 
 	return ret;
@@ -253,7 +696,7 @@ static int csid_set_stream(struct v4l2_subdev *sd, int enable)
 	}
 
 	if (csid->phy.need_vc_update) {
-		csid->ops->configure_stream(csid, enable);
+		csid->res->hw_ops->configure_stream(csid, enable);
 		csid->phy.need_vc_update = false;
 	}
 
@@ -301,12 +744,12 @@ static void csid_try_format(struct csid_device *csid,
 	case MSM_CSID_PAD_SINK:
 		/* Set format on sink pad */
 
-		for (i = 0; i < csid->nformats; i++)
-			if (fmt->code == csid->formats[i].code)
+		for (i = 0; i < csid->res->formats->nformats; i++)
+			if (fmt->code == csid->res->formats->formats[i].code)
 				break;
 
 		/* If not found, use UYVY as default */
-		if (i >= csid->nformats)
+		if (i >= csid->res->formats->nformats)
 			fmt->code = MEDIA_BUS_FMT_UYVY8_1X16;
 
 		fmt->width = clamp_t(u32, fmt->width, 1, 8191);
@@ -325,17 +768,17 @@ static void csid_try_format(struct csid_device *csid,
 
 			*fmt = *__csid_get_format(csid, sd_state,
 						      MSM_CSID_PAD_SINK, which);
-			fmt->code = csid->ops->src_pad_code(csid, fmt->code, 0, code);
+			fmt->code = csid->res->hw_ops->src_pad_code(csid, fmt->code, 0, code);
 		} else {
 			/* Test generator is enabled, set format on source */
 			/* pad to allow test generator usage */
 
-			for (i = 0; i < csid->nformats; i++)
-				if (csid->formats[i].code == fmt->code)
+			for (i = 0; i < csid->res->formats->nformats; i++)
+				if (csid->res->formats->formats[i].code == fmt->code)
 					break;
 
 			/* If not found, use UYVY as default */
-			if (i >= csid->nformats)
+			if (i >= csid->res->formats->nformats)
 				fmt->code = MEDIA_BUS_FMT_UYVY8_1X16;
 
 			fmt->width = clamp_t(u32, fmt->width, 1, 8191);
@@ -363,10 +806,10 @@ static int csid_enum_mbus_code(struct v4l2_subdev *sd,
 	struct csid_device *csid = v4l2_get_subdevdata(sd);
 
 	if (code->pad == MSM_CSID_PAD_SINK) {
-		if (code->index >= csid->nformats)
+		if (code->index >= csid->res->formats->nformats)
 			return -EINVAL;
 
-		code->code = csid->formats[code->index].code;
+		code->code = csid->res->formats->formats[code->index].code;
 	} else {
 		if (csid->testgen_mode->cur.val == 0) {
 			struct v4l2_mbus_framefmt *sink_fmt;
@@ -375,15 +818,15 @@ static int csid_enum_mbus_code(struct v4l2_subdev *sd,
 						     MSM_CSID_PAD_SINK,
 						     code->which);
 
-			code->code = csid->ops->src_pad_code(csid, sink_fmt->code,
-						       code->index, 0);
+			code->code = csid->res->hw_ops->src_pad_code(csid, sink_fmt->code,
+								     code->index, 0);
 			if (!code->code)
 				return -EINVAL;
 		} else {
-			if (code->index >= csid->nformats)
+			if (code->index >= csid->res->formats->nformats)
 				return -EINVAL;
 
-			code->code = csid->formats[code->index].code;
+			code->code = csid->res->formats->formats[code->index].code;
 		}
 	}
 
@@ -529,7 +972,7 @@ static int csid_set_test_pattern(struct csid_device *csid, s32 value)
 
 	tg->enabled = !!value;
 
-	return csid->ops->configure_testgen_pattern(csid, value);
+	return csid->res->hw_ops->configure_testgen_pattern(csid, value);
 }
 
 /*
@@ -575,9 +1018,14 @@ int msm_csid_subdev_init(struct camss *camss, struct csid_device *csid,
 
 	csid->camss = camss;
 	csid->id = id;
-	csid->ops = res->ops;
+	csid->res = &res->csid;
+
+	if (dev_WARN_ONCE(dev, !csid->res->parent_dev_ops,
+			  "Error: CSID depends on VFE/IFE device ops!\n")) {
+		return -EINVAL;
+	}
 
-	csid->ops->subdev_init(csid);
+	csid->res->hw_ops->subdev_init(csid);
 
 	/* Memory */
 
@@ -587,9 +1035,11 @@ int msm_csid_subdev_init(struct camss *camss, struct csid_device *csid,
 		 * VFE to be initialized before CSID
 		 */
 		if (id >= 2) /* VFE/CSID lite */
-			csid->base = camss->vfe[id].base + VFE_480_LITE_CSID_OFFSET;
+			csid->base = csid->res->parent_dev_ops->get_base_address(camss, id)
+				+ VFE_480_LITE_CSID_OFFSET;
 		else
-			csid->base = camss->vfe[id].base + VFE_480_CSID_OFFSET;
+			csid->base = csid->res->parent_dev_ops->get_base_address(camss, id)
+				 + VFE_480_CSID_OFFSET;
 	} else {
 		csid->base = devm_platform_ioremap_resource_byname(pdev, res->reg[0]);
 		if (IS_ERR(csid->base))
@@ -605,7 +1055,7 @@ int msm_csid_subdev_init(struct camss *camss, struct csid_device *csid,
 	csid->irq = ret;
 	snprintf(csid->irq_name, sizeof(csid->irq_name), "%s_%s%d",
 		 dev_name(dev), MSM_CSID_NAME, csid->id);
-	ret = devm_request_irq(dev, csid->irq, csid->ops->isr,
+	ret = devm_request_irq(dev, csid->irq, csid->res->hw_ops->isr,
 			       IRQF_TRIGGER_RISING | IRQF_NO_AUTOEN,
 			       csid->irq_name, csid);
 	if (ret < 0) {
@@ -899,5 +1349,5 @@ void msm_csid_unregister_entity(struct csid_device *csid)
 
 inline bool csid_is_lite(struct csid_device *csid)
 {
-	return csid->camss->res->csid_res[csid->id].is_lite;
+	return csid->camss->res->csid_res[csid->id].csid.is_lite;
 }
diff --git a/drivers/media/platform/qcom/camss/camss-csid.h b/drivers/media/platform/qcom/camss/camss-csid.h
index fddccb69da13a1..8cdae98e4dca6d 100644
--- a/drivers/media/platform/qcom/camss/camss-csid.h
+++ b/drivers/media/platform/qcom/camss/camss-csid.h
@@ -67,7 +67,7 @@ enum csid_testgen_mode {
 	CSID_PAYLOAD_MODE_NUM_SUPPORTED_GEN2 = 9, /* excluding disabled */
 };
 
-struct csid_format {
+struct csid_format_info {
 	u32 code;
 	u8 data_type;
 	u8 decode_format;
@@ -75,6 +75,11 @@ struct csid_format {
 	u8 spp; /* bus samples per pixel */
 };
 
+struct csid_formats {
+	unsigned int nformats;
+	const struct csid_format_info *formats;
+};
+
 struct csid_testgen_config {
 	enum csid_testgen_mode mode;
 	const char * const*modes;
@@ -149,6 +154,13 @@ struct csid_hw_ops {
 	void (*subdev_init)(struct csid_device *csid);
 };
 
+struct csid_subdev_resources {
+	bool is_lite;
+	const struct csid_hw_ops *hw_ops;
+	const struct parent_dev_ops *parent_dev_ops;
+	const struct csid_formats *formats;
+};
+
 struct csid_device {
 	struct camss *camss;
 	u8 id;
@@ -167,9 +179,7 @@ struct csid_device {
 	struct v4l2_mbus_framefmt fmt[MSM_CSID_PADS_NUM];
 	struct v4l2_ctrl_handler ctrls;
 	struct v4l2_ctrl *testgen_mode;
-	const struct csid_format *formats;
-	unsigned int nformats;
-	const struct csid_hw_ops *ops;
+	const struct csid_subdev_resources *res;
 };
 
 struct camss_subdev_resources;
@@ -188,16 +198,16 @@ u32 csid_find_code(u32 *codes, unsigned int ncode,
 		   unsigned int match_format_idx, u32 match_code);
 
 /*
- * csid_get_fmt_entry - Find csid_format entry with matching format code
- * @formats: Array of format csid_format entries
+ * csid_get_fmt_entry - Find csid_format_info entry with matching format code
+ * @formats: Array of format csid_format_info entries
  * @nformats: Length of @nformats array
  * @code: Desired format code
  *
  * Return formats[0] on failure to find code
  */
-const struct csid_format *csid_get_fmt_entry(const struct csid_format *formats,
-					     unsigned int nformats,
-					     u32 code);
+const struct csid_format_info *csid_get_fmt_entry(const struct csid_format_info *formats,
+						  unsigned int nformats,
+						  u32 code);
 
 int msm_csid_subdev_init(struct camss *camss, struct csid_device *csid,
 			 const struct camss_subdev_resources *res, u8 id);
@@ -211,6 +221,10 @@ void msm_csid_get_csid_id(struct media_entity *entity, u8 *id);
 
 extern const char * const csid_testgen_modes[];
 
+extern const struct csid_formats csid_formats_4_1;
+extern const struct csid_formats csid_formats_4_7;
+extern const struct csid_formats csid_formats_gen2;
+
 extern const struct csid_hw_ops csid_ops_4_1;
 extern const struct csid_hw_ops csid_ops_4_7;
 extern const struct csid_hw_ops csid_ops_gen2;
diff --git a/drivers/media/platform/qcom/camss/camss-csiphy-3ph-1-0.c b/drivers/media/platform/qcom/camss/camss-csiphy-3ph-1-0.c
index df7e93a5a4f6e2..6782f57565ebe9 100644
--- a/drivers/media/platform/qcom/camss/camss-csiphy-3ph-1-0.c
+++ b/drivers/media/platform/qcom/camss/camss-csiphy-3ph-1-0.c
@@ -348,6 +348,136 @@ csiphy_reg_t lane_regs_sm8250[5][20] = {
 	},
 };
 
+/* GEN2 1.2.2 2PH */
+static const struct
+csiphy_reg_t lane_regs_sc7180[5][23] = {
+	{
+		{0x0030, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0904, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0910, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0900, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0908, 0x06, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0904, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x002c, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0034, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0010, 0x50, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x001c, 0x0a, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0014, 0x60, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0028, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x003c, 0xb8, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0000, 0x91, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0004, 0x0c, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0020, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0008, 0x10, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
+		{0x0010, 0x52, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0038, 0xfe, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x005c, 0xc0, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0060, 0x0d, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0800, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
+	},
+	{
+		{0x0730, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c84, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c90, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c80, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c88, 0x06, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c84, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x072c, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0734, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0710, 0x50, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x071c, 0x0a, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0714, 0x60, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0728, 0x04, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x073c, 0xb8, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0700, 0x80, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0704, 0x0c, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0720, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0708, 0x04, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
+		{0x070c, 0xff, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0710, 0x52, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0738, 0x1f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0800, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
+		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
+	},
+	{
+		{0x0230, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0a04, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0a10, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0a00, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0a08, 0x06, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0a04, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x022c, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0234, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0210, 0x50, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x021c, 0x0a, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0214, 0x60, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0228, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x023c, 0xb8, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0200, 0x91, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0204, 0x0c, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0220, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0208, 0x04, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
+		{0x0210, 0x52, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0238, 0xfe, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x025c, 0xc0, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0260, 0x0d, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0800, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
+	},
+	{
+		{0x0430, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0b04, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0b10, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0b00, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0b08, 0x06, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0b04, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x042c, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0434, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0410, 0x50, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x041c, 0x0a, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0414, 0x60, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0428, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x043c, 0xb8, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0400, 0x91, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0404, 0x0c, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0420, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0408, 0x04, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
+		{0x0410, 0x52, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0438, 0xfe, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x045c, 0xc0, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0460, 0x0d, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0800, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
+	},
+	{
+		{0x0630, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c04, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c10, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c00, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c08, 0x06, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c04, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x062c, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0634, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0610, 0x50, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x061c, 0x0a, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0614, 0x60, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0628, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x063c, 0xb8, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0600, 0x91, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0604, 0x0c, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0620, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0608, 0x04, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
+		{0x0610, 0x52, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0638, 0xfe, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x065c, 0xc0, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0660, 0x0d, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0800, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
+	},
+};
+
 static void csiphy_hw_version_read(struct csiphy_device *csiphy,
 				   struct device *dev)
 {
@@ -509,6 +639,10 @@ static void csiphy_gen2_config_lanes(struct csiphy_device *csiphy,
 		r = &lane_regs_sdm845[0][0];
 		array_size = ARRAY_SIZE(lane_regs_sdm845[0]);
 		break;
+	case CAMSS_7180:
+		r = &lane_regs_sc7180[0][0];
+		array_size = ARRAY_SIZE(lane_regs_sc7180[0]);
+		break;
 	case CAMSS_8250:
 		r = &lane_regs_sm8250[0][0];
 		array_size = ARRAY_SIZE(lane_regs_sm8250[0]);
@@ -558,6 +692,7 @@ static bool csiphy_is_gen2(u32 version)
 
 	switch (version) {
 	case CAMSS_845:
+	case CAMSS_7180:
 	case CAMSS_8250:
 	case CAMSS_8280XP:
 		ret = true;
diff --git a/drivers/media/platform/qcom/camss/camss-csiphy.c b/drivers/media/platform/qcom/camss/camss-csiphy.c
index 45b3a8e5dea498..2f7361dfd4614c 100644
--- a/drivers/media/platform/qcom/camss/camss-csiphy.c
+++ b/drivers/media/platform/qcom/camss/camss-csiphy.c
@@ -24,12 +24,7 @@
 
 #define MSM_CSIPHY_NAME "msm_csiphy"
 
-struct csiphy_format {
-	u32 code;
-	u8 bpp;
-};
-
-static const struct csiphy_format csiphy_formats_8x16[] = {
+static const struct csiphy_format_info formats_8x16[] = {
 	{ MEDIA_BUS_FMT_UYVY8_1X16, 8 },
 	{ MEDIA_BUS_FMT_VYUY8_1X16, 8 },
 	{ MEDIA_BUS_FMT_YUYV8_1X16, 8 },
@@ -49,7 +44,7 @@ static const struct csiphy_format csiphy_formats_8x16[] = {
 	{ MEDIA_BUS_FMT_Y10_1X10, 10 },
 };
 
-static const struct csiphy_format csiphy_formats_8x96[] = {
+static const struct csiphy_format_info formats_8x96[] = {
 	{ MEDIA_BUS_FMT_UYVY8_1X16, 8 },
 	{ MEDIA_BUS_FMT_VYUY8_1X16, 8 },
 	{ MEDIA_BUS_FMT_YUYV8_1X16, 8 },
@@ -73,7 +68,7 @@ static const struct csiphy_format csiphy_formats_8x96[] = {
 	{ MEDIA_BUS_FMT_Y10_1X10, 10 },
 };
 
-static const struct csiphy_format csiphy_formats_sdm845[] = {
+static const struct csiphy_format_info formats_sdm845[] = {
 	{ MEDIA_BUS_FMT_UYVY8_1X16, 8 },
 	{ MEDIA_BUS_FMT_VYUY8_1X16, 8 },
 	{ MEDIA_BUS_FMT_YUYV8_1X16, 8 },
@@ -98,6 +93,21 @@ static const struct csiphy_format csiphy_formats_sdm845[] = {
 	{ MEDIA_BUS_FMT_Y10_1X10, 10 },
 };
 
+const struct csiphy_formats csiphy_formats_8x16 = {
+	.nformats = ARRAY_SIZE(formats_8x16),
+	.formats = formats_8x16
+};
+
+const struct csiphy_formats csiphy_formats_8x96 = {
+	.nformats = ARRAY_SIZE(formats_8x96),
+	.formats = formats_8x96
+};
+
+const struct csiphy_formats csiphy_formats_sdm845 = {
+	.nformats = ARRAY_SIZE(formats_sdm845),
+	.formats = formats_sdm845
+};
+
 /*
  * csiphy_get_bpp - map media bus format to bits per pixel
  * @formats: supported media bus formats array
@@ -106,7 +116,7 @@ static const struct csiphy_format csiphy_formats_sdm845[] = {
  *
  * Return number of bits per pixel
  */
-static u8 csiphy_get_bpp(const struct csiphy_format *formats,
+static u8 csiphy_get_bpp(const struct csiphy_format_info *formats,
 			 unsigned int nformats, u32 code)
 {
 	unsigned int i;
@@ -131,7 +141,7 @@ static int csiphy_set_clock_rates(struct csiphy_device *csiphy)
 	int i, j;
 	int ret;
 
-	u8 bpp = csiphy_get_bpp(csiphy->formats, csiphy->nformats,
+	u8 bpp = csiphy_get_bpp(csiphy->res->formats->formats, csiphy->res->formats->nformats,
 				csiphy->fmt[MSM_CSIPHY_PAD_SINK].code);
 	u8 num_lanes = csiphy->cfg.csi2->lane_cfg.num_data;
 
@@ -216,9 +226,9 @@ static int csiphy_set_power(struct v4l2_subdev *sd, int on)
 
 		enable_irq(csiphy->irq);
 
-		csiphy->ops->reset(csiphy);
+		csiphy->res->hw_ops->reset(csiphy);
 
-		csiphy->ops->hw_version_read(csiphy, dev);
+		csiphy->res->hw_ops->hw_version_read(csiphy, dev);
 	} else {
 		disable_irq(csiphy->irq);
 
@@ -243,8 +253,8 @@ static int csiphy_stream_on(struct csiphy_device *csiphy)
 {
 	struct csiphy_config *cfg = &csiphy->cfg;
 	s64 link_freq;
-	u8 lane_mask = csiphy->ops->get_lane_mask(&cfg->csi2->lane_cfg);
-	u8 bpp = csiphy_get_bpp(csiphy->formats, csiphy->nformats,
+	u8 lane_mask = csiphy->res->hw_ops->get_lane_mask(&cfg->csi2->lane_cfg);
+	u8 bpp = csiphy_get_bpp(csiphy->res->formats->formats, csiphy->res->formats->nformats,
 				csiphy->fmt[MSM_CSIPHY_PAD_SINK].code);
 	u8 num_lanes = csiphy->cfg.csi2->lane_cfg.num_data;
 	u8 val;
@@ -272,7 +282,7 @@ static int csiphy_stream_on(struct csiphy_device *csiphy)
 		wmb();
 	}
 
-	csiphy->ops->lanes_enable(csiphy, cfg, link_freq, lane_mask);
+	csiphy->res->hw_ops->lanes_enable(csiphy, cfg, link_freq, lane_mask);
 
 	return 0;
 }
@@ -285,7 +295,7 @@ static int csiphy_stream_on(struct csiphy_device *csiphy)
  */
 static void csiphy_stream_off(struct csiphy_device *csiphy)
 {
-	csiphy->ops->lanes_disable(csiphy, &csiphy->cfg);
+	csiphy->res->hw_ops->lanes_disable(csiphy, &csiphy->cfg);
 }
 
 
@@ -350,12 +360,12 @@ static void csiphy_try_format(struct csiphy_device *csiphy,
 	case MSM_CSIPHY_PAD_SINK:
 		/* Set format on sink pad */
 
-		for (i = 0; i < csiphy->nformats; i++)
-			if (fmt->code == csiphy->formats[i].code)
+		for (i = 0; i < csiphy->res->formats->nformats; i++)
+			if (fmt->code == csiphy->res->formats->formats[i].code)
 				break;
 
 		/* If not found, use UYVY as default */
-		if (i >= csiphy->nformats)
+		if (i >= csiphy->res->formats->nformats)
 			fmt->code = MEDIA_BUS_FMT_UYVY8_1X16;
 
 		fmt->width = clamp_t(u32, fmt->width, 1, 8191);
@@ -392,10 +402,10 @@ static int csiphy_enum_mbus_code(struct v4l2_subdev *sd,
 	struct v4l2_mbus_framefmt *format;
 
 	if (code->pad == MSM_CSIPHY_PAD_SINK) {
-		if (code->index >= csiphy->nformats)
+		if (code->index >= csiphy->res->formats->nformats)
 			return -EINVAL;
 
-		code->code = csiphy->formats[code->index].code;
+		code->code = csiphy->res->formats->formats[code->index].code;
 	} else {
 		if (code->index > 0)
 			return -EINVAL;
@@ -564,25 +574,7 @@ int msm_csiphy_subdev_init(struct camss *camss,
 	csiphy->camss = camss;
 	csiphy->id = id;
 	csiphy->cfg.combo_mode = 0;
-	csiphy->ops = res->ops;
-
-	switch (camss->res->version) {
-	case CAMSS_8x16:
-		csiphy->formats = csiphy_formats_8x16;
-		csiphy->nformats = ARRAY_SIZE(csiphy_formats_8x16);
-		break;
-	case CAMSS_8x96:
-	case CAMSS_660:
-		csiphy->formats = csiphy_formats_8x96;
-		csiphy->nformats = ARRAY_SIZE(csiphy_formats_8x96);
-		break;
-	case CAMSS_845:
-	case CAMSS_8250:
-	case CAMSS_8280XP:
-		csiphy->formats = csiphy_formats_sdm845;
-		csiphy->nformats = ARRAY_SIZE(csiphy_formats_sdm845);
-		break;
-	}
+	csiphy->res = &res->csiphy;
 
 	/* Memory */
 
@@ -610,7 +602,7 @@ int msm_csiphy_subdev_init(struct camss *camss,
 	snprintf(csiphy->irq_name, sizeof(csiphy->irq_name), "%s_%s%d",
 		 dev_name(dev), MSM_CSIPHY_NAME, csiphy->id);
 
-	ret = devm_request_irq(dev, csiphy->irq, csiphy->ops->isr,
+	ret = devm_request_irq(dev, csiphy->irq, csiphy->res->hw_ops->isr,
 			       IRQF_TRIGGER_RISING | IRQF_NO_AUTOEN,
 			       csiphy->irq_name, csiphy);
 	if (ret < 0) {
diff --git a/drivers/media/platform/qcom/camss/camss-csiphy.h b/drivers/media/platform/qcom/camss/camss-csiphy.h
index c9b7fe82b1f0d7..47f0b6b09eba4d 100644
--- a/drivers/media/platform/qcom/camss/camss-csiphy.h
+++ b/drivers/media/platform/qcom/camss/camss-csiphy.h
@@ -42,6 +42,16 @@ struct csiphy_config {
 	struct csiphy_csi2_cfg *csi2;
 };
 
+struct csiphy_format_info {
+	u32 code;
+	u8 bpp;
+};
+
+struct csiphy_formats {
+	unsigned int nformats;
+	const struct csiphy_format_info *formats;
+};
+
 struct csiphy_device;
 
 struct csiphy_hw_ops {
@@ -63,6 +73,11 @@ struct csiphy_hw_ops {
 	irqreturn_t (*isr)(int irq, void *dev);
 };
 
+struct csiphy_subdev_resources {
+	const struct csiphy_hw_ops *hw_ops;
+	const struct csiphy_formats *formats;
+};
+
 struct csiphy_device {
 	struct camss *camss;
 	u8 id;
@@ -78,9 +93,7 @@ struct csiphy_device {
 	u32 timer_clk_rate;
 	struct csiphy_config cfg;
 	struct v4l2_mbus_framefmt fmt[MSM_CSIPHY_PADS_NUM];
-	const struct csiphy_hw_ops *ops;
-	const struct csiphy_format *formats;
-	unsigned int nformats;
+	const struct csiphy_subdev_resources *res;
 };
 
 struct camss_subdev_resources;
@@ -94,6 +107,10 @@ int msm_csiphy_register_entity(struct csiphy_device *csiphy,
 
 void msm_csiphy_unregister_entity(struct csiphy_device *csiphy);
 
+extern const struct csiphy_formats csiphy_formats_8x16;
+extern const struct csiphy_formats csiphy_formats_8x96;
+extern const struct csiphy_formats csiphy_formats_sdm845;
+
 extern const struct csiphy_hw_ops csiphy_ops_2ph_1_0;
 extern const struct csiphy_hw_ops csiphy_ops_3ph_1_0;
 
diff --git a/drivers/media/platform/qcom/camss/camss-format.c b/drivers/media/platform/qcom/camss/camss-format.c
new file mode 100644
index 00000000000000..4a3d5549615cf8
--- /dev/null
+++ b/drivers/media/platform/qcom/camss/camss-format.c
@@ -0,0 +1,91 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * camss-format.c
+ *
+ * Qualcomm MSM Camera Subsystem - Format helpers
+ *
+ * Copyright (c) 2023, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2023 Qualcomm Technologies, Inc.
+ */
+#include <linux/bug.h>
+#include <linux/errno.h>
+
+#include "camss-format.h"
+
+/*
+ * camss_format_get_bpp - Map media bus format to bits per pixel
+ * @formats: supported media bus formats array
+ * @nformats: size of @formats array
+ * @code: media bus format code
+ *
+ * Return number of bits per pixel
+ */
+u8 camss_format_get_bpp(const struct camss_format_info *formats, unsigned int nformats, u32 code)
+{
+	unsigned int i;
+
+	for (i = 0; i < nformats; i++)
+		if (code == formats[i].code)
+			return formats[i].mbus_bpp;
+
+	WARN(1, "Unknown format\n");
+
+	return formats[0].mbus_bpp;
+}
+
+/*
+ * camss_format_find_code - Find a format code in an array
+ * @code: a pointer to media bus format codes array
+ * @n_code: size of @code array
+ * @index: index of code in the array
+ * @req_code: required code
+ *
+ * Return media bus format code
+ */
+u32 camss_format_find_code(u32 *code, unsigned int n_code, unsigned int index, u32 req_code)
+{
+	unsigned int i;
+
+	if (!req_code && index >= n_code)
+		return 0;
+
+	for (i = 0; i < n_code; i++) {
+		if (req_code) {
+			if (req_code == code[i])
+				return req_code;
+		} else {
+			if (i == index)
+				return code[i];
+		}
+	}
+
+	return code[0];
+}
+
+/*
+ * camss_format_find_format - Find a format in an array
+ * @code: media bus format code
+ * @pixelformat: V4L2 pixel format FCC identifier
+ * @formats: a pointer to formats array
+ * @nformats: size of @formats array
+ *
+ * Return index of a format or a negative error code otherwise
+ */
+int camss_format_find_format(u32 code, u32 pixelformat, const struct camss_format_info *formats,
+			     unsigned int nformats)
+{
+	unsigned int i;
+
+	for (i = 0; i < nformats; i++) {
+		if (formats[i].code == code &&
+		    formats[i].pixelformat == pixelformat)
+			return i;
+	}
+
+	for (i = 0; i < nformats; i++) {
+		if (formats[i].code == code)
+			return i;
+	}
+
+	return -EINVAL;
+}
diff --git a/drivers/media/platform/qcom/camss/camss-format.h b/drivers/media/platform/qcom/camss/camss-format.h
new file mode 100644
index 00000000000000..923a48c9c3fb6d
--- /dev/null
+++ b/drivers/media/platform/qcom/camss/camss-format.h
@@ -0,0 +1,62 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * camss-format.h
+ *
+ * Qualcomm MSM Camera Subsystem - Format helpers
+ *
+ * Copyright (c) 2023, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2023 Qualcomm Technologies, Inc.
+ */
+#ifndef __CAMSS_FORMAT_H__
+#define __CAMSS_FORMAT_H__
+
+#include <linux/types.h>
+
+#define PER_PLANE_DATA(plane, h_fract_num, h_fract_den, v_fract_num, v_fract_den, _bpp)         \
+	.hsub[(plane)].numerator	= (h_fract_num),                                        \
+	.hsub[(plane)].denominator	= (h_fract_den),                                        \
+	.vsub[(plane)].numerator	= (v_fract_num),                                        \
+	.vsub[(plane)].denominator	= (v_fract_den),                                        \
+	.bpp[(plane)]			= (_bpp)
+
+/*
+ * struct fract - Represents a fraction
+ * @numerator: Store the numerator part of the fraction
+ * @denominator: Store the denominator part of the fraction
+ */
+struct fract {
+	u8 numerator;
+	u8 denominator;
+};
+
+/*
+ * struct camss_format_info - ISP media bus format information
+ * @code: V4L2 media bus format code
+ * @mbus_bpp: Media bus bits per pixel
+ * @pixelformat: V4L2 pixel format FCC identifier
+ * @planes: Number of planes
+ * @hsub: Horizontal subsampling (for each plane)
+ * @vsub: Vertical subsampling (for each plane)
+ * @bpp: Bits per pixel when stored in memory (for each plane)
+ */
+struct camss_format_info {
+	u32 code;
+	u32 mbus_bpp;
+	u32 pixelformat;
+	u8 planes;
+	struct fract hsub[3];
+	struct fract vsub[3];
+	unsigned int bpp[3];
+};
+
+struct camss_formats {
+	unsigned int nformats;
+	const struct camss_format_info *formats;
+};
+
+u8 camss_format_get_bpp(const struct camss_format_info *formats, unsigned int nformats, u32 code);
+u32 camss_format_find_code(u32 *code, unsigned int n_code, unsigned int index, u32 req_code);
+int camss_format_find_format(u32 code, u32 pixelformat, const struct camss_format_info *formats,
+			     unsigned int nformats);
+
+#endif /* __CAMSS_FORMAT_H__ */
diff --git a/drivers/media/platform/qcom/camss/camss-vfe-17x.c b/drivers/media/platform/qcom/camss/camss-vfe-17x.c
index 795ac3815339a2..380c99321030ec 100644
--- a/drivers/media/platform/qcom/camss/camss-vfe-17x.c
+++ b/drivers/media/platform/qcom/camss/camss-vfe-17x.c
@@ -353,7 +353,7 @@ static irqreturn_t vfe_isr(int irq, void *dev)
 	writel_relaxed(status0, vfe->base + VFE_IRQ_CLEAR_0);
 	writel_relaxed(status1, vfe->base + VFE_IRQ_CLEAR_1);
 
-	for (i = VFE_LINE_RDI0; i < vfe->line_num; i++) {
+	for (i = VFE_LINE_RDI0; i < vfe->res->line_num; i++) {
 		vfe_bus_status[i] = readl_relaxed(vfe->base + VFE_BUS_IRQ_STATUS(i));
 		writel_relaxed(vfe_bus_status[i], vfe->base + VFE_BUS_IRQ_CLEAR(i));
 	}
@@ -367,11 +367,11 @@ static irqreturn_t vfe_isr(int irq, void *dev)
 	if (status0 & STATUS_0_RESET_ACK)
 		vfe->isr_ops.reset_ack(vfe);
 
-	for (i = VFE_LINE_RDI0; i < vfe->line_num; i++)
+	for (i = VFE_LINE_RDI0; i < vfe->res->line_num; i++)
 		if (status0 & STATUS_0_RDI_REG_UPDATE(i))
 			vfe->isr_ops.reg_update(vfe, i);
 
-	for (i = VFE_LINE_RDI0; i < vfe->line_num; i++)
+	for (i = VFE_LINE_RDI0; i < vfe->res->line_num; i++)
 		if (status0 & STATUS_1_RDI_SOF(i))
 			vfe->isr_ops.sof(vfe, i);
 
@@ -442,7 +442,7 @@ static int vfe_enable_output(struct vfe_line *line)
 {
 	struct vfe_device *vfe = to_vfe(line);
 	struct vfe_output *output = &line->output;
-	const struct vfe_hw_ops *ops = vfe->ops;
+	const struct vfe_hw_ops *ops = vfe->res->hw_ops;
 	struct media_entity *sensor;
 	unsigned long flags;
 	unsigned int frame_skip = 0;
@@ -560,7 +560,7 @@ static void vfe_isr_reg_update(struct vfe_device *vfe, enum vfe_line_id line_id)
 	unsigned long flags;
 
 	spin_lock_irqsave(&vfe->output_lock, flags);
-	vfe->ops->reg_update_clear(vfe, line_id);
+	vfe->res->hw_ops->reg_update_clear(vfe, line_id);
 
 	output = &vfe->line[line_id].output;
 
diff --git a/drivers/media/platform/qcom/camss/camss-vfe-4-1.c b/drivers/media/platform/qcom/camss/camss-vfe-4-1.c
index ef6b34c915df1d..1bd3a6ef1d04d8 100644
--- a/drivers/media/platform/qcom/camss/camss-vfe-4-1.c
+++ b/drivers/media/platform/qcom/camss/camss-vfe-4-1.c
@@ -892,7 +892,7 @@ static irqreturn_t vfe_isr(int irq, void *dev)
 	u32 value0, value1;
 	int i, j;
 
-	vfe->ops->isr_read(vfe, &value0, &value1);
+	vfe->res->hw_ops->isr_read(vfe, &value0, &value1);
 
 	dev_dbg(vfe->camss->dev, "VFE: status0 = 0x%08x, status1 = 0x%08x\n",
 		value0, value1);
@@ -901,7 +901,7 @@ static irqreturn_t vfe_isr(int irq, void *dev)
 		vfe->isr_ops.reset_ack(vfe);
 
 	if (value1 & VFE_0_IRQ_STATUS_1_VIOLATION)
-		vfe->ops->violation_read(vfe);
+		vfe->res->hw_ops->violation_read(vfe);
 
 	if (value1 & VFE_0_IRQ_STATUS_1_BUS_BDG_HALT_ACK)
 		vfe->isr_ops.halt_ack(vfe);
diff --git a/drivers/media/platform/qcom/camss/camss-vfe-4-7.c b/drivers/media/platform/qcom/camss/camss-vfe-4-7.c
index 7655d22a9fda2c..ce0719106bd344 100644
--- a/drivers/media/platform/qcom/camss/camss-vfe-4-7.c
+++ b/drivers/media/platform/qcom/camss/camss-vfe-4-7.c
@@ -1050,7 +1050,7 @@ static irqreturn_t vfe_isr(int irq, void *dev)
 	u32 value0, value1;
 	int i, j;
 
-	vfe->ops->isr_read(vfe, &value0, &value1);
+	vfe->res->hw_ops->isr_read(vfe, &value0, &value1);
 
 	dev_dbg(vfe->camss->dev, "VFE: status0 = 0x%08x, status1 = 0x%08x\n",
 		value0, value1);
@@ -1059,12 +1059,12 @@ static irqreturn_t vfe_isr(int irq, void *dev)
 		vfe->isr_ops.reset_ack(vfe);
 
 	if (value1 & VFE_0_IRQ_STATUS_1_VIOLATION)
-		vfe->ops->violation_read(vfe);
+		vfe->res->hw_ops->violation_read(vfe);
 
 	if (value1 & VFE_0_IRQ_STATUS_1_BUS_BDG_HALT_ACK)
 		vfe->isr_ops.halt_ack(vfe);
 
-	for (i = VFE_LINE_RDI0; i < vfe->line_num; i++)
+	for (i = VFE_LINE_RDI0; i < vfe->res->line_num; i++)
 		if (value0 & VFE_0_IRQ_STATUS_0_line_n_REG_UPDATE(i))
 			vfe->isr_ops.reg_update(vfe, i);
 
diff --git a/drivers/media/platform/qcom/camss/camss-vfe-4-8.c b/drivers/media/platform/qcom/camss/camss-vfe-4-8.c
index f52fa30f3853ec..6b59c8107a3c7d 100644
--- a/drivers/media/platform/qcom/camss/camss-vfe-4-8.c
+++ b/drivers/media/platform/qcom/camss/camss-vfe-4-8.c
@@ -980,7 +980,7 @@ static irqreturn_t vfe_isr(int irq, void *dev)
 	u32 value0, value1;
 	int i, j;
 
-	vfe->ops->isr_read(vfe, &value0, &value1);
+	vfe->res->hw_ops->isr_read(vfe, &value0, &value1);
 
 	dev_dbg(vfe->camss->dev, "VFE: status0 = 0x%08x, status1 = 0x%08x\n",
 		value0, value1);
@@ -989,12 +989,12 @@ static irqreturn_t vfe_isr(int irq, void *dev)
 		vfe->isr_ops.reset_ack(vfe);
 
 	if (value1 & VFE_0_IRQ_STATUS_1_VIOLATION)
-		vfe->ops->violation_read(vfe);
+		vfe->res->hw_ops->violation_read(vfe);
 
 	if (value1 & VFE_0_IRQ_STATUS_1_BUS_BDG_HALT_ACK)
 		vfe->isr_ops.halt_ack(vfe);
 
-	for (i = VFE_LINE_RDI0; i < vfe->line_num; i++)
+	for (i = VFE_LINE_RDI0; i < vfe->res->line_num; i++)
 		if (value0 & VFE_0_IRQ_STATUS_0_line_n_REG_UPDATE(i))
 			vfe->isr_ops.reg_update(vfe, i);
 
diff --git a/drivers/media/platform/qcom/camss/camss-vfe-gen1.c b/drivers/media/platform/qcom/camss/camss-vfe-gen1.c
index 239d3d4ac66612..eb33c03df27e55 100644
--- a/drivers/media/platform/qcom/camss/camss-vfe-gen1.c
+++ b/drivers/media/platform/qcom/camss/camss-vfe-gen1.c
@@ -37,7 +37,7 @@ static int vfe_disable_output(struct vfe_line *line)
 {
 	struct vfe_device *vfe = to_vfe(line);
 	struct vfe_output *output = &line->output;
-	const struct vfe_hw_ops *ops = vfe->ops;
+	const struct vfe_hw_ops *ops = vfe->res->hw_ops;
 	unsigned long flags;
 	unsigned long time;
 	unsigned int i;
@@ -162,14 +162,14 @@ static void vfe_output_frame_drop(struct vfe_device *vfe,
 		vfe->ops_gen1->wm_set_framedrop_pattern(vfe, output->wm_idx[i], drop_pattern);
 	}
 
-	vfe->ops->reg_update(vfe, container_of(output, struct vfe_line, output)->id);
+	vfe->res->hw_ops->reg_update(vfe, container_of(output, struct vfe_line, output)->id);
 }
 
 static int vfe_enable_output(struct vfe_line *line)
 {
 	struct vfe_device *vfe = to_vfe(line);
 	struct vfe_output *output = &line->output;
-	const struct vfe_hw_ops *ops = vfe->ops;
+	const struct vfe_hw_ops *ops = vfe->res->hw_ops;
 	struct media_entity *sensor;
 	unsigned long flags;
 	unsigned int frame_skip = 0;
@@ -545,7 +545,7 @@ static void vfe_isr_reg_update(struct vfe_device *vfe, enum vfe_line_id line_id)
 	unsigned long flags;
 
 	spin_lock_irqsave(&vfe->output_lock, flags);
-	vfe->ops->reg_update_clear(vfe, line_id);
+	vfe->res->hw_ops->reg_update_clear(vfe, line_id);
 
 	output = &line->output;
 
diff --git a/drivers/media/platform/qcom/camss/camss-vfe.c b/drivers/media/platform/qcom/camss/camss-vfe.c
index d875237cf24431..05191cc2c2f936 100644
--- a/drivers/media/platform/qcom/camss/camss-vfe.c
+++ b/drivers/media/platform/qcom/camss/camss-vfe.c
@@ -32,139 +32,251 @@
 
 #define SCALER_RATIO_MAX 16
 
-struct vfe_format {
-	u32 code;
-	u8 bpp;
+static const struct camss_format_info formats_rdi_8x16[] = {
+	{ MEDIA_BUS_FMT_UYVY8_1X16, 8, V4L2_PIX_FMT_UYVY, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_VYUY8_1X16, 8, V4L2_PIX_FMT_VYUY, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_YUYV8_1X16, 8, V4L2_PIX_FMT_YUYV, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_YVYU8_1X16, 8, V4L2_PIX_FMT_YVYU, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_SBGGR8_1X8, 8, V4L2_PIX_FMT_SBGGR8, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 8) },
+	{ MEDIA_BUS_FMT_SGBRG8_1X8, 8, V4L2_PIX_FMT_SGBRG8, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 8) },
+	{ MEDIA_BUS_FMT_SGRBG8_1X8, 8, V4L2_PIX_FMT_SGRBG8, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 8) },
+	{ MEDIA_BUS_FMT_SRGGB8_1X8, 8, V4L2_PIX_FMT_SRGGB8, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 8) },
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10, V4L2_PIX_FMT_SBGGR10P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 10) },
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10, V4L2_PIX_FMT_SGBRG10P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 10) },
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10, V4L2_PIX_FMT_SGRBG10P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 10) },
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10, V4L2_PIX_FMT_SRGGB10P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 10) },
+	{ MEDIA_BUS_FMT_SBGGR12_1X12, 12, V4L2_PIX_FMT_SBGGR12P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 12) },
+	{ MEDIA_BUS_FMT_SGBRG12_1X12, 12, V4L2_PIX_FMT_SGBRG12P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 12) },
+	{ MEDIA_BUS_FMT_SGRBG12_1X12, 12, V4L2_PIX_FMT_SGRBG12P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 12) },
+	{ MEDIA_BUS_FMT_SRGGB12_1X12, 12, V4L2_PIX_FMT_SRGGB12P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 12) },
+	{ MEDIA_BUS_FMT_Y10_1X10, 10, V4L2_PIX_FMT_Y10P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 10) },
 };
 
-static const struct vfe_format formats_rdi_8x16[] = {
-	{ MEDIA_BUS_FMT_UYVY8_1X16, 8 },
-	{ MEDIA_BUS_FMT_VYUY8_1X16, 8 },
-	{ MEDIA_BUS_FMT_YUYV8_1X16, 8 },
-	{ MEDIA_BUS_FMT_YVYU8_1X16, 8 },
-	{ MEDIA_BUS_FMT_SBGGR8_1X8, 8 },
-	{ MEDIA_BUS_FMT_SGBRG8_1X8, 8 },
-	{ MEDIA_BUS_FMT_SGRBG8_1X8, 8 },
-	{ MEDIA_BUS_FMT_SRGGB8_1X8, 8 },
-	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10 },
-	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10 },
-	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10 },
-	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10 },
-	{ MEDIA_BUS_FMT_SBGGR12_1X12, 12 },
-	{ MEDIA_BUS_FMT_SGBRG12_1X12, 12 },
-	{ MEDIA_BUS_FMT_SGRBG12_1X12, 12 },
-	{ MEDIA_BUS_FMT_SRGGB12_1X12, 12 },
-	{ MEDIA_BUS_FMT_Y10_1X10, 10 },
+static const struct camss_format_info formats_rdi_8x96[] = {
+	{ MEDIA_BUS_FMT_UYVY8_1X16, 8, V4L2_PIX_FMT_UYVY, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_VYUY8_1X16, 8, V4L2_PIX_FMT_VYUY, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_YUYV8_1X16, 8, V4L2_PIX_FMT_YUYV, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_YVYU8_1X16, 8, V4L2_PIX_FMT_YVYU, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_SBGGR8_1X8, 8, V4L2_PIX_FMT_SBGGR8, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 8) },
+	{ MEDIA_BUS_FMT_SGBRG8_1X8, 8, V4L2_PIX_FMT_SGBRG8, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 8) },
+	{ MEDIA_BUS_FMT_SGRBG8_1X8, 8, V4L2_PIX_FMT_SGRBG8, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 8) },
+	{ MEDIA_BUS_FMT_SRGGB8_1X8, 8, V4L2_PIX_FMT_SRGGB8, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 8) },
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10, V4L2_PIX_FMT_SBGGR10P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 10) },
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10, V4L2_PIX_FMT_SGBRG10P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 10) },
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10, V4L2_PIX_FMT_SGRBG10P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 10) },
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10, V4L2_PIX_FMT_SRGGB10P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 10) },
+	{ MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE, 16, V4L2_PIX_FMT_SBGGR10, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_SBGGR12_1X12, 12, V4L2_PIX_FMT_SBGGR12P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 12) },
+	{ MEDIA_BUS_FMT_SGBRG12_1X12, 12, V4L2_PIX_FMT_SGBRG12P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 12) },
+	{ MEDIA_BUS_FMT_SGRBG12_1X12, 12, V4L2_PIX_FMT_SGRBG12P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 12) },
+	{ MEDIA_BUS_FMT_SRGGB12_1X12, 12, V4L2_PIX_FMT_SRGGB12P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 12) },
+	{ MEDIA_BUS_FMT_SBGGR14_1X14, 14, V4L2_PIX_FMT_SBGGR14P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 14) },
+	{ MEDIA_BUS_FMT_SGBRG14_1X14, 14, V4L2_PIX_FMT_SGBRG14P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 14) },
+	{ MEDIA_BUS_FMT_SGRBG14_1X14, 14, V4L2_PIX_FMT_SGRBG14P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 14) },
+	{ MEDIA_BUS_FMT_SRGGB14_1X14, 14, V4L2_PIX_FMT_SRGGB14P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 14) },
+	{ MEDIA_BUS_FMT_Y10_1X10, 10, V4L2_PIX_FMT_Y10P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 10) },
+	{ MEDIA_BUS_FMT_Y10_2X8_PADHI_LE, 16, V4L2_PIX_FMT_Y10, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
 };
 
-static const struct vfe_format formats_pix_8x16[] = {
-	{ MEDIA_BUS_FMT_UYVY8_1X16, 8 },
-	{ MEDIA_BUS_FMT_VYUY8_1X16, 8 },
-	{ MEDIA_BUS_FMT_YUYV8_1X16, 8 },
-	{ MEDIA_BUS_FMT_YVYU8_1X16, 8 },
+static const struct camss_format_info formats_rdi_845[] = {
+	{ MEDIA_BUS_FMT_UYVY8_1X16, 8, V4L2_PIX_FMT_UYVY, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_VYUY8_1X16, 8, V4L2_PIX_FMT_VYUY, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_YUYV8_1X16, 8, V4L2_PIX_FMT_YUYV, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_YVYU8_1X16, 8, V4L2_PIX_FMT_YVYU, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_SBGGR8_1X8, 8, V4L2_PIX_FMT_SBGGR8, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 8) },
+	{ MEDIA_BUS_FMT_SGBRG8_1X8, 8, V4L2_PIX_FMT_SGBRG8, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 8) },
+	{ MEDIA_BUS_FMT_SGRBG8_1X8, 8, V4L2_PIX_FMT_SGRBG8, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 8) },
+	{ MEDIA_BUS_FMT_SRGGB8_1X8, 8, V4L2_PIX_FMT_SRGGB8, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 8) },
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10, V4L2_PIX_FMT_SBGGR10P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 10) },
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10, V4L2_PIX_FMT_SGBRG10P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 10) },
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10, V4L2_PIX_FMT_SGRBG10P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 10) },
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10, V4L2_PIX_FMT_SRGGB10P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 10) },
+	{ MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE, 16, V4L2_PIX_FMT_SBGGR10, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_SBGGR12_1X12, 12, V4L2_PIX_FMT_SBGGR12P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 12) },
+	{ MEDIA_BUS_FMT_SGBRG12_1X12, 12, V4L2_PIX_FMT_SGBRG12P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 12) },
+	{ MEDIA_BUS_FMT_SGRBG12_1X12, 12, V4L2_PIX_FMT_SGRBG12P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 12) },
+	{ MEDIA_BUS_FMT_SRGGB12_1X12, 12, V4L2_PIX_FMT_SRGGB12P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 12) },
+	{ MEDIA_BUS_FMT_SBGGR14_1X14, 14, V4L2_PIX_FMT_SBGGR14P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 14) },
+	{ MEDIA_BUS_FMT_SGBRG14_1X14, 14, V4L2_PIX_FMT_SGBRG14P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 14) },
+	{ MEDIA_BUS_FMT_SGRBG14_1X14, 14, V4L2_PIX_FMT_SGRBG14P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 14) },
+	{ MEDIA_BUS_FMT_SRGGB14_1X14, 14, V4L2_PIX_FMT_SRGGB14P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 14) },
+	{ MEDIA_BUS_FMT_Y8_1X8, 8, V4L2_PIX_FMT_GREY, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 8) },
+	{ MEDIA_BUS_FMT_Y10_1X10, 10, V4L2_PIX_FMT_Y10P, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 10) },
+	{ MEDIA_BUS_FMT_Y10_2X8_PADHI_LE, 16, V4L2_PIX_FMT_Y10, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
 };
 
-static const struct vfe_format formats_rdi_8x96[] = {
-	{ MEDIA_BUS_FMT_UYVY8_1X16, 8 },
-	{ MEDIA_BUS_FMT_VYUY8_1X16, 8 },
-	{ MEDIA_BUS_FMT_YUYV8_1X16, 8 },
-	{ MEDIA_BUS_FMT_YVYU8_1X16, 8 },
-	{ MEDIA_BUS_FMT_SBGGR8_1X8, 8 },
-	{ MEDIA_BUS_FMT_SGBRG8_1X8, 8 },
-	{ MEDIA_BUS_FMT_SGRBG8_1X8, 8 },
-	{ MEDIA_BUS_FMT_SRGGB8_1X8, 8 },
-	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10 },
-	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10 },
-	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10 },
-	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10 },
-	{ MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE, 16 },
-	{ MEDIA_BUS_FMT_SBGGR12_1X12, 12 },
-	{ MEDIA_BUS_FMT_SGBRG12_1X12, 12 },
-	{ MEDIA_BUS_FMT_SGRBG12_1X12, 12 },
-	{ MEDIA_BUS_FMT_SRGGB12_1X12, 12 },
-	{ MEDIA_BUS_FMT_SBGGR14_1X14, 14 },
-	{ MEDIA_BUS_FMT_SGBRG14_1X14, 14 },
-	{ MEDIA_BUS_FMT_SGRBG14_1X14, 14 },
-	{ MEDIA_BUS_FMT_SRGGB14_1X14, 14 },
-	{ MEDIA_BUS_FMT_Y10_1X10, 10 },
-	{ MEDIA_BUS_FMT_Y10_2X8_PADHI_LE, 16 },
+static const struct camss_format_info formats_pix_8x16[] = {
+	{ MEDIA_BUS_FMT_YUYV8_1_5X8, 8, V4L2_PIX_FMT_NV12, 1,
+	  PER_PLANE_DATA(0, 1, 1, 2, 3, 8) },
+	{ MEDIA_BUS_FMT_YVYU8_1_5X8, 8, V4L2_PIX_FMT_NV12, 1,
+	  PER_PLANE_DATA(0, 1, 1, 2, 3, 8) },
+	{ MEDIA_BUS_FMT_UYVY8_1_5X8, 8, V4L2_PIX_FMT_NV12, 1,
+	  PER_PLANE_DATA(0, 1, 1, 2, 3, 8) },
+	{ MEDIA_BUS_FMT_VYUY8_1_5X8, 8, V4L2_PIX_FMT_NV12, 1,
+	  PER_PLANE_DATA(0, 1, 1, 2, 3, 8) },
+	{ MEDIA_BUS_FMT_YUYV8_1_5X8, 8, V4L2_PIX_FMT_NV21, 1,
+	  PER_PLANE_DATA(0, 1, 1, 2, 3, 8) },
+	{ MEDIA_BUS_FMT_YVYU8_1_5X8, 8, V4L2_PIX_FMT_NV21, 1,
+	  PER_PLANE_DATA(0, 1, 1, 2, 3, 8) },
+	{ MEDIA_BUS_FMT_UYVY8_1_5X8, 8, V4L2_PIX_FMT_NV21, 1,
+	  PER_PLANE_DATA(0, 1, 1, 2, 3, 8) },
+	{ MEDIA_BUS_FMT_VYUY8_1_5X8, 8, V4L2_PIX_FMT_NV21, 1,
+	  PER_PLANE_DATA(0, 1, 1, 2, 3, 8) },
+	{ MEDIA_BUS_FMT_YUYV8_1X16, 8, V4L2_PIX_FMT_NV16, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 2, 8) },
+	{ MEDIA_BUS_FMT_YVYU8_1X16, 8, V4L2_PIX_FMT_NV16, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 2, 8) },
+	{ MEDIA_BUS_FMT_UYVY8_1X16, 8, V4L2_PIX_FMT_NV16, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 2, 8) },
+	{ MEDIA_BUS_FMT_VYUY8_1X16, 8, V4L2_PIX_FMT_NV16, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 2, 8) },
+	{ MEDIA_BUS_FMT_YUYV8_1X16, 8, V4L2_PIX_FMT_NV61, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 2, 8) },
+	{ MEDIA_BUS_FMT_YVYU8_1X16, 8, V4L2_PIX_FMT_NV61, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 2, 8) },
+	{ MEDIA_BUS_FMT_UYVY8_1X16, 8, V4L2_PIX_FMT_NV61, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 2, 8) },
+	{ MEDIA_BUS_FMT_VYUY8_1X16, 8, V4L2_PIX_FMT_NV61, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 2, 8) },
 };
 
-static const struct vfe_format formats_pix_8x96[] = {
-	{ MEDIA_BUS_FMT_UYVY8_1X16, 8 },
-	{ MEDIA_BUS_FMT_VYUY8_1X16, 8 },
-	{ MEDIA_BUS_FMT_YUYV8_1X16, 8 },
-	{ MEDIA_BUS_FMT_YVYU8_1X16, 8 },
+static const struct camss_format_info formats_pix_8x96[] = {
+	{ MEDIA_BUS_FMT_YUYV8_1_5X8, 8, V4L2_PIX_FMT_NV12, 1,
+	  PER_PLANE_DATA(0, 1, 1, 2, 3, 8) },
+	{ MEDIA_BUS_FMT_YVYU8_1_5X8, 8, V4L2_PIX_FMT_NV12, 1,
+	  PER_PLANE_DATA(0, 1, 1, 2, 3, 8) },
+	{ MEDIA_BUS_FMT_UYVY8_1_5X8, 8, V4L2_PIX_FMT_NV12, 1,
+	  PER_PLANE_DATA(0, 1, 1, 2, 3, 8) },
+	{ MEDIA_BUS_FMT_VYUY8_1_5X8, 8, V4L2_PIX_FMT_NV12, 1,
+	  PER_PLANE_DATA(0, 1, 1, 2, 3, 8) },
+	{ MEDIA_BUS_FMT_YUYV8_1_5X8, 8, V4L2_PIX_FMT_NV21, 1,
+	  PER_PLANE_DATA(0, 1, 1, 2, 3, 8) },
+	{ MEDIA_BUS_FMT_YVYU8_1_5X8, 8, V4L2_PIX_FMT_NV21, 1,
+	  PER_PLANE_DATA(0, 1, 1, 2, 3, 8) },
+	{ MEDIA_BUS_FMT_UYVY8_1_5X8, 8, V4L2_PIX_FMT_NV21, 1,
+	  PER_PLANE_DATA(0, 1, 1, 2, 3, 8) },
+	{ MEDIA_BUS_FMT_VYUY8_1_5X8, 8, V4L2_PIX_FMT_NV21, 1,
+	  PER_PLANE_DATA(0, 1, 1, 2, 3, 8) },
+	{ MEDIA_BUS_FMT_YUYV8_1X16, 8, V4L2_PIX_FMT_NV16, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 2, 8) },
+	{ MEDIA_BUS_FMT_YVYU8_1X16, 8, V4L2_PIX_FMT_NV16, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 2, 8) },
+	{ MEDIA_BUS_FMT_UYVY8_1X16, 8, V4L2_PIX_FMT_NV16, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 2, 8) },
+	{ MEDIA_BUS_FMT_VYUY8_1X16, 8, V4L2_PIX_FMT_NV16, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 2, 8) },
+	{ MEDIA_BUS_FMT_YUYV8_1X16, 8, V4L2_PIX_FMT_NV61, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 2, 8) },
+	{ MEDIA_BUS_FMT_YVYU8_1X16, 8, V4L2_PIX_FMT_NV61, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 2, 8) },
+	{ MEDIA_BUS_FMT_UYVY8_1X16, 8, V4L2_PIX_FMT_NV61, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 2, 8) },
+	{ MEDIA_BUS_FMT_VYUY8_1X16, 8, V4L2_PIX_FMT_NV61, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 2, 8) },
+	{ MEDIA_BUS_FMT_UYVY8_1X16, 8, V4L2_PIX_FMT_UYVY, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_VYUY8_1X16, 8, V4L2_PIX_FMT_VYUY, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_YUYV8_1X16, 8, V4L2_PIX_FMT_YUYV, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
+	{ MEDIA_BUS_FMT_YVYU8_1X16, 8, V4L2_PIX_FMT_YVYU, 1,
+	  PER_PLANE_DATA(0, 1, 1, 1, 1, 16) },
 };
 
-static const struct vfe_format formats_rdi_845[] = {
-	{ MEDIA_BUS_FMT_UYVY8_1X16, 8 },
-	{ MEDIA_BUS_FMT_VYUY8_1X16, 8 },
-	{ MEDIA_BUS_FMT_YUYV8_1X16, 8 },
-	{ MEDIA_BUS_FMT_YVYU8_1X16, 8 },
-	{ MEDIA_BUS_FMT_SBGGR8_1X8, 8 },
-	{ MEDIA_BUS_FMT_SGBRG8_1X8, 8 },
-	{ MEDIA_BUS_FMT_SGRBG8_1X8, 8 },
-	{ MEDIA_BUS_FMT_SRGGB8_1X8, 8 },
-	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10 },
-	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10 },
-	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10 },
-	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10 },
-	{ MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE, 16 },
-	{ MEDIA_BUS_FMT_SBGGR12_1X12, 12 },
-	{ MEDIA_BUS_FMT_SGBRG12_1X12, 12 },
-	{ MEDIA_BUS_FMT_SGRBG12_1X12, 12 },
-	{ MEDIA_BUS_FMT_SRGGB12_1X12, 12 },
-	{ MEDIA_BUS_FMT_SBGGR14_1X14, 14 },
-	{ MEDIA_BUS_FMT_SGBRG14_1X14, 14 },
-	{ MEDIA_BUS_FMT_SGRBG14_1X14, 14 },
-	{ MEDIA_BUS_FMT_SRGGB14_1X14, 14 },
-	{ MEDIA_BUS_FMT_Y8_1X8, 8 },
-	{ MEDIA_BUS_FMT_Y10_1X10, 10 },
-	{ MEDIA_BUS_FMT_Y10_2X8_PADHI_LE, 16 },
+const struct camss_formats vfe_formats_rdi_8x16 = {
+	.nformats = ARRAY_SIZE(formats_rdi_8x16),
+	.formats = formats_rdi_8x16
 };
 
-/*
- * vfe_get_bpp - map media bus format to bits per pixel
- * @formats: supported media bus formats array
- * @nformats: size of @formats array
- * @code: media bus format code
- *
- * Return number of bits per pixel
- */
-static u8 vfe_get_bpp(const struct vfe_format *formats,
-		      unsigned int nformats, u32 code)
-{
-	unsigned int i;
-
-	for (i = 0; i < nformats; i++)
-		if (code == formats[i].code)
-			return formats[i].bpp;
-
-	WARN(1, "Unknown format\n");
-
-	return formats[0].bpp;
-}
+const struct camss_formats vfe_formats_pix_8x16 = {
+	.nformats = ARRAY_SIZE(formats_pix_8x16),
+	.formats = formats_pix_8x16
+};
 
-static u32 vfe_find_code(u32 *code, unsigned int n_code,
-			 unsigned int index, u32 req_code)
-{
-	int i;
+const struct camss_formats vfe_formats_rdi_8x96 = {
+	.nformats = ARRAY_SIZE(formats_rdi_8x96),
+	.formats = formats_rdi_8x96
+};
 
-	if (!req_code && (index >= n_code))
-		return 0;
+const struct camss_formats vfe_formats_pix_8x96 = {
+	.nformats = ARRAY_SIZE(formats_pix_8x96),
+	.formats = formats_pix_8x96
+};
 
-	for (i = 0; i < n_code; i++)
-		if (req_code) {
-			if (req_code == code[i])
-				return req_code;
-		} else {
-			if (i == index)
-				return code[i];
-		}
+const struct camss_formats vfe_formats_rdi_845 = {
+	.nformats = ARRAY_SIZE(formats_rdi_845),
+	.formats = formats_rdi_845
+};
 
-	return code[0];
-}
+/* TODO: Replace with pix formats */
+const struct camss_formats vfe_formats_pix_845 = {
+	.nformats = ARRAY_SIZE(formats_rdi_845),
+	.formats = formats_rdi_845
+};
 
 static u32 vfe_src_pad_code(struct vfe_line *line, u32 sink_code,
 			    unsigned int index, u32 src_req_code)
@@ -181,8 +293,8 @@ static u32 vfe_src_pad_code(struct vfe_line *line, u32 sink_code,
 				MEDIA_BUS_FMT_YUYV8_1_5X8,
 			};
 
-			return vfe_find_code(src_code, ARRAY_SIZE(src_code),
-					     index, src_req_code);
+			return camss_format_find_code(src_code, ARRAY_SIZE(src_code),
+						      index, src_req_code);
 		}
 		case MEDIA_BUS_FMT_YVYU8_1X16:
 		{
@@ -191,8 +303,8 @@ static u32 vfe_src_pad_code(struct vfe_line *line, u32 sink_code,
 				MEDIA_BUS_FMT_YVYU8_1_5X8,
 			};
 
-			return vfe_find_code(src_code, ARRAY_SIZE(src_code),
-					     index, src_req_code);
+			return camss_format_find_code(src_code, ARRAY_SIZE(src_code),
+						      index, src_req_code);
 		}
 		case MEDIA_BUS_FMT_UYVY8_1X16:
 		{
@@ -201,8 +313,8 @@ static u32 vfe_src_pad_code(struct vfe_line *line, u32 sink_code,
 				MEDIA_BUS_FMT_UYVY8_1_5X8,
 			};
 
-			return vfe_find_code(src_code, ARRAY_SIZE(src_code),
-					     index, src_req_code);
+			return camss_format_find_code(src_code, ARRAY_SIZE(src_code),
+						      index, src_req_code);
 		}
 		case MEDIA_BUS_FMT_VYUY8_1X16:
 		{
@@ -211,8 +323,8 @@ static u32 vfe_src_pad_code(struct vfe_line *line, u32 sink_code,
 				MEDIA_BUS_FMT_VYUY8_1_5X8,
 			};
 
-			return vfe_find_code(src_code, ARRAY_SIZE(src_code),
-					     index, src_req_code);
+			return camss_format_find_code(src_code, ARRAY_SIZE(src_code),
+						      index, src_req_code);
 		}
 		default:
 			if (index > 0)
@@ -224,6 +336,7 @@ static u32 vfe_src_pad_code(struct vfe_line *line, u32 sink_code,
 	case CAMSS_8x96:
 	case CAMSS_660:
 	case CAMSS_845:
+	case CAMSS_7180:
 	case CAMSS_8250:
 	case CAMSS_8280XP:
 		switch (sink_code) {
@@ -237,8 +350,8 @@ static u32 vfe_src_pad_code(struct vfe_line *line, u32 sink_code,
 				MEDIA_BUS_FMT_YUYV8_1_5X8,
 			};
 
-			return vfe_find_code(src_code, ARRAY_SIZE(src_code),
-					     index, src_req_code);
+			return camss_format_find_code(src_code, ARRAY_SIZE(src_code),
+						      index, src_req_code);
 		}
 		case MEDIA_BUS_FMT_YVYU8_1X16:
 		{
@@ -250,8 +363,8 @@ static u32 vfe_src_pad_code(struct vfe_line *line, u32 sink_code,
 				MEDIA_BUS_FMT_YVYU8_1_5X8,
 			};
 
-			return vfe_find_code(src_code, ARRAY_SIZE(src_code),
-					     index, src_req_code);
+			return camss_format_find_code(src_code, ARRAY_SIZE(src_code),
+						      index, src_req_code);
 		}
 		case MEDIA_BUS_FMT_UYVY8_1X16:
 		{
@@ -263,8 +376,8 @@ static u32 vfe_src_pad_code(struct vfe_line *line, u32 sink_code,
 				MEDIA_BUS_FMT_UYVY8_1_5X8,
 			};
 
-			return vfe_find_code(src_code, ARRAY_SIZE(src_code),
-					     index, src_req_code);
+			return camss_format_find_code(src_code, ARRAY_SIZE(src_code),
+						      index, src_req_code);
 		}
 		case MEDIA_BUS_FMT_VYUY8_1X16:
 		{
@@ -276,8 +389,8 @@ static u32 vfe_src_pad_code(struct vfe_line *line, u32 sink_code,
 				MEDIA_BUS_FMT_VYUY8_1_5X8,
 			};
 
-			return vfe_find_code(src_code, ARRAY_SIZE(src_code),
-					     index, src_req_code);
+			return camss_format_find_code(src_code, ARRAY_SIZE(src_code),
+						      index, src_req_code);
 		}
 		default:
 			if (index > 0)
@@ -296,7 +409,7 @@ int vfe_reset(struct vfe_device *vfe)
 
 	reinit_completion(&vfe->reset_complete);
 
-	vfe->ops->global_reset(vfe);
+	vfe->res->hw_ops->global_reset(vfe);
 
 	time = wait_for_completion_timeout(&vfe->reset_complete,
 		msecs_to_jiffies(VFE_RESET_TIMEOUT_MS));
@@ -312,7 +425,7 @@ static void vfe_init_outputs(struct vfe_device *vfe)
 {
 	int i;
 
-	for (i = 0; i < vfe->line_num; i++) {
+	for (i = 0; i < vfe->res->line_num; i++) {
 		struct vfe_output *output = &vfe->line[i].output;
 
 		output->state = VFE_OUTPUT_OFF;
@@ -421,7 +534,7 @@ static int vfe_disable_output(struct vfe_line *line)
 
 	spin_lock_irqsave(&vfe->output_lock, flags);
 	for (i = 0; i < output->wm_num; i++)
-		vfe->ops->vfe_wm_stop(vfe, output->wm_idx[i]);
+		vfe->res->hw_ops->vfe_wm_stop(vfe, output->wm_idx[i]);
 	output->gen2.active_num = 0;
 	spin_unlock_irqrestore(&vfe->output_lock, flags);
 
@@ -537,7 +650,7 @@ static int vfe_set_clock_rates(struct vfe_device *vfe)
 	int i, j;
 	int ret;
 
-	for (i = VFE_LINE_RDI0; i < vfe->line_num; i++) {
+	for (i = VFE_LINE_RDI0; i < vfe->res->line_num; i++) {
 		ret = camss_get_pixel_clock(&vfe->line[i].subdev.entity,
 					    &pixel_clock[i]);
 		if (ret)
@@ -551,7 +664,7 @@ static int vfe_set_clock_rates(struct vfe_device *vfe)
 			u64 min_rate = 0;
 			long rate;
 
-			for (j = VFE_LINE_RDI0; j < vfe->line_num; j++) {
+			for (j = VFE_LINE_RDI0; j < vfe->res->line_num; j++) {
 				u32 tmp;
 				u8 bpp;
 
@@ -560,9 +673,9 @@ static int vfe_set_clock_rates(struct vfe_device *vfe)
 				} else {
 					struct vfe_line *l = &vfe->line[j];
 
-					bpp = vfe_get_bpp(l->formats,
-						l->nformats,
-						l->fmt[MSM_VFE_PAD_SINK].code);
+					bpp = camss_format_get_bpp(l->formats,
+								   l->nformats,
+								   l->fmt[MSM_VFE_PAD_SINK].code);
 					tmp = pixel_clock[j] * bpp / 64;
 				}
 
@@ -618,7 +731,7 @@ static int vfe_check_clock_rates(struct vfe_device *vfe)
 	int i, j;
 	int ret;
 
-	for (i = VFE_LINE_RDI0; i < vfe->line_num; i++) {
+	for (i = VFE_LINE_RDI0; i < vfe->res->line_num; i++) {
 		ret = camss_get_pixel_clock(&vfe->line[i].subdev.entity,
 					    &pixel_clock[i]);
 		if (ret)
@@ -632,7 +745,7 @@ static int vfe_check_clock_rates(struct vfe_device *vfe)
 			u64 min_rate = 0;
 			unsigned long rate;
 
-			for (j = VFE_LINE_RDI0; j < vfe->line_num; j++) {
+			for (j = VFE_LINE_RDI0; j < vfe->res->line_num; j++) {
 				u32 tmp;
 				u8 bpp;
 
@@ -641,9 +754,9 @@ static int vfe_check_clock_rates(struct vfe_device *vfe)
 				} else {
 					struct vfe_line *l = &vfe->line[j];
 
-					bpp = vfe_get_bpp(l->formats,
-						l->nformats,
-						l->fmt[MSM_VFE_PAD_SINK].code);
+					bpp = camss_format_get_bpp(l->formats,
+								   l->nformats,
+								   l->fmt[MSM_VFE_PAD_SINK].code);
 					tmp = pixel_clock[j] * bpp / 64;
 				}
 
@@ -675,7 +788,7 @@ int vfe_get(struct vfe_device *vfe)
 	mutex_lock(&vfe->power_lock);
 
 	if (vfe->power_count == 0) {
-		ret = vfe->ops->pm_domain_on(vfe);
+		ret = vfe->res->hw_ops->pm_domain_on(vfe);
 		if (ret < 0)
 			goto error_pm_domain;
 
@@ -700,7 +813,7 @@ int vfe_get(struct vfe_device *vfe)
 
 		vfe_init_outputs(vfe);
 
-		vfe->ops->hw_version(vfe);
+		vfe->res->hw_ops->hw_version(vfe);
 	} else {
 		ret = vfe_check_clock_rates(vfe);
 		if (ret < 0)
@@ -718,7 +831,7 @@ int vfe_get(struct vfe_device *vfe)
 error_pm_runtime_get:
 	pm_runtime_put_sync(vfe->camss->dev);
 error_domain_off:
-	vfe->ops->pm_domain_off(vfe);
+	vfe->res->hw_ops->pm_domain_off(vfe);
 
 error_pm_domain:
 	mutex_unlock(&vfe->power_lock);
@@ -740,11 +853,11 @@ void vfe_put(struct vfe_device *vfe)
 	} else if (vfe->power_count == 1) {
 		if (vfe->was_streaming) {
 			vfe->was_streaming = 0;
-			vfe->ops->vfe_halt(vfe);
+			vfe->res->hw_ops->vfe_halt(vfe);
 		}
 		camss_disable_clocks(vfe->nclocks, vfe->clock);
 		pm_runtime_put_sync(vfe->camss->dev);
-		vfe->ops->pm_domain_off(vfe);
+		vfe->res->hw_ops->pm_domain_off(vfe);
 	}
 
 	vfe->power_count--;
@@ -834,12 +947,12 @@ static int vfe_set_stream(struct v4l2_subdev *sd, int enable)
 
 	if (enable) {
 		line->output.state = VFE_OUTPUT_RESERVED;
-		ret = vfe->ops->vfe_enable(line);
+		ret = vfe->res->hw_ops->vfe_enable(line);
 		if (ret < 0)
 			dev_err(vfe->camss->dev,
 				"Failed to enable vfe outputs\n");
 	} else {
-		ret = vfe->ops->vfe_disable(line);
+		ret = vfe->res->hw_ops->vfe_disable(line);
 		if (ret < 0)
 			dev_err(vfe->camss->dev,
 				"Failed to disable vfe outputs\n");
@@ -1376,23 +1489,24 @@ int msm_vfe_subdev_init(struct camss *camss, struct vfe_device *vfe,
 	int i, j;
 	int ret;
 
-	vfe->ops = res->ops;
-
-	if (!res->line_num)
+	if (!res->vfe.line_num)
 		return -EINVAL;
 
+	vfe->res = &res->vfe;
+	vfe->res->hw_ops->subdev_init(dev, vfe);
+
 	/* Power domain */
 
-	if (res->pd_name) {
+	if (res->vfe.pd_name) {
 		vfe->genpd = dev_pm_domain_attach_by_name(camss->dev,
-							  res->pd_name);
+							  res->vfe.pd_name);
 		if (IS_ERR(vfe->genpd)) {
 			ret = PTR_ERR(vfe->genpd);
 			return ret;
 		}
 	}
 
-	if (!vfe->genpd && res->has_pd) {
+	if (!vfe->genpd && res->vfe.has_pd) {
 		/*
 		 * Legacy magic index.
 		 * Requires
@@ -1409,9 +1523,6 @@ int msm_vfe_subdev_init(struct camss *camss, struct vfe_device *vfe,
 			return PTR_ERR(vfe->genpd);
 	}
 
-	vfe->line_num = res->line_num;
-	vfe->ops->subdev_init(dev, vfe);
-
 	/* Memory */
 
 	vfe->base = devm_platform_ioremap_resource_byname(pdev, res->reg[0]);
@@ -1429,7 +1540,7 @@ int msm_vfe_subdev_init(struct camss *camss, struct vfe_device *vfe,
 	vfe->irq = ret;
 	snprintf(vfe->irq_name, sizeof(vfe->irq_name), "%s_%s%d",
 		 dev_name(dev), MSM_VFE_NAME, id);
-	ret = devm_request_irq(dev, vfe->irq, vfe->ops->isr,
+	ret = devm_request_irq(dev, vfe->irq, vfe->res->hw_ops->isr,
 			       IRQF_TRIGGER_RISING, vfe->irq_name, vfe);
 	if (ret < 0) {
 		dev_err(dev, "request_irq failed: %d\n", ret);
@@ -1488,7 +1599,7 @@ int msm_vfe_subdev_init(struct camss *camss, struct vfe_device *vfe,
 	vfe->id = id;
 	vfe->reg_update = 0;
 
-	for (i = VFE_LINE_RDI0; i < vfe->line_num; i++) {
+	for (i = VFE_LINE_RDI0; i < vfe->res->line_num; i++) {
 		struct vfe_line *l = &vfe->line[i];
 
 		l->video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
@@ -1497,32 +1608,12 @@ int msm_vfe_subdev_init(struct camss *camss, struct vfe_device *vfe,
 		init_completion(&l->output.sof);
 		init_completion(&l->output.reg_update);
 
-		switch (camss->res->version) {
-		case CAMSS_8x16:
-			if (i == VFE_LINE_PIX) {
-				l->formats = formats_pix_8x16;
-				l->nformats = ARRAY_SIZE(formats_pix_8x16);
-			} else {
-				l->formats = formats_rdi_8x16;
-				l->nformats = ARRAY_SIZE(formats_rdi_8x16);
-			}
-			break;
-		case CAMSS_8x96:
-		case CAMSS_660:
-			if (i == VFE_LINE_PIX) {
-				l->formats = formats_pix_8x96;
-				l->nformats = ARRAY_SIZE(formats_pix_8x96);
-			} else {
-				l->formats = formats_rdi_8x96;
-				l->nformats = ARRAY_SIZE(formats_rdi_8x96);
-			}
-			break;
-		case CAMSS_845:
-		case CAMSS_8250:
-		case CAMSS_8280XP:
-			l->formats = formats_rdi_845;
-			l->nformats = ARRAY_SIZE(formats_rdi_845);
-			break;
+		if (i == VFE_LINE_PIX) {
+			l->nformats = res->vfe.formats_pix->nformats;
+			l->formats = res->vfe.formats_pix->formats;
+		} else {
+			l->nformats = res->vfe.formats_rdi->nformats;
+			l->formats = res->vfe.formats_rdi->formats;
 		}
 	}
 
@@ -1603,6 +1694,7 @@ static int vfe_bpl_align(struct vfe_device *vfe)
 
 	switch (vfe->camss->res->version) {
 	case CAMSS_845:
+	case CAMSS_7180:
 	case CAMSS_8250:
 	case CAMSS_8280XP:
 		ret = 16;
@@ -1636,7 +1728,7 @@ int msm_vfe_register_entities(struct vfe_device *vfe,
 	int ret;
 	int i;
 
-	for (i = 0; i < vfe->line_num; i++) {
+	for (i = 0; i < vfe->res->line_num; i++) {
 		char name[32];
 
 		sd = &vfe->line[i].subdev;
@@ -1686,10 +1778,13 @@ int msm_vfe_register_entities(struct vfe_device *vfe,
 			video_out->bpl_alignment = 16;
 			video_out->line_based = 1;
 		}
+
+		video_out->nformats = vfe->line[i].nformats;
+		video_out->formats = vfe->line[i].formats;
+
 		snprintf(name, ARRAY_SIZE(name), "%s%d_%s%d",
 			 MSM_VFE_NAME, vfe->id, "video", i);
-		ret = msm_video_register(video_out, v4l2_dev, name,
-					 i == VFE_LINE_PIX ? 1 : 0);
+		ret = msm_video_register(video_out, v4l2_dev, name);
 		if (ret < 0) {
 			dev_err(dev, "Failed to register video node: %d\n",
 				ret);
@@ -1743,7 +1838,7 @@ void msm_vfe_unregister_entities(struct vfe_device *vfe)
 	mutex_destroy(&vfe->power_lock);
 	mutex_destroy(&vfe->stream_lock);
 
-	for (i = 0; i < vfe->line_num; i++) {
+	for (i = 0; i < vfe->res->line_num; i++) {
 		struct v4l2_subdev *sd = &vfe->line[i].subdev;
 		struct camss_video *video_out = &vfe->line[i].video_out;
 
@@ -1755,5 +1850,5 @@ void msm_vfe_unregister_entities(struct vfe_device *vfe)
 
 bool vfe_is_lite(struct vfe_device *vfe)
 {
-	return vfe->camss->res->vfe_res[vfe->id].is_lite;
+	return vfe->camss->res->vfe_res[vfe->id].vfe.is_lite;
 }
diff --git a/drivers/media/platform/qcom/camss/camss-vfe.h b/drivers/media/platform/qcom/camss/camss-vfe.h
index 0572c9b08e1127..10e2cc3c0b8398 100644
--- a/drivers/media/platform/qcom/camss/camss-vfe.h
+++ b/drivers/media/platform/qcom/camss/camss-vfe.h
@@ -92,7 +92,7 @@ struct vfe_line {
 	struct v4l2_rect crop;
 	struct camss_video video_out;
 	struct vfe_output output;
-	const struct vfe_format *formats;
+	const struct camss_format_info *formats;
 	unsigned int nformats;
 };
 
@@ -126,6 +126,16 @@ struct vfe_isr_ops {
 	void (*wm_done)(struct vfe_device *vfe, u8 wm);
 };
 
+struct vfe_subdev_resources {
+	bool is_lite;
+	u8 line_num;
+	bool has_pd;
+	char *pd_name;
+	const struct vfe_hw_ops *hw_ops;
+	const struct camss_formats *formats_rdi;
+	const struct camss_formats *formats_pix;
+};
+
 struct vfe_device {
 	struct camss *camss;
 	u8 id;
@@ -143,10 +153,9 @@ struct vfe_device {
 	spinlock_t output_lock;
 	enum vfe_line_id wm_output_map[MSM_VFE_IMAGE_MASTERS_NUM];
 	struct vfe_line line[VFE_LINE_NUM_MAX];
-	u8 line_num;
 	u32 reg_update;
 	u8 was_streaming;
-	const struct vfe_hw_ops *ops;
+	const struct vfe_subdev_resources *res;
 	const struct vfe_hw_ops_gen1 *ops_gen1;
 	struct vfe_isr_ops isr_ops;
 	struct camss_video_ops video_ops;
@@ -217,6 +226,13 @@ void vfe_pm_domain_off(struct vfe_device *vfe);
  */
 int vfe_pm_domain_on(struct vfe_device *vfe);
 
+extern const struct camss_formats vfe_formats_rdi_8x16;
+extern const struct camss_formats vfe_formats_pix_8x16;
+extern const struct camss_formats vfe_formats_rdi_8x96;
+extern const struct camss_formats vfe_formats_pix_8x96;
+extern const struct camss_formats vfe_formats_rdi_845;
+extern const struct camss_formats vfe_formats_pix_845;
+
 extern const struct vfe_hw_ops vfe_ops_4_1;
 extern const struct vfe_hw_ops vfe_ops_4_7;
 extern const struct vfe_hw_ops vfe_ops_4_8;
diff --git a/drivers/media/platform/qcom/camss/camss-video.c b/drivers/media/platform/qcom/camss/camss-video.c
index 54cd82f741154c..e9dc5a78e09f1d 100644
--- a/drivers/media/platform/qcom/camss/camss-video.c
+++ b/drivers/media/platform/qcom/camss/camss-video.c
@@ -24,269 +24,10 @@
 #define CAMSS_FRAME_MAX_HEIGHT_RDI	8191
 #define CAMSS_FRAME_MAX_HEIGHT_PIX	4096
 
-struct fract {
-	u8 numerator;
-	u8 denominator;
-};
-
-/*
- * struct camss_format_info - ISP media bus format information
- * @code: V4L2 media bus format code
- * @pixelformat: V4L2 pixel format FCC identifier
- * @planes: Number of planes
- * @hsub: Horizontal subsampling (for each plane)
- * @vsub: Vertical subsampling (for each plane)
- * @bpp: Bits per pixel when stored in memory (for each plane)
- */
-struct camss_format_info {
-	u32 code;
-	u32 pixelformat;
-	u8 planes;
-	struct fract hsub[3];
-	struct fract vsub[3];
-	unsigned int bpp[3];
-};
-
-static const struct camss_format_info formats_rdi_8x16[] = {
-	{ MEDIA_BUS_FMT_UYVY8_1X16, V4L2_PIX_FMT_UYVY, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_VYUY8_1X16, V4L2_PIX_FMT_VYUY, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_YUYV8_1X16, V4L2_PIX_FMT_YUYV, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_YVYU8_1X16, V4L2_PIX_FMT_YVYU, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_SBGGR8_1X8, V4L2_PIX_FMT_SBGGR8, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
-	{ MEDIA_BUS_FMT_SGBRG8_1X8, V4L2_PIX_FMT_SGBRG8, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
-	{ MEDIA_BUS_FMT_SGRBG8_1X8, V4L2_PIX_FMT_SGRBG8, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
-	{ MEDIA_BUS_FMT_SRGGB8_1X8, V4L2_PIX_FMT_SRGGB8, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
-	{ MEDIA_BUS_FMT_SBGGR10_1X10, V4L2_PIX_FMT_SBGGR10P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
-	{ MEDIA_BUS_FMT_SGBRG10_1X10, V4L2_PIX_FMT_SGBRG10P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
-	{ MEDIA_BUS_FMT_SGRBG10_1X10, V4L2_PIX_FMT_SGRBG10P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
-	{ MEDIA_BUS_FMT_SRGGB10_1X10, V4L2_PIX_FMT_SRGGB10P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
-	{ MEDIA_BUS_FMT_SBGGR12_1X12, V4L2_PIX_FMT_SBGGR12P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
-	{ MEDIA_BUS_FMT_SGBRG12_1X12, V4L2_PIX_FMT_SGBRG12P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
-	{ MEDIA_BUS_FMT_SGRBG12_1X12, V4L2_PIX_FMT_SGRBG12P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
-	{ MEDIA_BUS_FMT_SRGGB12_1X12, V4L2_PIX_FMT_SRGGB12P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
-	{ MEDIA_BUS_FMT_Y10_1X10, V4L2_PIX_FMT_Y10P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
-};
-
-static const struct camss_format_info formats_rdi_8x96[] = {
-	{ MEDIA_BUS_FMT_UYVY8_1X16, V4L2_PIX_FMT_UYVY, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_VYUY8_1X16, V4L2_PIX_FMT_VYUY, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_YUYV8_1X16, V4L2_PIX_FMT_YUYV, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_YVYU8_1X16, V4L2_PIX_FMT_YVYU, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_SBGGR8_1X8, V4L2_PIX_FMT_SBGGR8, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
-	{ MEDIA_BUS_FMT_SGBRG8_1X8, V4L2_PIX_FMT_SGBRG8, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
-	{ MEDIA_BUS_FMT_SGRBG8_1X8, V4L2_PIX_FMT_SGRBG8, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
-	{ MEDIA_BUS_FMT_SRGGB8_1X8, V4L2_PIX_FMT_SRGGB8, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
-	{ MEDIA_BUS_FMT_SBGGR10_1X10, V4L2_PIX_FMT_SBGGR10P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
-	{ MEDIA_BUS_FMT_SGBRG10_1X10, V4L2_PIX_FMT_SGBRG10P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
-	{ MEDIA_BUS_FMT_SGRBG10_1X10, V4L2_PIX_FMT_SGRBG10P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
-	{ MEDIA_BUS_FMT_SRGGB10_1X10, V4L2_PIX_FMT_SRGGB10P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
-	{ MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE, V4L2_PIX_FMT_SBGGR10, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_SBGGR12_1X12, V4L2_PIX_FMT_SBGGR12P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
-	{ MEDIA_BUS_FMT_SGBRG12_1X12, V4L2_PIX_FMT_SGBRG12P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
-	{ MEDIA_BUS_FMT_SGRBG12_1X12, V4L2_PIX_FMT_SGRBG12P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
-	{ MEDIA_BUS_FMT_SRGGB12_1X12, V4L2_PIX_FMT_SRGGB12P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
-	{ MEDIA_BUS_FMT_SBGGR14_1X14, V4L2_PIX_FMT_SBGGR14P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 14 } },
-	{ MEDIA_BUS_FMT_SGBRG14_1X14, V4L2_PIX_FMT_SGBRG14P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 14 } },
-	{ MEDIA_BUS_FMT_SGRBG14_1X14, V4L2_PIX_FMT_SGRBG14P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 14 } },
-	{ MEDIA_BUS_FMT_SRGGB14_1X14, V4L2_PIX_FMT_SRGGB14P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 14 } },
-	{ MEDIA_BUS_FMT_Y10_1X10, V4L2_PIX_FMT_Y10P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
-	{ MEDIA_BUS_FMT_Y10_2X8_PADHI_LE, V4L2_PIX_FMT_Y10, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-};
-
-static const struct camss_format_info formats_rdi_845[] = {
-	{ MEDIA_BUS_FMT_UYVY8_1X16, V4L2_PIX_FMT_UYVY, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_VYUY8_1X16, V4L2_PIX_FMT_VYUY, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_YUYV8_1X16, V4L2_PIX_FMT_YUYV, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_YVYU8_1X16, V4L2_PIX_FMT_YVYU, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_SBGGR8_1X8, V4L2_PIX_FMT_SBGGR8, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
-	{ MEDIA_BUS_FMT_SGBRG8_1X8, V4L2_PIX_FMT_SGBRG8, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
-	{ MEDIA_BUS_FMT_SGRBG8_1X8, V4L2_PIX_FMT_SGRBG8, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
-	{ MEDIA_BUS_FMT_SRGGB8_1X8, V4L2_PIX_FMT_SRGGB8, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
-	{ MEDIA_BUS_FMT_SBGGR10_1X10, V4L2_PIX_FMT_SBGGR10P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
-	{ MEDIA_BUS_FMT_SGBRG10_1X10, V4L2_PIX_FMT_SGBRG10P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
-	{ MEDIA_BUS_FMT_SGRBG10_1X10, V4L2_PIX_FMT_SGRBG10P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
-	{ MEDIA_BUS_FMT_SRGGB10_1X10, V4L2_PIX_FMT_SRGGB10P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
-	{ MEDIA_BUS_FMT_SBGGR10_2X8_PADHI_LE, V4L2_PIX_FMT_SBGGR10, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_SBGGR12_1X12, V4L2_PIX_FMT_SBGGR12P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
-	{ MEDIA_BUS_FMT_SGBRG12_1X12, V4L2_PIX_FMT_SGBRG12P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
-	{ MEDIA_BUS_FMT_SGRBG12_1X12, V4L2_PIX_FMT_SGRBG12P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
-	{ MEDIA_BUS_FMT_SRGGB12_1X12, V4L2_PIX_FMT_SRGGB12P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
-	{ MEDIA_BUS_FMT_SBGGR14_1X14, V4L2_PIX_FMT_SBGGR14P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 14 } },
-	{ MEDIA_BUS_FMT_SGBRG14_1X14, V4L2_PIX_FMT_SGBRG14P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 14 } },
-	{ MEDIA_BUS_FMT_SGRBG14_1X14, V4L2_PIX_FMT_SGRBG14P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 14 } },
-	{ MEDIA_BUS_FMT_SRGGB14_1X14, V4L2_PIX_FMT_SRGGB14P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 14 } },
-	{ MEDIA_BUS_FMT_Y8_1X8, V4L2_PIX_FMT_GREY, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
-	{ MEDIA_BUS_FMT_Y10_1X10, V4L2_PIX_FMT_Y10P, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
-	{ MEDIA_BUS_FMT_Y10_2X8_PADHI_LE, V4L2_PIX_FMT_Y10, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-};
-
-static const struct camss_format_info formats_pix_8x16[] = {
-	{ MEDIA_BUS_FMT_YUYV8_1_5X8, V4L2_PIX_FMT_NV12, 1,
-	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
-	{ MEDIA_BUS_FMT_YVYU8_1_5X8, V4L2_PIX_FMT_NV12, 1,
-	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
-	{ MEDIA_BUS_FMT_UYVY8_1_5X8, V4L2_PIX_FMT_NV12, 1,
-	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
-	{ MEDIA_BUS_FMT_VYUY8_1_5X8, V4L2_PIX_FMT_NV12, 1,
-	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
-	{ MEDIA_BUS_FMT_YUYV8_1_5X8, V4L2_PIX_FMT_NV21, 1,
-	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
-	{ MEDIA_BUS_FMT_YVYU8_1_5X8, V4L2_PIX_FMT_NV21, 1,
-	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
-	{ MEDIA_BUS_FMT_UYVY8_1_5X8, V4L2_PIX_FMT_NV21, 1,
-	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
-	{ MEDIA_BUS_FMT_VYUY8_1_5X8, V4L2_PIX_FMT_NV21, 1,
-	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
-	{ MEDIA_BUS_FMT_YUYV8_1X16, V4L2_PIX_FMT_NV16, 1,
-	  { { 1, 1 } }, { { 1, 2 } }, { 8 } },
-	{ MEDIA_BUS_FMT_YVYU8_1X16, V4L2_PIX_FMT_NV16, 1,
-	  { { 1, 1 } }, { { 1, 2 } }, { 8 } },
-	{ MEDIA_BUS_FMT_UYVY8_1X16, V4L2_PIX_FMT_NV16, 1,
-	  { { 1, 1 } }, { { 1, 2 } }, { 8 } },
-	{ MEDIA_BUS_FMT_VYUY8_1X16, V4L2_PIX_FMT_NV16, 1,
-	  { { 1, 1 } }, { { 1, 2 } }, { 8 } },
-	{ MEDIA_BUS_FMT_YUYV8_1X16, V4L2_PIX_FMT_NV61, 1,
-	  { { 1, 1 } }, { { 1, 2 } }, { 8 } },
-	{ MEDIA_BUS_FMT_YVYU8_1X16, V4L2_PIX_FMT_NV61, 1,
-	  { { 1, 1 } }, { { 1, 2 } }, { 8 } },
-	{ MEDIA_BUS_FMT_UYVY8_1X16, V4L2_PIX_FMT_NV61, 1,
-	  { { 1, 1 } }, { { 1, 2 } }, { 8 } },
-	{ MEDIA_BUS_FMT_VYUY8_1X16, V4L2_PIX_FMT_NV61, 1,
-	  { { 1, 1 } }, { { 1, 2 } }, { 8 } },
-};
-
-static const struct camss_format_info formats_pix_8x96[] = {
-	{ MEDIA_BUS_FMT_YUYV8_1_5X8, V4L2_PIX_FMT_NV12, 1,
-	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
-	{ MEDIA_BUS_FMT_YVYU8_1_5X8, V4L2_PIX_FMT_NV12, 1,
-	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
-	{ MEDIA_BUS_FMT_UYVY8_1_5X8, V4L2_PIX_FMT_NV12, 1,
-	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
-	{ MEDIA_BUS_FMT_VYUY8_1_5X8, V4L2_PIX_FMT_NV12, 1,
-	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
-	{ MEDIA_BUS_FMT_YUYV8_1_5X8, V4L2_PIX_FMT_NV21, 1,
-	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
-	{ MEDIA_BUS_FMT_YVYU8_1_5X8, V4L2_PIX_FMT_NV21, 1,
-	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
-	{ MEDIA_BUS_FMT_UYVY8_1_5X8, V4L2_PIX_FMT_NV21, 1,
-	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
-	{ MEDIA_BUS_FMT_VYUY8_1_5X8, V4L2_PIX_FMT_NV21, 1,
-	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
-	{ MEDIA_BUS_FMT_YUYV8_1X16, V4L2_PIX_FMT_NV16, 1,
-	  { { 1, 1 } }, { { 1, 2 } }, { 8 } },
-	{ MEDIA_BUS_FMT_YVYU8_1X16, V4L2_PIX_FMT_NV16, 1,
-	  { { 1, 1 } }, { { 1, 2 } }, { 8 } },
-	{ MEDIA_BUS_FMT_UYVY8_1X16, V4L2_PIX_FMT_NV16, 1,
-	  { { 1, 1 } }, { { 1, 2 } }, { 8 } },
-	{ MEDIA_BUS_FMT_VYUY8_1X16, V4L2_PIX_FMT_NV16, 1,
-	  { { 1, 1 } }, { { 1, 2 } }, { 8 } },
-	{ MEDIA_BUS_FMT_YUYV8_1X16, V4L2_PIX_FMT_NV61, 1,
-	  { { 1, 1 } }, { { 1, 2 } }, { 8 } },
-	{ MEDIA_BUS_FMT_YVYU8_1X16, V4L2_PIX_FMT_NV61, 1,
-	  { { 1, 1 } }, { { 1, 2 } }, { 8 } },
-	{ MEDIA_BUS_FMT_UYVY8_1X16, V4L2_PIX_FMT_NV61, 1,
-	  { { 1, 1 } }, { { 1, 2 } }, { 8 } },
-	{ MEDIA_BUS_FMT_VYUY8_1X16, V4L2_PIX_FMT_NV61, 1,
-	  { { 1, 1 } }, { { 1, 2 } }, { 8 } },
-	{ MEDIA_BUS_FMT_UYVY8_1X16, V4L2_PIX_FMT_UYVY, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_VYUY8_1X16, V4L2_PIX_FMT_VYUY, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_YUYV8_1X16, V4L2_PIX_FMT_YUYV, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-	{ MEDIA_BUS_FMT_YVYU8_1X16, V4L2_PIX_FMT_YVYU, 1,
-	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
-};
-
 /* -----------------------------------------------------------------------------
  * Helper functions
  */
 
-static int video_find_format(u32 code, u32 pixelformat,
-			     const struct camss_format_info *formats,
-			     unsigned int nformats)
-{
-	int i;
-
-	for (i = 0; i < nformats; i++) {
-		if (formats[i].code == code &&
-		    formats[i].pixelformat == pixelformat)
-			return i;
-	}
-
-	for (i = 0; i < nformats; i++)
-		if (formats[i].code == code)
-			return i;
-
-	WARN_ON(1);
-
-	return -EINVAL;
-}
-
 /*
  * video_mbus_to_pix_mp - Convert v4l2_mbus_framefmt to v4l2_pix_format_mplane
  * @mbus: v4l2_mbus_framefmt format (input)
@@ -359,9 +100,8 @@ static int video_get_subdev_format(struct camss_video *video,
 	if (ret)
 		return ret;
 
-	ret = video_find_format(fmt.format.code,
-				format->fmt.pix_mp.pixelformat,
-				video->formats, video->nformats);
+	ret = camss_format_find_format(fmt.format.code, format->fmt.pix_mp.pixelformat,
+				       video->formats, video->nformats);
 	if (ret < 0)
 		return ret;
 
@@ -472,15 +212,20 @@ static int video_check_format(struct camss_video *video)
 
 	sd_pix->pixelformat = pix->pixelformat;
 	ret = video_get_subdev_format(video, &format);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(video->camss->dev, "Failed to get subdev format");
 		return ret;
+	}
 
 	if (pix->pixelformat != sd_pix->pixelformat ||
 	    pix->height != sd_pix->height ||
 	    pix->width != sd_pix->width ||
 	    pix->num_planes != sd_pix->num_planes ||
-	    pix->field != format.fmt.pix_mp.field)
+	    pix->field != format.fmt.pix_mp.field) {
+		dev_err(video->camss->dev, "pix: pfmt=%c%c%c%c, height=%u, width=%u, planes=%u, field=%u", pix->pixelformat, pix->pixelformat >> 8, pix->pixelformat >> 16, pix->pixelformat >> 24, pix->height, pix->width, pix->num_planes, pix->field);
+		dev_err(video->camss->dev, "sd_pix: pfmt=%c%c%c%c, height=%u, width=%u, planes=%u, field=%u", sd_pix->pixelformat, sd_pix->pixelformat >> 8, sd_pix->pixelformat >> 16, sd_pix->pixelformat >> 24, sd_pix->height, sd_pix->width, sd_pix->num_planes, sd_pix->field);
 		return -EPIPE;
+	}
 
 	return 0;
 }
@@ -501,8 +246,10 @@ static int video_start_streaming(struct vb2_queue *q, unsigned int count)
 	}
 
 	ret = video_check_format(video);
-	if (ret < 0)
+	if (ret < 0) {
+		dev_err(video->camss->dev, "Failed to check format: %d\n", ret);
 		goto error;
+	}
 
 	entity = &vdev->entity;
 	while (1) {
@@ -557,11 +304,11 @@ static void video_stop_streaming(struct vb2_queue *q)
 
 		ret = v4l2_subdev_call(subdev, video, s_stream, 0);
 
-		if (entity->use_count > 1) {
-			/* Don't stop if other instances of the pipeline are still running */
-			dev_dbg(video->camss->dev, "Video pipeline still used, don't stop streaming.\n");
-			return;
-		}
+		// if (entity->use_count > 1) {
+		// 	/* Don't stop if other instances of the pipeline are still running */
+		// 	dev_dbg(video->camss->dev, "Video pipeline still used, don't stop streaming.\n");
+		// 	return;
+		// }
 
 		if (ret) {
 			dev_err(video->camss->dev, "Video pipeline stop failed: %d\n", ret);
@@ -969,7 +716,7 @@ static int msm_video_init_format(struct camss_video *video)
  */
 
 int msm_video_register(struct camss_video *video, struct v4l2_device *v4l2_dev,
-		       const char *name, int is_pix)
+		       const char *name)
 {
 	struct media_pad *pad = &video->pad;
 	struct video_device *vdev;
@@ -1006,34 +753,6 @@ int msm_video_register(struct camss_video *video, struct v4l2_device *v4l2_dev,
 
 	mutex_init(&video->lock);
 
-	switch (video->camss->res->version) {
-	case CAMSS_8x16:
-		if (is_pix) {
-			video->formats = formats_pix_8x16;
-			video->nformats = ARRAY_SIZE(formats_pix_8x16);
-		} else {
-			video->formats = formats_rdi_8x16;
-			video->nformats = ARRAY_SIZE(formats_rdi_8x16);
-		}
-		break;
-	case CAMSS_8x96:
-	case CAMSS_660:
-		if (is_pix) {
-			video->formats = formats_pix_8x96;
-			video->nformats = ARRAY_SIZE(formats_pix_8x96);
-		} else {
-			video->formats = formats_rdi_8x96;
-			video->nformats = ARRAY_SIZE(formats_rdi_8x96);
-		}
-		break;
-	case CAMSS_845:
-	case CAMSS_8250:
-	case CAMSS_8280XP:
-		video->formats = formats_rdi_845;
-		video->nformats = ARRAY_SIZE(formats_rdi_845);
-		break;
-	}
-
 	ret = msm_video_init_format(video);
 	if (ret < 0) {
 		dev_err(v4l2_dev->dev, "Failed to init format: %d\n", ret);
diff --git a/drivers/media/platform/qcom/camss/camss-video.h b/drivers/media/platform/qcom/camss/camss-video.h
index bdbae84241403d..d3e56e240a8880 100644
--- a/drivers/media/platform/qcom/camss/camss-video.h
+++ b/drivers/media/platform/qcom/camss/camss-video.h
@@ -33,8 +33,6 @@ struct camss_video_ops {
 			     enum vb2_buffer_state state);
 };
 
-struct camss_format_info;
-
 struct camss_video {
 	struct camss *camss;
 	struct vb2_queue vb2_q;
@@ -53,7 +51,7 @@ struct camss_video {
 };
 
 int msm_video_register(struct camss_video *video, struct v4l2_device *v4l2_dev,
-		       const char *name, int is_pix);
+		       const char *name);
 
 void msm_video_unregister(struct camss_video *video);
 
diff --git a/drivers/media/platform/qcom/camss/camss.c b/drivers/media/platform/qcom/camss/camss.c
index 1923615f0eea7c..fab841faa5ce5d 100644
--- a/drivers/media/platform/qcom/camss/camss.c
+++ b/drivers/media/platform/qcom/camss/camss.c
@@ -32,6 +32,8 @@
 #define CAMSS_CLOCK_MARGIN_NUMERATOR 105
 #define CAMSS_CLOCK_MARGIN_DENOMINATOR 100
 
+static const struct parent_dev_ops vfe_parent_dev_ops;
+
 static const struct camss_subdev_resources csiphy_res_8x16[] = {
 	/* CSIPHY0 */
 	{
@@ -43,7 +45,10 @@ static const struct camss_subdev_resources csiphy_res_8x16[] = {
 				{ 100000000, 200000000 } },
 		.reg = { "csiphy0", "csiphy0_clk_mux" },
 		.interrupt = { "csiphy0" },
-		.ops = &csiphy_ops_2ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_2ph_1_0,
+			.formats = &csiphy_formats_8x16
+		}
 	},
 
 	/* CSIPHY1 */
@@ -56,7 +61,10 @@ static const struct camss_subdev_resources csiphy_res_8x16[] = {
 				{ 100000000, 200000000 } },
 		.reg = { "csiphy1", "csiphy1_clk_mux" },
 		.interrupt = { "csiphy1" },
-		.ops = &csiphy_ops_2ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_2ph_1_0,
+			.formats = &csiphy_formats_8x16
+		}
 	}
 };
 
@@ -76,7 +84,11 @@ static const struct camss_subdev_resources csid_res_8x16[] = {
 				{ 0 } },
 		.reg = { "csid0" },
 		.interrupt = { "csid0" },
-		.ops = &csid_ops_4_1,
+		.csid = {
+			.hw_ops = &csid_ops_4_1,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_4_1
+		}
 	},
 
 	/* CSID1 */
@@ -94,7 +106,11 @@ static const struct camss_subdev_resources csid_res_8x16[] = {
 				{ 0 } },
 		.reg = { "csid1" },
 		.interrupt = { "csid1" },
-		.ops = &csid_ops_4_1,
+		.csid = {
+			.hw_ops = &csid_ops_4_1,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_4_1
+		}
 	},
 };
 
@@ -105,8 +121,7 @@ static const struct camss_subdev_resources ispif_res_8x16 = {
 		   "csi1", "csi1_pix", "csi1_rdi" },
 	.clock_for_reset = { "vfe0", "csi_vfe0" },
 	.reg = { "ispif", "csi_clk_mux" },
-	.interrupt = { "ispif" }
-
+	.interrupt = { "ispif" },
 };
 
 static const struct camss_subdev_resources vfe_res_8x16[] = {
@@ -128,8 +143,12 @@ static const struct camss_subdev_resources vfe_res_8x16[] = {
 				{ 0 } },
 		.reg = { "vfe0" },
 		.interrupt = { "vfe0" },
-		.line_num = 3,
-		.ops = &vfe_ops_4_1
+		.vfe = {
+			.line_num = 3,
+			.hw_ops = &vfe_ops_4_1,
+			.formats_rdi = &vfe_formats_rdi_8x16,
+			.formats_pix = &vfe_formats_pix_8x16
+		}
 	}
 };
 
@@ -144,7 +163,10 @@ static const struct camss_subdev_resources csiphy_res_8x96[] = {
 				{ 100000000, 200000000, 266666667 } },
 		.reg = { "csiphy0", "csiphy0_clk_mux" },
 		.interrupt = { "csiphy0" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_8x96
+		}
 	},
 
 	/* CSIPHY1 */
@@ -157,7 +179,10 @@ static const struct camss_subdev_resources csiphy_res_8x96[] = {
 				{ 100000000, 200000000, 266666667 } },
 		.reg = { "csiphy1", "csiphy1_clk_mux" },
 		.interrupt = { "csiphy1" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_8x96
+		}
 	},
 
 	/* CSIPHY2 */
@@ -170,7 +195,10 @@ static const struct camss_subdev_resources csiphy_res_8x96[] = {
 				{ 100000000, 200000000, 266666667 } },
 		.reg = { "csiphy2", "csiphy2_clk_mux" },
 		.interrupt = { "csiphy2" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_8x96
+		}
 	}
 };
 
@@ -190,7 +218,11 @@ static const struct camss_subdev_resources csid_res_8x96[] = {
 				{ 0 } },
 		.reg = { "csid0" },
 		.interrupt = { "csid0" },
-		.ops = &csid_ops_4_7,
+		.csid = {
+			.hw_ops = &csid_ops_4_7,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_4_7
+		}
 	},
 
 	/* CSID1 */
@@ -208,7 +240,11 @@ static const struct camss_subdev_resources csid_res_8x96[] = {
 				{ 0 } },
 		.reg = { "csid1" },
 		.interrupt = { "csid1" },
-		.ops = &csid_ops_4_7,
+		.csid = {
+			.hw_ops = &csid_ops_4_7,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_4_7
+		}
 	},
 
 	/* CSID2 */
@@ -226,7 +262,11 @@ static const struct camss_subdev_resources csid_res_8x96[] = {
 				{ 0 } },
 		.reg = { "csid2" },
 		.interrupt = { "csid2" },
-		.ops = &csid_ops_4_7,
+		.csid = {
+			.hw_ops = &csid_ops_4_7,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_4_7
+		}
 	},
 
 	/* CSID3 */
@@ -244,7 +284,11 @@ static const struct camss_subdev_resources csid_res_8x96[] = {
 				{ 0 } },
 		.reg = { "csid3" },
 		.interrupt = { "csid3" },
-		.ops = &csid_ops_4_7,
+		.csid = {
+			.hw_ops = &csid_ops_4_7,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_4_7
+		}
 	}
 };
 
@@ -257,7 +301,7 @@ static const struct camss_subdev_resources ispif_res_8x96 = {
 		   "csi3", "csi3_pix", "csi3_rdi" },
 	.clock_for_reset = { "vfe0", "csi_vfe0", "vfe1", "csi_vfe1" },
 	.reg = { "ispif", "csi_clk_mux" },
-	.interrupt = { "ispif" }
+	.interrupt = { "ispif" },
 };
 
 static const struct camss_subdev_resources vfe_res_8x96[] = {
@@ -277,9 +321,13 @@ static const struct camss_subdev_resources vfe_res_8x96[] = {
 				{ 0 } },
 		.reg = { "vfe0" },
 		.interrupt = { "vfe0" },
-		.line_num = 3,
-		.has_pd = true,
-		.ops = &vfe_ops_4_7
+		.vfe = {
+			.line_num = 3,
+			.has_pd = true,
+			.hw_ops = &vfe_ops_4_7,
+			.formats_rdi = &vfe_formats_rdi_8x96,
+			.formats_pix = &vfe_formats_pix_8x96
+		}
 	},
 
 	/* VFE1 */
@@ -298,9 +346,13 @@ static const struct camss_subdev_resources vfe_res_8x96[] = {
 				{ 0 } },
 		.reg = { "vfe1" },
 		.interrupt = { "vfe1" },
-		.line_num = 3,
-		.has_pd = true,
-		.ops = &vfe_ops_4_7
+		.vfe = {
+			.line_num = 3,
+			.has_pd = true,
+			.hw_ops = &vfe_ops_4_7,
+			.formats_rdi = &vfe_formats_rdi_8x96,
+			.formats_pix = &vfe_formats_pix_8x96
+		}
 	}
 };
 
@@ -317,7 +369,10 @@ static const struct camss_subdev_resources csiphy_res_660[] = {
 				{ 0 } },
 		.reg = { "csiphy0", "csiphy0_clk_mux" },
 		.interrupt = { "csiphy0" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_8x96
+		}
 	},
 
 	/* CSIPHY1 */
@@ -332,7 +387,10 @@ static const struct camss_subdev_resources csiphy_res_660[] = {
 				{ 0 } },
 		.reg = { "csiphy1", "csiphy1_clk_mux" },
 		.interrupt = { "csiphy1" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_8x96
+		}
 	},
 
 	/* CSIPHY2 */
@@ -347,7 +405,10 @@ static const struct camss_subdev_resources csiphy_res_660[] = {
 				{ 0 } },
 		.reg = { "csiphy2", "csiphy2_clk_mux" },
 		.interrupt = { "csiphy2" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_8x96
+		}
 	}
 };
 
@@ -370,7 +431,11 @@ static const struct camss_subdev_resources csid_res_660[] = {
 				{ 0 } },
 		.reg = { "csid0" },
 		.interrupt = { "csid0" },
-		.ops = &csid_ops_4_7,
+		.csid = {
+			.hw_ops = &csid_ops_4_7,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_4_7
+		}
 	},
 
 	/* CSID1 */
@@ -391,7 +456,11 @@ static const struct camss_subdev_resources csid_res_660[] = {
 				{ 0 } },
 		.reg = { "csid1" },
 		.interrupt = { "csid1" },
-		.ops = &csid_ops_4_7,
+		.csid = {
+			.hw_ops = &csid_ops_4_7,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_4_7
+		}
 	},
 
 	/* CSID2 */
@@ -412,7 +481,11 @@ static const struct camss_subdev_resources csid_res_660[] = {
 				{ 0 } },
 		.reg = { "csid2" },
 		.interrupt = { "csid2" },
-		.ops = &csid_ops_4_7,
+		.csid = {
+			.hw_ops = &csid_ops_4_7,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_4_7
+		}
 	},
 
 	/* CSID3 */
@@ -433,7 +506,11 @@ static const struct camss_subdev_resources csid_res_660[] = {
 				{ 0 } },
 		.reg = { "csid3" },
 		.interrupt = { "csid3" },
-		.ops = &csid_ops_4_7,
+		.csid = {
+			.hw_ops = &csid_ops_4_7,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_4_7
+		}
 	}
 };
 
@@ -446,7 +523,7 @@ static const struct camss_subdev_resources ispif_res_660 = {
 		   "csi3", "csi3_pix", "csi3_rdi" },
 	.clock_for_reset = { "vfe0", "csi_vfe0", "vfe1", "csi_vfe1" },
 	.reg = { "ispif", "csi_clk_mux" },
-	.interrupt = { "ispif" }
+	.interrupt = { "ispif" },
 };
 
 static const struct camss_subdev_resources vfe_res_660[] = {
@@ -469,9 +546,13 @@ static const struct camss_subdev_resources vfe_res_660[] = {
 				{ 0 } },
 		.reg = { "vfe0" },
 		.interrupt = { "vfe0" },
-		.line_num = 3,
-		.has_pd = true,
-		.ops = &vfe_ops_4_8
+		.vfe = {
+			.line_num = 3,
+			.has_pd = true,
+			.hw_ops = &vfe_ops_4_8,
+			.formats_rdi = &vfe_formats_rdi_8x96,
+			.formats_pix = &vfe_formats_pix_8x96
+		}
 	},
 
 	/* VFE1 */
@@ -493,9 +574,13 @@ static const struct camss_subdev_resources vfe_res_660[] = {
 				{ 0 } },
 		.reg = { "vfe1" },
 		.interrupt = { "vfe1" },
-		.line_num = 3,
-		.has_pd = true,
-		.ops = &vfe_ops_4_8
+		.vfe = {
+			.line_num = 3,
+			.has_pd = true,
+			.hw_ops = &vfe_ops_4_8,
+			.formats_rdi = &vfe_formats_rdi_8x96,
+			.formats_pix = &vfe_formats_pix_8x96
+		}
 	}
 };
 
@@ -516,7 +601,10 @@ static const struct camss_subdev_resources csiphy_res_845[] = {
 				{ 19200000, 240000000, 269333333 } },
 		.reg = { "csiphy0" },
 		.interrupt = { "csiphy0" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
 	},
 
 	/* CSIPHY1 */
@@ -535,7 +623,10 @@ static const struct camss_subdev_resources csiphy_res_845[] = {
 				{ 19200000, 240000000, 269333333 } },
 		.reg = { "csiphy1" },
 		.interrupt = { "csiphy1" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
 	},
 
 	/* CSIPHY2 */
@@ -554,7 +645,10 @@ static const struct camss_subdev_resources csiphy_res_845[] = {
 				{ 19200000, 240000000, 269333333 } },
 		.reg = { "csiphy2" },
 		.interrupt = { "csiphy2" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
 	},
 
 	/* CSIPHY3 */
@@ -573,7 +667,10 @@ static const struct camss_subdev_resources csiphy_res_845[] = {
 				{ 19200000, 240000000, 269333333 } },
 		.reg = { "csiphy3" },
 		.interrupt = { "csiphy3" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
 	}
 };
 
@@ -596,7 +693,11 @@ static const struct camss_subdev_resources csid_res_845[] = {
 				{ 384000000 } },
 		.reg = { "csid0" },
 		.interrupt = { "csid0" },
-		.ops = &csid_ops_gen2
+		.csid = {
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
 	},
 
 	/* CSID1 */
@@ -617,7 +718,11 @@ static const struct camss_subdev_resources csid_res_845[] = {
 				{ 384000000 } },
 		.reg = { "csid1" },
 		.interrupt = { "csid1" },
-		.ops = &csid_ops_gen2
+		.csid = {
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
 	},
 
 	/* CSID2 */
@@ -638,8 +743,12 @@ static const struct camss_subdev_resources csid_res_845[] = {
 				{ 384000000 } },
 		.reg = { "csid2" },
 		.interrupt = { "csid2" },
-		.is_lite = true,
-		.ops = &csid_ops_gen2
+		.csid = {
+			.is_lite = true,
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
 	}
 };
 
@@ -662,9 +771,13 @@ static const struct camss_subdev_resources vfe_res_845[] = {
 				{ 384000000 } },
 		.reg = { "vfe0" },
 		.interrupt = { "vfe0" },
-		.line_num = 4,
-		.has_pd = true,
-		.ops = &vfe_ops_170
+		.vfe = {
+			.line_num = 4,
+			.has_pd = true,
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
 	},
 
 	/* VFE1 */
@@ -685,9 +798,13 @@ static const struct camss_subdev_resources vfe_res_845[] = {
 				{ 384000000 } },
 		.reg = { "vfe1" },
 		.interrupt = { "vfe1" },
-		.line_num = 4,
-		.has_pd = true,
-		.ops = &vfe_ops_170
+		.vfe = {
+			.line_num = 4,
+			.has_pd = true,
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
 	},
 
 	/* VFE-lite */
@@ -707,9 +824,13 @@ static const struct camss_subdev_resources vfe_res_845[] = {
 				{ 384000000 } },
 		.reg = { "vfe_lite" },
 		.interrupt = { "vfe_lite" },
-		.is_lite = true,
-		.line_num = 4,
-		.ops = &vfe_ops_170
+		.vfe = {
+			.is_lite = true,
+			.line_num = 4,
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
 	}
 };
 
@@ -722,7 +843,10 @@ static const struct camss_subdev_resources csiphy_res_8250[] = {
 				{ 300000000 } },
 		.reg = { "csiphy0" },
 		.interrupt = { "csiphy0" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
 	},
 	/* CSIPHY1 */
 	{
@@ -732,7 +856,10 @@ static const struct camss_subdev_resources csiphy_res_8250[] = {
 				{ 300000000 } },
 		.reg = { "csiphy1" },
 		.interrupt = { "csiphy1" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
 	},
 	/* CSIPHY2 */
 	{
@@ -742,7 +869,10 @@ static const struct camss_subdev_resources csiphy_res_8250[] = {
 				{ 300000000 } },
 		.reg = { "csiphy2" },
 		.interrupt = { "csiphy2" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
 	},
 	/* CSIPHY3 */
 	{
@@ -752,7 +882,10 @@ static const struct camss_subdev_resources csiphy_res_8250[] = {
 				{ 300000000 } },
 		.reg = { "csiphy3" },
 		.interrupt = { "csiphy3" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
 	},
 	/* CSIPHY4 */
 	{
@@ -762,7 +895,10 @@ static const struct camss_subdev_resources csiphy_res_8250[] = {
 				{ 300000000 } },
 		.reg = { "csiphy4" },
 		.interrupt = { "csiphy4" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
 	},
 	/* CSIPHY5 */
 	{
@@ -772,7 +908,10 @@ static const struct camss_subdev_resources csiphy_res_8250[] = {
 				{ 300000000 } },
 		.reg = { "csiphy5" },
 		.interrupt = { "csiphy5" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
 	}
 };
 
@@ -788,7 +927,11 @@ static const struct camss_subdev_resources csid_res_8250[] = {
 				{ 0 } },
 		.reg = { "csid0" },
 		.interrupt = { "csid0" },
-		.ops = &csid_ops_gen2
+		.csid = {
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
 	},
 	/* CSID1 */
 	{
@@ -801,7 +944,11 @@ static const struct camss_subdev_resources csid_res_8250[] = {
 				{ 0 } },
 		.reg = { "csid1" },
 		.interrupt = { "csid1" },
-		.ops = &csid_ops_gen2
+		.csid = {
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
 	},
 	/* CSID2 */
 	{
@@ -813,8 +960,12 @@ static const struct camss_subdev_resources csid_res_8250[] = {
 				{ 0 } },
 		.reg = { "csid2" },
 		.interrupt = { "csid2" },
-		.is_lite = true,
-		.ops = &csid_ops_gen2
+		.csid = {
+			.is_lite = true,
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
 	},
 	/* CSID3 */
 	{
@@ -826,8 +977,12 @@ static const struct camss_subdev_resources csid_res_8250[] = {
 				{ 0 } },
 		.reg = { "csid3" },
 		.interrupt = { "csid3" },
-		.is_lite = true,
-		.ops = &csid_ops_gen2
+		.csid = {
+			.is_lite = true,
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
 	}
 };
 
@@ -849,10 +1004,14 @@ static const struct camss_subdev_resources vfe_res_8250[] = {
 				{ 0 } },
 		.reg = { "vfe0" },
 		.interrupt = { "vfe0" },
-		.pd_name = "ife0",
-		.line_num = 3,
-		.has_pd = true,
-		.ops = &vfe_ops_480
+		.vfe = {
+			.line_num = 3,
+			.has_pd = true,
+			.pd_name = "ife0",
+			.hw_ops = &vfe_ops_480,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
 	},
 	/* VFE1 */
 	{
@@ -871,10 +1030,14 @@ static const struct camss_subdev_resources vfe_res_8250[] = {
 				{ 0 } },
 		.reg = { "vfe1" },
 		.interrupt = { "vfe1" },
-		.pd_name = "ife1",
-		.line_num = 3,
-		.has_pd = true,
-		.ops = &vfe_ops_480
+		.vfe = {
+			.line_num = 3,
+			.has_pd = true,
+			.pd_name = "ife1",
+			.hw_ops = &vfe_ops_480,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
 	},
 	/* VFE2 (lite) */
 	{
@@ -892,9 +1055,13 @@ static const struct camss_subdev_resources vfe_res_8250[] = {
 				{ 0 } },
 		.reg = { "vfe_lite0" },
 		.interrupt = { "vfe_lite0" },
-		.is_lite = true,
-		.line_num = 4,
-		.ops = &vfe_ops_480
+		.vfe = {
+			.is_lite = true,
+			.line_num = 4,
+			.hw_ops = &vfe_ops_480,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
 	},
 	/* VFE3 (lite) */
 	{
@@ -912,9 +1079,13 @@ static const struct camss_subdev_resources vfe_res_8250[] = {
 				{ 0 } },
 		.reg = { "vfe_lite1" },
 		.interrupt = { "vfe_lite1" },
-		.is_lite = true,
-		.line_num = 4,
-		.ops = &vfe_ops_480
+		.vfe = {
+			.is_lite = true,
+			.line_num = 4,
+			.hw_ops = &vfe_ops_480,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
 	},
 };
 
@@ -941,6 +1112,267 @@ static const struct resources_icc icc_res_sm8250[] = {
 	},
 };
 
+static const struct camss_subdev_resources csiphy_res_7180[] = {
+	/* CSIPHY0 */
+	{
+		.regulators = {},
+		.clock = {
+			"csiphy0",
+			"csiphy0_timer"
+		},
+		.clock_rate = {
+			{ 150000000, 270000000, 360000000 },
+			{ 300000000 },
+		},
+		.reg = { "csiphy0" },
+		.interrupt = { "csiphy0" },
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
+	},
+	/* CSIPHY1 */
+	{
+		.regulators = {},
+		.clock = {
+			"csiphy1",
+			"csiphy1_timer"
+		},
+		.clock_rate = {
+			{ 150000000, 270000000, 360000000 },
+			{ 300000000 },
+		},
+		.reg = { "csiphy1" },
+		.interrupt = { "csiphy1" },
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
+	},
+	/* CSIPHY2 */
+	{
+		.regulators = {},
+		.clock = {
+			"csiphy2",
+			"csiphy2_timer"
+		},
+		.clock_rate = {
+			{ 150000000, 270000000, 360000000 },
+			{ 300000000 },
+		},
+		.reg = { "csiphy2" },
+		.interrupt = { "csiphy2" },
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
+	},
+	/* CSIPHY3 */
+	{
+		.regulators = {},
+		.clock = {
+			"csiphy3",
+			"csiphy3_timer"
+		},
+		.clock_rate = {
+			{ 150000000, 270000000, 360000000 },
+			{ 300000000 },
+		},
+		.reg = { "csiphy3" },
+		.interrupt = { "csiphy3" },
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
+	}
+};
+
+static const struct camss_subdev_resources csid_res_7180[] = {
+	/* CSID0 */
+	{
+		.regulators = { "vdda-phy", "vdda-pll" },
+		.clock = {
+			"soc_ahb",
+			"vfe0",
+			"vfe0_cphy_rx",
+			"csi0"
+		},
+		.clock_rate = {
+			{ 0 },
+			{ 240000000, 360000000, 432000000, 600000000 },
+			{ 150000000, 270000000, 360000000 },
+			{ 150000000, 270000000, 360000000, 480000000 },
+		},
+		.reg = { "csid0" },
+		.interrupt = { "csid0" },
+		.csid = {
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
+	},
+	/* CSID1 */
+	{
+		.regulators = { "vdda-phy", "vdda-pll" },
+		.clock = {
+			"soc_ahb",
+			"vfe1",
+			"vfe1_cphy_rx",
+			"csi1",
+		},
+		.clock_rate = {
+			{ 0 },
+			{ 240000000, 360000000, 432000000, 600000000 },
+			{ 150000000, 270000000, 360000000 },
+			{ 150000000, 270000000, 360000000, 480000000 },
+		},
+		.reg = { "csid1" },
+		.interrupt = { "csid1" },
+		.csid = {
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
+	},
+	/* CSID2 */
+	{
+		.regulators = { "vdda-phy", "vdda-pll" },
+		.clock = {
+			"soc_ahb",
+			"vfe_lite",
+			"vfe_lite_cphy_rx",
+			"csi2",
+		},
+		.clock_rate = {
+			{ 0 },
+			{ 240000000, 360000000, 432000000, 600000000 },
+			{ 150000000, 270000000, 360000000 },
+			{ 150000000, 270000000, 360000000, 480000000 },
+		},
+		.reg = { "csid2" },
+		.interrupt = { "csid2" },
+		.csid = {
+			.is_lite = true,
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
+	}
+};
+
+static const struct camss_subdev_resources vfe_res_7180[] = {
+	/* VFE0 */
+	{
+		.regulators = {},
+		.clock = {
+			"camnoc_axi",
+			"cpas_ahb",
+			"soc_ahb",
+			"vfe0",
+			"vfe0_axi",
+			"csi0",
+		},
+		.clock_rate = {
+			{ 0 },
+			{ 0 },
+			{ 0 },
+			{ 19200000, 240000000, 360000000, 432000000, 600000000 },
+			{ 0 },
+			{ 150000000, 270000000, 360000000, 480000000 },
+		},
+		.reg = { "vfe0" },
+		.interrupt = { "vfe0" },
+		.vfe = {
+			.line_num = 4,
+			.has_pd = true,
+			.pd_name = "ife0",
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
+	},
+	/* VFE1 */
+	{
+		.regulators = {},
+		.clock = {
+			"camnoc_axi",
+			"cpas_ahb",
+			"soc_ahb",
+			"vfe1",
+			"vfe1_axi",
+			"csi1",
+		},
+		.clock_rate = {
+			{ 0 },
+			{ 0 },
+			{ 0 },
+			{ 19200000, 240000000, 360000000, 432000000, 600000000 },
+			{ 0 },
+			{ 150000000, 270000000, 360000000, 480000000 },
+		},
+		.reg = { "vfe1" },
+		.interrupt = { "vfe1" },
+		.vfe = {
+			.line_num = 4,
+			.has_pd = true,
+			.pd_name = "ife1",
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
+	},
+	/* VFE-lite */
+	{
+		.regulators = {},
+		.clock = {
+			"camnoc_axi",
+			"cpas_ahb",
+			"soc_ahb",
+			"vfe_lite",
+			"csi2",
+		},
+		.clock_rate = {
+			{ 0 },
+			{ 0 },
+			{ 0 },
+			{ 19200000, 240000000, 360000000, 432000000, 600000000 },
+			{ 150000000, 270000000, 360000000, 480000000 },
+		},
+		.reg = { "vfe_lite" },
+		.interrupt = { "vfe_lite" },
+		.vfe = {
+			.is_lite = true,
+			.line_num = 4,
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
+	}
+};
+
+static const struct resources_icc icc_res_7180[] = {
+	{
+		.name = "cam_ahb",
+		.icc_bw_tbl.avg = 125000,
+		.icc_bw_tbl.peak = 250000,
+	},
+	{
+		.name = "cam_hf_0_camnoc",
+		.icc_bw_tbl.avg = 2097152,
+		.icc_bw_tbl.peak = 2097152,
+	},
+	{
+		.name = "cam_hf_1_camnoc",
+		.icc_bw_tbl.avg = 2097152,
+		.icc_bw_tbl.peak = 2097152,
+	},
+	{
+		.name = "cam_sf_camnoc",
+		.icc_bw_tbl.avg = 2097152,
+		.icc_bw_tbl.peak = 2097152,
+	},
+};
+
 static const struct camss_subdev_resources csiphy_res_sc8280xp[] = {
 	/* CSIPHY0 */
 	{
@@ -950,7 +1382,10 @@ static const struct camss_subdev_resources csiphy_res_sc8280xp[] = {
 				{ 300000000 } },
 		.reg = { "csiphy0" },
 		.interrupt = { "csiphy0" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
 	},
 	/* CSIPHY1 */
 	{
@@ -960,7 +1395,10 @@ static const struct camss_subdev_resources csiphy_res_sc8280xp[] = {
 				{ 300000000 } },
 		.reg = { "csiphy1" },
 		.interrupt = { "csiphy1" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
 	},
 	/* CSIPHY2 */
 	{
@@ -970,7 +1408,10 @@ static const struct camss_subdev_resources csiphy_res_sc8280xp[] = {
 				{ 300000000 } },
 		.reg = { "csiphy2" },
 		.interrupt = { "csiphy2" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
 	},
 	/* CSIPHY3 */
 	{
@@ -980,7 +1421,10 @@ static const struct camss_subdev_resources csiphy_res_sc8280xp[] = {
 				{ 300000000 } },
 		.reg = { "csiphy3" },
 		.interrupt = { "csiphy3" },
-		.ops = &csiphy_ops_3ph_1_0
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
 	},
 };
 
@@ -995,7 +1439,11 @@ static const struct camss_subdev_resources csid_res_sc8280xp[] = {
 				{ 0 } },
 		.reg = { "csid0" },
 		.interrupt = { "csid0" },
-		.ops = &csid_ops_gen2
+		.csid = {
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
 	},
 	/* CSID1 */
 	{
@@ -1007,7 +1455,11 @@ static const struct camss_subdev_resources csid_res_sc8280xp[] = {
 				{ 0 } },
 		.reg = { "csid1" },
 		.interrupt = { "csid1" },
-		.ops = &csid_ops_gen2
+		.csid = {
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
 	},
 	/* CSID2 */
 	{
@@ -1019,7 +1471,11 @@ static const struct camss_subdev_resources csid_res_sc8280xp[] = {
 				{ 0 } },
 		.reg = { "csid2" },
 		.interrupt = { "csid2" },
-		.ops = &csid_ops_gen2
+		.csid = {
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
 	},
 	/* CSID3 */
 	{
@@ -1031,7 +1487,11 @@ static const struct camss_subdev_resources csid_res_sc8280xp[] = {
 				{ 0 } },
 		.reg = { "csid3" },
 		.interrupt = { "csid3" },
-		.ops = &csid_ops_gen2
+		.csid = {
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
 	},
 	/* CSID_LITE0 */
 	{
@@ -1042,8 +1502,12 @@ static const struct camss_subdev_resources csid_res_sc8280xp[] = {
 				{ 0 }, },
 		.reg = { "csid0_lite" },
 		.interrupt = { "csid0_lite" },
-		.is_lite = true,
-		.ops = &csid_ops_gen2
+		.csid = {
+			.is_lite = true,
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
 	},
 	/* CSID_LITE1 */
 	{
@@ -1054,8 +1518,12 @@ static const struct camss_subdev_resources csid_res_sc8280xp[] = {
 				{ 0 }, },
 		.reg = { "csid1_lite" },
 		.interrupt = { "csid1_lite" },
-		.is_lite = true,
-		.ops = &csid_ops_gen2
+		.csid = {
+			.is_lite = true,
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
 	},
 	/* CSID_LITE2 */
 	{
@@ -1066,8 +1534,12 @@ static const struct camss_subdev_resources csid_res_sc8280xp[] = {
 				{ 0 }, },
 		.reg = { "csid2_lite" },
 		.interrupt = { "csid2_lite" },
-		.is_lite = true,
-		.ops = &csid_ops_gen2
+		.csid = {
+			.is_lite = true,
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
 	},
 	/* CSID_LITE3 */
 	{
@@ -1078,8 +1550,12 @@ static const struct camss_subdev_resources csid_res_sc8280xp[] = {
 				{ 0 }, },
 		.reg = { "csid3_lite" },
 		.interrupt = { "csid3_lite" },
-		.is_lite = true,
-		.ops = &csid_ops_gen2
+		.csid = {
+			.is_lite = true,
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
 	}
 };
 
@@ -1096,9 +1572,13 @@ static const struct camss_subdev_resources vfe_res_sc8280xp[] = {
 				{ 0 }, },
 		.reg = { "vfe0" },
 		.interrupt = { "vfe0" },
-		.pd_name = "ife0",
-		.line_num = 4,
-		.ops = &vfe_ops_170
+		.vfe = {
+			.line_num = 4,
+			.pd_name = "ife0",
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
 	},
 	/* VFE1 */
 	{
@@ -1112,9 +1592,13 @@ static const struct camss_subdev_resources vfe_res_sc8280xp[] = {
 				{ 0 }, },
 		.reg = { "vfe1" },
 		.interrupt = { "vfe1" },
-		.pd_name = "ife1",
-		.line_num = 4,
-		.ops = &vfe_ops_170
+		.vfe = {
+			.line_num = 4,
+			.pd_name = "ife1",
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
 	},
 	/* VFE2 */
 	{
@@ -1128,9 +1612,13 @@ static const struct camss_subdev_resources vfe_res_sc8280xp[] = {
 				{ 0 }, },
 		.reg = { "vfe2" },
 		.interrupt = { "vfe2" },
-		.pd_name = "ife2",
-		.line_num = 4,
-		.ops = &vfe_ops_170
+		.vfe = {
+			.line_num = 4,
+			.pd_name = "ife2",
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
 	},
 	/* VFE3 */
 	{
@@ -1144,9 +1632,13 @@ static const struct camss_subdev_resources vfe_res_sc8280xp[] = {
 				{ 0 }, },
 		.reg = { "vfe3" },
 		.interrupt = { "vfe3" },
-		.pd_name = "ife3",
-		.line_num = 4,
-		.ops = &vfe_ops_170
+		.vfe = {
+			.line_num = 4,
+			.pd_name = "ife3",
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
 	},
 	/* VFE_LITE_0 */
 	{
@@ -1159,9 +1651,13 @@ static const struct camss_subdev_resources vfe_res_sc8280xp[] = {
 				{ 320000000, 400000000, 480000000, 600000000 }, },
 		.reg = { "vfe_lite0" },
 		.interrupt = { "vfe_lite0" },
-		.is_lite = true,
-		.line_num = 4,
-		.ops = &vfe_ops_170
+		.vfe = {
+			.is_lite = true,
+			.line_num = 4,
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
 	},
 	/* VFE_LITE_1 */
 	{
@@ -1174,9 +1670,13 @@ static const struct camss_subdev_resources vfe_res_sc8280xp[] = {
 				{ 320000000, 400000000, 480000000, 600000000 }, },
 		.reg = { "vfe_lite1" },
 		.interrupt = { "vfe_lite1" },
-		.is_lite = true,
-		.line_num = 4,
-		.ops = &vfe_ops_170
+		.vfe = {
+			.is_lite = true,
+			.line_num = 4,
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
 	},
 	/* VFE_LITE_2 */
 	{
@@ -1189,9 +1689,13 @@ static const struct camss_subdev_resources vfe_res_sc8280xp[] = {
 				{ 320000000, 400000000, 480000000, 600000000, }, },
 		.reg = { "vfe_lite2" },
 		.interrupt = { "vfe_lite2" },
-		.is_lite = true,
-		.line_num = 4,
-		.ops = &vfe_ops_170
+		.vfe = {
+			.is_lite = true,
+			.line_num = 4,
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
 	},
 	/* VFE_LITE_3 */
 	{
@@ -1204,9 +1708,13 @@ static const struct camss_subdev_resources vfe_res_sc8280xp[] = {
 				{ 320000000, 400000000, 480000000, 600000000 }, },
 		.reg = { "vfe_lite3" },
 		.interrupt = { "vfe_lite3" },
-		.is_lite = true,
-		.line_num = 4,
-		.ops = &vfe_ops_170
+		.vfe = {
+			.is_lite = true,
+			.line_num = 4,
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
 	},
 };
 
@@ -1375,7 +1883,7 @@ int camss_pm_domain_on(struct camss *camss, int id)
 	if (id < camss->res->vfe_num) {
 		struct vfe_device *vfe = &camss->vfe[id];
 
-		ret = vfe->ops->pm_domain_on(vfe);
+		ret = vfe->res->hw_ops->pm_domain_on(vfe);
 	}
 
 	return ret;
@@ -1386,10 +1894,52 @@ void camss_pm_domain_off(struct camss *camss, int id)
 	if (id < camss->res->vfe_num) {
 		struct vfe_device *vfe = &camss->vfe[id];
 
-		vfe->ops->pm_domain_off(vfe);
+		vfe->res->hw_ops->pm_domain_off(vfe);
 	}
 }
 
+static int vfe_parent_dev_ops_get(struct camss *camss, int id)
+{
+	int ret = -EINVAL;
+
+	if (id < camss->res->vfe_num) {
+		struct vfe_device *vfe = &camss->vfe[id];
+
+		ret = vfe_get(vfe);
+	}
+
+	return ret;
+}
+
+static int vfe_parent_dev_ops_put(struct camss *camss, int id)
+{
+	if (id < camss->res->vfe_num) {
+		struct vfe_device *vfe = &camss->vfe[id];
+
+		vfe_put(vfe);
+	}
+
+	return 0;
+}
+
+static void __iomem
+*vfe_parent_dev_ops_get_base_address(struct camss *camss, int id)
+{
+	if (id < camss->res->vfe_num) {
+		struct vfe_device *vfe = &camss->vfe[id];
+
+		return vfe->base;
+	}
+
+	return NULL;
+}
+
+static const struct parent_dev_ops vfe_parent_dev_ops = {
+	.get = vfe_parent_dev_ops_get,
+	.put = vfe_parent_dev_ops_put,
+	.get_base_address = vfe_parent_dev_ops_get_base_address
+};
+
 /*
  * camss_of_parse_endpoint_node - Parse port endpoint node
  * @dev: Device
@@ -1536,72 +2086,30 @@ static int camss_init_subdevices(struct camss *camss)
 }
 
 /*
- * camss_register_entities - Register subdev nodes and create links
+ * camss_link_entities - Register subdev nodes and create links
  * @camss: CAMSS device
  *
  * Return 0 on success or a negative error code on failure
  */
-static int camss_register_entities(struct camss *camss)
+static int camss_link_entities(struct camss *camss)
 {
 	int i, j, k;
 	int ret;
 
-	for (i = 0; i < camss->res->csiphy_num; i++) {
-		ret = msm_csiphy_register_entity(&camss->csiphy[i],
-						 &camss->v4l2_dev);
-		if (ret < 0) {
-			dev_err(camss->dev,
-				"Failed to register csiphy%d entity: %d\n",
-				i, ret);
-			goto err_reg_csiphy;
-		}
-	}
-
-	for (i = 0; i < camss->res->csid_num; i++) {
-		ret = msm_csid_register_entity(&camss->csid[i],
-					       &camss->v4l2_dev);
-		if (ret < 0) {
-			dev_err(camss->dev,
-				"Failed to register csid%d entity: %d\n",
-				i, ret);
-			goto err_reg_csid;
-		}
-	}
-
-	ret = msm_ispif_register_entities(camss->ispif,
-					  &camss->v4l2_dev);
-	if (ret < 0) {
-		dev_err(camss->dev, "Failed to register ispif entities: %d\n",
-		ret);
-		goto err_reg_ispif;
-	}
-
-	for (i = 0; i < camss->res->vfe_num; i++) {
-		ret = msm_vfe_register_entities(&camss->vfe[i],
-						&camss->v4l2_dev);
-		if (ret < 0) {
-			dev_err(camss->dev,
-				"Failed to register vfe%d entities: %d\n",
-				i, ret);
-			goto err_reg_vfe;
-		}
-	}
-
 	for (i = 0; i < camss->res->csiphy_num; i++) {
 		for (j = 0; j < camss->res->csid_num; j++) {
-			ret = media_create_pad_link(
-				&camss->csiphy[i].subdev.entity,
-				MSM_CSIPHY_PAD_SRC,
-				&camss->csid[j].subdev.entity,
-				MSM_CSID_PAD_SINK,
-				0);
+			ret = media_create_pad_link(&camss->csiphy[i].subdev.entity,
+						    MSM_CSIPHY_PAD_SRC,
+						    &camss->csid[j].subdev.entity,
+						    MSM_CSID_PAD_SINK,
+						    0);
 			if (ret < 0) {
 				dev_err(camss->dev,
 					"Failed to link %s->%s entities: %d\n",
 					camss->csiphy[i].subdev.entity.name,
 					camss->csid[j].subdev.entity.name,
 					ret);
-				goto err_link;
+				return ret;
 			}
 		}
 	}
@@ -1609,26 +2117,25 @@ static int camss_register_entities(struct camss *camss)
 	if (camss->ispif) {
 		for (i = 0; i < camss->res->csid_num; i++) {
 			for (j = 0; j < camss->ispif->line_num; j++) {
-				ret = media_create_pad_link(
-					&camss->csid[i].subdev.entity,
-					MSM_CSID_PAD_SRC,
-					&camss->ispif->line[j].subdev.entity,
-					MSM_ISPIF_PAD_SINK,
-					0);
+				ret = media_create_pad_link(&camss->csid[i].subdev.entity,
+							    MSM_CSID_PAD_SRC,
+							    &camss->ispif->line[j].subdev.entity,
+							    MSM_ISPIF_PAD_SINK,
+							    0);
 				if (ret < 0) {
 					dev_err(camss->dev,
 						"Failed to link %s->%s entities: %d\n",
 						camss->csid[i].subdev.entity.name,
 						camss->ispif->line[j].subdev.entity.name,
 						ret);
-					goto err_link;
+					return ret;
 				}
 			}
 		}
 
 		for (i = 0; i < camss->ispif->line_num; i++)
 			for (k = 0; k < camss->res->vfe_num; k++)
-				for (j = 0; j < camss->vfe[k].line_num; j++) {
+				for (j = 0; j < camss->vfe[k].res->line_num; j++) {
 					struct v4l2_subdev *ispif = &camss->ispif->line[i].subdev;
 					struct v4l2_subdev *vfe = &camss->vfe[k].line[j].subdev;
 
@@ -1643,13 +2150,13 @@ static int camss_register_entities(struct camss *camss)
 							ispif->entity.name,
 							vfe->entity.name,
 							ret);
-						goto err_link;
+						return ret;
 					}
 				}
 	} else {
 		for (i = 0; i < camss->res->csid_num; i++)
 			for (k = 0; k < camss->res->vfe_num; k++)
-				for (j = 0; j < camss->vfe[k].line_num; j++) {
+				for (j = 0; j < camss->vfe[k].res->line_num; j++) {
 					struct v4l2_subdev *csid = &camss->csid[i].subdev;
 					struct v4l2_subdev *vfe = &camss->vfe[k].line[j].subdev;
 
@@ -1664,15 +2171,67 @@ static int camss_register_entities(struct camss *camss)
 							csid->entity.name,
 							vfe->entity.name,
 							ret);
-						goto err_link;
+						return ret;
 					}
 				}
 	}
 
+	return 0;
+}
+
+/*
+ * camss_register_entities - Register subdev nodes and create links
+ * @camss: CAMSS device
+ *
+ * Return 0 on success or a negative error code on failure
+ */
+static int camss_register_entities(struct camss *camss)
+{
+	int i;
+	int ret;
+
+	for (i = 0; i < camss->res->csiphy_num; i++) {
+		ret = msm_csiphy_register_entity(&camss->csiphy[i],
+						 &camss->v4l2_dev);
+		if (ret < 0) {
+			dev_err(camss->dev,
+				"Failed to register csiphy%d entity: %d\n",
+				i, ret);
+			goto err_reg_csiphy;
+		}
+	}
+
+	for (i = 0; i < camss->res->csid_num; i++) {
+		ret = msm_csid_register_entity(&camss->csid[i],
+					       &camss->v4l2_dev);
+		if (ret < 0) {
+			dev_err(camss->dev,
+				"Failed to register csid%d entity: %d\n",
+				i, ret);
+			goto err_reg_csid;
+		}
+	}
+
+	ret = msm_ispif_register_entities(camss->ispif,
+					  &camss->v4l2_dev);
+	if (ret < 0) {
+		dev_err(camss->dev, "Failed to register ispif entities: %d\n", ret);
+		goto err_reg_ispif;
+	}
+
+	for (i = 0; i < camss->res->vfe_num; i++) {
+		ret = msm_vfe_register_entities(&camss->vfe[i],
+						&camss->v4l2_dev);
+		if (ret < 0) {
+			dev_err(camss->dev,
+				"Failed to register vfe%d entities: %d\n",
+				i, ret);
+			goto err_reg_vfe;
+		}
+	}
+
 	return 0;
 
-err_link:
-	i = camss->res->vfe_num;
 err_reg_vfe:
 	for (i--; i >= 0; i--)
 		msm_vfe_unregister_entities(&camss->vfe[i]);
@@ -1810,7 +2369,7 @@ static int camss_configure_pd(struct camss *camss)
 
 	/* count the # of VFEs which have flagged power-domain */
 	for (vfepd_num = i = 0; i < camss->res->vfe_num; i++) {
-		if (res->vfe_res[i].has_pd)
+		if (res->vfe_res[i].vfe.has_pd)
 			vfepd_num++;
 	}
 
@@ -1992,6 +2551,10 @@ static int camss_probe(struct platform_device *pdev)
 	if (ret < 0)
 		goto err_v4l2_device_unregister;
 
+	ret = camss->res->link_entities(camss);
+	if (ret < 0)
+		goto err_register_subdevs;
+
 	if (num_subdevs) {
 		camss->notifier.ops = &camss_subdev_notifier_ops;
 
@@ -2071,6 +2634,7 @@ static const struct camss_resources msm8916_resources = {
 	.csiphy_num = ARRAY_SIZE(csiphy_res_8x16),
 	.csid_num = ARRAY_SIZE(csid_res_8x16),
 	.vfe_num = ARRAY_SIZE(vfe_res_8x16),
+	.link_entities = camss_link_entities
 };
 
 static const struct camss_resources msm8996_resources = {
@@ -2082,6 +2646,7 @@ static const struct camss_resources msm8996_resources = {
 	.csiphy_num = ARRAY_SIZE(csiphy_res_8x96),
 	.csid_num = ARRAY_SIZE(csid_res_8x96),
 	.vfe_num = ARRAY_SIZE(vfe_res_8x96),
+	.link_entities = camss_link_entities
 };
 
 static const struct camss_resources sdm660_resources = {
@@ -2093,6 +2658,7 @@ static const struct camss_resources sdm660_resources = {
 	.csiphy_num = ARRAY_SIZE(csiphy_res_660),
 	.csid_num = ARRAY_SIZE(csid_res_660),
 	.vfe_num = ARRAY_SIZE(vfe_res_660),
+	.link_entities = camss_link_entities
 };
 
 static const struct camss_resources sdm845_resources = {
@@ -2103,6 +2669,7 @@ static const struct camss_resources sdm845_resources = {
 	.csiphy_num = ARRAY_SIZE(csiphy_res_845),
 	.csid_num = ARRAY_SIZE(csid_res_845),
 	.vfe_num = ARRAY_SIZE(vfe_res_845),
+	.link_entities = camss_link_entities
 };
 
 static const struct camss_resources sm8250_resources = {
@@ -2116,6 +2683,21 @@ static const struct camss_resources sm8250_resources = {
 	.csiphy_num = ARRAY_SIZE(csiphy_res_8250),
 	.csid_num = ARRAY_SIZE(csid_res_8250),
 	.vfe_num = ARRAY_SIZE(vfe_res_8250),
+	.link_entities = camss_link_entities
+};
+
+static const struct camss_resources sc7180_resources = {
+	.version = CAMSS_7180,
+	.pd_name = "top",
+	.csiphy_res = csiphy_res_7180,
+	.csid_res = csid_res_7180,
+	.vfe_res = vfe_res_7180,
+	.icc_res = icc_res_7180,
+	.icc_path_num = ARRAY_SIZE(icc_res_7180),
+	.csiphy_num = ARRAY_SIZE(csiphy_res_7180),
+	.csid_num = ARRAY_SIZE(csid_res_7180),
+	.vfe_num = ARRAY_SIZE(vfe_res_7180),
+	.link_entities = camss_link_entities
 };
 
 static const struct camss_resources sc8280xp_resources = {
@@ -2130,6 +2712,7 @@ static const struct camss_resources sc8280xp_resources = {
 	.csiphy_num = ARRAY_SIZE(csiphy_res_sc8280xp),
 	.csid_num = ARRAY_SIZE(csid_res_sc8280xp),
 	.vfe_num = ARRAY_SIZE(vfe_res_sc8280xp),
+	.link_entities = camss_link_entities
 };
 
 static const struct of_device_id camss_dt_match[] = {
@@ -2138,6 +2721,7 @@ static const struct of_device_id camss_dt_match[] = {
 	{ .compatible = "qcom,sdm660-camss", .data = &sdm660_resources },
 	{ .compatible = "qcom,sdm845-camss", .data = &sdm845_resources },
 	{ .compatible = "qcom,sm8250-camss", .data = &sm8250_resources },
+	{ .compatible = "qcom,sc7180-camss", .data = &sc7180_resources },
 	{ .compatible = "qcom,sc8280xp-camss", .data = &sc8280xp_resources },
 	{ }
 };
diff --git a/drivers/media/platform/qcom/camss/camss.h b/drivers/media/platform/qcom/camss/camss.h
index ac15fe23a702e0..867e275db4bec8 100644
--- a/drivers/media/platform/qcom/camss/camss.h
+++ b/drivers/media/platform/qcom/camss/camss.h
@@ -22,6 +22,7 @@
 #include "camss-csiphy.h"
 #include "camss-ispif.h"
 #include "camss-vfe.h"
+#include "camss-format.h"
 
 #define to_camss(ptr_module)	\
 	container_of(ptr_module, struct camss, ptr_module)
@@ -48,11 +49,11 @@ struct camss_subdev_resources {
 	u32 clock_rate[CAMSS_RES_MAX][CAMSS_RES_MAX];
 	char *reg[CAMSS_RES_MAX];
 	char *interrupt[CAMSS_RES_MAX];
-	char *pd_name;
-	u8 line_num;
-	bool has_pd;
-	bool is_lite;
-	const void *ops;
+	union {
+		struct csiphy_subdev_resources csiphy;
+		struct csid_subdev_resources csid;
+		struct vfe_subdev_resources vfe;
+	};
 };
 
 struct icc_bw_tbl {
@@ -76,6 +77,7 @@ enum camss_version {
 	CAMSS_8x96,
 	CAMSS_660,
 	CAMSS_845,
+	CAMSS_7180,
 	CAMSS_8250,
 	CAMSS_8280XP,
 };
@@ -97,6 +99,7 @@ struct camss_resources {
 	const unsigned int csiphy_num;
 	const unsigned int csid_num;
 	const unsigned int vfe_num;
+	int (*link_entities)(struct camss *camss);
 };
 
 struct camss {
@@ -133,6 +136,12 @@ struct camss_clock {
 	u32 nfreqs;
 };
 
+struct parent_dev_ops {
+	int (*get)(struct camss *camss, int id);
+	int (*put)(struct camss *camss, int id);
+	void __iomem *(*get_base_address)(struct camss *camss, int id);
+};
+
 void camss_add_clock_margin(u64 *rate);
 int camss_enable_clocks(int nclocks, struct camss_clock *clock,
 			struct device *dev);
@@ -143,6 +152,8 @@ s64 camss_get_link_freq(struct media_entity *entity, unsigned int bpp,
 int camss_get_pixel_clock(struct media_entity *entity, u64 *pixel_clock);
 int camss_pm_domain_on(struct camss *camss, int id);
 void camss_pm_domain_off(struct camss *camss, int id);
+int camss_vfe_get(struct camss *camss, int id);
+void camss_vfe_put(struct camss *camss, int id);
 void camss_delete(struct camss *camss);
 
 #endif /* QC_MSM_CAMSS_H */
diff --git a/drivers/media/v4l2-core/v4l2-subdev.c b/drivers/media/v4l2-core/v4l2-subdev.c
index 8470d6eda9a3af..c9ae1c1fc67175 100644
--- a/drivers/media/v4l2-core/v4l2-subdev.c
+++ b/drivers/media/v4l2-core/v4l2-subdev.c
@@ -1423,8 +1423,12 @@ static int v4l2_subdev_link_validate_locked(struct media_link *link, bool states
 		if (!ret)
 			continue;
 
-		if (ret != -ENOIOCTLCMD)
+		if (ret != -ENOIOCTLCMD) {
+			dev_dbg(dev,
+				"link_validate failed on sink pad \"%s\":%u\n\n",
+				link->sink->entity->name, link->sink->index);
 			return ret;
+		}
 
 		ret = v4l2_subdev_link_validate_default(sink_subdev, link,
 							&source_fmt, &sink_fmt);
diff --git a/drivers/misc/fastrpc.c b/drivers/misc/fastrpc.c
index a7a2bcedb37e44..5680856c0fb82c 100644
--- a/drivers/misc/fastrpc.c
+++ b/drivers/misc/fastrpc.c
@@ -2087,16 +2087,6 @@ static int fastrpc_req_mem_map(struct fastrpc_user *fl, char __user *argp)
 	return err;
 }
 
-static int is_attach_rejected(struct fastrpc_user *fl)
-{
-	/* Check if the device node is non-secure */
-	if (!fl->is_secure_dev) {
-		dev_dbg(&fl->cctx->rpdev->dev, "untrusted app trying to attach to privileged DSP PD\n");
-		return -EACCES;
-	}
-	return 0;
-}
-
 static long fastrpc_device_ioctl(struct file *file, unsigned int cmd,
 				 unsigned long arg)
 {
@@ -2109,19 +2099,13 @@ static long fastrpc_device_ioctl(struct file *file, unsigned int cmd,
 		err = fastrpc_invoke(fl, argp);
 		break;
 	case FASTRPC_IOCTL_INIT_ATTACH:
-		err = is_attach_rejected(fl);
-		if (!err)
-			err = fastrpc_init_attach(fl, ROOT_PD);
+		err = fastrpc_init_attach(fl, ROOT_PD);
 		break;
 	case FASTRPC_IOCTL_INIT_ATTACH_SNS:
-		err = is_attach_rejected(fl);
-		if (!err)
-			err = fastrpc_init_attach(fl, SENSORS_PD);
+		err = fastrpc_init_attach(fl, SENSORS_PD);
 		break;
 	case FASTRPC_IOCTL_INIT_CREATE_STATIC:
-		err = is_attach_rejected(fl);
-		if (!err)
-			err = fastrpc_init_create_static_process(fl, argp);
+		err = fastrpc_init_create_static_process(fl, argp);
 		break;
 	case FASTRPC_IOCTL_INIT_CREATE:
 		err = fastrpc_init_create_process(fl, argp);
diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index 3e31375491d580..d712c1f621d1ec 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -183,6 +183,16 @@ config BATTERY_QCOM_BATTMGR
 	  which is used on modern Qualcomm platforms to provide battery and
 	  power supply information.
 
+config BATTERY_QCOM_QG
+	tristate "Qualcomm PMIC QGauge driver"
+	depends on MFD_SPMI_PMIC
+	depends on IIO
+	help
+	  Say Y here to enable the Qualcomm Technologies, Inc. QGauge driver
+	  which uses the periodic sampling of the battery voltage and current
+	  to determine the battery state-of-charge (SOC) and supports other
+	  battery management features.
+
 config BATTERY_OLPC
 	tristate "One Laptop Per Child battery"
 	depends on OLPC_EC
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index 58b56727803498..3d371cfceaf821 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_BATTERY_GOLDFISH)	+= goldfish_battery.o
 obj-$(CONFIG_BATTERY_LEGO_EV3)	+= lego_ev3_battery.o
 obj-$(CONFIG_BATTERY_PMU)	+= pmu_battery.o
 obj-$(CONFIG_BATTERY_QCOM_BATTMGR)	+= qcom_battmgr.o
+obj-$(CONFIG_BATTERY_QCOM_QG)	+= qcom_qg.o
 obj-$(CONFIG_BATTERY_OLPC)	+= olpc_battery.o
 obj-$(CONFIG_BATTERY_SAMSUNG_SDI)	+= samsung-sdi-battery.o
 obj-$(CONFIG_BATTERY_COLLIE)	+= collie_battery.o
diff --git a/drivers/power/supply/qcom_qg.c b/drivers/power/supply/qcom_qg.c
new file mode 100644
index 00000000000000..d6bda9ad94f675
--- /dev/null
+++ b/drivers/power/supply/qcom_qg.c
@@ -0,0 +1,264 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2024, Danila Tikhonov <danila@jiaxyga.com>
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/power_supply.h>
+#include <linux/iio/consumer.h>
+#include <linux/regmap.h>
+
+/* SRAM */
+#define QG_SRAM_BASE	0xb600
+
+/* BATT offsets */
+#define QG_S2_NORMAL_AVG_V_DATA0_REG	0x80 /* 2-byte 0x80-0x81 */
+#define QG_S2_NORMAL_AVG_I_DATA0_REG	0x82 /* 2-byte 0x82-0x83 */
+#define QG_LAST_ADC_V_DATA0_REG		0xc0 /* 2-byte 0xc0-0xc1 */
+#define QG_LAST_ADC_I_DATA0_REG		0xc2 /* 2-byte 0xc2-0xc3 */
+
+/* SRAM offsets */
+#define QG_SDAM_OCV_OFFSET		0x4c /* 4-byte 0x4c-0x4f */
+#define QG_SDAM_LEARNED_CAPACITY_OFFSET	0x68 /* 2-byte 0x68-0x69 */
+
+struct qcom_qg_chip {
+	struct device *dev;
+	struct regmap *regmap;
+	unsigned int base;
+
+	struct iio_channel *batt_therm_chan;
+	struct iio_channel *batt_id_chan;
+
+	struct power_supply *batt_psy;
+	struct power_supply_battery_info *batt_info;
+};
+
+static int qcom_qg_get_current(struct qcom_qg_chip *chip, u8 offset, int *val)
+{
+	s16 temp;
+	u8 readval[2];
+	int ret;
+
+	ret = regmap_bulk_read(chip->regmap, chip->base + offset, readval, 2);
+	if (ret) {
+		dev_err(chip->dev, "Failed to read current: %d\n", ret);
+		return ret;
+	}
+
+	temp = (s16)(readval[1] << 8 | readval[0]);
+	*val = div_s64((s64)temp * 152588, 1000);
+
+	return 0;
+}
+
+static int qcom_qg_get_voltage(struct qcom_qg_chip *chip, u8 offset, int *val)
+{
+	int ret, temp;
+	u8 readval[2];
+
+	ret = regmap_bulk_read(chip->regmap, chip->base + offset, readval, 2);
+	if (ret) {
+		dev_err(chip->dev, "Failed to read voltage: %d\n", ret);
+		return ret;
+	}
+
+	temp = readval[1] << 8 | readval[0];
+	*val = div_u64((u64)temp * 194637, 1000);
+
+	return 0;
+}
+
+/*
+ * Yes, this function simply calculates the capacity based on
+ * the current voltage. This will be rewritten in the future.
+ */
+static int qcom_qg_get_capacity(struct qcom_qg_chip *chip, int *val)
+{
+	int ret, voltage_now;
+	int voltage_min = chip->batt_info->voltage_min_design_uv;
+	int voltage_max = chip->batt_info->voltage_max_design_uv;
+
+	ret = qcom_qg_get_voltage(chip,
+				QG_S2_NORMAL_AVG_V_DATA0_REG, &voltage_now);
+	if (ret) {
+		dev_err(chip->dev, "Failed to get current voltage: %d\n", ret);
+		return ret;
+	}
+
+	if (voltage_now <= voltage_min)
+		*val = 0;
+	else if (voltage_now >= voltage_max)
+		*val = 100;
+	else
+		*val = (((voltage_now - voltage_min) * 100) /
+						(voltage_max - voltage_min));
+
+	return 0;
+}
+
+static enum power_supply_property qcom_qg_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_VOLTAGE_OCV,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+};
+
+static int qcom_qg_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct qcom_qg_chip *chip = power_supply_get_drvdata(psy);
+	int ret;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LIPO;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		val->intval = chip->batt_info->voltage_max_design_uv;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+		val->intval = chip->batt_info->voltage_min_design_uv;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		ret = qcom_qg_get_voltage(chip,
+				QG_LAST_ADC_V_DATA0_REG, &val->intval);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		ret = qcom_qg_get_voltage(chip,
+				QG_S2_NORMAL_AVG_V_DATA0_REG, &val->intval);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_OCV:
+		ret = regmap_raw_read(chip->regmap,
+			QG_SRAM_BASE + QG_SDAM_OCV_OFFSET, &val->intval, 4);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		ret = qcom_qg_get_current(chip,
+				QG_LAST_ADC_I_DATA0_REG, &val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		ret = qcom_qg_get_current(chip,
+				QG_S2_NORMAL_AVG_I_DATA0_REG, &val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		val->intval = chip->batt_info->charge_full_design_uah;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		ret = regmap_raw_read(chip->regmap, QG_SRAM_BASE +
+				QG_SDAM_LEARNED_CAPACITY_OFFSET, &val->intval, 2);
+		if (!ret) val->intval *= 1000; /* mah to uah */
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		ret = qcom_qg_get_capacity(chip, &val->intval);
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		ret = iio_read_channel_processed
+					(chip->batt_therm_chan, &val->intval);
+		break;
+	default:
+		dev_err(chip->dev, "invalid property: %d\n", psp);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct power_supply_desc batt_psy_desc = {
+	.name = "qcom_qg",
+	.type = POWER_SUPPLY_TYPE_BATTERY,
+	.properties = qcom_qg_props,
+	.num_properties = ARRAY_SIZE(qcom_qg_props),
+	.get_property = qcom_qg_get_property,
+};
+
+static int qcom_qg_probe(struct platform_device *pdev)
+{
+	struct qcom_qg_chip *chip;
+	struct power_supply_config psy_cfg = {};
+	int ret;
+
+	chip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	chip->dev = &pdev->dev;
+
+	/* Regmap */
+	chip->regmap = dev_get_regmap(pdev->dev.parent, NULL);
+	if (!chip->regmap)
+		return dev_err_probe(chip->dev, -ENODEV,
+				     "Failed to locate the regmap\n");
+
+	/* Get base address */
+	ret = device_property_read_u32(chip->dev, "reg", &chip->base);
+	if (ret < 0)
+		return dev_err_probe(chip->dev, ret,
+				     "Couldn't read base address\n");
+
+	/* ADC for Battery ID & THERM */
+	chip->batt_id_chan = devm_iio_channel_get(&pdev->dev, "batt-id");
+	if (IS_ERR(chip->batt_id_chan))
+		return dev_err_probe(chip->dev, PTR_ERR(chip->batt_id_chan),
+				     "Couldn't get batt-id IIO channel\n");
+
+	chip->batt_therm_chan = devm_iio_channel_get(&pdev->dev, "batt-therm");
+	if (IS_ERR(chip->batt_therm_chan))
+		return dev_err_probe(chip->dev, PTR_ERR(chip->batt_therm_chan),
+				     "Couldn't get batt-therm IIO channel\n");
+
+	psy_cfg.drv_data = chip;
+	psy_cfg.of_node = pdev->dev.of_node;
+
+	/* Power supply */
+	chip->batt_psy =
+		devm_power_supply_register(chip->dev, &batt_psy_desc, &psy_cfg);
+	if (IS_ERR(chip->batt_psy))
+		return dev_err_probe(chip->dev, PTR_ERR(chip->batt_psy),
+				     "Failed to register power supply\n");
+
+	/* Battery info */
+	ret = power_supply_get_battery_info(chip->batt_psy, &chip->batt_info);
+	if (ret)
+		return dev_err_probe(chip->dev, ret,
+				     "Failed to get battery info\n");
+
+	platform_set_drvdata(pdev, chip);
+
+	return 0;
+}
+
+static const struct of_device_id qcom_qg_of_match[] = {
+	{ .compatible = "qcom,pm6150-qg", },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, qcom_qg_of_match);
+
+static struct platform_driver qcom_qg_driver = {
+	.driver = {
+		.name = "qcom,qcom_qg",
+		.of_match_table = qcom_qg_of_match,
+	},
+	.probe = qcom_qg_probe,
+};
+
+module_platform_driver(qcom_qg_driver);
+
+MODULE_AUTHOR("Danila Tikhonov <danila@jiaxyga.com>");
+MODULE_DESCRIPTION("Qualcomm PMIC QGauge (QG) driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/backlight/qcom-wled.c b/drivers/video/backlight/qcom-wled.c
index 10129095a4c178..a1fa32e5ae814b 100644
--- a/drivers/video/backlight/qcom-wled.c
+++ b/drivers/video/backlight/qcom-wled.c
@@ -3,6 +3,7 @@
  */
 
 #include <linux/delay.h>
+#include <linux/devm-helpers.h>
 #include <linux/interrupt.h>
 #include <linux/ktime.h>
 #include <linux/kernel.h>
@@ -202,6 +203,7 @@ struct wled {
 
 	struct wled_config cfg;
 	struct delayed_work ovp_work;
+	struct delayed_work fault_work;
 
 	/* Configures the brightness. Applicable for wled3, wled4 and wled5 */
 	int (*wled_set_brightness)(struct wled *wled, u16 brightness);
@@ -294,6 +296,17 @@ static void wled_ovp_work(struct work_struct *work)
 {
 	struct wled *wled = container_of(work,
 					 struct wled, ovp_work.work);
+	
+	disable_irq(wled->ovp_irq);
+
+	/* move it here is due to a known issue of spurious irq storm for 10ms */
+	regmap_update_bits(wled->regmap, wled->ctrl_addr +
+                                WLED3_CTRL_REG_MOD_EN,
+                                WLED3_CTRL_REG_MOD_EN_MASK,
+                                1 << WLED3_CTRL_REG_MOD_EN_SHIFT);
+
+	msleep(50);
+
 	enable_irq(wled->ovp_irq);
 }
 
@@ -304,13 +317,6 @@ static int wled_module_enable(struct wled *wled, int val)
 	if (wled->disabled_by_short)
 		return -ENXIO;
 
-	rc = regmap_update_bits(wled->regmap, wled->ctrl_addr +
-				WLED3_CTRL_REG_MOD_EN,
-				WLED3_CTRL_REG_MOD_EN_MASK,
-				val << WLED3_CTRL_REG_MOD_EN_SHIFT);
-	if (rc < 0)
-		return rc;
-
 	if (wled->ovp_irq > 0) {
 		if (val) {
 			/*
@@ -319,13 +325,18 @@ static int wled_module_enable(struct wled *wled, int val)
 			 * enabling the IRQ for 10ms to ensure that the
 			 * soft start is complete.
 			 */
-			schedule_delayed_work(&wled->ovp_work, HZ / 100);
-		} else {
-			if (!cancel_delayed_work_sync(&wled->ovp_work))
-				disable_irq(wled->ovp_irq);
+			schedule_delayed_work(&wled->ovp_work, 0);
 		}
 	}
 
+	/* the only case is to switch it off. safe to do it here */
+	rc = regmap_update_bits(wled->regmap, wled->ctrl_addr +
+                                WLED3_CTRL_REG_MOD_EN,
+                                WLED3_CTRL_REG_MOD_EN_MASK,
+                                val << WLED3_CTRL_REG_MOD_EN_SHIFT);
+	if (rc < 0)
+		return rc;
+
 	return 0;
 }
 
@@ -524,7 +535,6 @@ static int wled5_cabc_config(struct wled *wled, bool enable)
 	return 0;
 }
 
-#define WLED_SHORT_DLY_MS			20
 #define WLED_SHORT_CNT_MAX			5
 #define WLED_SHORT_RESET_CNT_DLY_US		USEC_PER_SEC
 
@@ -556,7 +566,7 @@ static irqreturn_t wled_short_irq_handler(int irq, void *_wled)
 
 	wled->last_short_event = ktime_get();
 
-	msleep(WLED_SHORT_DLY_MS);
+	/* no more need to sleep 20ms in irq handler, put it in a tasklet for 50ms */
 	rc = wled_module_enable(wled, true);
 	if (rc < 0)
 		dev_err(wled->dev, "wled enable failed rc:%d\n", rc);
@@ -837,13 +847,15 @@ static irqreturn_t wled_ovp_irq_handler(int irq, void *_wled)
 	struct wled *wled = _wled;
 	int rc;
 	u32 int_sts, fault_sts;
+	
+	disable_irq(wled->ovp_irq);
 
 	rc = regmap_read(wled->regmap,
 			 wled->ctrl_addr + WLED3_CTRL_REG_INT_RT_STS, &int_sts);
 	if (rc < 0) {
 		dev_err(wled->dev, "Error in reading WLED3_INT_RT_STS rc=%d\n",
 			rc);
-		return IRQ_HANDLED;
+		goto exit;
 	}
 
 	rc = regmap_read(wled->regmap, wled->ctrl_addr +
@@ -851,7 +863,7 @@ static irqreturn_t wled_ovp_irq_handler(int irq, void *_wled)
 	if (rc < 0) {
 		dev_err(wled->dev, "Error in reading WLED_FAULT_STATUS rc=%d\n",
 			rc);
-		return IRQ_HANDLED;
+		goto exit;
 	}
 
 	if (fault_sts & (WLED3_CTRL_REG_OVP_FAULT_BIT |
@@ -861,15 +873,28 @@ static irqreturn_t wled_ovp_irq_handler(int irq, void *_wled)
 
 	if (fault_sts & WLED3_CTRL_REG_OVP_FAULT_BIT) {
 		if (wled->wled_auto_detection_required(wled)) {
-			mutex_lock(&wled->lock);
-			wled_auto_string_detection(wled);
-			mutex_unlock(&wled->lock);
+			cancel_delayed_work(&wled->fault_work);
+			schedule_delayed_work(&wled->fault_work, 0);
 		}
 	}
 
+exit:
+	enable_irq(wled->ovp_irq);
+
 	return IRQ_HANDLED;
 }
 
+static void wled_fault_ovp_work(struct work_struct *work) {
+	struct wled *wled = container_of(work,
+                                         struct wled, fault_work.work);
+
+	mutex_lock(&wled->lock);
+
+	wled_auto_string_detection(wled);
+
+	mutex_unlock(&wled->lock);
+}
+
 static int wled3_setup(struct wled *wled)
 {
 	u16 addr;
@@ -1596,7 +1621,7 @@ static int wled_configure_ovp_irq(struct wled *wled,
 	}
 
 	rc = devm_request_threaded_irq(wled->dev, wled->ovp_irq, NULL,
-				       wled_ovp_irq_handler, IRQF_ONESHOT,
+				       wled_ovp_irq_handler, IRQF_ONESHOT | IRQ_TYPE_EDGE_RISING,
 				       "wled_ovp_irq", wled);
 	if (rc < 0) {
 		dev_err(wled->dev, "Unable to request ovp_irq (err:%d)\n",
@@ -1604,16 +1629,16 @@ static int wled_configure_ovp_irq(struct wled *wled,
 		wled->ovp_irq = 0;
 		return 0;
 	}
+	
+	devm_delayed_work_autocancel(wled->dev, &wled->ovp_work, wled_ovp_work);
+	
+	devm_delayed_work_autocancel(wled->dev, &wled->fault_work, wled_fault_ovp_work);
 
 	rc = regmap_read(wled->regmap, wled->ctrl_addr +
 			 WLED3_CTRL_REG_MOD_EN, &val);
 	if (rc < 0)
 		return rc;
 
-	/* Keep OVP irq disabled until module is enabled */
-	if (!(val & WLED3_CTRL_REG_MOD_EN_MASK))
-		disable_irq(wled->ovp_irq);
-
 	return 0;
 }
 
@@ -1694,8 +1719,6 @@ static int wled_probe(struct platform_device *pdev)
 		break;
 	}
 
-	INIT_DELAYED_WORK(&wled->ovp_work, wled_ovp_work);
-
 	rc = wled_configure_short_irq(wled, pdev);
 	if (rc < 0)
 		return rc;
diff --git a/include/dt-bindings/input/ti-drv2624.h b/include/dt-bindings/input/ti-drv2624.h
new file mode 100644
index 00000000000000..5b9c9a80e840ee
--- /dev/null
+++ b/include/dt-bindings/input/ti-drv2624.h
@@ -0,0 +1,17 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * drv2624 haptics driver
+ *
+ * Copyright (c) 2016 Texas Instruments Inc.
+ * Copyright (c) 2024 Vitalii Skorkin <nikroksm@mail.ru>
+ *
+ */
+
+#ifndef _DT_BINDINGS_TI_DRV2624_H
+#define _DT_BINDINGS_TI_DRV2624_H
+
+/* Calibration Types */
+#define DRV2624_ERM_MODE		0x00
+#define DRV2624_LRA_MODE		0x01
+
+#endif
diff --git a/include/uapi/misc/fastrpc.h b/include/uapi/misc/fastrpc.h
index 91583690bddc52..f33d914d8f4699 100644
--- a/include/uapi/misc/fastrpc.h
+++ b/include/uapi/misc/fastrpc.h
@@ -8,14 +8,11 @@
 #define FASTRPC_IOCTL_ALLOC_DMA_BUFF	_IOWR('R', 1, struct fastrpc_alloc_dma_buf)
 #define FASTRPC_IOCTL_FREE_DMA_BUFF	_IOWR('R', 2, __u32)
 #define FASTRPC_IOCTL_INVOKE		_IOWR('R', 3, struct fastrpc_invoke)
-/* This ioctl is only supported with secure device nodes */
 #define FASTRPC_IOCTL_INIT_ATTACH	_IO('R', 4)
 #define FASTRPC_IOCTL_INIT_CREATE	_IOWR('R', 5, struct fastrpc_init_create)
 #define FASTRPC_IOCTL_MMAP		_IOWR('R', 6, struct fastrpc_req_mmap)
 #define FASTRPC_IOCTL_MUNMAP		_IOWR('R', 7, struct fastrpc_req_munmap)
-/* This ioctl is only supported with secure device nodes */
 #define FASTRPC_IOCTL_INIT_ATTACH_SNS	_IO('R', 8)
-/* This ioctl is only supported with secure device nodes */
 #define FASTRPC_IOCTL_INIT_CREATE_STATIC _IOWR('R', 9, struct fastrpc_init_create_static)
 #define FASTRPC_IOCTL_MEM_MAP		_IOWR('R', 10, struct fastrpc_mem_map)
 #define FASTRPC_IOCTL_MEM_UNMAP		_IOWR('R', 11, struct fastrpc_mem_unmap)
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 4afc43d3f71fd7..a6bb5716632d9c 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -278,6 +278,7 @@ config SND_SOC_ALL_CODECS
 	imply SND_SOC_UDA1380
 	imply SND_SOC_WCD9335
 	imply SND_SOC_WCD934X
+	imply SND_SOC_WCD937X_SDW
 	imply SND_SOC_WCD938X_SDW
 	imply SND_SOC_WCD939X_SDW
 	imply SND_SOC_LPASS_MACRO_COMMON
@@ -2100,6 +2101,25 @@ config SND_SOC_WCD934X
 	  The WCD9340/9341 is a audio codec IC Integrated in
 	  Qualcomm SoCs like SDM845.
 
+config SND_SOC_WCD937X
+	depends on SND_SOC_WCD937X_SDW
+	tristate
+	depends on SOUNDWIRE || !SOUNDWIRE
+	select SND_SOC_WCD_CLASSH
+
+config SND_SOC_WCD937X_SDW
+	tristate "WCD9370/WCD9375 Codec - SDW"
+	select SND_SOC_WCD937X
+	select SND_SOC_WCD_MBHC
+	select REGMAP_IRQ
+	depends on SOUNDWIRE
+	select REGMAP_SOUNDWIRE
+	help
+	  The WCD9370/9375 is an audio codec IC used with SoCs
+	  like SC7280 or QCM6490 chipsets, and it connected
+	  via soundwire.
+	  To compile this codec driver say Y or m.
+
 config SND_SOC_WCD938X
 	depends on SND_SOC_WCD938X_SDW
 	tristate
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index b4df22186e2552..c6f0cd5815f2c2 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -316,6 +316,8 @@ snd-soc-wcd-classh-y := wcd-clsh-v2.o
 snd-soc-wcd-mbhc-y := wcd-mbhc-v2.o
 snd-soc-wcd9335-y := wcd9335.o
 snd-soc-wcd934x-y := wcd934x.o
+snd-soc-wcd937x-objs := wcd937x.o
+snd-soc-wcd937x-sdw-objs := wcd937x-sdw.o
 snd-soc-wcd938x-y := wcd938x.o
 snd-soc-wcd938x-sdw-y := wcd938x-sdw.o
 snd-soc-wcd939x-y := wcd939x.o
@@ -710,6 +712,11 @@ obj-$(CONFIG_SND_SOC_WCD_CLASSH)	+= snd-soc-wcd-classh.o
 obj-$(CONFIG_SND_SOC_WCD_MBHC)	+= snd-soc-wcd-mbhc.o
 obj-$(CONFIG_SND_SOC_WCD9335)	+= snd-soc-wcd9335.o
 obj-$(CONFIG_SND_SOC_WCD934X)	+= snd-soc-wcd934x.o
+obj-$(CONFIG_SND_SOC_WCD937X)	+= snd-soc-wcd937x.o
+ifdef CONFIG_SND_SOC_WCD937X_SDW
+# avoid link failure by forcing sdw code built-in when needed
+obj-$(CONFIG_SND_SOC_WCD937X) += snd-soc-wcd937x-sdw.o
+endif
 obj-$(CONFIG_SND_SOC_WCD938X)	+= snd-soc-wcd938x.o
 ifdef CONFIG_SND_SOC_WCD938X_SDW
 # avoid link failure by forcing sdw code built-in when needed
diff --git a/sound/soc/codecs/tas2562.c b/sound/soc/codecs/tas2562.c
index 54561ae598b87a..159c6a77634116 100644
--- a/sound/soc/codecs/tas2562.c
+++ b/sound/soc/codecs/tas2562.c
@@ -471,6 +471,9 @@ static int tas2562_volume_control_put(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
 	struct tas2562_data *tas2562 = snd_soc_component_get_drvdata(component);
+	
+//Sometimes doesn't work with "amixer -c0 cset" command. Maybe it has to do something with 'page' switching
+#if 0
 	int ret;
 	u32 reg_val;
 
@@ -491,6 +494,7 @@ static int tas2562_volume_control_put(struct snd_kcontrol *kcontrol,
 				      ((reg_val >> 24) & 0xff));
 	if (ret)
 		return ret;
+#endif
 
 	tas2562->volume_lvl = ucontrol->value.integer.value[0];
 
diff --git a/sound/soc/codecs/wcd937x-sdw.c b/sound/soc/codecs/wcd937x-sdw.c
new file mode 100644
index 00000000000000..3abc8041406adc
--- /dev/null
+++ b/sound/soc/codecs/wcd937x-sdw.c
@@ -0,0 +1,1137 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2023-2024 Qualcomm Innovation Center, Inc. All rights reserved.
+
+#include <linux/component.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/soundwire/sdw.h>
+#include <linux/soundwire/sdw_registers.h>
+#include <linux/soundwire/sdw_type.h>
+#include <sound/soc-dapm.h>
+#include <sound/soc.h>
+#include "wcd937x.h"
+
+static const struct wcd937x_sdw_ch_info wcd937x_sdw_rx_ch_info[] = {
+	WCD_SDW_CH(WCD937X_HPH_L, WCD937X_HPH_PORT, BIT(0)),
+	WCD_SDW_CH(WCD937X_HPH_R, WCD937X_HPH_PORT, BIT(1)),
+	WCD_SDW_CH(WCD937X_CLSH, WCD937X_CLSH_PORT, BIT(0)),
+	WCD_SDW_CH(WCD937X_COMP_L, WCD937X_COMP_PORT, BIT(0)),
+	WCD_SDW_CH(WCD937X_COMP_R, WCD937X_COMP_PORT, BIT(1)),
+	WCD_SDW_CH(WCD937X_LO, WCD937X_LO_PORT, BIT(0)),
+	WCD_SDW_CH(WCD937X_DSD_L, WCD937X_DSD_PORT, BIT(0)),
+	WCD_SDW_CH(WCD937X_DSD_R, WCD937X_DSD_PORT, BIT(1)),
+};
+
+static const struct wcd937x_sdw_ch_info wcd937x_sdw_tx_ch_info[] = {
+	WCD_SDW_CH(WCD937X_ADC1, WCD937X_ADC_1_PORT, BIT(0)),
+	WCD_SDW_CH(WCD937X_ADC2, WCD937X_ADC_2_3_PORT, BIT(0)),
+	WCD_SDW_CH(WCD937X_ADC3, WCD937X_ADC_2_3_PORT, BIT(0)),
+	WCD_SDW_CH(WCD937X_DMIC0, WCD937X_DMIC_0_3_MBHC_PORT, BIT(0)),
+	WCD_SDW_CH(WCD937X_DMIC1, WCD937X_DMIC_0_3_MBHC_PORT, BIT(1)),
+	WCD_SDW_CH(WCD937X_MBHC, WCD937X_DMIC_0_3_MBHC_PORT, BIT(2)),
+	WCD_SDW_CH(WCD937X_DMIC2, WCD937X_DMIC_0_3_MBHC_PORT, BIT(2)),
+	WCD_SDW_CH(WCD937X_DMIC3, WCD937X_DMIC_0_3_MBHC_PORT, BIT(3)),
+	WCD_SDW_CH(WCD937X_DMIC4, WCD937X_DMIC_4_6_PORT, BIT(0)),
+	WCD_SDW_CH(WCD937X_DMIC5, WCD937X_DMIC_4_6_PORT, BIT(1)),
+	WCD_SDW_CH(WCD937X_DMIC6, WCD937X_DMIC_4_6_PORT, BIT(2)),
+};
+
+static struct sdw_dpn_prop wcd937x_dpn_prop[WCD937X_MAX_SWR_PORTS] = {
+	{
+		.num = 1,
+		.type = SDW_DPN_SIMPLE,
+		.min_ch = 1,
+		.max_ch = 8,
+		.simple_ch_prep_sm = true,
+	}, {
+		.num = 2,
+		.type = SDW_DPN_SIMPLE,
+		.min_ch = 1,
+		.max_ch = 4,
+		.simple_ch_prep_sm = true,
+	}, {
+		.num = 3,
+		.type = SDW_DPN_SIMPLE,
+		.min_ch = 1,
+		.max_ch = 4,
+		.simple_ch_prep_sm = true,
+	}, {
+		.num = 4,
+		.type = SDW_DPN_SIMPLE,
+		.min_ch = 1,
+		.max_ch = 4,
+		.simple_ch_prep_sm = true,
+	}, {
+		.num = 5,
+		.type = SDW_DPN_SIMPLE,
+		.min_ch = 1,
+		.max_ch = 4,
+		.simple_ch_prep_sm = true,
+	}
+};
+
+struct device *wcd937x_sdw_device_get(struct device_node *np)
+{
+	return bus_find_device_by_of_node(&sdw_bus_type, np);
+}
+EXPORT_SYMBOL_GPL(wcd937x_sdw_device_get);
+
+int wcd937x_sdw_hw_params(struct wcd937x_sdw_priv *wcd,
+			  struct snd_pcm_substream *substream,
+			  struct snd_pcm_hw_params *params,
+			  struct snd_soc_dai *dai)
+{
+	struct sdw_port_config port_config[WCD937X_MAX_SWR_PORTS];
+	unsigned long ch_mask;
+	int i, j;
+
+	wcd->sconfig.ch_count = 1;
+	wcd->active_ports = 0;
+	for (i = 0; i < WCD937X_MAX_SWR_PORTS; i++) {
+		ch_mask = wcd->port_config[i].ch_mask;
+		if (!ch_mask)
+			continue;
+
+		for_each_set_bit(j, &ch_mask, 4)
+			wcd->sconfig.ch_count++;
+
+		port_config[wcd->active_ports] = wcd->port_config[i];
+		wcd->active_ports++;
+	}
+
+	wcd->sconfig.bps = 1;
+	wcd->sconfig.frame_rate = params_rate(params);
+	wcd->sconfig.direction = wcd->is_tx ? SDW_DATA_DIR_TX : SDW_DATA_DIR_RX;
+	wcd->sconfig.type = SDW_STREAM_PCM;
+
+	return sdw_stream_add_slave(wcd->sdev, &wcd->sconfig,
+				    &port_config[0], wcd->active_ports,
+				    wcd->sruntime);
+}
+EXPORT_SYMBOL_GPL(wcd937x_sdw_hw_params);
+
+static int wcd9370_update_status(struct sdw_slave *slave, enum sdw_slave_status status)
+{
+	struct wcd937x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
+
+	if (wcd->regmap && status == SDW_SLAVE_ATTACHED) {
+		/* Write out any cached changes that happened between probe and attach */
+		regcache_cache_only(wcd->regmap, false);
+		return regcache_sync(wcd->regmap);
+	}
+
+	return 0;
+}
+
+/*
+ * Handle Soundwire out-of-band interrupt event by triggering
+ * the first irq of the slave_irq irq domain, which then will
+ * be handled by the regmap_irq threaded irq.
+ * Looping is to ensure no interrupts were missed in the process.
+ */
+static int wcd9370_interrupt_callback(struct sdw_slave *slave,
+				      struct sdw_slave_intr_status *status)
+{
+	struct wcd937x_sdw_priv *wcd = dev_get_drvdata(&slave->dev);
+	struct irq_domain *slave_irq = wcd->slave_irq;
+	u32 sts1, sts2, sts3;
+
+	do {
+		handle_nested_irq(irq_find_mapping(slave_irq, 0));
+		regmap_read(wcd->regmap, WCD937X_DIGITAL_INTR_STATUS_0, &sts1);
+		regmap_read(wcd->regmap, WCD937X_DIGITAL_INTR_STATUS_1, &sts2);
+		regmap_read(wcd->regmap, WCD937X_DIGITAL_INTR_STATUS_2, &sts3);
+
+	} while (sts1 || sts2 || sts3);
+
+	return IRQ_HANDLED;
+}
+
+static const struct reg_default wcd937x_defaults[] = {
+	/* Default values except for Read-Only & Volatile registers */
+	{ WCD937X_ANA_BIAS,					0x00 },
+	{ WCD937X_ANA_RX_SUPPLIES,				0x00 },
+	{ WCD937X_ANA_HPH,					0x0c },
+	{ WCD937X_ANA_EAR,					0x00 },
+	{ WCD937X_ANA_EAR_COMPANDER_CTL,			0x02 },
+	{ WCD937X_ANA_TX_CH1,					0x20 },
+	{ WCD937X_ANA_TX_CH2,					0x00 },
+	{ WCD937X_ANA_TX_CH3,					0x20 },
+	{ WCD937X_ANA_TX_CH3_HPF,				0x00 },
+	{ WCD937X_ANA_MICB1_MICB2_DSP_EN_LOGIC,			0x00 },
+	{ WCD937X_ANA_MICB3_DSP_EN_LOGIC,			0x00 },
+	{ WCD937X_ANA_MBHC_MECH,				0x39 },
+	{ WCD937X_ANA_MBHC_ELECT,				0x08 },
+	{ WCD937X_ANA_MBHC_ZDET,				0x00 },
+	{ WCD937X_ANA_MBHC_BTN0,				0x00 },
+	{ WCD937X_ANA_MBHC_BTN1,				0x10 },
+	{ WCD937X_ANA_MBHC_BTN2,				0x20 },
+	{ WCD937X_ANA_MBHC_BTN3,				0x30 },
+	{ WCD937X_ANA_MBHC_BTN4,				0x40 },
+	{ WCD937X_ANA_MBHC_BTN5,				0x50 },
+	{ WCD937X_ANA_MBHC_BTN6,				0x60 },
+	{ WCD937X_ANA_MBHC_BTN7,				0x70 },
+	{ WCD937X_ANA_MICB1,					0x10 },
+	{ WCD937X_ANA_MICB2,					0x10 },
+	{ WCD937X_ANA_MICB2_RAMP,				0x00 },
+	{ WCD937X_ANA_MICB3,					0x10 },
+	{ WCD937X_BIAS_CTL,					0x2a },
+	{ WCD937X_BIAS_VBG_FINE_ADJ,				0x55 },
+	{ WCD937X_LDOL_VDDCX_ADJUST,				0x01 },
+	{ WCD937X_LDOL_DISABLE_LDOL,				0x00 },
+	{ WCD937X_MBHC_CTL_CLK,					0x00 },
+	{ WCD937X_MBHC_CTL_ANA,					0x00 },
+	{ WCD937X_MBHC_CTL_SPARE_1,				0x00 },
+	{ WCD937X_MBHC_CTL_SPARE_2,				0x00 },
+	{ WCD937X_MBHC_CTL_BCS,					0x00 },
+	{ WCD937X_MBHC_TEST_CTL,				0x00 },
+	{ WCD937X_LDOH_MODE,					0x2b },
+	{ WCD937X_LDOH_BIAS,					0x68 },
+	{ WCD937X_LDOH_STB_LOADS,				0x00 },
+	{ WCD937X_LDOH_SLOWRAMP,				0x50 },
+	{ WCD937X_MICB1_TEST_CTL_1,				0x1a },
+	{ WCD937X_MICB1_TEST_CTL_2,				0x18 },
+	{ WCD937X_MICB1_TEST_CTL_3,				0xa4 },
+	{ WCD937X_MICB2_TEST_CTL_1,				0x1a },
+	{ WCD937X_MICB2_TEST_CTL_2,				0x18 },
+	{ WCD937X_MICB2_TEST_CTL_3,				0xa4 },
+	{ WCD937X_MICB3_TEST_CTL_1,				0x1a },
+	{ WCD937X_MICB3_TEST_CTL_2,				0x18 },
+	{ WCD937X_MICB3_TEST_CTL_3,				0xa4 },
+	{ WCD937X_TX_COM_ADC_VCM,				0x39 },
+	{ WCD937X_TX_COM_BIAS_ATEST,				0xc0 },
+	{ WCD937X_TX_COM_ADC_INT1_IB,				0x6f },
+	{ WCD937X_TX_COM_ADC_INT2_IB,				0x4f },
+	{ WCD937X_TX_COM_TXFE_DIV_CTL,				0x2e },
+	{ WCD937X_TX_COM_TXFE_DIV_START,			0x00 },
+	{ WCD937X_TX_COM_TXFE_DIV_STOP_9P6M,			0xc7 },
+	{ WCD937X_TX_COM_TXFE_DIV_STOP_12P288M,			0xff },
+	{ WCD937X_TX_1_2_TEST_EN,				0xcc },
+	{ WCD937X_TX_1_2_ADC_IB,				0x09 },
+	{ WCD937X_TX_1_2_ATEST_REFCTL,				0x0a },
+	{ WCD937X_TX_1_2_TEST_CTL,				0x38 },
+	{ WCD937X_TX_1_2_TEST_BLK_EN,				0xff },
+	{ WCD937X_TX_1_2_TXFE_CLKDIV,				0x00 },
+	{ WCD937X_TX_3_TEST_EN,					0xcc },
+	{ WCD937X_TX_3_ADC_IB,					0x09 },
+	{ WCD937X_TX_3_ATEST_REFCTL,				0x0a },
+	{ WCD937X_TX_3_TEST_CTL,				0x38 },
+	{ WCD937X_TX_3_TEST_BLK_EN,				0xff },
+	{ WCD937X_TX_3_TXFE_CLKDIV,				0x00 },
+	{ WCD937X_TX_3_SPARE_MONO,				0x00 },
+	{ WCD937X_CLASSH_MODE_1,				0x40 },
+	{ WCD937X_CLASSH_MODE_2,				0x3a },
+	{ WCD937X_CLASSH_MODE_3,				0x00 },
+	{ WCD937X_CLASSH_CTRL_VCL_1,				0x70 },
+	{ WCD937X_CLASSH_CTRL_VCL_2,				0x82 },
+	{ WCD937X_CLASSH_CTRL_CCL_1,				0x31 },
+	{ WCD937X_CLASSH_CTRL_CCL_2,				0x80 },
+	{ WCD937X_CLASSH_CTRL_CCL_3,				0x80 },
+	{ WCD937X_CLASSH_CTRL_CCL_4,				0x51 },
+	{ WCD937X_CLASSH_CTRL_CCL_5,				0x00 },
+	{ WCD937X_CLASSH_BUCK_TMUX_A_D,				0x00 },
+	{ WCD937X_CLASSH_BUCK_SW_DRV_CNTL,			0x77 },
+	{ WCD937X_CLASSH_SPARE,					0x00 },
+	{ WCD937X_FLYBACK_EN,					0x4e },
+	{ WCD937X_FLYBACK_VNEG_CTRL_1,				0x0b },
+	{ WCD937X_FLYBACK_VNEG_CTRL_2,				0x45 },
+	{ WCD937X_FLYBACK_VNEG_CTRL_3,				0x74 },
+	{ WCD937X_FLYBACK_VNEG_CTRL_4,				0x7f },
+	{ WCD937X_FLYBACK_VNEG_CTRL_5,				0x83 },
+	{ WCD937X_FLYBACK_VNEG_CTRL_6,				0x98 },
+	{ WCD937X_FLYBACK_VNEG_CTRL_7,				0xa9 },
+	{ WCD937X_FLYBACK_VNEG_CTRL_8,				0x68 },
+	{ WCD937X_FLYBACK_VNEG_CTRL_9,				0x64 },
+	{ WCD937X_FLYBACK_VNEGDAC_CTRL_1,			0xed },
+	{ WCD937X_FLYBACK_VNEGDAC_CTRL_2,			0xf0 },
+	{ WCD937X_FLYBACK_VNEGDAC_CTRL_3,			0xa6 },
+	{ WCD937X_FLYBACK_CTRL_1,				0x65 },
+	{ WCD937X_FLYBACK_TEST_CTL,				0x00 },
+	{ WCD937X_RX_AUX_SW_CTL,				0x00 },
+	{ WCD937X_RX_PA_AUX_IN_CONN,				0x00 },
+	{ WCD937X_RX_TIMER_DIV,					0x32 },
+	{ WCD937X_RX_OCP_CTL,					0x1f },
+	{ WCD937X_RX_OCP_COUNT,					0x77 },
+	{ WCD937X_RX_BIAS_EAR_DAC,				0xa0 },
+	{ WCD937X_RX_BIAS_EAR_AMP,				0xaa },
+	{ WCD937X_RX_BIAS_HPH_LDO,				0xa9 },
+	{ WCD937X_RX_BIAS_HPH_PA,				0xaa },
+	{ WCD937X_RX_BIAS_HPH_RDACBUFF_CNP2,			0x8a },
+	{ WCD937X_RX_BIAS_HPH_RDAC_LDO,				0x88 },
+	{ WCD937X_RX_BIAS_HPH_CNP1,				0x82 },
+	{ WCD937X_RX_BIAS_HPH_LOWPOWER,				0x82 },
+	{ WCD937X_RX_BIAS_AUX_DAC,				0xa0 },
+	{ WCD937X_RX_BIAS_AUX_AMP,				0xaa },
+	{ WCD937X_RX_BIAS_VNEGDAC_BLEEDER,			0x50 },
+	{ WCD937X_RX_BIAS_MISC,					0x00 },
+	{ WCD937X_RX_BIAS_BUCK_RST,				0x08 },
+	{ WCD937X_RX_BIAS_BUCK_VREF_ERRAMP,			0x44 },
+	{ WCD937X_RX_BIAS_FLYB_ERRAMP,				0x40 },
+	{ WCD937X_RX_BIAS_FLYB_BUFF,				0xaa },
+	{ WCD937X_RX_BIAS_FLYB_MID_RST,				0x14 },
+	{ WCD937X_HPH_CNP_EN,					0x80 },
+	{ WCD937X_HPH_CNP_WG_CTL,				0x9a },
+	{ WCD937X_HPH_CNP_WG_TIME,				0x14 },
+	{ WCD937X_HPH_OCP_CTL,					0x28 },
+	{ WCD937X_HPH_AUTO_CHOP,				0x16 },
+	{ WCD937X_HPH_CHOP_CTL,					0x83 },
+	{ WCD937X_HPH_PA_CTL1,					0x46 },
+	{ WCD937X_HPH_PA_CTL2,					0x50 },
+	{ WCD937X_HPH_L_EN,					0x80 },
+	{ WCD937X_HPH_L_TEST,					0xe0 },
+	{ WCD937X_HPH_L_ATEST,					0x50 },
+	{ WCD937X_HPH_R_EN,					0x80 },
+	{ WCD937X_HPH_R_TEST,					0xe0 },
+	{ WCD937X_HPH_R_ATEST,					0x54 },
+	{ WCD937X_HPH_RDAC_CLK_CTL1,				0x99 },
+	{ WCD937X_HPH_RDAC_CLK_CTL2,				0x9b },
+	{ WCD937X_HPH_RDAC_LDO_CTL,				0x33 },
+	{ WCD937X_HPH_RDAC_CHOP_CLK_LP_CTL,			0x00 },
+	{ WCD937X_HPH_REFBUFF_UHQA_CTL,				0xa8 },
+	{ WCD937X_HPH_REFBUFF_LP_CTL,				0x0e },
+	{ WCD937X_HPH_L_DAC_CTL,				0x20 },
+	{ WCD937X_HPH_R_DAC_CTL,				0x20 },
+	{ WCD937X_HPH_SURGE_HPHLR_SURGE_COMP_SEL,		0x55 },
+	{ WCD937X_HPH_SURGE_HPHLR_SURGE_EN,			0x19 },
+	{ WCD937X_HPH_SURGE_HPHLR_SURGE_MISC1,			0xa0 },
+	{ WCD937X_EAR_EAR_EN_REG,				0x22 },
+	{ WCD937X_EAR_EAR_PA_CON,				0x44 },
+	{ WCD937X_EAR_EAR_SP_CON,				0xdb },
+	{ WCD937X_EAR_EAR_DAC_CON,				0x80 },
+	{ WCD937X_EAR_EAR_CNP_FSM_CON,				0xb2 },
+	{ WCD937X_EAR_TEST_CTL,					0x00 },
+	{ WCD937X_ANA_NEW_PAGE_REGISTER,			0x00 },
+	{ WCD937X_HPH_NEW_ANA_HPH2,				0x00 },
+	{ WCD937X_HPH_NEW_ANA_HPH3,				0x00 },
+	{ WCD937X_SLEEP_CTL,					0x16 },
+	{ WCD937X_SLEEP_WATCHDOG_CTL,				0x00 },
+	{ WCD937X_MBHC_NEW_ELECT_REM_CLAMP_CTL,			0x00 },
+	{ WCD937X_MBHC_NEW_CTL_1,				0x02 },
+	{ WCD937X_MBHC_NEW_CTL_2,				0x05 },
+	{ WCD937X_MBHC_NEW_PLUG_DETECT_CTL,			0xe9 },
+	{ WCD937X_MBHC_NEW_ZDET_ANA_CTL,			0x0f },
+	{ WCD937X_MBHC_NEW_ZDET_RAMP_CTL,			0x00 },
+	{ WCD937X_TX_NEW_TX_CH2_SEL,				0x00 },
+	{ WCD937X_AUX_AUXPA,					0x00 },
+	{ WCD937X_LDORXTX_MODE,					0x0c },
+	{ WCD937X_LDORXTX_CONFIG,				0x10 },
+	{ WCD937X_DIE_CRACK_DIE_CRK_DET_EN,			0x00 },
+	{ WCD937X_HPH_NEW_INT_RDAC_GAIN_CTL,			0x40 },
+	{ WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_L,			0x81 },
+	{ WCD937X_HPH_NEW_INT_RDAC_VREF_CTL,			0x10 },
+	{ WCD937X_HPH_NEW_INT_RDAC_OVERRIDE_CTL,		0x00 },
+	{ WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_R,			0x81 },
+	{ WCD937X_HPH_NEW_INT_PA_MISC1,				0x22 },
+	{ WCD937X_HPH_NEW_INT_PA_MISC2,				0x00 },
+	{ WCD937X_HPH_NEW_INT_PA_RDAC_MISC,			0x00 },
+	{ WCD937X_HPH_NEW_INT_HPH_TIMER1,			0xfe },
+	{ WCD937X_HPH_NEW_INT_HPH_TIMER2,			0x02 },
+	{ WCD937X_HPH_NEW_INT_HPH_TIMER3,			0x4e },
+	{ WCD937X_HPH_NEW_INT_HPH_TIMER4,			0x54 },
+	{ WCD937X_HPH_NEW_INT_PA_RDAC_MISC2,			0x00 },
+	{ WCD937X_HPH_NEW_INT_PA_RDAC_MISC3,			0x00 },
+	{ WCD937X_RX_NEW_INT_HPH_RDAC_BIAS_LOHIFI,		0x62 },
+	{ WCD937X_RX_NEW_INT_HPH_RDAC_BIAS_ULP,			0x01 },
+	{ WCD937X_RX_NEW_INT_HPH_RDAC_LDO_LP,			0x11 },
+	{ WCD937X_MBHC_NEW_INT_MOISTURE_DET_DC_CTRL,		0x57 },
+	{ WCD937X_MBHC_NEW_INT_MOISTURE_DET_POLLING_CTRL,	0x01 },
+	{ WCD937X_MBHC_NEW_INT_MECH_DET_CURRENT,		0x00 },
+	{ WCD937X_MBHC_NEW_INT_SPARE_2,				0x00 },
+	{ WCD937X_EAR_INT_NEW_EAR_CHOPPER_CON,			0xa8 },
+	{ WCD937X_EAR_INT_NEW_CNP_VCM_CON1,			0x42 },
+	{ WCD937X_EAR_INT_NEW_CNP_VCM_CON2,			0x22 },
+	{ WCD937X_EAR_INT_NEW_EAR_DYNAMIC_BIAS,			0x00 },
+	{ WCD937X_AUX_INT_EN_REG,				0x00 },
+	{ WCD937X_AUX_INT_PA_CTRL,				0x06 },
+	{ WCD937X_AUX_INT_SP_CTRL,				0xd2 },
+	{ WCD937X_AUX_INT_DAC_CTRL,				0x80 },
+	{ WCD937X_AUX_INT_CLK_CTRL,				0x50 },
+	{ WCD937X_AUX_INT_TEST_CTRL,				0x00 },
+	{ WCD937X_AUX_INT_STATUS_REG,				0x00 },
+	{ WCD937X_AUX_INT_MISC,					0x00 },
+	{ WCD937X_LDORXTX_INT_BIAS,				0x6e },
+	{ WCD937X_LDORXTX_INT_STB_LOADS_DTEST,			0x50 },
+	{ WCD937X_LDORXTX_INT_TEST0,				0x1c },
+	{ WCD937X_LDORXTX_INT_STARTUP_TIMER,			0xff },
+	{ WCD937X_LDORXTX_INT_TEST1,				0x1f },
+	{ WCD937X_LDORXTX_INT_STATUS,				0x00 },
+	{ WCD937X_SLEEP_INT_WATCHDOG_CTL_1,			0x0a },
+	{ WCD937X_SLEEP_INT_WATCHDOG_CTL_2,			0x0a },
+	{ WCD937X_DIE_CRACK_INT_DIE_CRK_DET_INT1,		0x02 },
+	{ WCD937X_DIE_CRACK_INT_DIE_CRK_DET_INT2,		0x60 },
+	{ WCD937X_DIGITAL_PAGE_REGISTER,			0x00 },
+	{ WCD937X_DIGITAL_CDC_RST_CTL,				0x03 },
+	{ WCD937X_DIGITAL_TOP_CLK_CFG,				0x00 },
+	{ WCD937X_DIGITAL_CDC_ANA_CLK_CTL,			0x00 },
+	{ WCD937X_DIGITAL_CDC_DIG_CLK_CTL,			0x00 },
+	{ WCD937X_DIGITAL_SWR_RST_EN,				0x00 },
+	{ WCD937X_DIGITAL_CDC_PATH_MODE,			0x55 },
+	{ WCD937X_DIGITAL_CDC_RX_RST,				0x00 },
+	{ WCD937X_DIGITAL_CDC_RX0_CTL,				0xfc },
+	{ WCD937X_DIGITAL_CDC_RX1_CTL,				0xfc },
+	{ WCD937X_DIGITAL_CDC_RX2_CTL,				0xfc },
+	{ WCD937X_DIGITAL_DEM_BYPASS_DATA0,			0x55 },
+	{ WCD937X_DIGITAL_DEM_BYPASS_DATA1,			0x55 },
+	{ WCD937X_DIGITAL_DEM_BYPASS_DATA2,			0x55 },
+	{ WCD937X_DIGITAL_DEM_BYPASS_DATA3,			0x01 },
+	{ WCD937X_DIGITAL_CDC_COMP_CTL_0,			0x00 },
+	{ WCD937X_DIGITAL_CDC_RX_DELAY_CTL,			0x66 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_A1_0,			0x00 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_A1_1,			0x01 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_A2_0,			0x63 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_A2_1,			0x04 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_A3_0,			0xac },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_A3_1,			0x04 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_A4_0,			0x1a },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_A4_1,			0x03 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_A5_0,			0xbc },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_A5_1,			0x02 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_A6_0,			0xc7 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_A7_0,			0xf8 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_C_0,			0x47 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_C_1,			0x43 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_C_2,			0xb1 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_C_3,			0x17 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_R1,			0x4b },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_R2,			0x26 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_R3,			0x32 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_R4,			0x57 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_R5,			0x63 },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_R6,			0x7c },
+	{ WCD937X_DIGITAL_CDC_HPH_DSM_R7,			0x57 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_A1_0,			0x00 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_A1_1,			0x01 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_A2_0,			0x96 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_A2_1,			0x09 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_A3_0,			0xab },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_A3_1,			0x05 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_A4_0,			0x1c },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_A4_1,			0x02 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_A5_0,			0x17 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_A5_1,			0x02 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_A6_0,			0xaa },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_A7_0,			0xe3 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_C_0,			0x69 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_C_1,			0x54 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_C_2,			0x02 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_C_3,			0x15 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_R1,			0xa4 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_R2,			0xb5 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_R3,			0x86 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_R4,			0x85 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_R5,			0xaa },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_R6,			0xe2 },
+	{ WCD937X_DIGITAL_CDC_AUX_DSM_R7,			0x62 },
+	{ WCD937X_DIGITAL_CDC_HPH_GAIN_RX_0,			0x55 },
+	{ WCD937X_DIGITAL_CDC_HPH_GAIN_RX_1,			0xa9 },
+	{ WCD937X_DIGITAL_CDC_HPH_GAIN_DSD_0,			0x3d },
+	{ WCD937X_DIGITAL_CDC_HPH_GAIN_DSD_1,			0x2e },
+	{ WCD937X_DIGITAL_CDC_HPH_GAIN_DSD_2,			0x01 },
+	{ WCD937X_DIGITAL_CDC_AUX_GAIN_DSD_0,			0x00 },
+	{ WCD937X_DIGITAL_CDC_AUX_GAIN_DSD_1,			0xfc },
+	{ WCD937X_DIGITAL_CDC_AUX_GAIN_DSD_2,			0x01 },
+	{ WCD937X_DIGITAL_CDC_HPH_GAIN_CTL,			0x00 },
+	{ WCD937X_DIGITAL_CDC_AUX_GAIN_CTL,			0x00 },
+	{ WCD937X_DIGITAL_CDC_EAR_PATH_CTL,			0x00 },
+	{ WCD937X_DIGITAL_CDC_SWR_CLH,				0x00 },
+	{ WCD937X_DIGITAL_SWR_CLH_BYP,				0x00 },
+	{ WCD937X_DIGITAL_CDC_TX0_CTL,				0x68 },
+	{ WCD937X_DIGITAL_CDC_TX1_CTL,				0x68 },
+	{ WCD937X_DIGITAL_CDC_TX2_CTL,				0x68 },
+	{ WCD937X_DIGITAL_CDC_TX_RST,				0x00 },
+	{ WCD937X_DIGITAL_CDC_REQ_CTL,				0x01 },
+	{ WCD937X_DIGITAL_CDC_AMIC_CTL,				0x07 },
+	{ WCD937X_DIGITAL_CDC_DMIC_CTL,				0x00 },
+	{ WCD937X_DIGITAL_CDC_DMIC1_CTL,			0x01 },
+	{ WCD937X_DIGITAL_CDC_DMIC2_CTL,			0x01 },
+	{ WCD937X_DIGITAL_CDC_DMIC3_CTL,			0x01 },
+	{ WCD937X_DIGITAL_EFUSE_CTL,				0x2b },
+	{ WCD937X_DIGITAL_EFUSE_PRG_CTL,			0x00 },
+	{ WCD937X_DIGITAL_EFUSE_TEST_CTL_0,			0x00 },
+	{ WCD937X_DIGITAL_EFUSE_TEST_CTL_1,			0x00 },
+	{ WCD937X_DIGITAL_PDM_WD_CTL0,				0x00 },
+	{ WCD937X_DIGITAL_PDM_WD_CTL1,				0x00 },
+	{ WCD937X_DIGITAL_PDM_WD_CTL2,				0x00 },
+	{ WCD937X_DIGITAL_INTR_MODE,				0x00 },
+	{ WCD937X_DIGITAL_INTR_MASK_0,				0xff },
+	{ WCD937X_DIGITAL_INTR_MASK_1,				0xff },
+	{ WCD937X_DIGITAL_INTR_MASK_2,				0x0f },
+	{ WCD937X_DIGITAL_INTR_CLEAR_0,				0x00 },
+	{ WCD937X_DIGITAL_INTR_CLEAR_1,				0x00 },
+	{ WCD937X_DIGITAL_INTR_CLEAR_2,				0x00 },
+	{ WCD937X_DIGITAL_INTR_LEVEL_0,				0x00 },
+	{ WCD937X_DIGITAL_INTR_LEVEL_1,				0x00 },
+	{ WCD937X_DIGITAL_INTR_LEVEL_2,				0x00 },
+	{ WCD937X_DIGITAL_INTR_SET_0,				0x00 },
+	{ WCD937X_DIGITAL_INTR_SET_1,				0x00 },
+	{ WCD937X_DIGITAL_INTR_SET_2,				0x00 },
+	{ WCD937X_DIGITAL_INTR_TEST_0,				0x00 },
+	{ WCD937X_DIGITAL_INTR_TEST_1,				0x00 },
+	{ WCD937X_DIGITAL_INTR_TEST_2,				0x00 },
+	{ WCD937X_DIGITAL_CDC_CONN_RX0_CTL,			0x00 },
+	{ WCD937X_DIGITAL_CDC_CONN_RX1_CTL,			0x00 },
+	{ WCD937X_DIGITAL_CDC_CONN_RX2_CTL,			0x00 },
+	{ WCD937X_DIGITAL_CDC_CONN_TX_CTL,			0x00 },
+	{ WCD937X_DIGITAL_LOOP_BACK_MODE,			0x00 },
+	{ WCD937X_DIGITAL_SWR_DAC_TEST,				0x00 },
+	{ WCD937X_DIGITAL_SWR_HM_TEST_RX_0,			0x40 },
+	{ WCD937X_DIGITAL_SWR_HM_TEST_TX_0,			0x40 },
+	{ WCD937X_DIGITAL_SWR_HM_TEST_RX_1,			0x00 },
+	{ WCD937X_DIGITAL_SWR_HM_TEST_TX_1,			0x00 },
+	{ WCD937X_DIGITAL_PAD_CTL_PDM_RX0,			0xf1 },
+	{ WCD937X_DIGITAL_PAD_CTL_PDM_RX1,			0xf1 },
+	{ WCD937X_DIGITAL_PAD_CTL_PDM_TX0,			0xf1 },
+	{ WCD937X_DIGITAL_PAD_CTL_PDM_TX1,			0xf1 },
+	{ WCD937X_DIGITAL_PAD_INP_DIS_0,			0x00 },
+	{ WCD937X_DIGITAL_PAD_INP_DIS_1,			0x00 },
+	{ WCD937X_DIGITAL_DRIVE_STRENGTH_0,			0x00 },
+	{ WCD937X_DIGITAL_DRIVE_STRENGTH_1,			0x00 },
+	{ WCD937X_DIGITAL_DRIVE_STRENGTH_2,			0x00 },
+	{ WCD937X_DIGITAL_RX_DATA_EDGE_CTL,			0x1f },
+	{ WCD937X_DIGITAL_TX_DATA_EDGE_CTL,			0x10 },
+	{ WCD937X_DIGITAL_GPIO_MODE,				0x00 },
+	{ WCD937X_DIGITAL_PIN_CTL_OE,				0x00 },
+	{ WCD937X_DIGITAL_PIN_CTL_DATA_0,			0x00 },
+	{ WCD937X_DIGITAL_PIN_CTL_DATA_1,			0x00 },
+	{ WCD937X_DIGITAL_DIG_DEBUG_CTL,			0x00 },
+	{ WCD937X_DIGITAL_DIG_DEBUG_EN,				0x00 },
+	{ WCD937X_DIGITAL_ANA_CSR_DBG_ADD,			0x00 },
+	{ WCD937X_DIGITAL_ANA_CSR_DBG_CTL,			0x48 },
+	{ WCD937X_DIGITAL_SSP_DBG,				0x00 },
+	{ WCD937X_DIGITAL_SPARE_0,				0x00 },
+	{ WCD937X_DIGITAL_SPARE_1,				0x00 },
+	{ WCD937X_DIGITAL_SPARE_2,				0x00 },
+};
+
+static bool wcd937x_rdwr_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case WCD937X_ANA_BIAS:
+	case WCD937X_ANA_RX_SUPPLIES:
+	case WCD937X_ANA_HPH:
+	case WCD937X_ANA_EAR:
+	case WCD937X_ANA_EAR_COMPANDER_CTL:
+	case WCD937X_ANA_TX_CH1:
+	case WCD937X_ANA_TX_CH2:
+	case WCD937X_ANA_TX_CH3:
+	case WCD937X_ANA_TX_CH3_HPF:
+	case WCD937X_ANA_MICB1_MICB2_DSP_EN_LOGIC:
+	case WCD937X_ANA_MICB3_DSP_EN_LOGIC:
+	case WCD937X_ANA_MBHC_MECH:
+	case WCD937X_ANA_MBHC_ELECT:
+	case WCD937X_ANA_MBHC_ZDET:
+	case WCD937X_ANA_MBHC_BTN0:
+	case WCD937X_ANA_MBHC_BTN1:
+	case WCD937X_ANA_MBHC_BTN2:
+	case WCD937X_ANA_MBHC_BTN3:
+	case WCD937X_ANA_MBHC_BTN4:
+	case WCD937X_ANA_MBHC_BTN5:
+	case WCD937X_ANA_MBHC_BTN6:
+	case WCD937X_ANA_MBHC_BTN7:
+	case WCD937X_ANA_MICB1:
+	case WCD937X_ANA_MICB2:
+	case WCD937X_ANA_MICB2_RAMP:
+	case WCD937X_ANA_MICB3:
+	case WCD937X_BIAS_CTL:
+	case WCD937X_BIAS_VBG_FINE_ADJ:
+	case WCD937X_LDOL_VDDCX_ADJUST:
+	case WCD937X_LDOL_DISABLE_LDOL:
+	case WCD937X_MBHC_CTL_CLK:
+	case WCD937X_MBHC_CTL_ANA:
+	case WCD937X_MBHC_CTL_SPARE_1:
+	case WCD937X_MBHC_CTL_SPARE_2:
+	case WCD937X_MBHC_CTL_BCS:
+	case WCD937X_MBHC_TEST_CTL:
+	case WCD937X_LDOH_MODE:
+	case WCD937X_LDOH_BIAS:
+	case WCD937X_LDOH_STB_LOADS:
+	case WCD937X_LDOH_SLOWRAMP:
+	case WCD937X_MICB1_TEST_CTL_1:
+	case WCD937X_MICB1_TEST_CTL_2:
+	case WCD937X_MICB1_TEST_CTL_3:
+	case WCD937X_MICB2_TEST_CTL_1:
+	case WCD937X_MICB2_TEST_CTL_2:
+	case WCD937X_MICB2_TEST_CTL_3:
+	case WCD937X_MICB3_TEST_CTL_1:
+	case WCD937X_MICB3_TEST_CTL_2:
+	case WCD937X_MICB3_TEST_CTL_3:
+	case WCD937X_TX_COM_ADC_VCM:
+	case WCD937X_TX_COM_BIAS_ATEST:
+	case WCD937X_TX_COM_ADC_INT1_IB:
+	case WCD937X_TX_COM_ADC_INT2_IB:
+	case WCD937X_TX_COM_TXFE_DIV_CTL:
+	case WCD937X_TX_COM_TXFE_DIV_START:
+	case WCD937X_TX_COM_TXFE_DIV_STOP_9P6M:
+	case WCD937X_TX_COM_TXFE_DIV_STOP_12P288M:
+	case WCD937X_TX_1_2_TEST_EN:
+	case WCD937X_TX_1_2_ADC_IB:
+	case WCD937X_TX_1_2_ATEST_REFCTL:
+	case WCD937X_TX_1_2_TEST_CTL:
+	case WCD937X_TX_1_2_TEST_BLK_EN:
+	case WCD937X_TX_1_2_TXFE_CLKDIV:
+	case WCD937X_TX_3_TEST_EN:
+	case WCD937X_TX_3_ADC_IB:
+	case WCD937X_TX_3_ATEST_REFCTL:
+	case WCD937X_TX_3_TEST_CTL:
+	case WCD937X_TX_3_TEST_BLK_EN:
+	case WCD937X_TX_3_TXFE_CLKDIV:
+	case WCD937X_CLASSH_MODE_1:
+	case WCD937X_CLASSH_MODE_2:
+	case WCD937X_CLASSH_MODE_3:
+	case WCD937X_CLASSH_CTRL_VCL_1:
+	case WCD937X_CLASSH_CTRL_VCL_2:
+	case WCD937X_CLASSH_CTRL_CCL_1:
+	case WCD937X_CLASSH_CTRL_CCL_2:
+	case WCD937X_CLASSH_CTRL_CCL_3:
+	case WCD937X_CLASSH_CTRL_CCL_4:
+	case WCD937X_CLASSH_CTRL_CCL_5:
+	case WCD937X_CLASSH_BUCK_TMUX_A_D:
+	case WCD937X_CLASSH_BUCK_SW_DRV_CNTL:
+	case WCD937X_CLASSH_SPARE:
+	case WCD937X_FLYBACK_EN:
+	case WCD937X_FLYBACK_VNEG_CTRL_1:
+	case WCD937X_FLYBACK_VNEG_CTRL_2:
+	case WCD937X_FLYBACK_VNEG_CTRL_3:
+	case WCD937X_FLYBACK_VNEG_CTRL_4:
+	case WCD937X_FLYBACK_VNEG_CTRL_5:
+	case WCD937X_FLYBACK_VNEG_CTRL_6:
+	case WCD937X_FLYBACK_VNEG_CTRL_7:
+	case WCD937X_FLYBACK_VNEG_CTRL_8:
+	case WCD937X_FLYBACK_VNEG_CTRL_9:
+	case WCD937X_FLYBACK_VNEGDAC_CTRL_1:
+	case WCD937X_FLYBACK_VNEGDAC_CTRL_2:
+	case WCD937X_FLYBACK_VNEGDAC_CTRL_3:
+	case WCD937X_FLYBACK_CTRL_1:
+	case WCD937X_FLYBACK_TEST_CTL:
+	case WCD937X_RX_AUX_SW_CTL:
+	case WCD937X_RX_PA_AUX_IN_CONN:
+	case WCD937X_RX_TIMER_DIV:
+	case WCD937X_RX_OCP_CTL:
+	case WCD937X_RX_OCP_COUNT:
+	case WCD937X_RX_BIAS_EAR_DAC:
+	case WCD937X_RX_BIAS_EAR_AMP:
+	case WCD937X_RX_BIAS_HPH_LDO:
+	case WCD937X_RX_BIAS_HPH_PA:
+	case WCD937X_RX_BIAS_HPH_RDACBUFF_CNP2:
+	case WCD937X_RX_BIAS_HPH_RDAC_LDO:
+	case WCD937X_RX_BIAS_HPH_CNP1:
+	case WCD937X_RX_BIAS_HPH_LOWPOWER:
+	case WCD937X_RX_BIAS_AUX_DAC:
+	case WCD937X_RX_BIAS_AUX_AMP:
+	case WCD937X_RX_BIAS_VNEGDAC_BLEEDER:
+	case WCD937X_RX_BIAS_MISC:
+	case WCD937X_RX_BIAS_BUCK_RST:
+	case WCD937X_RX_BIAS_BUCK_VREF_ERRAMP:
+	case WCD937X_RX_BIAS_FLYB_ERRAMP:
+	case WCD937X_RX_BIAS_FLYB_BUFF:
+	case WCD937X_RX_BIAS_FLYB_MID_RST:
+	case WCD937X_HPH_CNP_EN:
+	case WCD937X_HPH_CNP_WG_CTL:
+	case WCD937X_HPH_CNP_WG_TIME:
+	case WCD937X_HPH_OCP_CTL:
+	case WCD937X_HPH_AUTO_CHOP:
+	case WCD937X_HPH_CHOP_CTL:
+	case WCD937X_HPH_PA_CTL1:
+	case WCD937X_HPH_PA_CTL2:
+	case WCD937X_HPH_L_EN:
+	case WCD937X_HPH_L_TEST:
+	case WCD937X_HPH_L_ATEST:
+	case WCD937X_HPH_R_EN:
+	case WCD937X_HPH_R_TEST:
+	case WCD937X_HPH_R_ATEST:
+	case WCD937X_HPH_RDAC_CLK_CTL1:
+	case WCD937X_HPH_RDAC_CLK_CTL2:
+	case WCD937X_HPH_RDAC_LDO_CTL:
+	case WCD937X_HPH_RDAC_CHOP_CLK_LP_CTL:
+	case WCD937X_HPH_REFBUFF_UHQA_CTL:
+	case WCD937X_HPH_REFBUFF_LP_CTL:
+	case WCD937X_HPH_L_DAC_CTL:
+	case WCD937X_HPH_R_DAC_CTL:
+	case WCD937X_HPH_SURGE_HPHLR_SURGE_COMP_SEL:
+	case WCD937X_HPH_SURGE_HPHLR_SURGE_EN:
+	case WCD937X_HPH_SURGE_HPHLR_SURGE_MISC1:
+	case WCD937X_EAR_EAR_EN_REG:
+	case WCD937X_EAR_EAR_PA_CON:
+	case WCD937X_EAR_EAR_SP_CON:
+	case WCD937X_EAR_EAR_DAC_CON:
+	case WCD937X_EAR_EAR_CNP_FSM_CON:
+	case WCD937X_EAR_TEST_CTL:
+	case WCD937X_HPH_NEW_ANA_HPH2:
+	case WCD937X_HPH_NEW_ANA_HPH3:
+	case WCD937X_SLEEP_CTL:
+	case WCD937X_SLEEP_WATCHDOG_CTL:
+	case WCD937X_MBHC_NEW_ELECT_REM_CLAMP_CTL:
+	case WCD937X_MBHC_NEW_CTL_1:
+	case WCD937X_MBHC_NEW_CTL_2:
+	case WCD937X_MBHC_NEW_PLUG_DETECT_CTL:
+	case WCD937X_MBHC_NEW_ZDET_ANA_CTL:
+	case WCD937X_MBHC_NEW_ZDET_RAMP_CTL:
+	case WCD937X_TX_NEW_TX_CH2_SEL:
+	case WCD937X_AUX_AUXPA:
+	case WCD937X_LDORXTX_MODE:
+	case WCD937X_LDORXTX_CONFIG:
+	case WCD937X_DIE_CRACK_DIE_CRK_DET_EN:
+	case WCD937X_HPH_NEW_INT_RDAC_GAIN_CTL:
+	case WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_L:
+	case WCD937X_HPH_NEW_INT_RDAC_VREF_CTL:
+	case WCD937X_HPH_NEW_INT_RDAC_OVERRIDE_CTL:
+	case WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_R:
+	case WCD937X_HPH_NEW_INT_PA_MISC1:
+	case WCD937X_HPH_NEW_INT_PA_MISC2:
+	case WCD937X_HPH_NEW_INT_PA_RDAC_MISC:
+	case WCD937X_HPH_NEW_INT_HPH_TIMER1:
+	case WCD937X_HPH_NEW_INT_HPH_TIMER2:
+	case WCD937X_HPH_NEW_INT_HPH_TIMER3:
+	case WCD937X_HPH_NEW_INT_HPH_TIMER4:
+	case WCD937X_HPH_NEW_INT_PA_RDAC_MISC2:
+	case WCD937X_HPH_NEW_INT_PA_RDAC_MISC3:
+	case WCD937X_RX_NEW_INT_HPH_RDAC_BIAS_LOHIFI:
+	case WCD937X_RX_NEW_INT_HPH_RDAC_BIAS_ULP:
+	case WCD937X_RX_NEW_INT_HPH_RDAC_LDO_LP:
+	case WCD937X_MBHC_NEW_INT_MOISTURE_DET_DC_CTRL:
+	case WCD937X_MBHC_NEW_INT_MOISTURE_DET_POLLING_CTRL:
+	case WCD937X_MBHC_NEW_INT_MECH_DET_CURRENT:
+	case WCD937X_MBHC_NEW_INT_SPARE_2:
+	case WCD937X_EAR_INT_NEW_EAR_CHOPPER_CON:
+	case WCD937X_EAR_INT_NEW_CNP_VCM_CON1:
+	case WCD937X_EAR_INT_NEW_CNP_VCM_CON2:
+	case WCD937X_EAR_INT_NEW_EAR_DYNAMIC_BIAS:
+	case WCD937X_AUX_INT_EN_REG:
+	case WCD937X_AUX_INT_PA_CTRL:
+	case WCD937X_AUX_INT_SP_CTRL:
+	case WCD937X_AUX_INT_DAC_CTRL:
+	case WCD937X_AUX_INT_CLK_CTRL:
+	case WCD937X_AUX_INT_TEST_CTRL:
+	case WCD937X_AUX_INT_MISC:
+	case WCD937X_LDORXTX_INT_BIAS:
+	case WCD937X_LDORXTX_INT_STB_LOADS_DTEST:
+	case WCD937X_LDORXTX_INT_TEST0:
+	case WCD937X_LDORXTX_INT_STARTUP_TIMER:
+	case WCD937X_LDORXTX_INT_TEST1:
+	case WCD937X_SLEEP_INT_WATCHDOG_CTL_1:
+	case WCD937X_SLEEP_INT_WATCHDOG_CTL_2:
+	case WCD937X_DIE_CRACK_INT_DIE_CRK_DET_INT1:
+	case WCD937X_DIE_CRACK_INT_DIE_CRK_DET_INT2:
+	case WCD937X_DIGITAL_CDC_RST_CTL:
+	case WCD937X_DIGITAL_TOP_CLK_CFG:
+	case WCD937X_DIGITAL_CDC_ANA_CLK_CTL:
+	case WCD937X_DIGITAL_CDC_DIG_CLK_CTL:
+	case WCD937X_DIGITAL_SWR_RST_EN:
+	case WCD937X_DIGITAL_CDC_PATH_MODE:
+	case WCD937X_DIGITAL_CDC_RX_RST:
+	case WCD937X_DIGITAL_CDC_RX0_CTL:
+	case WCD937X_DIGITAL_CDC_RX1_CTL:
+	case WCD937X_DIGITAL_CDC_RX2_CTL:
+	case WCD937X_DIGITAL_DEM_BYPASS_DATA0:
+	case WCD937X_DIGITAL_DEM_BYPASS_DATA1:
+	case WCD937X_DIGITAL_DEM_BYPASS_DATA2:
+	case WCD937X_DIGITAL_DEM_BYPASS_DATA3:
+	case WCD937X_DIGITAL_CDC_COMP_CTL_0:
+	case WCD937X_DIGITAL_CDC_RX_DELAY_CTL:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_A1_0:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_A1_1:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_A2_0:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_A2_1:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_A3_0:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_A3_1:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_A4_0:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_A4_1:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_A5_0:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_A5_1:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_A6_0:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_A7_0:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_C_0:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_C_1:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_C_2:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_C_3:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_R1:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_R2:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_R3:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_R4:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_R5:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_R6:
+	case WCD937X_DIGITAL_CDC_HPH_DSM_R7:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_A1_0:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_A1_1:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_A2_0:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_A2_1:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_A3_0:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_A3_1:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_A4_0:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_A4_1:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_A5_0:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_A5_1:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_A6_0:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_A7_0:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_C_0:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_C_1:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_C_2:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_C_3:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_R1:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_R2:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_R3:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_R4:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_R5:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_R6:
+	case WCD937X_DIGITAL_CDC_AUX_DSM_R7:
+	case WCD937X_DIGITAL_CDC_HPH_GAIN_RX_0:
+	case WCD937X_DIGITAL_CDC_HPH_GAIN_RX_1:
+	case WCD937X_DIGITAL_CDC_HPH_GAIN_DSD_0:
+	case WCD937X_DIGITAL_CDC_HPH_GAIN_DSD_1:
+	case WCD937X_DIGITAL_CDC_HPH_GAIN_DSD_2:
+	case WCD937X_DIGITAL_CDC_AUX_GAIN_DSD_0:
+	case WCD937X_DIGITAL_CDC_AUX_GAIN_DSD_1:
+	case WCD937X_DIGITAL_CDC_AUX_GAIN_DSD_2:
+	case WCD937X_DIGITAL_CDC_HPH_GAIN_CTL:
+	case WCD937X_DIGITAL_CDC_AUX_GAIN_CTL:
+	case WCD937X_DIGITAL_CDC_EAR_PATH_CTL:
+	case WCD937X_DIGITAL_CDC_SWR_CLH:
+	case WCD937X_DIGITAL_SWR_CLH_BYP:
+	case WCD937X_DIGITAL_CDC_TX0_CTL:
+	case WCD937X_DIGITAL_CDC_TX1_CTL:
+	case WCD937X_DIGITAL_CDC_TX2_CTL:
+	case WCD937X_DIGITAL_CDC_TX_RST:
+	case WCD937X_DIGITAL_CDC_REQ_CTL:
+	case WCD937X_DIGITAL_CDC_AMIC_CTL:
+	case WCD937X_DIGITAL_CDC_DMIC_CTL:
+	case WCD937X_DIGITAL_CDC_DMIC1_CTL:
+	case WCD937X_DIGITAL_CDC_DMIC2_CTL:
+	case WCD937X_DIGITAL_CDC_DMIC3_CTL:
+	case WCD937X_DIGITAL_EFUSE_CTL:
+	case WCD937X_DIGITAL_EFUSE_PRG_CTL:
+	case WCD937X_DIGITAL_EFUSE_TEST_CTL_0:
+	case WCD937X_DIGITAL_EFUSE_TEST_CTL_1:
+	case WCD937X_DIGITAL_PDM_WD_CTL0:
+	case WCD937X_DIGITAL_PDM_WD_CTL1:
+	case WCD937X_DIGITAL_PDM_WD_CTL2:
+	case WCD937X_DIGITAL_INTR_MODE:
+	case WCD937X_DIGITAL_INTR_MASK_0:
+	case WCD937X_DIGITAL_INTR_MASK_1:
+	case WCD937X_DIGITAL_INTR_MASK_2:
+	case WCD937X_DIGITAL_INTR_CLEAR_0:
+	case WCD937X_DIGITAL_INTR_CLEAR_1:
+	case WCD937X_DIGITAL_INTR_CLEAR_2:
+	case WCD937X_DIGITAL_INTR_LEVEL_0:
+	case WCD937X_DIGITAL_INTR_LEVEL_1:
+	case WCD937X_DIGITAL_INTR_LEVEL_2:
+	case WCD937X_DIGITAL_INTR_SET_0:
+	case WCD937X_DIGITAL_INTR_SET_1:
+	case WCD937X_DIGITAL_INTR_SET_2:
+	case WCD937X_DIGITAL_INTR_TEST_0:
+	case WCD937X_DIGITAL_INTR_TEST_1:
+	case WCD937X_DIGITAL_INTR_TEST_2:
+	case WCD937X_DIGITAL_CDC_CONN_RX0_CTL:
+	case WCD937X_DIGITAL_CDC_CONN_RX1_CTL:
+	case WCD937X_DIGITAL_CDC_CONN_RX2_CTL:
+	case WCD937X_DIGITAL_CDC_CONN_TX_CTL:
+	case WCD937X_DIGITAL_LOOP_BACK_MODE:
+	case WCD937X_DIGITAL_SWR_DAC_TEST:
+	case WCD937X_DIGITAL_SWR_HM_TEST_RX_0:
+	case WCD937X_DIGITAL_SWR_HM_TEST_TX_0:
+	case WCD937X_DIGITAL_SWR_HM_TEST_RX_1:
+	case WCD937X_DIGITAL_SWR_HM_TEST_TX_1:
+	case WCD937X_DIGITAL_SWR_HM_TEST:
+	case WCD937X_DIGITAL_PAD_CTL_PDM_RX0:
+	case WCD937X_DIGITAL_PAD_CTL_PDM_RX1:
+	case WCD937X_DIGITAL_PAD_CTL_PDM_TX0:
+	case WCD937X_DIGITAL_PAD_CTL_PDM_TX1:
+	case WCD937X_DIGITAL_PAD_INP_DIS_0:
+	case WCD937X_DIGITAL_PAD_INP_DIS_1:
+	case WCD937X_DIGITAL_DRIVE_STRENGTH_0:
+	case WCD937X_DIGITAL_DRIVE_STRENGTH_1:
+	case WCD937X_DIGITAL_DRIVE_STRENGTH_2:
+	case WCD937X_DIGITAL_RX_DATA_EDGE_CTL:
+	case WCD937X_DIGITAL_TX_DATA_EDGE_CTL:
+	case WCD937X_DIGITAL_GPIO_MODE:
+	case WCD937X_DIGITAL_PIN_CTL_OE:
+	case WCD937X_DIGITAL_PIN_CTL_DATA_0:
+	case WCD937X_DIGITAL_PIN_CTL_DATA_1:
+	case WCD937X_DIGITAL_PIN_STATUS_0:
+	case WCD937X_DIGITAL_PIN_STATUS_1:
+	case WCD937X_DIGITAL_DIG_DEBUG_CTL:
+	case WCD937X_DIGITAL_DIG_DEBUG_EN:
+	case WCD937X_DIGITAL_ANA_CSR_DBG_ADD:
+	case WCD937X_DIGITAL_ANA_CSR_DBG_CTL:
+	case WCD937X_DIGITAL_SSP_DBG:
+	case WCD937X_DIGITAL_MODE_STATUS_0:
+	case WCD937X_DIGITAL_MODE_STATUS_1:
+	case WCD937X_DIGITAL_SPARE_0:
+	case WCD937X_DIGITAL_SPARE_1:
+	case WCD937X_DIGITAL_SPARE_2:
+		return true;
+	}
+
+	return false;
+}
+
+static bool wcd937x_readable_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case WCD937X_ANA_MBHC_RESULT_1:
+	case WCD937X_ANA_MBHC_RESULT_2:
+	case WCD937X_ANA_MBHC_RESULT_3:
+	case WCD937X_MBHC_MOISTURE_DET_FSM_STATUS:
+	case WCD937X_TX_1_2_SAR2_ERR:
+	case WCD937X_TX_1_2_SAR1_ERR:
+	case WCD937X_TX_3_SPARE_MONO:
+	case WCD937X_TX_3_SAR1_ERR:
+	case WCD937X_HPH_L_STATUS:
+	case WCD937X_HPH_R_STATUS:
+	case WCD937X_HPH_SURGE_HPHLR_SURGE_STATUS:
+	case WCD937X_EAR_STATUS_REG_1:
+	case WCD937X_EAR_STATUS_REG_2:
+	case WCD937X_MBHC_NEW_FSM_STATUS:
+	case WCD937X_MBHC_NEW_ADC_RESULT:
+	case WCD937X_DIE_CRACK_DIE_CRK_DET_OUT:
+	case WCD937X_AUX_INT_STATUS_REG:
+	case WCD937X_LDORXTX_INT_STATUS:
+	case WCD937X_DIGITAL_CHIP_ID0:
+	case WCD937X_DIGITAL_CHIP_ID1:
+	case WCD937X_DIGITAL_CHIP_ID2:
+	case WCD937X_DIGITAL_CHIP_ID3:
+	case WCD937X_DIGITAL_EFUSE_T_DATA_0:
+	case WCD937X_DIGITAL_EFUSE_T_DATA_1:
+	case WCD937X_DIGITAL_INTR_STATUS_0:
+	case WCD937X_DIGITAL_INTR_STATUS_1:
+	case WCD937X_DIGITAL_INTR_STATUS_2:
+	case WCD937X_DIGITAL_EFUSE_REG_0:
+	case WCD937X_DIGITAL_EFUSE_REG_1:
+	case WCD937X_DIGITAL_EFUSE_REG_2:
+	case WCD937X_DIGITAL_EFUSE_REG_3:
+	case WCD937X_DIGITAL_EFUSE_REG_4:
+	case WCD937X_DIGITAL_EFUSE_REG_5:
+	case WCD937X_DIGITAL_EFUSE_REG_6:
+	case WCD937X_DIGITAL_EFUSE_REG_7:
+	case WCD937X_DIGITAL_EFUSE_REG_8:
+	case WCD937X_DIGITAL_EFUSE_REG_9:
+	case WCD937X_DIGITAL_EFUSE_REG_10:
+	case WCD937X_DIGITAL_EFUSE_REG_11:
+	case WCD937X_DIGITAL_EFUSE_REG_12:
+	case WCD937X_DIGITAL_EFUSE_REG_13:
+	case WCD937X_DIGITAL_EFUSE_REG_14:
+	case WCD937X_DIGITAL_EFUSE_REG_15:
+	case WCD937X_DIGITAL_EFUSE_REG_16:
+	case WCD937X_DIGITAL_EFUSE_REG_17:
+	case WCD937X_DIGITAL_EFUSE_REG_18:
+	case WCD937X_DIGITAL_EFUSE_REG_19:
+	case WCD937X_DIGITAL_EFUSE_REG_20:
+	case WCD937X_DIGITAL_EFUSE_REG_21:
+	case WCD937X_DIGITAL_EFUSE_REG_22:
+	case WCD937X_DIGITAL_EFUSE_REG_23:
+	case WCD937X_DIGITAL_EFUSE_REG_24:
+	case WCD937X_DIGITAL_EFUSE_REG_25:
+	case WCD937X_DIGITAL_EFUSE_REG_26:
+	case WCD937X_DIGITAL_EFUSE_REG_27:
+	case WCD937X_DIGITAL_EFUSE_REG_28:
+	case WCD937X_DIGITAL_EFUSE_REG_29:
+	case WCD937X_DIGITAL_EFUSE_REG_30:
+	case WCD937X_DIGITAL_EFUSE_REG_31:
+		return true;
+	}
+
+	return wcd937x_rdwr_register(dev, reg);
+}
+
+static bool wcd937x_volatile_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case WCD937X_ANA_MBHC_RESULT_1:
+	case WCD937X_ANA_MBHC_RESULT_2:
+	case WCD937X_ANA_MBHC_RESULT_3:
+	case WCD937X_MBHC_MOISTURE_DET_FSM_STATUS:
+	case WCD937X_TX_1_2_SAR1_ERR:
+	case WCD937X_TX_1_2_SAR2_ERR:
+	case WCD937X_TX_3_SAR1_ERR:
+	case WCD937X_HPH_L_STATUS:
+	case WCD937X_HPH_R_STATUS:
+	case WCD937X_HPH_SURGE_HPHLR_SURGE_STATUS:
+	case WCD937X_EAR_STATUS_REG_1:
+	case WCD937X_EAR_STATUS_REG_2:
+	case WCD937X_MBHC_NEW_FSM_STATUS:
+	case WCD937X_MBHC_NEW_ADC_RESULT:
+	case WCD937X_DIE_CRACK_DIE_CRK_DET_OUT:
+	case WCD937X_DIGITAL_INTR_STATUS_0:
+	case WCD937X_DIGITAL_INTR_STATUS_1:
+	case WCD937X_DIGITAL_INTR_STATUS_2:
+	case WCD937X_DIGITAL_SWR_HM_TEST:
+	case WCD937X_DIGITAL_PIN_STATUS_0:
+	case WCD937X_DIGITAL_PIN_STATUS_1:
+	case WCD937X_DIGITAL_MODE_STATUS_0:
+	case WCD937X_DIGITAL_MODE_STATUS_1:
+		return true;
+	}
+	return false;
+}
+
+static const struct regmap_config wcd937x_regmap_config = {
+	.name = "wcd937x_csr",
+	.reg_bits = 32,
+	.val_bits = 8,
+	.cache_type = REGCACHE_MAPLE,
+	.reg_defaults = wcd937x_defaults,
+	.num_reg_defaults = ARRAY_SIZE(wcd937x_defaults),
+	.max_register = WCD937X_MAX_REGISTER,
+	.readable_reg = wcd937x_readable_register,
+	.writeable_reg = wcd937x_rdwr_register,
+	.volatile_reg = wcd937x_volatile_register,
+};
+
+static const struct sdw_slave_ops wcd9370_slave_ops = {
+	.update_status = wcd9370_update_status,
+	.interrupt_callback = wcd9370_interrupt_callback,
+};
+
+static int wcd937x_sdw_component_bind(struct device *dev,
+				      struct device *master, void *data)
+{
+	pm_runtime_set_autosuspend_delay(dev, 3000);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+	return 0;
+}
+
+static void wcd937x_sdw_component_unbind(struct device *dev,
+					 struct device *master, void *data)
+{
+	pm_runtime_disable(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_dont_use_autosuspend(dev);
+}
+
+static const struct component_ops wcd937x_sdw_component_ops = {
+	.bind = wcd937x_sdw_component_bind,
+	.unbind = wcd937x_sdw_component_unbind,
+};
+
+static int wcd9370_probe(struct sdw_slave *pdev,
+			 const struct sdw_device_id *id)
+{
+	struct device *dev = &pdev->dev;
+	struct wcd937x_sdw_priv *wcd;
+	int ret;
+
+	wcd = devm_kzalloc(dev, sizeof(*wcd), GFP_KERNEL);
+	if (!wcd)
+		return -ENOMEM;
+
+	/* Port map index starts at 0, however the data port for this codec start at index 1 */
+	if (of_property_read_bool(dev->of_node, "qcom,tx-port-mapping")) {
+		wcd->is_tx = true;
+		ret = of_property_read_u32_array(dev->of_node, "qcom,tx-port-mapping",
+						 &pdev->m_port_map[1],
+						 WCD937X_MAX_TX_SWR_PORTS);
+	} else {
+		ret = of_property_read_u32_array(dev->of_node, "qcom,rx-port-mapping",
+						 &pdev->m_port_map[1],
+						 WCD937X_MAX_SWR_PORTS);
+	}
+	if (ret < 0)
+		dev_info(dev, "Error getting static port mapping for %s (%d)\n",
+			 wcd->is_tx ? "TX" : "RX", ret);
+
+	wcd->sdev = pdev;
+	dev_set_drvdata(dev, wcd);
+
+	pdev->prop.scp_int1_mask = SDW_SCP_INT1_IMPL_DEF |
+				   SDW_SCP_INT1_BUS_CLASH |
+				   SDW_SCP_INT1_PARITY;
+	pdev->prop.lane_control_support = true;
+	pdev->prop.simple_clk_stop_capable = true;
+	if (wcd->is_tx) {
+		pdev->prop.source_ports = GENMASK(WCD937X_MAX_TX_SWR_PORTS, 0);
+		pdev->prop.src_dpn_prop = wcd937x_dpn_prop;
+		wcd->ch_info = &wcd937x_sdw_tx_ch_info[0];
+		pdev->prop.wake_capable = true;
+
+		wcd->regmap = devm_regmap_init_sdw(pdev, &wcd937x_regmap_config);
+		if (IS_ERR(wcd->regmap))
+			return dev_err_probe(dev, PTR_ERR(wcd->regmap),
+					     "Regmap init failed\n");
+
+		/* Start in cache-only until device is enumerated */
+		regcache_cache_only(wcd->regmap, true);
+	} else {
+		pdev->prop.sink_ports = GENMASK(WCD937X_MAX_SWR_PORTS, 0);
+		pdev->prop.sink_dpn_prop = wcd937x_dpn_prop;
+		wcd->ch_info = &wcd937x_sdw_rx_ch_info[0];
+	}
+
+
+	ret = component_add(dev, &wcd937x_sdw_component_ops);
+	if (ret)
+		return ret;
+
+	/* Set suspended until aggregate device is bind */
+	pm_runtime_set_suspended(dev);
+
+	return 0;
+}
+
+static int wcd9370_remove(struct sdw_slave *pdev)
+{
+	struct device *dev = &pdev->dev;
+
+	component_del(dev, &wcd937x_sdw_component_ops);
+
+	return 0;
+}
+
+static const struct sdw_device_id wcd9370_slave_id[] = {
+	SDW_SLAVE_ENTRY(0x0217, 0x10a, 0), /* WCD9370 RX/TX Device ID */
+	{ },
+};
+MODULE_DEVICE_TABLE(sdw, wcd9370_slave_id);
+
+static int __maybe_unused wcd937x_sdw_runtime_suspend(struct device *dev)
+{
+	struct wcd937x_sdw_priv *wcd = dev_get_drvdata(dev);
+
+	if (wcd->regmap) {
+		regcache_cache_only(wcd->regmap, true);
+		regcache_mark_dirty(wcd->regmap);
+	}
+
+	return 0;
+}
+
+static int __maybe_unused wcd937x_sdw_runtime_resume(struct device *dev)
+{
+	struct wcd937x_sdw_priv *wcd = dev_get_drvdata(dev);
+
+	if (wcd->regmap) {
+		regcache_cache_only(wcd->regmap, false);
+		regcache_sync(wcd->regmap);
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops wcd937x_sdw_pm_ops = {
+	SET_RUNTIME_PM_OPS(wcd937x_sdw_runtime_suspend, wcd937x_sdw_runtime_resume, NULL)
+};
+
+static struct sdw_driver wcd9370_codec_driver = {
+	.probe = wcd9370_probe,
+	.remove = wcd9370_remove,
+	.ops = &wcd9370_slave_ops,
+	.id_table = wcd9370_slave_id,
+	.driver = {
+		.name = "wcd9370-codec",
+		.pm = &wcd937x_sdw_pm_ops,
+	}
+};
+module_sdw_driver(wcd9370_codec_driver);
+
+MODULE_DESCRIPTION("WCD937X SDW codec driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/wcd937x.c b/sound/soc/codecs/wcd937x.c
new file mode 100644
index 00000000000000..13926f4b0d9f16
--- /dev/null
+++ b/sound/soc/codecs/wcd937x.c
@@ -0,0 +1,2971 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2023-2024 Qualcomm Innovation Center, Inc. All rights reserved.
+
+#include <linux/component.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <sound/jack.h>
+#include <sound/pcm_params.h>
+#include <sound/pcm.h>
+#include <sound/soc-dapm.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#include "wcd-clsh-v2.h"
+#include "wcd-mbhc-v2.h"
+#include "wcd937x.h"
+
+enum {
+	CHIPID_WCD9370 = 0,
+	CHIPID_WCD9375 = 5,
+};
+
+/* Z value defined in milliohm */
+#define WCD937X_ZDET_VAL_32		(32000)
+#define WCD937X_ZDET_VAL_400		(400000)
+#define WCD937X_ZDET_VAL_1200		(1200000)
+#define WCD937X_ZDET_VAL_100K		(100000000)
+/* Z floating defined in ohms */
+#define WCD937X_ZDET_FLOATING_IMPEDANCE	(0x0FFFFFFE)
+#define WCD937X_ZDET_NUM_MEASUREMENTS	(900)
+#define WCD937X_MBHC_GET_C1(c)		(((c) & 0xC000) >> 14)
+#define WCD937X_MBHC_GET_X1(x)		((x) & 0x3FFF)
+/* Z value compared in milliOhm */
+#define WCD937X_MBHC_IS_SECOND_RAMP_REQUIRED(z)	(((z) > 400000) || ((z) < 32000))
+#define WCD937X_MBHC_ZDET_CONST		(86 * 16384)
+#define WCD937X_MBHC_MOISTURE_RREF	R_24_KOHM
+#define WCD_MBHC_HS_V_MAX		1600
+#define EAR_RX_PATH_AUX			1
+#define WCD937X_MBHC_MAX_BUTTONS	8
+
+#define WCD937X_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |\
+		       SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_48000 |\
+		       SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000 |\
+		       SNDRV_PCM_RATE_384000)
+
+/* Fractional Rates */
+#define WCD937X_FRAC_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_88200 |\
+			    SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_352800)
+
+#define WCD937X_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |\
+			 SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+enum {
+	ALLOW_BUCK_DISABLE,
+	HPH_COMP_DELAY,
+	HPH_PA_DELAY,
+	AMIC2_BCS_ENABLE,
+};
+
+enum {
+	AIF1_PB = 0,
+	AIF1_CAP,
+	NUM_CODEC_DAIS,
+};
+
+struct wcd937x_priv {
+	struct sdw_slave *tx_sdw_dev;
+	struct wcd937x_sdw_priv *sdw_priv[NUM_CODEC_DAIS];
+	struct device *txdev;
+	struct device *rxdev;
+	struct device_node *rxnode;
+	struct device_node *txnode;
+	struct regmap *regmap;
+	/* micb setup lock */
+	struct mutex micb_lock;
+	/* mbhc module */
+	struct wcd_mbhc *wcd_mbhc;
+	struct wcd_mbhc_config mbhc_cfg;
+	struct wcd_mbhc_intr intr_ids;
+	struct wcd_clsh_ctrl *clsh_info;
+	struct irq_domain *virq;
+	struct regmap_irq_chip *wcd_regmap_irq_chip;
+	struct regmap_irq_chip_data *irq_chip;
+	struct regulator_bulk_data supplies[WCD937X_MAX_BULK_SUPPLY];
+	struct regulator *buck_supply;
+	struct snd_soc_jack *jack;
+	unsigned long status_mask;
+	s32 micb_ref[WCD937X_MAX_MICBIAS];
+	s32 pullup_ref[WCD937X_MAX_MICBIAS];
+	u32 hph_mode;
+	int ear_rx_path;
+	u32 micb1_mv;
+	u32 micb2_mv;
+	u32 micb3_mv;
+	int hphr_pdm_wd_int;
+	int hphl_pdm_wd_int;
+	int aux_pdm_wd_int;
+	bool comp1_enable;
+	bool comp2_enable;
+
+	struct gpio_desc *us_euro_gpio;
+	struct gpio_desc *reset_gpio;
+
+	atomic_t rx_clk_cnt;
+	atomic_t ana_clk_count;
+};
+
+static const SNDRV_CTL_TLVD_DECLARE_DB_MINMAX(ear_pa_gain, 600, -1800);
+static const DECLARE_TLV_DB_SCALE(line_gain, 0, 7, 1);
+static const DECLARE_TLV_DB_SCALE(analog_gain, 0, 25, 1);
+
+struct wcd937x_mbhc_zdet_param {
+	u16 ldo_ctl;
+	u16 noff;
+	u16 nshift;
+	u16 btn5;
+	u16 btn6;
+	u16 btn7;
+};
+
+static const struct wcd_mbhc_field wcd_mbhc_fields[WCD_MBHC_REG_FUNC_MAX] = {
+	WCD_MBHC_FIELD(WCD_MBHC_L_DET_EN, WCD937X_ANA_MBHC_MECH, 0x80),
+	WCD_MBHC_FIELD(WCD_MBHC_GND_DET_EN, WCD937X_ANA_MBHC_MECH, 0x40),
+	WCD_MBHC_FIELD(WCD_MBHC_MECH_DETECTION_TYPE, WCD937X_ANA_MBHC_MECH, 0x20),
+	WCD_MBHC_FIELD(WCD_MBHC_MIC_CLAMP_CTL, WCD937X_MBHC_NEW_PLUG_DETECT_CTL, 0x30),
+	WCD_MBHC_FIELD(WCD_MBHC_ELECT_DETECTION_TYPE, WCD937X_ANA_MBHC_ELECT, 0x08),
+	WCD_MBHC_FIELD(WCD_MBHC_HS_L_DET_PULL_UP_CTRL, WCD937X_MBHC_NEW_INT_MECH_DET_CURRENT, 0x1F),
+	WCD_MBHC_FIELD(WCD_MBHC_HS_L_DET_PULL_UP_COMP_CTRL, WCD937X_ANA_MBHC_MECH, 0x04),
+	WCD_MBHC_FIELD(WCD_MBHC_HPHL_PLUG_TYPE, WCD937X_ANA_MBHC_MECH, 0x10),
+	WCD_MBHC_FIELD(WCD_MBHC_GND_PLUG_TYPE, WCD937X_ANA_MBHC_MECH, 0x08),
+	WCD_MBHC_FIELD(WCD_MBHC_SW_HPH_LP_100K_TO_GND, WCD937X_ANA_MBHC_MECH, 0x01),
+	WCD_MBHC_FIELD(WCD_MBHC_ELECT_SCHMT_ISRC, WCD937X_ANA_MBHC_ELECT, 0x06),
+	WCD_MBHC_FIELD(WCD_MBHC_FSM_EN, WCD937X_ANA_MBHC_ELECT, 0x80),
+	WCD_MBHC_FIELD(WCD_MBHC_INSREM_DBNC, WCD937X_MBHC_NEW_PLUG_DETECT_CTL, 0x0F),
+	WCD_MBHC_FIELD(WCD_MBHC_BTN_DBNC, WCD937X_MBHC_NEW_CTL_1, 0x03),
+	WCD_MBHC_FIELD(WCD_MBHC_HS_VREF, WCD937X_MBHC_NEW_CTL_2, 0x03),
+	WCD_MBHC_FIELD(WCD_MBHC_HS_COMP_RESULT, WCD937X_ANA_MBHC_RESULT_3, 0x08),
+	WCD_MBHC_FIELD(WCD_MBHC_IN2P_CLAMP_STATE, WCD937X_ANA_MBHC_RESULT_3, 0x10),
+	WCD_MBHC_FIELD(WCD_MBHC_MIC_SCHMT_RESULT, WCD937X_ANA_MBHC_RESULT_3, 0x20),
+	WCD_MBHC_FIELD(WCD_MBHC_HPHL_SCHMT_RESULT, WCD937X_ANA_MBHC_RESULT_3, 0x80),
+	WCD_MBHC_FIELD(WCD_MBHC_HPHR_SCHMT_RESULT, WCD937X_ANA_MBHC_RESULT_3, 0x40),
+	WCD_MBHC_FIELD(WCD_MBHC_OCP_FSM_EN, WCD937X_HPH_OCP_CTL, 0x10),
+	WCD_MBHC_FIELD(WCD_MBHC_BTN_RESULT, WCD937X_ANA_MBHC_RESULT_3, 0x07),
+	WCD_MBHC_FIELD(WCD_MBHC_BTN_ISRC_CTL, WCD937X_ANA_MBHC_ELECT, 0x70),
+	WCD_MBHC_FIELD(WCD_MBHC_ELECT_RESULT, WCD937X_ANA_MBHC_RESULT_3, 0xFF),
+	WCD_MBHC_FIELD(WCD_MBHC_MICB_CTRL, WCD937X_ANA_MICB2, 0xC0),
+	WCD_MBHC_FIELD(WCD_MBHC_HPH_CNP_WG_TIME, WCD937X_HPH_CNP_WG_TIME, 0xFF),
+	WCD_MBHC_FIELD(WCD_MBHC_HPHR_PA_EN, WCD937X_ANA_HPH, 0x40),
+	WCD_MBHC_FIELD(WCD_MBHC_HPHL_PA_EN, WCD937X_ANA_HPH, 0x80),
+	WCD_MBHC_FIELD(WCD_MBHC_HPH_PA_EN, WCD937X_ANA_HPH, 0xC0),
+	WCD_MBHC_FIELD(WCD_MBHC_SWCH_LEVEL_REMOVE, WCD937X_ANA_MBHC_RESULT_3, 0x10),
+	WCD_MBHC_FIELD(WCD_MBHC_ANC_DET_EN, WCD937X_MBHC_CTL_BCS, 0x02),
+	WCD_MBHC_FIELD(WCD_MBHC_FSM_STATUS, WCD937X_MBHC_NEW_FSM_STATUS, 0x01),
+	WCD_MBHC_FIELD(WCD_MBHC_MUX_CTL, WCD937X_MBHC_NEW_CTL_2, 0x70),
+	WCD_MBHC_FIELD(WCD_MBHC_MOISTURE_STATUS, WCD937X_MBHC_NEW_FSM_STATUS, 0x20),
+	WCD_MBHC_FIELD(WCD_MBHC_HPHR_GND, WCD937X_HPH_PA_CTL2, 0x40),
+	WCD_MBHC_FIELD(WCD_MBHC_HPHL_GND, WCD937X_HPH_PA_CTL2, 0x10),
+	WCD_MBHC_FIELD(WCD_MBHC_HPHL_OCP_DET_EN, WCD937X_HPH_L_TEST, 0x01),
+	WCD_MBHC_FIELD(WCD_MBHC_HPHR_OCP_DET_EN, WCD937X_HPH_R_TEST, 0x01),
+	WCD_MBHC_FIELD(WCD_MBHC_HPHL_OCP_STATUS, WCD937X_DIGITAL_INTR_STATUS_0, 0x80),
+	WCD_MBHC_FIELD(WCD_MBHC_HPHR_OCP_STATUS, WCD937X_DIGITAL_INTR_STATUS_0, 0x20),
+	WCD_MBHC_FIELD(WCD_MBHC_ADC_EN, WCD937X_MBHC_NEW_CTL_1, 0x08),
+	WCD_MBHC_FIELD(WCD_MBHC_ADC_COMPLETE, WCD937X_MBHC_NEW_FSM_STATUS, 0x40),
+	WCD_MBHC_FIELD(WCD_MBHC_ADC_TIMEOUT, WCD937X_MBHC_NEW_FSM_STATUS, 0x80),
+	WCD_MBHC_FIELD(WCD_MBHC_ADC_RESULT, WCD937X_MBHC_NEW_ADC_RESULT, 0xFF),
+	WCD_MBHC_FIELD(WCD_MBHC_MICB2_VOUT, WCD937X_ANA_MICB2, 0x3F),
+	WCD_MBHC_FIELD(WCD_MBHC_ADC_MODE, WCD937X_MBHC_NEW_CTL_1, 0x10),
+	WCD_MBHC_FIELD(WCD_MBHC_DETECTION_DONE, WCD937X_MBHC_NEW_CTL_1, 0x04),
+	WCD_MBHC_FIELD(WCD_MBHC_ELECT_ISRC_EN, WCD937X_ANA_MBHC_ZDET, 0x02),
+};
+
+static const struct regmap_irq wcd937x_irqs[WCD937X_NUM_IRQS] = {
+	REGMAP_IRQ_REG(WCD937X_IRQ_MBHC_BUTTON_PRESS_DET, 0, BIT(0)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_MBHC_BUTTON_RELEASE_DET, 0, BIT(1)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_MBHC_ELECT_INS_REM_DET, 0, BIT(2)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_MBHC_ELECT_INS_REM_LEG_DET, 0, BIT(3)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_MBHC_SW_DET, 0, BIT(4)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_HPHR_OCP_INT, 0, BIT(5)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_HPHR_CNP_INT, 0, BIT(6)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_HPHL_OCP_INT, 0, BIT(7)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_HPHL_CNP_INT, 1, BIT(0)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_EAR_CNP_INT, 1, BIT(1)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_EAR_SCD_INT, 1, BIT(2)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_AUX_CNP_INT, 1, BIT(3)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_AUX_SCD_INT, 1, BIT(4)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_HPHL_PDM_WD_INT, 1, BIT(5)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_HPHR_PDM_WD_INT, 1, BIT(6)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_AUX_PDM_WD_INT, 1, BIT(7)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_LDORT_SCD_INT, 2, BIT(0)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_MBHC_MOISTURE_INT, 2, BIT(1)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_HPHL_SURGE_DET_INT, 2, BIT(2)),
+	REGMAP_IRQ_REG(WCD937X_IRQ_HPHR_SURGE_DET_INT, 2, BIT(3)),
+};
+
+static int wcd937x_handle_post_irq(void *data)
+{
+	struct wcd937x_priv *wcd937x;
+
+	if (data)
+		wcd937x = (struct wcd937x_priv *)data;
+	else
+		return IRQ_HANDLED;
+
+	regmap_write(wcd937x->regmap, WCD937X_DIGITAL_INTR_CLEAR_0, 0);
+	regmap_write(wcd937x->regmap, WCD937X_DIGITAL_INTR_CLEAR_1, 0);
+	regmap_write(wcd937x->regmap, WCD937X_DIGITAL_INTR_CLEAR_2, 0);
+
+	return IRQ_HANDLED;
+}
+
+static const u32 wcd937x_config_regs[] = {
+	WCD937X_DIGITAL_INTR_LEVEL_0,
+};
+
+static const struct regmap_irq_chip wcd937x_regmap_irq_chip = {
+	.name = "wcd937x",
+	.irqs = wcd937x_irqs,
+	.num_irqs = ARRAY_SIZE(wcd937x_irqs),
+	.num_regs = 3,
+	.status_base = WCD937X_DIGITAL_INTR_STATUS_0,
+	.mask_base = WCD937X_DIGITAL_INTR_MASK_0,
+	.ack_base = WCD937X_DIGITAL_INTR_CLEAR_0,
+	.use_ack = 1,
+	.clear_ack = 1,
+	.config_base = wcd937x_config_regs,
+	.num_config_bases = ARRAY_SIZE(wcd937x_config_regs),
+	.num_config_regs = 1,
+	.runtime_pm = true,
+	.handle_post_irq = wcd937x_handle_post_irq,
+	.irq_drv_data = NULL,
+};
+
+static void wcd937x_reset(struct wcd937x_priv *wcd937x)
+{
+	usleep_range(20, 30);
+
+	gpiod_set_value(wcd937x->reset_gpio, 1);
+
+	usleep_range(20, 30);
+}
+
+static void wcd937x_io_init(struct regmap *regmap)
+{
+	u32 val = 0, temp = 0, temp1 = 0;
+
+	regmap_read(regmap, WCD937X_DIGITAL_EFUSE_REG_29, &val);
+
+	val = val & 0x0F;
+
+	regmap_read(regmap, WCD937X_DIGITAL_EFUSE_REG_16, &temp);
+	regmap_read(regmap, WCD937X_DIGITAL_EFUSE_REG_17, &temp1);
+
+	if (temp == 0x02 || temp1 > 0x09)
+		regmap_update_bits(regmap, WCD937X_SLEEP_CTL, 0x0E, val);
+	else
+		regmap_update_bits(regmap, WCD937X_SLEEP_CTL, 0x0e, 0x0e);
+
+	regmap_update_bits(regmap, WCD937X_SLEEP_CTL, 0x80, 0x80);
+	usleep_range(1000, 1010);
+
+	regmap_update_bits(regmap, WCD937X_SLEEP_CTL, 0x40, 0x40);
+	usleep_range(1000, 1010);
+
+	regmap_update_bits(regmap, WCD937X_LDORXTX_CONFIG, BIT(4), 0x00);
+	regmap_update_bits(regmap, WCD937X_BIAS_VBG_FINE_ADJ, 0xf0, BIT(7));
+	regmap_update_bits(regmap, WCD937X_ANA_BIAS, BIT(7), BIT(7));
+	regmap_update_bits(regmap, WCD937X_ANA_BIAS, BIT(6), BIT(6));
+	usleep_range(10000, 10010);
+
+	regmap_update_bits(regmap, WCD937X_ANA_BIAS, BIT(6), 0x00);
+	regmap_update_bits(regmap, WCD937X_HPH_SURGE_HPHLR_SURGE_EN, 0xff, 0xd9);
+	regmap_update_bits(regmap, WCD937X_MICB1_TEST_CTL_1, 0xff, 0xfa);
+	regmap_update_bits(regmap, WCD937X_MICB2_TEST_CTL_1, 0xff, 0xfa);
+	regmap_update_bits(regmap, WCD937X_MICB3_TEST_CTL_1, 0xff, 0xfa);
+
+	regmap_update_bits(regmap, WCD937X_MICB1_TEST_CTL_2, 0x38, 0x00);
+	regmap_update_bits(regmap, WCD937X_MICB2_TEST_CTL_2, 0x38, 0x00);
+	regmap_update_bits(regmap, WCD937X_MICB3_TEST_CTL_2, 0x38, 0x00);
+
+	/* Set Bandgap Fine Adjustment to +5mV for Tanggu SMIC part */
+	regmap_read(regmap, WCD937X_DIGITAL_EFUSE_REG_16, &val);
+	if (val == 0x01) {
+		regmap_update_bits(regmap, WCD937X_BIAS_VBG_FINE_ADJ, 0xF0, 0xB0);
+	} else if (val == 0x02) {
+		regmap_update_bits(regmap, WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_L, 0x1F, 0x04);
+		regmap_update_bits(regmap, WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_R, 0x1F, 0x04);
+		regmap_update_bits(regmap, WCD937X_BIAS_VBG_FINE_ADJ, 0xF0, 0xB0);
+		regmap_update_bits(regmap, WCD937X_HPH_NEW_INT_RDAC_GAIN_CTL, 0xF0, 0x50);
+	}
+}
+
+static int wcd937x_rx_clk_enable(struct snd_soc_component *component)
+{
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+
+	if (atomic_read(&wcd937x->rx_clk_cnt))
+		return 0;
+
+	snd_soc_component_update_bits(component, WCD937X_DIGITAL_CDC_DIG_CLK_CTL, BIT(3), BIT(3));
+	snd_soc_component_update_bits(component, WCD937X_DIGITAL_CDC_ANA_CLK_CTL, BIT(0), BIT(0));
+	snd_soc_component_update_bits(component, WCD937X_ANA_RX_SUPPLIES, BIT(0), BIT(0));
+	snd_soc_component_update_bits(component, WCD937X_DIGITAL_CDC_RX0_CTL, BIT(6), 0x00);
+	snd_soc_component_update_bits(component, WCD937X_DIGITAL_CDC_RX1_CTL, BIT(6), 0x00);
+	snd_soc_component_update_bits(component, WCD937X_DIGITAL_CDC_RX2_CTL, BIT(6), 0x00);
+	snd_soc_component_update_bits(component, WCD937X_DIGITAL_CDC_ANA_CLK_CTL, BIT(1), BIT(1));
+
+	atomic_inc(&wcd937x->rx_clk_cnt);
+
+	return 0;
+}
+
+static int wcd937x_rx_clk_disable(struct snd_soc_component *component)
+{
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+
+	if (!atomic_read(&wcd937x->rx_clk_cnt)) {
+		dev_err(component->dev, "clk already disabled\n");
+		return 0;
+	}
+
+	atomic_dec(&wcd937x->rx_clk_cnt);
+
+	snd_soc_component_update_bits(component, WCD937X_ANA_RX_SUPPLIES, BIT(0), 0x00);
+	snd_soc_component_update_bits(component, WCD937X_DIGITAL_CDC_ANA_CLK_CTL, BIT(1), 0x00);
+	snd_soc_component_update_bits(component, WCD937X_DIGITAL_CDC_ANA_CLK_CTL, BIT(0), 0x00);
+
+	return 0;
+}
+
+static int wcd937x_codec_hphl_dac_event(struct snd_soc_dapm_widget *w,
+					struct snd_kcontrol *kcontrol,
+					int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	int hph_mode = wcd937x->hph_mode;
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		wcd937x_rx_clk_enable(component);
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_DIG_CLK_CTL,
+					      BIT(0), BIT(0));
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_HPH_GAIN_CTL,
+					      BIT(2), BIT(2));
+		snd_soc_component_update_bits(component,
+					      WCD937X_HPH_RDAC_CLK_CTL1,
+					      BIT(7), 0x00);
+		set_bit(HPH_COMP_DELAY, &wcd937x->status_mask);
+		break;
+	case SND_SOC_DAPM_POST_PMU:
+		if (hph_mode == CLS_AB_HIFI || hph_mode == CLS_H_HIFI)
+			snd_soc_component_update_bits(component,
+						      WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_L,
+						      0x0f, BIT(1));
+		else if (hph_mode == CLS_H_LOHIFI)
+			snd_soc_component_update_bits(component,
+						      WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_L,
+						      0x0f, 0x06);
+
+		if (wcd937x->comp1_enable) {
+			snd_soc_component_update_bits(component,
+						      WCD937X_DIGITAL_CDC_COMP_CTL_0,
+						      BIT(1), BIT(1));
+			snd_soc_component_update_bits(component,
+						      WCD937X_HPH_L_EN,
+						      BIT(5), 0x00);
+
+			if (wcd937x->comp2_enable) {
+				snd_soc_component_update_bits(component,
+							      WCD937X_DIGITAL_CDC_COMP_CTL_0,
+							      BIT(0), BIT(0));
+				snd_soc_component_update_bits(component,
+							      WCD937X_HPH_R_EN, BIT(5), 0x00);
+			}
+
+			if (test_bit(HPH_COMP_DELAY, &wcd937x->status_mask)) {
+				usleep_range(5000, 5110);
+				clear_bit(HPH_COMP_DELAY, &wcd937x->status_mask);
+			}
+		} else {
+			snd_soc_component_update_bits(component,
+						      WCD937X_DIGITAL_CDC_COMP_CTL_0,
+						      BIT(1), 0x00);
+			snd_soc_component_update_bits(component,
+						      WCD937X_HPH_L_EN,
+						      BIT(5), BIT(5));
+		}
+
+		snd_soc_component_update_bits(component,
+					      WCD937X_HPH_NEW_INT_HPH_TIMER1,
+					      BIT(1), 0x00);
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component,
+					      WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_L,
+					      0x0f, BIT(0));
+		break;
+	}
+
+	return 0;
+}
+
+static int wcd937x_codec_hphr_dac_event(struct snd_soc_dapm_widget *w,
+					struct snd_kcontrol *kcontrol,
+					int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	int hph_mode = wcd937x->hph_mode;
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		wcd937x_rx_clk_enable(component);
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_DIG_CLK_CTL, BIT(1), BIT(1));
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_HPH_GAIN_CTL, BIT(3), BIT(3));
+		snd_soc_component_update_bits(component,
+					      WCD937X_HPH_RDAC_CLK_CTL1, BIT(7), 0x00);
+		set_bit(HPH_COMP_DELAY, &wcd937x->status_mask);
+		break;
+	case SND_SOC_DAPM_POST_PMU:
+		if (hph_mode == CLS_AB_HIFI || hph_mode == CLS_H_HIFI)
+			snd_soc_component_update_bits(component,
+						      WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_R,
+						      0x0f, BIT(1));
+		else if (hph_mode == CLS_H_LOHIFI)
+			snd_soc_component_update_bits(component,
+						      WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_R,
+						      0x0f, 0x06);
+		if (wcd937x->comp2_enable) {
+			snd_soc_component_update_bits(component,
+						      WCD937X_DIGITAL_CDC_COMP_CTL_0,
+						      BIT(0), BIT(0));
+			snd_soc_component_update_bits(component,
+						      WCD937X_HPH_R_EN, BIT(5), 0x00);
+			if (wcd937x->comp1_enable) {
+				snd_soc_component_update_bits(component,
+							      WCD937X_DIGITAL_CDC_COMP_CTL_0,
+							      BIT(1), BIT(1));
+				snd_soc_component_update_bits(component,
+							      WCD937X_HPH_L_EN,
+							      BIT(5), 0x00);
+			}
+
+			if (test_bit(HPH_COMP_DELAY, &wcd937x->status_mask)) {
+				usleep_range(5000, 5110);
+				clear_bit(HPH_COMP_DELAY, &wcd937x->status_mask);
+			}
+		} else {
+			snd_soc_component_update_bits(component,
+						      WCD937X_DIGITAL_CDC_COMP_CTL_0,
+						      BIT(0), 0x00);
+			snd_soc_component_update_bits(component,
+						      WCD937X_HPH_R_EN,
+						      BIT(5), BIT(5));
+		}
+		snd_soc_component_update_bits(component,
+					      WCD937X_HPH_NEW_INT_HPH_TIMER1,
+					      BIT(1), 0x00);
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component,
+					      WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_R,
+					      0x0f, BIT(0));
+		break;
+	}
+
+	return 0;
+}
+
+static int wcd937x_codec_ear_dac_event(struct snd_soc_dapm_widget *w,
+				       struct snd_kcontrol *kcontrol,
+				       int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	int hph_mode = wcd937x->hph_mode;
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		wcd937x_rx_clk_enable(component);
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_HPH_GAIN_CTL,
+					      BIT(2), BIT(2));
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_DIG_CLK_CTL,
+					      BIT(0), BIT(0));
+
+		if (hph_mode == CLS_AB_HIFI || hph_mode == CLS_H_HIFI)
+			snd_soc_component_update_bits(component,
+						      WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_L,
+						      0x0f, BIT(1));
+		else if (hph_mode == CLS_H_LOHIFI)
+			snd_soc_component_update_bits(component,
+						      WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_L,
+						      0x0f, 0x06);
+		if (wcd937x->comp1_enable)
+			snd_soc_component_update_bits(component,
+						      WCD937X_DIGITAL_CDC_COMP_CTL_0,
+						      BIT(1), BIT(1));
+		usleep_range(5000, 5010);
+
+		snd_soc_component_update_bits(component, WCD937X_FLYBACK_EN, BIT(2), 0x00);
+		wcd_clsh_ctrl_set_state(wcd937x->clsh_info,
+					WCD_CLSH_EVENT_PRE_DAC,
+					WCD_CLSH_STATE_EAR,
+					hph_mode);
+
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		if (hph_mode == CLS_AB_HIFI || hph_mode == CLS_H_LOHIFI ||
+		    hph_mode == CLS_H_HIFI)
+			snd_soc_component_update_bits(component,
+						      WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_L,
+						      0x0f, BIT(0));
+		if (wcd937x->comp1_enable)
+			snd_soc_component_update_bits(component,
+						      WCD937X_DIGITAL_CDC_COMP_CTL_0,
+						      BIT(1), 0x00);
+		break;
+	}
+
+	return 0;
+}
+
+static int wcd937x_codec_aux_dac_event(struct snd_soc_dapm_widget *w,
+				       struct snd_kcontrol *kcontrol,
+				       int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	int hph_mode = wcd937x->hph_mode;
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		wcd937x_rx_clk_enable(component);
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_ANA_CLK_CTL,
+					      BIT(2), BIT(2));
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_DIG_CLK_CTL,
+					      BIT(2), BIT(2));
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_AUX_GAIN_CTL,
+					      BIT(0), BIT(0));
+		wcd_clsh_ctrl_set_state(wcd937x->clsh_info,
+					WCD_CLSH_EVENT_PRE_DAC,
+					WCD_CLSH_STATE_AUX,
+					hph_mode);
+
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_ANA_CLK_CTL,
+					      BIT(2), 0x00);
+		break;
+	}
+
+	return 0;
+}
+
+static int wcd937x_codec_enable_hphr_pa(struct snd_soc_dapm_widget *w,
+					struct snd_kcontrol *kcontrol,
+					int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	int hph_mode = wcd937x->hph_mode;
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		wcd_clsh_ctrl_set_state(wcd937x->clsh_info,
+					WCD_CLSH_EVENT_PRE_DAC,
+					WCD_CLSH_STATE_HPHR,
+					hph_mode);
+		snd_soc_component_update_bits(component, WCD937X_ANA_HPH,
+					      BIT(4), BIT(4));
+		usleep_range(100, 110);
+		set_bit(HPH_PA_DELAY, &wcd937x->status_mask);
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_PDM_WD_CTL1,
+					      0x07, 0x03);
+		break;
+	case SND_SOC_DAPM_POST_PMU:
+		if (test_bit(HPH_PA_DELAY, &wcd937x->status_mask)) {
+			if (wcd937x->comp2_enable)
+				usleep_range(7000, 7100);
+			else
+				usleep_range(20000, 20100);
+			clear_bit(HPH_PA_DELAY, &wcd937x->status_mask);
+		}
+
+		snd_soc_component_update_bits(component,
+					      WCD937X_HPH_NEW_INT_HPH_TIMER1,
+					      BIT(1), BIT(1));
+		if (hph_mode == CLS_AB || hph_mode == CLS_AB_HIFI)
+			snd_soc_component_update_bits(component,
+						      WCD937X_ANA_RX_SUPPLIES,
+						      BIT(1), BIT(1));
+		enable_irq(wcd937x->hphr_pdm_wd_int);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		disable_irq_nosync(wcd937x->hphr_pdm_wd_int);
+		set_bit(HPH_PA_DELAY, &wcd937x->status_mask);
+		wcd_mbhc_event_notify(wcd937x->wcd_mbhc, WCD_EVENT_PRE_HPHR_PA_OFF);
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		if (test_bit(HPH_PA_DELAY, &wcd937x->status_mask)) {
+			if (wcd937x->comp2_enable)
+				usleep_range(7000, 7100);
+			else
+				usleep_range(20000, 20100);
+			clear_bit(HPH_PA_DELAY, &wcd937x->status_mask);
+		}
+
+		wcd_mbhc_event_notify(wcd937x->wcd_mbhc, WCD_EVENT_POST_HPHR_PA_OFF);
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_PDM_WD_CTL1, 0x07, 0x00);
+		snd_soc_component_update_bits(component, WCD937X_ANA_HPH,
+					      BIT(4), 0x00);
+		wcd_clsh_ctrl_set_state(wcd937x->clsh_info,
+					WCD_CLSH_EVENT_POST_PA,
+					WCD_CLSH_STATE_HPHR,
+					hph_mode);
+		break;
+	}
+
+	return 0;
+}
+
+static int wcd937x_codec_enable_hphl_pa(struct snd_soc_dapm_widget *w,
+					struct snd_kcontrol *kcontrol,
+					int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	int hph_mode = wcd937x->hph_mode;
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		wcd_clsh_ctrl_set_state(wcd937x->clsh_info,
+					WCD_CLSH_EVENT_PRE_DAC,
+					WCD_CLSH_STATE_HPHL,
+					hph_mode);
+		snd_soc_component_update_bits(component, WCD937X_ANA_HPH,
+					      BIT(5), BIT(5));
+		usleep_range(100, 110);
+		set_bit(HPH_PA_DELAY, &wcd937x->status_mask);
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_PDM_WD_CTL0, 0x07, 0x03);
+		break;
+	case SND_SOC_DAPM_POST_PMU:
+		if (test_bit(HPH_PA_DELAY, &wcd937x->status_mask)) {
+			if (!wcd937x->comp1_enable)
+				usleep_range(20000, 20100);
+			else
+				usleep_range(7000, 7100);
+			clear_bit(HPH_PA_DELAY, &wcd937x->status_mask);
+		}
+
+		snd_soc_component_update_bits(component,
+					      WCD937X_HPH_NEW_INT_HPH_TIMER1,
+					      BIT(1), BIT(1));
+		if (hph_mode == CLS_AB || hph_mode == CLS_AB_HIFI)
+			snd_soc_component_update_bits(component,
+						      WCD937X_ANA_RX_SUPPLIES,
+						      BIT(1), BIT(1));
+		enable_irq(wcd937x->hphl_pdm_wd_int);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		disable_irq_nosync(wcd937x->hphl_pdm_wd_int);
+		set_bit(HPH_PA_DELAY, &wcd937x->status_mask);
+		wcd_mbhc_event_notify(wcd937x->wcd_mbhc, WCD_EVENT_PRE_HPHL_PA_OFF);
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		if (test_bit(HPH_PA_DELAY, &wcd937x->status_mask)) {
+			if (!wcd937x->comp1_enable)
+				usleep_range(20000, 20100);
+			else
+				usleep_range(7000, 7100);
+			clear_bit(HPH_PA_DELAY, &wcd937x->status_mask);
+		}
+
+		wcd_mbhc_event_notify(wcd937x->wcd_mbhc, WCD_EVENT_POST_HPHL_PA_OFF);
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_PDM_WD_CTL0, 0x07, 0x00);
+		snd_soc_component_update_bits(component,
+					      WCD937X_ANA_HPH, BIT(5), 0x00);
+		wcd_clsh_ctrl_set_state(wcd937x->clsh_info,
+					WCD_CLSH_EVENT_POST_PA,
+					WCD_CLSH_STATE_HPHL,
+					hph_mode);
+		break;
+	}
+
+	return 0;
+}
+
+static int wcd937x_codec_enable_aux_pa(struct snd_soc_dapm_widget *w,
+				       struct snd_kcontrol *kcontrol,
+				       int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	int hph_mode = wcd937x->hph_mode;
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_PDM_WD_CTL2,
+					      BIT(0), BIT(0));
+		break;
+	case SND_SOC_DAPM_POST_PMU:
+		usleep_range(1000, 1010);
+		if (hph_mode == CLS_AB || hph_mode == CLS_AB_HIFI)
+			snd_soc_component_update_bits(component,
+						      WCD937X_ANA_RX_SUPPLIES,
+						      BIT(1), BIT(1));
+		enable_irq(wcd937x->aux_pdm_wd_int);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		disable_irq_nosync(wcd937x->aux_pdm_wd_int);
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		usleep_range(2000, 2010);
+		wcd_clsh_ctrl_set_state(wcd937x->clsh_info,
+					WCD_CLSH_EVENT_POST_PA,
+					WCD_CLSH_STATE_AUX,
+					hph_mode);
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_PDM_WD_CTL2,
+					      BIT(0), 0x00);
+		break;
+	}
+
+	return 0;
+}
+
+static int wcd937x_codec_enable_ear_pa(struct snd_soc_dapm_widget *w,
+				       struct snd_kcontrol *kcontrol,
+				       int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	int hph_mode = wcd937x->hph_mode;
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		/* Enable watchdog interrupt for HPHL or AUX depending on mux value */
+		wcd937x->ear_rx_path = snd_soc_component_read(component,
+							      WCD937X_DIGITAL_CDC_EAR_PATH_CTL);
+
+		if (wcd937x->ear_rx_path & EAR_RX_PATH_AUX)
+			snd_soc_component_update_bits(component,
+						      WCD937X_DIGITAL_PDM_WD_CTL2,
+						      BIT(0), BIT(0));
+		else
+			snd_soc_component_update_bits(component,
+						      WCD937X_DIGITAL_PDM_WD_CTL0,
+						      0x07, 0x03);
+		if (!wcd937x->comp1_enable)
+			snd_soc_component_update_bits(component,
+						      WCD937X_ANA_EAR_COMPANDER_CTL,
+						      BIT(7), BIT(7));
+		break;
+	case SND_SOC_DAPM_POST_PMU:
+		usleep_range(6000, 6010);
+		if (hph_mode == CLS_AB || hph_mode == CLS_AB_HIFI)
+			snd_soc_component_update_bits(component,
+						      WCD937X_ANA_RX_SUPPLIES,
+						      BIT(1), BIT(1));
+
+		if (wcd937x->ear_rx_path & EAR_RX_PATH_AUX)
+			enable_irq(wcd937x->aux_pdm_wd_int);
+		else
+			enable_irq(wcd937x->hphl_pdm_wd_int);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		if (wcd937x->ear_rx_path & EAR_RX_PATH_AUX)
+			disable_irq_nosync(wcd937x->aux_pdm_wd_int);
+		else
+			disable_irq_nosync(wcd937x->hphl_pdm_wd_int);
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		if (!wcd937x->comp1_enable)
+			snd_soc_component_update_bits(component,
+						      WCD937X_ANA_EAR_COMPANDER_CTL,
+						      BIT(7), 0x00);
+		usleep_range(7000, 7010);
+		wcd_clsh_ctrl_set_state(wcd937x->clsh_info,
+					WCD_CLSH_EVENT_POST_PA,
+					WCD_CLSH_STATE_EAR,
+					hph_mode);
+		snd_soc_component_update_bits(component, WCD937X_FLYBACK_EN,
+					      BIT(2), BIT(2));
+
+		if (wcd937x->ear_rx_path & EAR_RX_PATH_AUX)
+			snd_soc_component_update_bits(component,
+						      WCD937X_DIGITAL_PDM_WD_CTL2,
+						      BIT(0), 0x00);
+		else
+			snd_soc_component_update_bits(component,
+						      WCD937X_DIGITAL_PDM_WD_CTL0,
+						      0x07, 0x00);
+		break;
+	}
+
+	return 0;
+}
+
+static int wcd937x_enable_rx1(struct snd_soc_dapm_widget *w,
+			      struct snd_kcontrol *kcontrol,
+			      int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+
+	if (event == SND_SOC_DAPM_POST_PMD) {
+		wcd937x_rx_clk_disable(component);
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_DIG_CLK_CTL,
+					      BIT(0), 0x00);
+	}
+
+	return 0;
+}
+
+static int wcd937x_enable_rx2(struct snd_soc_dapm_widget *w,
+			      struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+
+	if (event == SND_SOC_DAPM_POST_PMD) {
+		wcd937x_rx_clk_disable(component);
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_DIG_CLK_CTL,
+					      BIT(1), 0x00);
+	}
+
+	return 0;
+}
+
+static int wcd937x_enable_rx3(struct snd_soc_dapm_widget *w,
+			      struct snd_kcontrol *kcontrol,
+			      int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+
+	if (event == SND_SOC_DAPM_POST_PMD) {
+		usleep_range(6000, 6010);
+		wcd937x_rx_clk_disable(component);
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_DIG_CLK_CTL,
+					      BIT(2), 0x00);
+	}
+
+	return 0;
+}
+
+static int wcd937x_get_micb_vout_ctl_val(u32 micb_mv)
+{
+	if (micb_mv < 1000 || micb_mv > 2850) {
+		pr_err("Unsupported micbias voltage (%u mV)\n", micb_mv);
+		return -EINVAL;
+	}
+
+	return (micb_mv - 1000) / 50;
+}
+
+static int wcd937x_tx_swr_ctrl(struct snd_soc_dapm_widget *w,
+			       struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	bool use_amic3 = snd_soc_component_read(component, WCD937X_TX_NEW_TX_CH2_SEL) & BIT(7);
+
+	/* Enable BCS for Headset mic */
+	if (event == SND_SOC_DAPM_PRE_PMU && strnstr(w->name, "ADC", sizeof("ADC")))
+		if (w->shift == 1 && !use_amic3)
+			set_bit(AMIC2_BCS_ENABLE, &wcd937x->status_mask);
+
+	return 0;
+}
+
+static int wcd937x_codec_enable_adc(struct snd_soc_dapm_widget *w,
+				    struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		atomic_inc(&wcd937x->ana_clk_count);
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_DIG_CLK_CTL, BIT(7), BIT(7));
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_ANA_CLK_CTL, BIT(3), BIT(3));
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_ANA_CLK_CTL, BIT(4), BIT(4));
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		if (w->shift == 1 && test_bit(AMIC2_BCS_ENABLE, &wcd937x->status_mask))
+			clear_bit(AMIC2_BCS_ENABLE, &wcd937x->status_mask);
+
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_ANA_CLK_CTL, BIT(3), 0x00);
+		break;
+	}
+
+	return 0;
+}
+
+static int wcd937x_enable_req(struct snd_soc_dapm_widget *w,
+			      struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_REQ_CTL, BIT(1), BIT(1));
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_REQ_CTL, BIT(0), 0x00);
+		snd_soc_component_update_bits(component,
+					      WCD937X_ANA_TX_CH2, BIT(6), BIT(6));
+		snd_soc_component_update_bits(component,
+					      WCD937X_ANA_TX_CH3_HPF, BIT(6), BIT(6));
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_DIG_CLK_CTL, 0x70, 0x70);
+		snd_soc_component_update_bits(component,
+					      WCD937X_ANA_TX_CH1, BIT(7), BIT(7));
+		snd_soc_component_update_bits(component,
+					      WCD937X_ANA_TX_CH2, BIT(6), 0x00);
+		snd_soc_component_update_bits(component,
+					      WCD937X_ANA_TX_CH2, BIT(7), BIT(7));
+		snd_soc_component_update_bits(component,
+					      WCD937X_ANA_TX_CH3, BIT(7), BIT(7));
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component,
+					      WCD937X_ANA_TX_CH1, BIT(7), 0x00);
+		snd_soc_component_update_bits(component,
+					      WCD937X_ANA_TX_CH2, BIT(7), 0x00);
+		snd_soc_component_update_bits(component,
+					      WCD937X_ANA_TX_CH3, BIT(7), 0x00);
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_DIG_CLK_CTL, BIT(4), 0x00);
+
+		atomic_dec(&wcd937x->ana_clk_count);
+		if (atomic_read(&wcd937x->ana_clk_count) <= 0) {
+			snd_soc_component_update_bits(component,
+						      WCD937X_DIGITAL_CDC_ANA_CLK_CTL,
+						      BIT(4), 0x00);
+			atomic_set(&wcd937x->ana_clk_count, 0);
+		}
+
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_DIG_CLK_CTL,
+					      BIT(7), 0x00);
+		break;
+	}
+
+	return 0;
+}
+
+static int wcd937x_codec_enable_dmic(struct snd_soc_dapm_widget *w,
+				     struct snd_kcontrol *kcontrol,
+				     int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	u16 dmic_clk_reg;
+
+	switch (w->shift) {
+	case 0:
+	case 1:
+		dmic_clk_reg = WCD937X_DIGITAL_CDC_DMIC1_CTL;
+		break;
+	case 2:
+	case 3:
+		dmic_clk_reg = WCD937X_DIGITAL_CDC_DMIC2_CTL;
+		break;
+	case 4:
+	case 5:
+		dmic_clk_reg = WCD937X_DIGITAL_CDC_DMIC3_CTL;
+		break;
+	default:
+		dev_err(component->dev, "Invalid DMIC Selection\n");
+		return -EINVAL;
+	}
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		snd_soc_component_update_bits(component,
+					      WCD937X_DIGITAL_CDC_DIG_CLK_CTL,
+					      BIT(7), BIT(7));
+		snd_soc_component_update_bits(component,
+					      dmic_clk_reg, 0x07, BIT(1));
+		snd_soc_component_update_bits(component,
+					      dmic_clk_reg, BIT(3), BIT(3));
+		snd_soc_component_update_bits(component,
+					      dmic_clk_reg, 0x70, BIT(5));
+		break;
+	}
+
+	return 0;
+}
+
+static int wcd937x_micbias_control(struct snd_soc_component *component,
+				   int micb_num, int req, bool is_dapm)
+{
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	int micb_index = micb_num - 1;
+	u16 micb_reg;
+
+	if (micb_index < 0 || (micb_index > WCD937X_MAX_MICBIAS - 1)) {
+		dev_err(component->dev, "Invalid micbias index, micb_ind:%d\n", micb_index);
+		return -EINVAL;
+	}
+	switch (micb_num) {
+	case MIC_BIAS_1:
+		micb_reg = WCD937X_ANA_MICB1;
+		break;
+	case MIC_BIAS_2:
+		micb_reg = WCD937X_ANA_MICB2;
+		break;
+	case MIC_BIAS_3:
+		micb_reg = WCD937X_ANA_MICB3;
+		break;
+	default:
+		dev_err(component->dev, "Invalid micbias number: %d\n", micb_num);
+		return -EINVAL;
+	}
+
+	mutex_lock(&wcd937x->micb_lock);
+	switch (req) {
+	case MICB_PULLUP_ENABLE:
+		wcd937x->pullup_ref[micb_index]++;
+		if (wcd937x->pullup_ref[micb_index] == 1 &&
+		    wcd937x->micb_ref[micb_index] == 0)
+			snd_soc_component_update_bits(component, micb_reg,
+						      0xc0, BIT(7));
+		break;
+	case MICB_PULLUP_DISABLE:
+		if (wcd937x->pullup_ref[micb_index] > 0)
+			wcd937x->pullup_ref[micb_index]++;
+		if (wcd937x->pullup_ref[micb_index] == 0 &&
+		    wcd937x->micb_ref[micb_index] == 0)
+			snd_soc_component_update_bits(component, micb_reg,
+						      0xc0, 0x00);
+		break;
+	case MICB_ENABLE:
+		wcd937x->micb_ref[micb_index]++;
+		atomic_inc(&wcd937x->ana_clk_count);
+		if (wcd937x->micb_ref[micb_index] == 1) {
+			snd_soc_component_update_bits(component,
+						      WCD937X_DIGITAL_CDC_DIG_CLK_CTL,
+						      0xf0, 0xf0);
+			snd_soc_component_update_bits(component,
+						      WCD937X_DIGITAL_CDC_ANA_CLK_CTL,
+						      BIT(4), BIT(4));
+			snd_soc_component_update_bits(component,
+						      WCD937X_MICB1_TEST_CTL_2,
+						      BIT(0), BIT(0));
+			snd_soc_component_update_bits(component,
+						      WCD937X_MICB2_TEST_CTL_2,
+						      BIT(0), BIT(0));
+			snd_soc_component_update_bits(component,
+						      WCD937X_MICB3_TEST_CTL_2,
+						      BIT(0), BIT(0));
+			snd_soc_component_update_bits(component,
+						      micb_reg, 0xc0, BIT(6));
+
+			if (micb_num == MIC_BIAS_2)
+				wcd_mbhc_event_notify(wcd937x->wcd_mbhc,
+						      WCD_EVENT_POST_MICBIAS_2_ON);
+
+			if (micb_num == MIC_BIAS_2 && is_dapm)
+				wcd_mbhc_event_notify(wcd937x->wcd_mbhc,
+						      WCD_EVENT_POST_DAPM_MICBIAS_2_ON);
+		}
+		break;
+	case MICB_DISABLE:
+		atomic_dec(&wcd937x->ana_clk_count);
+		if (wcd937x->micb_ref[micb_index] > 0)
+			wcd937x->micb_ref[micb_index]--;
+		if (wcd937x->micb_ref[micb_index] == 0 &&
+		    wcd937x->pullup_ref[micb_index] > 0)
+			snd_soc_component_update_bits(component, micb_reg,
+						      0xc0, BIT(7));
+		else if (wcd937x->micb_ref[micb_index] == 0 &&
+			 wcd937x->pullup_ref[micb_index] == 0) {
+			if (micb_num == MIC_BIAS_2)
+				wcd_mbhc_event_notify(wcd937x->wcd_mbhc,
+						      WCD_EVENT_PRE_MICBIAS_2_OFF);
+
+			snd_soc_component_update_bits(component, micb_reg,
+						      0xc0, 0x00);
+			if (micb_num == MIC_BIAS_2)
+				wcd_mbhc_event_notify(wcd937x->wcd_mbhc,
+						      WCD_EVENT_POST_MICBIAS_2_OFF);
+		}
+
+		if (is_dapm && micb_num == MIC_BIAS_2)
+			wcd_mbhc_event_notify(wcd937x->wcd_mbhc,
+					      WCD_EVENT_POST_DAPM_MICBIAS_2_OFF);
+		if (atomic_read(&wcd937x->ana_clk_count) <= 0) {
+			snd_soc_component_update_bits(component,
+						      WCD937X_DIGITAL_CDC_ANA_CLK_CTL,
+						      BIT(4), 0x00);
+			atomic_set(&wcd937x->ana_clk_count, 0);
+		}
+		break;
+	}
+	mutex_unlock(&wcd937x->micb_lock);
+
+	return 0;
+}
+
+static int __wcd937x_codec_enable_micbias(struct snd_soc_dapm_widget *w,
+					  int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	int micb_num = w->shift;
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		wcd937x_micbias_control(component, micb_num,
+					MICB_ENABLE, true);
+		break;
+	case SND_SOC_DAPM_POST_PMU:
+		usleep_range(1000, 1100);
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		wcd937x_micbias_control(component, micb_num,
+					MICB_DISABLE, true);
+		break;
+	}
+
+	return 0;
+}
+
+static int wcd937x_codec_enable_micbias(struct snd_soc_dapm_widget *w,
+					struct snd_kcontrol *kcontrol,
+					int event)
+{
+	return __wcd937x_codec_enable_micbias(w, event);
+}
+
+static int __wcd937x_codec_enable_micbias_pullup(struct snd_soc_dapm_widget *w,
+						 int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	int micb_num = w->shift;
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		wcd937x_micbias_control(component, micb_num, MICB_PULLUP_ENABLE, true);
+		break;
+	case SND_SOC_DAPM_POST_PMU:
+		usleep_range(1000, 1100);
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		wcd937x_micbias_control(component, micb_num, MICB_PULLUP_DISABLE, true);
+		break;
+	}
+
+	return 0;
+}
+
+static int wcd937x_codec_enable_micbias_pullup(struct snd_soc_dapm_widget *w,
+					       struct snd_kcontrol *kcontrol,
+					       int event)
+{
+	return __wcd937x_codec_enable_micbias_pullup(w, event);
+}
+
+static int wcd937x_connect_port(struct wcd937x_sdw_priv *wcd, u8 port_idx, u8 ch_id, bool enable)
+{
+	struct sdw_port_config *port_config = &wcd->port_config[port_idx - 1];
+	const struct wcd937x_sdw_ch_info *ch_info = &wcd->ch_info[ch_id];
+	u8 port_num = ch_info->port_num;
+	u8 ch_mask = ch_info->ch_mask;
+
+	port_config->num = port_num;
+
+	if (enable)
+		port_config->ch_mask |= ch_mask;
+	else
+		port_config->ch_mask &= ~ch_mask;
+
+	return 0;
+}
+
+static int wcd937x_rx_hph_mode_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = wcd937x->hph_mode;
+	return 0;
+}
+
+static int wcd937x_rx_hph_mode_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+				snd_soc_kcontrol_component(kcontrol);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	u32 mode_val;
+
+	mode_val = ucontrol->value.enumerated.item[0];
+
+	if (!mode_val)
+		mode_val = CLS_AB;
+
+	if (mode_val == wcd937x->hph_mode)
+		return 0;
+
+	switch (mode_val) {
+	case CLS_H_NORMAL:
+	case CLS_H_HIFI:
+	case CLS_H_LP:
+	case CLS_AB:
+	case CLS_H_LOHIFI:
+	case CLS_H_ULP:
+	case CLS_AB_LP:
+	case CLS_AB_HIFI:
+		wcd937x->hph_mode = mode_val;
+		return 1;
+	}
+
+	dev_dbg(component->dev, "%s: Invalid HPH Mode\n", __func__);
+	return -EINVAL;
+}
+
+static int wcd937x_get_compander(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	struct soc_mixer_control *mc;
+	bool hphr;
+
+	mc = (struct soc_mixer_control *)(kcontrol->private_value);
+	hphr = mc->shift;
+
+	ucontrol->value.integer.value[0] = hphr ? wcd937x->comp2_enable :
+						  wcd937x->comp1_enable;
+	return 0;
+}
+
+static int wcd937x_set_compander(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	struct wcd937x_sdw_priv *wcd = wcd937x->sdw_priv[AIF1_PB];
+	int value = ucontrol->value.integer.value[0];
+	struct soc_mixer_control *mc;
+	int portidx;
+	bool hphr;
+
+	mc = (struct soc_mixer_control *)(kcontrol->private_value);
+	hphr = mc->shift;
+
+	if (hphr) {
+		if (value == wcd937x->comp2_enable)
+			return 0;
+
+		wcd937x->comp2_enable = value;
+	} else {
+		if (value == wcd937x->comp1_enable)
+			return 0;
+
+		wcd937x->comp1_enable = value;
+	}
+
+	portidx = wcd->ch_info[mc->reg].port_num;
+
+	if (value)
+		wcd937x_connect_port(wcd, portidx, mc->reg, true);
+	else
+		wcd937x_connect_port(wcd, portidx, mc->reg, false);
+
+	return 1;
+}
+
+static int wcd937x_get_swr_port(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mixer = (struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(comp);
+	struct wcd937x_sdw_priv *wcd;
+	int dai_id = mixer->shift;
+	int ch_idx = mixer->reg;
+	int portidx;
+
+	wcd = wcd937x->sdw_priv[dai_id];
+	portidx = wcd->ch_info[ch_idx].port_num;
+
+	ucontrol->value.integer.value[0] = wcd->port_enable[portidx];
+
+	return 0;
+}
+
+static int wcd937x_set_swr_port(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_mixer_control *mixer = (struct soc_mixer_control *)kcontrol->private_value;
+	struct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(comp);
+	struct wcd937x_sdw_priv *wcd;
+	int dai_id = mixer->shift;
+	int ch_idx = mixer->reg;
+	int portidx;
+	bool enable;
+
+	wcd = wcd937x->sdw_priv[dai_id];
+
+	portidx = wcd->ch_info[ch_idx].port_num;
+
+	enable = ucontrol->value.integer.value[0];
+
+	if (enable == wcd->port_enable[portidx]) {
+		wcd937x_connect_port(wcd, portidx, ch_idx, enable);
+		return 0;
+	}
+
+	wcd->port_enable[portidx] = enable;
+	wcd937x_connect_port(wcd, portidx, ch_idx, enable);
+
+	return 1;
+}
+
+static const char * const rx_hph_mode_mux_text[] = {
+	"CLS_H_NORMAL", "CLS_H_INVALID", "CLS_H_HIFI", "CLS_H_LP", "CLS_AB",
+	"CLS_H_LOHIFI", "CLS_H_ULP", "CLS_AB_LP", "CLS_AB_HIFI",
+};
+
+static const struct soc_enum rx_hph_mode_mux_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(rx_hph_mode_mux_text), rx_hph_mode_mux_text);
+
+/* MBHC related */
+static void wcd937x_mbhc_clk_setup(struct snd_soc_component *component,
+				   bool enable)
+{
+	snd_soc_component_write_field(component, WCD937X_MBHC_NEW_CTL_1,
+				      WCD937X_MBHC_CTL_RCO_EN_MASK, enable);
+}
+
+static void wcd937x_mbhc_mbhc_bias_control(struct snd_soc_component *component,
+					   bool enable)
+{
+	snd_soc_component_write_field(component, WCD937X_ANA_MBHC_ELECT,
+				      WCD937X_ANA_MBHC_BIAS_EN, enable);
+}
+
+static void wcd937x_mbhc_program_btn_thr(struct snd_soc_component *component,
+					 int *btn_low, int *btn_high,
+					 int num_btn, bool is_micbias)
+{
+	int i, vth;
+
+	if (num_btn > WCD_MBHC_DEF_BUTTONS) {
+		dev_err(component->dev, "%s: invalid number of buttons: %d\n",
+			__func__, num_btn);
+		return;
+	}
+
+	for (i = 0; i < num_btn; i++) {
+		vth = ((btn_high[i] * 2) / 25) & 0x3F;
+		snd_soc_component_write_field(component, WCD937X_ANA_MBHC_BTN0 + i,
+					      WCD937X_MBHC_BTN_VTH_MASK, vth);
+	}
+}
+
+static bool wcd937x_mbhc_micb_en_status(struct snd_soc_component *component, int micb_num)
+{
+	u8 val;
+
+	if (micb_num == MIC_BIAS_2) {
+		val = snd_soc_component_read_field(component,
+						   WCD937X_ANA_MICB2,
+						   WCD937X_ANA_MICB2_ENABLE_MASK);
+		if (val == WCD937X_MICB_ENABLE)
+			return true;
+	}
+	return false;
+}
+
+static void wcd937x_mbhc_hph_l_pull_up_control(struct snd_soc_component *component,
+					       int pull_up_cur)
+{
+	/* Default pull up current to 2uA */
+	if (pull_up_cur > HS_PULLUP_I_OFF || pull_up_cur < HS_PULLUP_I_3P0_UA)
+		pull_up_cur = HS_PULLUP_I_2P0_UA;
+
+	snd_soc_component_write_field(component,
+				      WCD937X_MBHC_NEW_INT_MECH_DET_CURRENT,
+				      WCD937X_HSDET_PULLUP_C_MASK, pull_up_cur);
+}
+
+static int wcd937x_mbhc_request_micbias(struct snd_soc_component *component,
+					int micb_num, int req)
+{
+	return wcd937x_micbias_control(component, micb_num, req, false);
+}
+
+static void wcd937x_mbhc_micb_ramp_control(struct snd_soc_component *component,
+					   bool enable)
+{
+	if (enable) {
+		snd_soc_component_write_field(component, WCD937X_ANA_MICB2_RAMP,
+					      WCD937X_RAMP_SHIFT_CTRL_MASK, 0x0C);
+		snd_soc_component_write_field(component, WCD937X_ANA_MICB2_RAMP,
+					      WCD937X_RAMP_EN_MASK, 1);
+	} else {
+		snd_soc_component_write_field(component, WCD937X_ANA_MICB2_RAMP,
+					      WCD937X_RAMP_EN_MASK, 0);
+		snd_soc_component_write_field(component, WCD937X_ANA_MICB2_RAMP,
+					      WCD937X_RAMP_SHIFT_CTRL_MASK, 0);
+	}
+}
+
+static int wcd937x_mbhc_micb_adjust_voltage(struct snd_soc_component *component,
+					    int req_volt, int micb_num)
+{
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	int cur_vout_ctl, req_vout_ctl, micb_reg, micb_en, ret = 0;
+
+	switch (micb_num) {
+	case MIC_BIAS_1:
+		micb_reg = WCD937X_ANA_MICB1;
+		break;
+	case MIC_BIAS_2:
+		micb_reg = WCD937X_ANA_MICB2;
+		break;
+	case MIC_BIAS_3:
+		micb_reg = WCD937X_ANA_MICB3;
+		break;
+	default:
+		return -EINVAL;
+	}
+	mutex_lock(&wcd937x->micb_lock);
+	/*
+	 * If requested micbias voltage is same as current micbias
+	 * voltage, then just return. Otherwise, adjust voltage as
+	 * per requested value. If micbias is already enabled, then
+	 * to avoid slow micbias ramp-up or down enable pull-up
+	 * momentarily, change the micbias value and then re-enable
+	 * micbias.
+	 */
+	micb_en = snd_soc_component_read_field(component, micb_reg,
+					       WCD937X_MICB_EN_MASK);
+	cur_vout_ctl = snd_soc_component_read_field(component, micb_reg,
+						    WCD937X_MICB_VOUT_MASK);
+
+	req_vout_ctl = wcd937x_get_micb_vout_ctl_val(req_volt);
+	if (req_vout_ctl < 0) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (cur_vout_ctl == req_vout_ctl) {
+		ret = 0;
+		goto exit;
+	}
+
+	if (micb_en == WCD937X_MICB_ENABLE)
+		snd_soc_component_write_field(component, micb_reg,
+					      WCD937X_MICB_EN_MASK,
+					      WCD937X_MICB_PULL_UP);
+
+	snd_soc_component_write_field(component, micb_reg,
+				      WCD937X_MICB_VOUT_MASK,
+				      req_vout_ctl);
+
+	if (micb_en == WCD937X_MICB_ENABLE) {
+		snd_soc_component_write_field(component, micb_reg,
+					      WCD937X_MICB_EN_MASK,
+					      WCD937X_MICB_ENABLE);
+		/*
+		 * Add 2ms delay as per HW requirement after enabling
+		 * micbias
+		 */
+		usleep_range(2000, 2100);
+	}
+exit:
+	mutex_unlock(&wcd937x->micb_lock);
+	return ret;
+}
+
+static int wcd937x_mbhc_micb_ctrl_threshold_mic(struct snd_soc_component *component,
+						int micb_num, bool req_en)
+{
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	int micb_mv;
+
+	if (micb_num != MIC_BIAS_2)
+		return -EINVAL;
+	/*
+	 * If device tree micbias level is already above the minimum
+	 * voltage needed to detect threshold microphone, then do
+	 * not change the micbias, just return.
+	 */
+	if (wcd937x->micb2_mv >= WCD_MBHC_THR_HS_MICB_MV)
+		return 0;
+
+	micb_mv = req_en ? WCD_MBHC_THR_HS_MICB_MV : wcd937x->micb2_mv;
+
+	return wcd937x_mbhc_micb_adjust_voltage(component, micb_mv, MIC_BIAS_2);
+}
+
+static void wcd937x_mbhc_get_result_params(struct snd_soc_component *component,
+					   s16 *d1_a, u16 noff,
+					   int32_t *zdet)
+{
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	int i;
+	int val, val1;
+	s16 c1;
+	s32 x1, d1;
+	s32 denom;
+	static const int minCode_param[] = {
+		3277, 1639, 820, 410, 205, 103, 52, 26
+	};
+
+	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MBHC_ZDET, 0x20, 0x20);
+	for (i = 0; i < WCD937X_ZDET_NUM_MEASUREMENTS; i++) {
+		regmap_read(wcd937x->regmap, WCD937X_ANA_MBHC_RESULT_2, &val);
+		if (val & 0x80)
+			break;
+	}
+	val = val << 0x8;
+	regmap_read(wcd937x->regmap, WCD937X_ANA_MBHC_RESULT_1, &val1);
+	val |= val1;
+	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MBHC_ZDET, 0x20, 0x00);
+	x1 = WCD937X_MBHC_GET_X1(val);
+	c1 = WCD937X_MBHC_GET_C1(val);
+	/* If ramp is not complete, give additional 5ms */
+	if (c1 < 2 && x1)
+		usleep_range(5000, 5050);
+
+	if (!c1 || !x1) {
+		dev_err(component->dev, "Impedance detect ramp error, c1=%d, x1=0x%x\n",
+			c1, x1);
+		goto ramp_down;
+	}
+	d1 = d1_a[c1];
+	denom = (x1 * d1) - (1 << (14 - noff));
+	if (denom > 0)
+		*zdet = (WCD937X_MBHC_ZDET_CONST * 1000) / denom;
+	else if (x1 < minCode_param[noff])
+		*zdet = WCD937X_ZDET_FLOATING_IMPEDANCE;
+
+	dev_err(component->dev, "%s: d1=%d, c1=%d, x1=0x%x, z_val=%d (milliohm)\n",
+		__func__, d1, c1, x1, *zdet);
+ramp_down:
+	i = 0;
+	while (x1) {
+		regmap_read(wcd937x->regmap,
+			    WCD937X_ANA_MBHC_RESULT_1, &val);
+		regmap_read(wcd937x->regmap,
+			    WCD937X_ANA_MBHC_RESULT_2, &val1);
+		val = val << 0x08;
+		val |= val1;
+		x1 = WCD937X_MBHC_GET_X1(val);
+		i++;
+		if (i == WCD937X_ZDET_NUM_MEASUREMENTS)
+			break;
+	}
+}
+
+static void wcd937x_mbhc_zdet_ramp(struct snd_soc_component *component,
+				   struct wcd937x_mbhc_zdet_param *zdet_param,
+				   s32 *zl, s32 *zr, s16 *d1_a)
+{
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	s32 zdet = 0;
+
+	snd_soc_component_write_field(component, WCD937X_MBHC_NEW_ZDET_ANA_CTL,
+				      WCD937X_ZDET_MAXV_CTL_MASK, zdet_param->ldo_ctl);
+	snd_soc_component_update_bits(component, WCD937X_ANA_MBHC_BTN5,
+				      WCD937X_VTH_MASK, zdet_param->btn5);
+	snd_soc_component_update_bits(component, WCD937X_ANA_MBHC_BTN6,
+				      WCD937X_VTH_MASK, zdet_param->btn6);
+	snd_soc_component_update_bits(component, WCD937X_ANA_MBHC_BTN7,
+				      WCD937X_VTH_MASK, zdet_param->btn7);
+	snd_soc_component_write_field(component, WCD937X_MBHC_NEW_ZDET_ANA_CTL,
+				      WCD937X_ZDET_RANGE_CTL_MASK, zdet_param->noff);
+	snd_soc_component_update_bits(component, WCD937X_MBHC_NEW_ZDET_RAMP_CTL,
+				      0x0F, zdet_param->nshift);
+
+	if (!zl)
+		goto z_right;
+	/* Start impedance measurement for HPH_L */
+	regmap_update_bits(wcd937x->regmap,
+			   WCD937X_ANA_MBHC_ZDET, 0x80, 0x80);
+	wcd937x_mbhc_get_result_params(component, d1_a, zdet_param->noff, &zdet);
+	regmap_update_bits(wcd937x->regmap,
+			   WCD937X_ANA_MBHC_ZDET, 0x80, 0x00);
+
+	*zl = zdet;
+
+z_right:
+	if (!zr)
+		return;
+	/* Start impedance measurement for HPH_R */
+	regmap_update_bits(wcd937x->regmap,
+			   WCD937X_ANA_MBHC_ZDET, 0x40, 0x40);
+	wcd937x_mbhc_get_result_params(component, d1_a, zdet_param->noff, &zdet);
+	regmap_update_bits(wcd937x->regmap,
+			   WCD937X_ANA_MBHC_ZDET, 0x40, 0x00);
+
+	*zr = zdet;
+}
+
+static void wcd937x_wcd_mbhc_qfuse_cal(struct snd_soc_component *component,
+				       s32 *z_val, int flag_l_r)
+{
+	s16 q1;
+	int q1_cal;
+
+	if (*z_val < (WCD937X_ZDET_VAL_400 / 1000))
+		q1 = snd_soc_component_read(component,
+					    WCD937X_DIGITAL_EFUSE_REG_23 + (2 * flag_l_r));
+	else
+		q1 = snd_soc_component_read(component,
+					    WCD937X_DIGITAL_EFUSE_REG_24 + (2 * flag_l_r));
+	if (q1 & 0x80)
+		q1_cal = (10000 - ((q1 & 0x7F) * 25));
+	else
+		q1_cal = (10000 + (q1 * 25));
+	if (q1_cal > 0)
+		*z_val = ((*z_val) * 10000) / q1_cal;
+}
+
+static void wcd937x_wcd_mbhc_calc_impedance(struct snd_soc_component *component,
+					    u32 *zl, u32 *zr)
+{
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	s16 reg0, reg1, reg2, reg3, reg4;
+	s32 z1l, z1r, z1ls;
+	int zMono, z_diff1, z_diff2;
+	bool is_fsm_disable = false;
+	struct wcd937x_mbhc_zdet_param zdet_param[] = {
+		{4, 0, 4, 0x08, 0x14, 0x18}, /* < 32ohm */
+		{2, 0, 3, 0x18, 0x7C, 0x90}, /* 32ohm < Z < 400ohm */
+		{1, 4, 5, 0x18, 0x7C, 0x90}, /* 400ohm < Z < 1200ohm */
+		{1, 6, 7, 0x18, 0x7C, 0x90}, /* >1200ohm */
+	};
+	struct wcd937x_mbhc_zdet_param *zdet_param_ptr = NULL;
+	s16 d1_a[][4] = {
+		{0, 30, 90, 30},
+		{0, 30, 30, 5},
+		{0, 30, 30, 5},
+		{0, 30, 30, 5},
+	};
+	s16 *d1 = NULL;
+
+	reg0 = snd_soc_component_read(component, WCD937X_ANA_MBHC_BTN5);
+	reg1 = snd_soc_component_read(component, WCD937X_ANA_MBHC_BTN6);
+	reg2 = snd_soc_component_read(component, WCD937X_ANA_MBHC_BTN7);
+	reg3 = snd_soc_component_read(component, WCD937X_MBHC_CTL_CLK);
+	reg4 = snd_soc_component_read(component, WCD937X_MBHC_NEW_ZDET_ANA_CTL);
+
+	if (snd_soc_component_read(component, WCD937X_ANA_MBHC_ELECT) & 0x80) {
+		is_fsm_disable = true;
+		regmap_update_bits(wcd937x->regmap,
+				   WCD937X_ANA_MBHC_ELECT, 0x80, 0x00);
+	}
+
+	/* For NO-jack, disable L_DET_EN before Z-det measurements */
+	if (wcd937x->mbhc_cfg.hphl_swh)
+		regmap_update_bits(wcd937x->regmap,
+				   WCD937X_ANA_MBHC_MECH, 0x80, 0x00);
+
+	/* Turn off 100k pull down on HPHL */
+	regmap_update_bits(wcd937x->regmap,
+			   WCD937X_ANA_MBHC_MECH, 0x01, 0x00);
+
+	/* Disable surge protection before impedance detection.
+	 * This is done to give correct value for high impedance.
+	 */
+	regmap_update_bits(wcd937x->regmap,
+			   WCD937X_HPH_SURGE_HPHLR_SURGE_EN, 0xC0, 0x00);
+	/* 1ms delay needed after disable surge protection */
+	usleep_range(1000, 1010);
+
+	/* First get impedance on Left */
+	d1 = d1_a[1];
+	zdet_param_ptr = &zdet_param[1];
+	wcd937x_mbhc_zdet_ramp(component, zdet_param_ptr, &z1l, NULL, d1);
+
+	if (!WCD937X_MBHC_IS_SECOND_RAMP_REQUIRED(z1l))
+		goto left_ch_impedance;
+
+	/* Second ramp for left ch */
+	if (z1l < WCD937X_ZDET_VAL_32) {
+		zdet_param_ptr = &zdet_param[0];
+		d1 = d1_a[0];
+	} else if ((z1l > WCD937X_ZDET_VAL_400) &&
+		  (z1l <= WCD937X_ZDET_VAL_1200)) {
+		zdet_param_ptr = &zdet_param[2];
+		d1 = d1_a[2];
+	} else if (z1l > WCD937X_ZDET_VAL_1200) {
+		zdet_param_ptr = &zdet_param[3];
+		d1 = d1_a[3];
+	}
+	wcd937x_mbhc_zdet_ramp(component, zdet_param_ptr, &z1l, NULL, d1);
+
+left_ch_impedance:
+	if (z1l == WCD937X_ZDET_FLOATING_IMPEDANCE ||
+	    z1l > WCD937X_ZDET_VAL_100K) {
+		*zl = WCD937X_ZDET_FLOATING_IMPEDANCE;
+		zdet_param_ptr = &zdet_param[1];
+		d1 = d1_a[1];
+	} else {
+		*zl = z1l / 1000;
+		wcd937x_wcd_mbhc_qfuse_cal(component, zl, 0);
+	}
+
+	/* Start of right impedance ramp and calculation */
+	wcd937x_mbhc_zdet_ramp(component, zdet_param_ptr, NULL, &z1r, d1);
+	if (WCD937X_MBHC_IS_SECOND_RAMP_REQUIRED(z1r)) {
+		if ((z1r > WCD937X_ZDET_VAL_1200 &&
+		     zdet_param_ptr->noff == 0x6) ||
+		     ((*zl) != WCD937X_ZDET_FLOATING_IMPEDANCE))
+			goto right_ch_impedance;
+		/* Second ramp for right ch */
+		if (z1r < WCD937X_ZDET_VAL_32) {
+			zdet_param_ptr = &zdet_param[0];
+			d1 = d1_a[0];
+		} else if ((z1r > WCD937X_ZDET_VAL_400) &&
+			(z1r <= WCD937X_ZDET_VAL_1200)) {
+			zdet_param_ptr = &zdet_param[2];
+			d1 = d1_a[2];
+		} else if (z1r > WCD937X_ZDET_VAL_1200) {
+			zdet_param_ptr = &zdet_param[3];
+			d1 = d1_a[3];
+		}
+		wcd937x_mbhc_zdet_ramp(component, zdet_param_ptr, NULL, &z1r, d1);
+	}
+right_ch_impedance:
+	if (z1r == WCD937X_ZDET_FLOATING_IMPEDANCE ||
+	    z1r > WCD937X_ZDET_VAL_100K) {
+		*zr = WCD937X_ZDET_FLOATING_IMPEDANCE;
+	} else {
+		*zr = z1r / 1000;
+		wcd937x_wcd_mbhc_qfuse_cal(component, zr, 1);
+	}
+
+	/* Mono/stereo detection */
+	if ((*zl == WCD937X_ZDET_FLOATING_IMPEDANCE) &&
+	    (*zr == WCD937X_ZDET_FLOATING_IMPEDANCE)) {
+		dev_err(component->dev,
+			"%s: plug type is invalid or extension cable\n",
+			__func__);
+		goto zdet_complete;
+	}
+	if ((*zl == WCD937X_ZDET_FLOATING_IMPEDANCE) ||
+	    (*zr == WCD937X_ZDET_FLOATING_IMPEDANCE) ||
+	    ((*zl < WCD_MONO_HS_MIN_THR) && (*zr > WCD_MONO_HS_MIN_THR)) ||
+	    ((*zl > WCD_MONO_HS_MIN_THR) && (*zr < WCD_MONO_HS_MIN_THR))) {
+		wcd_mbhc_set_hph_type(wcd937x->wcd_mbhc, WCD_MBHC_HPH_MONO);
+		goto zdet_complete;
+	}
+	snd_soc_component_write_field(component, WCD937X_HPH_R_ATEST,
+				      WCD937X_HPHPA_GND_OVR_MASK, 1);
+	snd_soc_component_write_field(component, WCD937X_HPH_PA_CTL2,
+				      WCD937X_HPHPA_GND_R_MASK, 1);
+	if (*zl < (WCD937X_ZDET_VAL_32 / 1000))
+		wcd937x_mbhc_zdet_ramp(component, &zdet_param[0], &z1ls, NULL, d1);
+	else
+		wcd937x_mbhc_zdet_ramp(component, &zdet_param[1], &z1ls, NULL, d1);
+	snd_soc_component_write_field(component, WCD937X_HPH_PA_CTL2,
+				      WCD937X_HPHPA_GND_R_MASK, 0);
+	snd_soc_component_write_field(component, WCD937X_HPH_R_ATEST,
+				      WCD937X_HPHPA_GND_OVR_MASK, 0);
+	z1ls /= 1000;
+	wcd937x_wcd_mbhc_qfuse_cal(component, &z1ls, 0);
+	/* Parallel of left Z and 9 ohm pull down resistor */
+	zMono = ((*zl) * 9) / ((*zl) + 9);
+	z_diff1 = (z1ls > zMono) ? (z1ls - zMono) : (zMono - z1ls);
+	z_diff2 = ((*zl) > z1ls) ? ((*zl) - z1ls) : (z1ls - (*zl));
+	if ((z_diff1 * (*zl + z1ls)) > (z_diff2 * (z1ls + zMono)))
+		wcd_mbhc_set_hph_type(wcd937x->wcd_mbhc, WCD_MBHC_HPH_STEREO);
+	else
+		wcd_mbhc_set_hph_type(wcd937x->wcd_mbhc, WCD_MBHC_HPH_MONO);
+
+	/* Enable surge protection again after impedance detection */
+	regmap_update_bits(wcd937x->regmap,
+			   WCD937X_HPH_SURGE_HPHLR_SURGE_EN, 0xC0, 0xC0);
+zdet_complete:
+	snd_soc_component_write(component, WCD937X_ANA_MBHC_BTN5, reg0);
+	snd_soc_component_write(component, WCD937X_ANA_MBHC_BTN6, reg1);
+	snd_soc_component_write(component, WCD937X_ANA_MBHC_BTN7, reg2);
+	/* Turn on 100k pull down on HPHL */
+	regmap_update_bits(wcd937x->regmap,
+			   WCD937X_ANA_MBHC_MECH, 0x01, 0x01);
+
+	/* For NO-jack, re-enable L_DET_EN after Z-det measurements */
+	if (wcd937x->mbhc_cfg.hphl_swh)
+		regmap_update_bits(wcd937x->regmap,
+				   WCD937X_ANA_MBHC_MECH, 0x80, 0x80);
+
+	snd_soc_component_write(component, WCD937X_MBHC_NEW_ZDET_ANA_CTL, reg4);
+	snd_soc_component_write(component, WCD937X_MBHC_CTL_CLK, reg3);
+	if (is_fsm_disable)
+		regmap_update_bits(wcd937x->regmap,
+				   WCD937X_ANA_MBHC_ELECT, 0x80, 0x80);
+}
+
+static void wcd937x_mbhc_gnd_det_ctrl(struct snd_soc_component *component,
+				      bool enable)
+{
+	if (enable) {
+		snd_soc_component_write_field(component, WCD937X_ANA_MBHC_MECH,
+					      WCD937X_MBHC_HSG_PULLUP_COMP_EN, 1);
+		snd_soc_component_write_field(component, WCD937X_ANA_MBHC_MECH,
+					      WCD937X_MBHC_GND_DET_EN_MASK, 1);
+	} else {
+		snd_soc_component_write_field(component, WCD937X_ANA_MBHC_MECH,
+					      WCD937X_MBHC_GND_DET_EN_MASK, 0);
+		snd_soc_component_write_field(component, WCD937X_ANA_MBHC_MECH,
+					      WCD937X_MBHC_HSG_PULLUP_COMP_EN, 0);
+	}
+}
+
+static void wcd937x_mbhc_hph_pull_down_ctrl(struct snd_soc_component *component,
+					    bool enable)
+{
+	snd_soc_component_write_field(component, WCD937X_HPH_PA_CTL2,
+				      WCD937X_HPHPA_GND_R_MASK, enable);
+	snd_soc_component_write_field(component, WCD937X_HPH_PA_CTL2,
+				      WCD937X_HPHPA_GND_L_MASK, enable);
+}
+
+static void wcd937x_mbhc_moisture_config(struct snd_soc_component *component)
+{
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+
+	if (wcd937x->mbhc_cfg.moist_rref == R_OFF) {
+		snd_soc_component_write_field(component, WCD937X_MBHC_NEW_CTL_2,
+					      WCD937X_M_RTH_CTL_MASK, R_OFF);
+		return;
+	}
+
+	/* Do not enable moisture detection if jack type is NC */
+	if (!wcd937x->mbhc_cfg.hphl_swh) {
+		dev_err(component->dev, "%s: disable moisture detection for NC\n",
+			__func__);
+		snd_soc_component_write_field(component, WCD937X_MBHC_NEW_CTL_2,
+					      WCD937X_M_RTH_CTL_MASK, R_OFF);
+		return;
+	}
+
+	snd_soc_component_write_field(component, WCD937X_MBHC_NEW_CTL_2,
+				      WCD937X_M_RTH_CTL_MASK, wcd937x->mbhc_cfg.moist_rref);
+}
+
+static void wcd937x_mbhc_moisture_detect_en(struct snd_soc_component *component, bool enable)
+{
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+
+	if (enable)
+		snd_soc_component_write_field(component, WCD937X_MBHC_NEW_CTL_2,
+					      WCD937X_M_RTH_CTL_MASK, wcd937x->mbhc_cfg.moist_rref);
+	else
+		snd_soc_component_write_field(component, WCD937X_MBHC_NEW_CTL_2,
+					      WCD937X_M_RTH_CTL_MASK, R_OFF);
+}
+
+static bool wcd937x_mbhc_get_moisture_status(struct snd_soc_component *component)
+{
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	bool ret = false;
+
+	if (wcd937x->mbhc_cfg.moist_rref == R_OFF) {
+		snd_soc_component_write_field(component, WCD937X_MBHC_NEW_CTL_2,
+					      WCD937X_M_RTH_CTL_MASK, R_OFF);
+		goto done;
+	}
+
+	/* Do not enable moisture detection if jack type is NC */
+	if (!wcd937x->mbhc_cfg.hphl_swh) {
+		dev_err(component->dev, "%s: disable moisture detection for NC\n",
+			__func__);
+		snd_soc_component_write_field(component, WCD937X_MBHC_NEW_CTL_2,
+					      WCD937X_M_RTH_CTL_MASK, R_OFF);
+		goto done;
+	}
+
+	/*
+	 * If moisture_en is already enabled, then skip to plug type
+	 * detection.
+	 */
+	if (snd_soc_component_read_field(component, WCD937X_MBHC_NEW_CTL_2, WCD937X_M_RTH_CTL_MASK))
+		goto done;
+
+	wcd937x_mbhc_moisture_detect_en(component, true);
+	/* Read moisture comparator status */
+	ret = ((snd_soc_component_read(component, WCD937X_MBHC_NEW_FSM_STATUS)
+				       & 0x20) ? 0 : 1);
+done:
+	return ret;
+}
+
+static void wcd937x_mbhc_moisture_polling_ctrl(struct snd_soc_component *component,
+					       bool enable)
+{
+	snd_soc_component_write_field(component,
+				      WCD937X_MBHC_NEW_INT_MOISTURE_DET_POLLING_CTRL,
+				      WCD937X_MOISTURE_EN_POLLING_MASK, enable);
+}
+
+static const struct wcd_mbhc_cb mbhc_cb = {
+	.clk_setup = wcd937x_mbhc_clk_setup,
+	.mbhc_bias = wcd937x_mbhc_mbhc_bias_control,
+	.set_btn_thr = wcd937x_mbhc_program_btn_thr,
+	.micbias_enable_status = wcd937x_mbhc_micb_en_status,
+	.hph_pull_up_control_v2 = wcd937x_mbhc_hph_l_pull_up_control,
+	.mbhc_micbias_control = wcd937x_mbhc_request_micbias,
+	.mbhc_micb_ramp_control = wcd937x_mbhc_micb_ramp_control,
+	.mbhc_micb_ctrl_thr_mic = wcd937x_mbhc_micb_ctrl_threshold_mic,
+	.compute_impedance = wcd937x_wcd_mbhc_calc_impedance,
+	.mbhc_gnd_det_ctrl = wcd937x_mbhc_gnd_det_ctrl,
+	.hph_pull_down_ctrl = wcd937x_mbhc_hph_pull_down_ctrl,
+	.mbhc_moisture_config = wcd937x_mbhc_moisture_config,
+	.mbhc_get_moisture_status = wcd937x_mbhc_get_moisture_status,
+	.mbhc_moisture_polling_ctrl = wcd937x_mbhc_moisture_polling_ctrl,
+	.mbhc_moisture_detect_en = wcd937x_mbhc_moisture_detect_en,
+};
+
+static int wcd937x_get_hph_type(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = wcd_mbhc_get_hph_type(wcd937x->wcd_mbhc);
+
+	return 0;
+}
+
+static int wcd937x_hph_impedance_get(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	u32 zl, zr;
+	bool hphr;
+	struct soc_mixer_control *mc;
+	struct snd_soc_component *component =
+					snd_soc_kcontrol_component(kcontrol);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+
+	mc = (struct soc_mixer_control *)(kcontrol->private_value);
+	hphr = mc->shift;
+	wcd_mbhc_get_impedance(wcd937x->wcd_mbhc, &zl, &zr);
+	ucontrol->value.integer.value[0] = hphr ? zr : zl;
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new hph_type_detect_controls[] = {
+	SOC_SINGLE_EXT("HPH Type", 0, 0, WCD_MBHC_HPH_STEREO, 0,
+		       wcd937x_get_hph_type, NULL),
+};
+
+static const struct snd_kcontrol_new impedance_detect_controls[] = {
+	SOC_SINGLE_EXT("HPHL Impedance", 0, 0, INT_MAX, 0,
+		       wcd937x_hph_impedance_get, NULL),
+	SOC_SINGLE_EXT("HPHR Impedance", 0, 1, INT_MAX, 0,
+		       wcd937x_hph_impedance_get, NULL),
+};
+
+static int wcd937x_mbhc_init(struct snd_soc_component *component)
+{
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	struct wcd_mbhc_intr *intr_ids = &wcd937x->intr_ids;
+
+	intr_ids->mbhc_sw_intr = regmap_irq_get_virq(wcd937x->irq_chip,
+						     WCD937X_IRQ_MBHC_SW_DET);
+	intr_ids->mbhc_btn_press_intr = regmap_irq_get_virq(wcd937x->irq_chip,
+							    WCD937X_IRQ_MBHC_BUTTON_PRESS_DET);
+	intr_ids->mbhc_btn_release_intr = regmap_irq_get_virq(wcd937x->irq_chip,
+							      WCD937X_IRQ_MBHC_BUTTON_RELEASE_DET);
+	intr_ids->mbhc_hs_ins_intr = regmap_irq_get_virq(wcd937x->irq_chip,
+							 WCD937X_IRQ_MBHC_ELECT_INS_REM_LEG_DET);
+	intr_ids->mbhc_hs_rem_intr = regmap_irq_get_virq(wcd937x->irq_chip,
+							 WCD937X_IRQ_MBHC_ELECT_INS_REM_DET);
+	intr_ids->hph_left_ocp = regmap_irq_get_virq(wcd937x->irq_chip,
+						     WCD937X_IRQ_HPHL_OCP_INT);
+	intr_ids->hph_right_ocp = regmap_irq_get_virq(wcd937x->irq_chip,
+						      WCD937X_IRQ_HPHR_OCP_INT);
+
+	wcd937x->wcd_mbhc = wcd_mbhc_init(component, &mbhc_cb, intr_ids, wcd_mbhc_fields, true);
+	if (IS_ERR(wcd937x->wcd_mbhc))
+		return PTR_ERR(wcd937x->wcd_mbhc);
+
+	snd_soc_add_component_controls(component, impedance_detect_controls,
+				       ARRAY_SIZE(impedance_detect_controls));
+	snd_soc_add_component_controls(component, hph_type_detect_controls,
+				       ARRAY_SIZE(hph_type_detect_controls));
+
+	return 0;
+}
+
+static void wcd937x_mbhc_deinit(struct snd_soc_component *component)
+{
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+
+	wcd_mbhc_deinit(wcd937x->wcd_mbhc);
+}
+
+/* END MBHC */
+
+static const struct snd_kcontrol_new wcd937x_snd_controls[] = {
+	SOC_SINGLE_TLV("EAR_PA Volume", WCD937X_ANA_EAR_COMPANDER_CTL,
+		       2, 0x10, 0, ear_pa_gain),
+	SOC_ENUM_EXT("RX HPH Mode", rx_hph_mode_mux_enum,
+		     wcd937x_rx_hph_mode_get, wcd937x_rx_hph_mode_put),
+
+	SOC_SINGLE_EXT("HPHL_COMP Switch", SND_SOC_NOPM, 0, 1, 0,
+		       wcd937x_get_compander, wcd937x_set_compander),
+	SOC_SINGLE_EXT("HPHR_COMP Switch", SND_SOC_NOPM, 1, 1, 0,
+		       wcd937x_get_compander, wcd937x_set_compander),
+
+	SOC_SINGLE_TLV("HPHL Volume", WCD937X_HPH_L_EN, 0, 20, 1, line_gain),
+	SOC_SINGLE_TLV("HPHR Volume", WCD937X_HPH_R_EN, 0, 20, 1, line_gain),
+	SOC_SINGLE_TLV("ADC1 Volume", WCD937X_ANA_TX_CH1, 0, 20, 0, analog_gain),
+	SOC_SINGLE_TLV("ADC2 Volume", WCD937X_ANA_TX_CH2, 0, 20, 0, analog_gain),
+	SOC_SINGLE_TLV("ADC3 Volume", WCD937X_ANA_TX_CH3, 0, 20, 0, analog_gain),
+
+	SOC_SINGLE_EXT("HPHL Switch", WCD937X_HPH_L, 0, 1, 0,
+		       wcd937x_get_swr_port, wcd937x_set_swr_port),
+	SOC_SINGLE_EXT("HPHR Switch", WCD937X_HPH_R, 0, 1, 0,
+		       wcd937x_get_swr_port, wcd937x_set_swr_port),
+
+	SOC_SINGLE_EXT("ADC1 Switch", WCD937X_ADC1, 1, 1, 0,
+		       wcd937x_get_swr_port, wcd937x_set_swr_port),
+	SOC_SINGLE_EXT("ADC2 Switch", WCD937X_ADC2, 1, 1, 0,
+		       wcd937x_get_swr_port, wcd937x_set_swr_port),
+	SOC_SINGLE_EXT("ADC3 Switch", WCD937X_ADC3, 1, 1, 0,
+		       wcd937x_get_swr_port, wcd937x_set_swr_port),
+	SOC_SINGLE_EXT("DMIC0 Switch", WCD937X_DMIC0, 1, 1, 0,
+		       wcd937x_get_swr_port, wcd937x_set_swr_port),
+	SOC_SINGLE_EXT("DMIC1 Switch", WCD937X_DMIC1, 1, 1, 0,
+		       wcd937x_get_swr_port, wcd937x_set_swr_port),
+	SOC_SINGLE_EXT("MBHC Switch", WCD937X_MBHC, 1, 1, 0,
+		       wcd937x_get_swr_port, wcd937x_set_swr_port),
+	SOC_SINGLE_EXT("DMIC2 Switch", WCD937X_DMIC2, 1, 1, 0,
+		       wcd937x_get_swr_port, wcd937x_set_swr_port),
+	SOC_SINGLE_EXT("DMIC3 Switch", WCD937X_DMIC3, 1, 1, 0,
+		       wcd937x_get_swr_port, wcd937x_set_swr_port),
+	SOC_SINGLE_EXT("DMIC4 Switch", WCD937X_DMIC4, 1, 1, 0,
+		       wcd937x_get_swr_port, wcd937x_set_swr_port),
+	SOC_SINGLE_EXT("DMIC5 Switch", WCD937X_DMIC5, 1, 1, 0,
+		       wcd937x_get_swr_port, wcd937x_set_swr_port),
+};
+
+static const struct snd_kcontrol_new adc1_switch[] = {
+	SOC_DAPM_SINGLE("Switch", SND_SOC_NOPM, 0, 1, 0)
+};
+
+static const struct snd_kcontrol_new adc2_switch[] = {
+	SOC_DAPM_SINGLE("Switch", SND_SOC_NOPM, 0, 1, 0)
+};
+
+static const struct snd_kcontrol_new adc3_switch[] = {
+	SOC_DAPM_SINGLE("Switch", SND_SOC_NOPM, 0, 1, 0)
+};
+
+static const struct snd_kcontrol_new dmic1_switch[] = {
+	SOC_DAPM_SINGLE("Switch", SND_SOC_NOPM, 0, 1, 0)
+};
+
+static const struct snd_kcontrol_new dmic2_switch[] = {
+	SOC_DAPM_SINGLE("Switch", SND_SOC_NOPM, 0, 1, 0)
+};
+
+static const struct snd_kcontrol_new dmic3_switch[] = {
+	SOC_DAPM_SINGLE("Switch", SND_SOC_NOPM, 0, 1, 0)
+};
+
+static const struct snd_kcontrol_new dmic4_switch[] = {
+	SOC_DAPM_SINGLE("Switch", SND_SOC_NOPM, 0, 1, 0)
+};
+
+static const struct snd_kcontrol_new dmic5_switch[] = {
+	SOC_DAPM_SINGLE("Switch", SND_SOC_NOPM, 0, 1, 0)
+};
+
+static const struct snd_kcontrol_new dmic6_switch[] = {
+	SOC_DAPM_SINGLE("Switch", SND_SOC_NOPM, 0, 1, 0)
+};
+
+static const struct snd_kcontrol_new ear_rdac_switch[] = {
+	SOC_DAPM_SINGLE("Switch", SND_SOC_NOPM, 0, 1, 0)
+};
+
+static const struct snd_kcontrol_new aux_rdac_switch[] = {
+	SOC_DAPM_SINGLE("Switch", SND_SOC_NOPM, 0, 1, 0)
+};
+
+static const struct snd_kcontrol_new hphl_rdac_switch[] = {
+	SOC_DAPM_SINGLE("Switch", SND_SOC_NOPM, 0, 1, 0)
+};
+
+static const struct snd_kcontrol_new hphr_rdac_switch[] = {
+	SOC_DAPM_SINGLE("Switch", SND_SOC_NOPM, 0, 1, 0)
+};
+
+static const char * const adc2_mux_text[] = {
+	"INP2", "INP3"
+};
+
+static const char * const rdac3_mux_text[] = {
+	"RX1", "RX3"
+};
+
+static const struct soc_enum adc2_enum =
+	SOC_ENUM_SINGLE(WCD937X_TX_NEW_TX_CH2_SEL, 7,
+			ARRAY_SIZE(adc2_mux_text), adc2_mux_text);
+
+static const struct soc_enum rdac3_enum =
+	SOC_ENUM_SINGLE(WCD937X_DIGITAL_CDC_EAR_PATH_CTL, 0,
+			ARRAY_SIZE(rdac3_mux_text), rdac3_mux_text);
+
+static const struct snd_kcontrol_new tx_adc2_mux = SOC_DAPM_ENUM("ADC2 MUX Mux", adc2_enum);
+
+static const struct snd_kcontrol_new rx_rdac3_mux = SOC_DAPM_ENUM("RDAC3_MUX Mux", rdac3_enum);
+
+static const struct snd_soc_dapm_widget wcd937x_dapm_widgets[] = {
+	/* Input widgets */
+	SND_SOC_DAPM_INPUT("AMIC1"),
+	SND_SOC_DAPM_INPUT("AMIC2"),
+	SND_SOC_DAPM_INPUT("AMIC3"),
+	SND_SOC_DAPM_INPUT("IN1_HPHL"),
+	SND_SOC_DAPM_INPUT("IN2_HPHR"),
+	SND_SOC_DAPM_INPUT("IN3_AUX"),
+
+	/* TX widgets */
+	SND_SOC_DAPM_ADC_E("ADC1", NULL, SND_SOC_NOPM, 0, 0,
+			   wcd937x_codec_enable_adc,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_ADC_E("ADC2", NULL, SND_SOC_NOPM, 1, 0,
+			   wcd937x_codec_enable_adc,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MIXER_E("ADC1 REQ", SND_SOC_NOPM, 0, 0,
+			     NULL, 0, wcd937x_enable_req,
+			     SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_MIXER_E("ADC2 REQ", SND_SOC_NOPM, 0, 0,
+			     NULL, 0, wcd937x_enable_req,
+			     SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MUX("ADC2 MUX", SND_SOC_NOPM, 0, 0, &tx_adc2_mux),
+
+	/* TX mixers */
+	SND_SOC_DAPM_MIXER_E("ADC1_MIXER", SND_SOC_NOPM, 0, 0,
+			     adc1_switch, ARRAY_SIZE(adc1_switch),
+			     wcd937x_tx_swr_ctrl, SND_SOC_DAPM_PRE_PMU |
+			     SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_MIXER_E("ADC2_MIXER", SND_SOC_NOPM, 1, 0,
+			     adc2_switch, ARRAY_SIZE(adc2_switch),
+			     wcd937x_tx_swr_ctrl, SND_SOC_DAPM_PRE_PMU |
+			     SND_SOC_DAPM_POST_PMD),
+
+	/* MIC_BIAS widgets */
+	SND_SOC_DAPM_SUPPLY("MIC BIAS1", SND_SOC_NOPM, MIC_BIAS_1, 0,
+			    wcd937x_codec_enable_micbias,
+			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+			    SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_SUPPLY("MIC BIAS2", SND_SOC_NOPM, MIC_BIAS_2, 0,
+			    wcd937x_codec_enable_micbias,
+			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+			    SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_SUPPLY("MIC BIAS3", SND_SOC_NOPM, MIC_BIAS_3, 0,
+			    wcd937x_codec_enable_micbias,
+			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+			    SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_SUPPLY("VDD_BUCK", SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY_S("CLS_H_PORT", 1, SND_SOC_NOPM, 0, 0, NULL, 0),
+
+	/* RX widgets */
+	SND_SOC_DAPM_PGA_E("EAR PGA", WCD937X_ANA_EAR, 7, 0, NULL, 0,
+			   wcd937x_codec_enable_ear_pa,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+			   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_PGA_E("AUX PGA", WCD937X_AUX_AUXPA, 7, 0, NULL, 0,
+			   wcd937x_codec_enable_aux_pa,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+			   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_PGA_E("HPHL PGA", WCD937X_ANA_HPH, 7, 0, NULL, 0,
+			   wcd937x_codec_enable_hphl_pa,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+			   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_PGA_E("HPHR PGA", WCD937X_ANA_HPH, 6, 0, NULL, 0,
+			   wcd937x_codec_enable_hphr_pa,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+			   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_DAC_E("RDAC1", NULL, SND_SOC_NOPM, 0, 0,
+			   wcd937x_codec_hphl_dac_event,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+			   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_DAC_E("RDAC2", NULL, SND_SOC_NOPM, 0, 0,
+			   wcd937x_codec_hphr_dac_event,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+			   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_DAC_E("RDAC3", NULL, SND_SOC_NOPM, 0, 0,
+			   wcd937x_codec_ear_dac_event,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+			   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_DAC_E("RDAC4", NULL, SND_SOC_NOPM, 0, 0,
+			   wcd937x_codec_aux_dac_event,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+			   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MUX("RDAC3_MUX", SND_SOC_NOPM, 0, 0, &rx_rdac3_mux),
+
+	SND_SOC_DAPM_MIXER_E("RX1", SND_SOC_NOPM, 0, 0, NULL, 0,
+			     wcd937x_enable_rx1, SND_SOC_DAPM_PRE_PMU |
+			     SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_MIXER_E("RX2", SND_SOC_NOPM, 0, 0, NULL, 0,
+			     wcd937x_enable_rx2, SND_SOC_DAPM_PRE_PMU |
+			     SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_MIXER_E("RX3", SND_SOC_NOPM, 0, 0, NULL, 0,
+			     wcd937x_enable_rx3, SND_SOC_DAPM_PRE_PMU |
+			     SND_SOC_DAPM_POST_PMD),
+
+	/* RX mixer widgets*/
+	SND_SOC_DAPM_MIXER("EAR_RDAC", SND_SOC_NOPM, 0, 0,
+			   ear_rdac_switch, ARRAY_SIZE(ear_rdac_switch)),
+	SND_SOC_DAPM_MIXER("AUX_RDAC", SND_SOC_NOPM, 0, 0,
+			   aux_rdac_switch, ARRAY_SIZE(aux_rdac_switch)),
+	SND_SOC_DAPM_MIXER("HPHL_RDAC", SND_SOC_NOPM, 0, 0,
+			   hphl_rdac_switch, ARRAY_SIZE(hphl_rdac_switch)),
+	SND_SOC_DAPM_MIXER("HPHR_RDAC", SND_SOC_NOPM, 0, 0,
+			   hphr_rdac_switch, ARRAY_SIZE(hphr_rdac_switch)),
+
+	/* TX output widgets */
+	SND_SOC_DAPM_OUTPUT("ADC1_OUTPUT"),
+	SND_SOC_DAPM_OUTPUT("ADC2_OUTPUT"),
+	SND_SOC_DAPM_OUTPUT("ADC3_OUTPUT"),
+	SND_SOC_DAPM_OUTPUT("WCD_TX_OUTPUT"),
+
+	/* RX output widgets */
+	SND_SOC_DAPM_OUTPUT("EAR"),
+	SND_SOC_DAPM_OUTPUT("AUX"),
+	SND_SOC_DAPM_OUTPUT("HPHL"),
+	SND_SOC_DAPM_OUTPUT("HPHR"),
+
+	/* MIC_BIAS pull up widgets */
+	SND_SOC_DAPM_SUPPLY("VA MIC BIAS1", SND_SOC_NOPM, MIC_BIAS_1, 0,
+			    wcd937x_codec_enable_micbias_pullup,
+			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+			    SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_SUPPLY("VA MIC BIAS2", SND_SOC_NOPM, MIC_BIAS_2, 0,
+			    wcd937x_codec_enable_micbias_pullup,
+			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+			    SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_SUPPLY("VA MIC BIAS3", SND_SOC_NOPM, MIC_BIAS_3, 0,
+			    wcd937x_codec_enable_micbias_pullup,
+			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+			    SND_SOC_DAPM_POST_PMD),
+};
+
+static const struct snd_soc_dapm_widget wcd9375_dapm_widgets[] = {
+	/* Input widgets */
+	SND_SOC_DAPM_INPUT("AMIC4"),
+
+	/* TX widgets */
+	SND_SOC_DAPM_ADC_E("ADC3", NULL, SND_SOC_NOPM, 2, 0,
+			   wcd937x_codec_enable_adc,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MIXER_E("ADC3 REQ", SND_SOC_NOPM, 0, 0,
+			     NULL, 0, wcd937x_enable_req,
+			     SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_ADC_E("DMIC1", NULL, SND_SOC_NOPM, 0, 0,
+			   wcd937x_codec_enable_dmic,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_ADC_E("DMIC2", NULL, SND_SOC_NOPM, 1, 0,
+			   wcd937x_codec_enable_dmic,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_ADC_E("DMIC3", NULL, SND_SOC_NOPM, 2, 0,
+			   wcd937x_codec_enable_dmic,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_ADC_E("DMIC4", NULL, SND_SOC_NOPM, 3, 0,
+			   wcd937x_codec_enable_dmic,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_ADC_E("DMIC5", NULL, SND_SOC_NOPM, 4, 0,
+			   wcd937x_codec_enable_dmic,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_ADC_E("DMIC6", NULL, SND_SOC_NOPM, 5, 0,
+			   wcd937x_codec_enable_dmic,
+			   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	/* TX mixer widgets */
+	SND_SOC_DAPM_MIXER_E("DMIC1_MIXER", SND_SOC_NOPM, 0,
+			     0, dmic1_switch, ARRAY_SIZE(dmic1_switch),
+			     wcd937x_tx_swr_ctrl, SND_SOC_DAPM_PRE_PMU |
+			     SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_MIXER_E("DMIC2_MIXER", SND_SOC_NOPM, 1,
+			     0, dmic2_switch, ARRAY_SIZE(dmic2_switch),
+			     wcd937x_tx_swr_ctrl, SND_SOC_DAPM_PRE_PMU |
+			     SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_MIXER_E("DMIC3_MIXER", SND_SOC_NOPM, 2,
+			     0, dmic3_switch, ARRAY_SIZE(dmic3_switch),
+			     wcd937x_tx_swr_ctrl, SND_SOC_DAPM_PRE_PMU |
+			     SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_MIXER_E("DMIC4_MIXER", SND_SOC_NOPM, 3,
+			     0, dmic4_switch, ARRAY_SIZE(dmic4_switch),
+			     wcd937x_tx_swr_ctrl, SND_SOC_DAPM_PRE_PMU |
+			     SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_MIXER_E("DMIC5_MIXER", SND_SOC_NOPM, 4,
+			     0, dmic5_switch, ARRAY_SIZE(dmic5_switch),
+			     wcd937x_tx_swr_ctrl, SND_SOC_DAPM_PRE_PMU |
+			     SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_MIXER_E("DMIC6_MIXER", SND_SOC_NOPM, 5,
+			     0, dmic6_switch, ARRAY_SIZE(dmic6_switch),
+			     wcd937x_tx_swr_ctrl, SND_SOC_DAPM_PRE_PMU |
+			     SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_MIXER_E("ADC3_MIXER", SND_SOC_NOPM, 2, 0, adc3_switch,
+			     ARRAY_SIZE(adc3_switch), wcd937x_tx_swr_ctrl,
+			     SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+
+	/* Output widgets */
+	SND_SOC_DAPM_OUTPUT("DMIC1_OUTPUT"),
+	SND_SOC_DAPM_OUTPUT("DMIC2_OUTPUT"),
+	SND_SOC_DAPM_OUTPUT("DMIC3_OUTPUT"),
+	SND_SOC_DAPM_OUTPUT("DMIC4_OUTPUT"),
+	SND_SOC_DAPM_OUTPUT("DMIC5_OUTPUT"),
+	SND_SOC_DAPM_OUTPUT("DMIC6_OUTPUT"),
+};
+
+static const struct snd_soc_dapm_route wcd937x_audio_map[] = {
+	{ "ADC1_OUTPUT", NULL, "ADC1_MIXER" },
+	{ "ADC1_MIXER", "Switch", "ADC1 REQ" },
+	{ "ADC1 REQ", NULL, "ADC1" },
+	{ "ADC1", NULL, "AMIC1" },
+
+	{ "ADC2_OUTPUT", NULL, "ADC2_MIXER" },
+	{ "ADC2_MIXER", "Switch", "ADC2 REQ" },
+	{ "ADC2 REQ", NULL, "ADC2" },
+	{ "ADC2", NULL, "ADC2 MUX" },
+	{ "ADC2 MUX", "INP3", "AMIC3" },
+	{ "ADC2 MUX", "INP2", "AMIC2" },
+
+	{ "IN1_HPHL", NULL, "VDD_BUCK" },
+	{ "IN1_HPHL", NULL, "CLS_H_PORT" },
+	{ "RX1", NULL, "IN1_HPHL" },
+	{ "RDAC1", NULL, "RX1" },
+	{ "HPHL_RDAC", "Switch", "RDAC1" },
+	{ "HPHL PGA", NULL, "HPHL_RDAC" },
+	{ "HPHL", NULL, "HPHL PGA" },
+
+	{ "IN2_HPHR", NULL, "VDD_BUCK" },
+	{ "IN2_HPHR", NULL, "CLS_H_PORT" },
+	{ "RX2", NULL, "IN2_HPHR" },
+	{ "RDAC2", NULL, "RX2" },
+	{ "HPHR_RDAC", "Switch", "RDAC2" },
+	{ "HPHR PGA", NULL, "HPHR_RDAC" },
+	{ "HPHR", NULL, "HPHR PGA" },
+
+	{ "IN3_AUX", NULL, "VDD_BUCK" },
+	{ "IN3_AUX", NULL, "CLS_H_PORT" },
+	{ "RX3", NULL, "IN3_AUX" },
+	{ "RDAC4", NULL, "RX3" },
+	{ "AUX_RDAC", "Switch", "RDAC4" },
+	{ "AUX PGA", NULL, "AUX_RDAC" },
+	{ "AUX", NULL, "AUX PGA" },
+
+	{ "RDAC3_MUX", "RX3", "RX3" },
+	{ "RDAC3_MUX", "RX1", "RX1" },
+	{ "RDAC3", NULL, "RDAC3_MUX" },
+	{ "EAR_RDAC", "Switch", "RDAC3" },
+	{ "EAR PGA", NULL, "EAR_RDAC" },
+	{ "EAR", NULL, "EAR PGA" },
+};
+
+static const struct snd_soc_dapm_route wcd9375_audio_map[] = {
+	{ "ADC3_OUTPUT", NULL, "ADC3_MIXER" },
+	{ "ADC3_OUTPUT", NULL, "ADC3_MIXER" },
+	{ "ADC3_MIXER", "Switch", "ADC3 REQ" },
+	{ "ADC3 REQ", NULL, "ADC3" },
+	{ "ADC3", NULL, "AMIC4" },
+
+	{ "DMIC1_OUTPUT", NULL, "DMIC1_MIXER" },
+	{ "DMIC1_MIXER", "Switch", "DMIC1" },
+
+	{ "DMIC2_OUTPUT", NULL, "DMIC2_MIXER" },
+	{ "DMIC2_MIXER", "Switch", "DMIC2" },
+
+	{ "DMIC3_OUTPUT", NULL, "DMIC3_MIXER" },
+	{ "DMIC3_MIXER", "Switch", "DMIC3" },
+
+	{ "DMIC4_OUTPUT", NULL, "DMIC4_MIXER" },
+	{ "DMIC4_MIXER", "Switch", "DMIC4" },
+
+	{ "DMIC5_OUTPUT", NULL, "DMIC5_MIXER" },
+	{ "DMIC5_MIXER", "Switch", "DMIC5" },
+
+	{ "DMIC6_OUTPUT", NULL, "DMIC6_MIXER" },
+	{ "DMIC6_MIXER", "Switch", "DMIC6" },
+};
+
+static int wcd937x_set_micbias_data(struct wcd937x_priv *wcd937x)
+{
+	int vout_ctl[3];
+
+	/* Set micbias voltage */
+	vout_ctl[0] = wcd937x_get_micb_vout_ctl_val(wcd937x->micb1_mv);
+	vout_ctl[1] = wcd937x_get_micb_vout_ctl_val(wcd937x->micb2_mv);
+	vout_ctl[2] = wcd937x_get_micb_vout_ctl_val(wcd937x->micb3_mv);
+	if ((vout_ctl[0] | vout_ctl[1] | vout_ctl[2]) < 0)
+		return -EINVAL;
+
+	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB1, WCD937X_ANA_MICB_VOUT, vout_ctl[0]);
+	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB2, WCD937X_ANA_MICB_VOUT, vout_ctl[1]);
+	regmap_update_bits(wcd937x->regmap, WCD937X_ANA_MICB3, WCD937X_ANA_MICB_VOUT, vout_ctl[2]);
+
+	return 0;
+}
+
+static irqreturn_t wcd937x_wd_handle_irq(int irq, void *data)
+{
+	return IRQ_HANDLED;
+}
+
+static const struct irq_chip wcd_irq_chip = {
+	.name = "WCD937x",
+};
+
+static int wcd_irq_chip_map(struct irq_domain *irqd, unsigned int virq,
+			    irq_hw_number_t hw)
+{
+	irq_set_chip_and_handler(virq, &wcd_irq_chip, handle_simple_irq);
+	irq_set_nested_thread(virq, 1);
+	irq_set_noprobe(virq);
+
+	return 0;
+}
+
+static const struct irq_domain_ops wcd_domain_ops = {
+	.map = wcd_irq_chip_map,
+};
+
+static int wcd937x_irq_init(struct wcd937x_priv *wcd, struct device *dev)
+{
+	wcd->virq = irq_domain_add_linear(NULL, 1, &wcd_domain_ops, NULL);
+	if (!(wcd->virq)) {
+		dev_err(dev, "%s: Failed to add IRQ domain\n", __func__);
+		return -EINVAL;
+	}
+
+	return devm_regmap_add_irq_chip(dev, wcd->regmap,
+					irq_create_mapping(wcd->virq, 0),
+					IRQF_ONESHOT, 0, &wcd937x_regmap_irq_chip,
+					&wcd->irq_chip);
+}
+
+static int wcd937x_soc_codec_probe(struct snd_soc_component *component)
+{
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+	struct sdw_slave *tx_sdw_dev = wcd937x->tx_sdw_dev;
+	struct device *dev = component->dev;
+	unsigned long time_left;
+	int i, ret;
+	u32 chipid;
+
+	time_left = wait_for_completion_timeout(&tx_sdw_dev->initialization_complete,
+						msecs_to_jiffies(5000));
+	if (!time_left) {
+		dev_err(dev, "soundwire device init timeout\n");
+		return -ETIMEDOUT;
+	}
+
+	snd_soc_component_init_regmap(component, wcd937x->regmap);
+	ret = pm_runtime_resume_and_get(dev);
+	if (ret < 0)
+		return ret;
+
+	chipid = (snd_soc_component_read(component,
+					 WCD937X_DIGITAL_EFUSE_REG_0) & 0x1e) >> 1;
+	if (chipid != CHIPID_WCD9370 && chipid != CHIPID_WCD9375) {
+		dev_err(dev, "Got unknown chip id: 0x%x\n", chipid);
+		pm_runtime_put(dev);
+		return -EINVAL;
+	}
+
+	wcd937x->clsh_info = wcd_clsh_ctrl_alloc(component, WCD937X);
+	if (IS_ERR(wcd937x->clsh_info)) {
+		pm_runtime_put(dev);
+		return PTR_ERR(wcd937x->clsh_info);
+	}
+
+	wcd937x_io_init(wcd937x->regmap);
+	/* Set all interrupts as edge triggered */
+	for (i = 0; i < wcd937x_regmap_irq_chip.num_regs; i++)
+		regmap_write(wcd937x->regmap, (WCD937X_DIGITAL_INTR_LEVEL_0 + i), 0);
+
+	pm_runtime_put(dev);
+
+	wcd937x->hphr_pdm_wd_int = regmap_irq_get_virq(wcd937x->irq_chip,
+						       WCD937X_IRQ_HPHR_PDM_WD_INT);
+	wcd937x->hphl_pdm_wd_int = regmap_irq_get_virq(wcd937x->irq_chip,
+						       WCD937X_IRQ_HPHL_PDM_WD_INT);
+	wcd937x->aux_pdm_wd_int = regmap_irq_get_virq(wcd937x->irq_chip,
+						      WCD937X_IRQ_AUX_PDM_WD_INT);
+
+	/* Request for watchdog interrupt */
+	ret = devm_request_threaded_irq(dev, wcd937x->hphr_pdm_wd_int, NULL, wcd937x_wd_handle_irq,
+					IRQF_ONESHOT | IRQF_TRIGGER_RISING,
+					"HPHR PDM WDOG INT", wcd937x);
+	if (ret)
+		dev_err(dev, "Failed to request HPHR watchdog interrupt (%d)\n", ret);
+
+	ret = devm_request_threaded_irq(dev, wcd937x->hphl_pdm_wd_int, NULL, wcd937x_wd_handle_irq,
+					IRQF_ONESHOT | IRQF_TRIGGER_RISING,
+					"HPHL PDM WDOG INT", wcd937x);
+	if (ret)
+		dev_err(dev, "Failed to request HPHL watchdog interrupt (%d)\n", ret);
+
+	ret = devm_request_threaded_irq(dev, wcd937x->aux_pdm_wd_int, NULL, wcd937x_wd_handle_irq,
+					IRQF_ONESHOT | IRQF_TRIGGER_RISING,
+					"AUX PDM WDOG INT", wcd937x);
+	if (ret)
+		dev_err(dev, "Failed to request Aux watchdog interrupt (%d)\n", ret);
+
+	/* Disable watchdog interrupt for HPH and AUX */
+	disable_irq_nosync(wcd937x->hphr_pdm_wd_int);
+	disable_irq_nosync(wcd937x->hphl_pdm_wd_int);
+	disable_irq_nosync(wcd937x->aux_pdm_wd_int);
+
+	if (chipid == CHIPID_WCD9375) {
+		ret = snd_soc_dapm_new_controls(dapm, wcd9375_dapm_widgets,
+						ARRAY_SIZE(wcd9375_dapm_widgets));
+		if (ret < 0) {
+			dev_err(component->dev, "Failed to add snd_ctls\n");
+			return ret;
+		}
+
+		ret = snd_soc_dapm_add_routes(dapm, wcd9375_audio_map,
+					      ARRAY_SIZE(wcd9375_audio_map));
+		if (ret < 0) {
+			dev_err(component->dev, "Failed to add routes\n");
+			return ret;
+		}
+	}
+
+	ret = wcd937x_mbhc_init(component);
+	if (ret)
+		dev_err(component->dev, "mbhc initialization failed\n");
+
+	return ret;
+}
+
+static void wcd937x_soc_codec_remove(struct snd_soc_component *component)
+{
+	struct wcd937x_priv *wcd937x = snd_soc_component_get_drvdata(component);
+
+	wcd937x_mbhc_deinit(component);
+	free_irq(wcd937x->aux_pdm_wd_int, wcd937x);
+	free_irq(wcd937x->hphl_pdm_wd_int, wcd937x);
+	free_irq(wcd937x->hphr_pdm_wd_int, wcd937x);
+
+	wcd_clsh_ctrl_free(wcd937x->clsh_info);
+}
+
+static int wcd937x_codec_set_jack(struct snd_soc_component *comp,
+				  struct snd_soc_jack *jack, void *data)
+{
+	struct wcd937x_priv *wcd = dev_get_drvdata(comp->dev);
+	int ret = 0;
+
+	if (jack)
+		ret = wcd_mbhc_start(wcd->wcd_mbhc, &wcd->mbhc_cfg, jack);
+	else
+		wcd_mbhc_stop(wcd->wcd_mbhc);
+
+	return ret;
+}
+
+static const struct snd_soc_component_driver soc_codec_dev_wcd937x = {
+	.name = "wcd937x_codec",
+	.probe = wcd937x_soc_codec_probe,
+	.remove = wcd937x_soc_codec_remove,
+	.controls = wcd937x_snd_controls,
+	.num_controls = ARRAY_SIZE(wcd937x_snd_controls),
+	.dapm_widgets = wcd937x_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(wcd937x_dapm_widgets),
+	.dapm_routes = wcd937x_audio_map,
+	.num_dapm_routes = ARRAY_SIZE(wcd937x_audio_map),
+	.set_jack = wcd937x_codec_set_jack,
+	.endianness = 1,
+};
+
+static void wcd937x_dt_parse_micbias_info(struct device *dev, struct wcd937x_priv *wcd)
+{
+	struct device_node *np = dev->of_node;
+	u32 prop_val = 0;
+	int ret = 0;
+
+	ret = of_property_read_u32(np, "qcom,micbias1-microvolt", &prop_val);
+	if (!ret)
+		wcd->micb1_mv = prop_val / 1000;
+	else
+		dev_warn(dev, "Micbias1 DT property not found\n");
+
+	ret = of_property_read_u32(np, "qcom,micbias2-microvolt", &prop_val);
+	if (!ret)
+		wcd->micb2_mv = prop_val / 1000;
+	else
+		dev_warn(dev, "Micbias2 DT property not found\n");
+
+	ret = of_property_read_u32(np, "qcom,micbias3-microvolt", &prop_val);
+	if (!ret)
+		wcd->micb3_mv = prop_val / 1000;
+	else
+		dev_warn(dev, "Micbias3 DT property not found\n");
+}
+
+static bool wcd937x_swap_gnd_mic(struct snd_soc_component *component, bool active)
+{
+	int value;
+	struct wcd937x_priv *wcd937x;
+
+	wcd937x = snd_soc_component_get_drvdata(component);
+
+	value = gpiod_get_value(wcd937x->us_euro_gpio);
+	gpiod_set_value(wcd937x->us_euro_gpio, !value);
+
+	return true;
+}
+
+static int wcd937x_codec_hw_params(struct snd_pcm_substream *substream,
+				   struct snd_pcm_hw_params *params,
+				   struct snd_soc_dai *dai)
+{
+	struct wcd937x_priv *wcd937x = dev_get_drvdata(dai->dev);
+	struct wcd937x_sdw_priv *wcd = wcd937x->sdw_priv[dai->id];
+
+	return wcd937x_sdw_hw_params(wcd, substream, params, dai);
+}
+
+static int wcd937x_codec_free(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *dai)
+{
+	struct wcd937x_priv *wcd937x = dev_get_drvdata(dai->dev);
+	struct wcd937x_sdw_priv *wcd = wcd937x->sdw_priv[dai->id];
+
+	return sdw_stream_remove_slave(wcd->sdev, wcd->sruntime);
+}
+
+static int wcd937x_codec_set_sdw_stream(struct snd_soc_dai *dai,
+					void *stream, int direction)
+{
+	struct wcd937x_priv *wcd937x = dev_get_drvdata(dai->dev);
+	struct wcd937x_sdw_priv *wcd = wcd937x->sdw_priv[dai->id];
+
+	wcd->sruntime = stream;
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops wcd937x_sdw_dai_ops = {
+	.hw_params = wcd937x_codec_hw_params,
+	.hw_free = wcd937x_codec_free,
+	.set_stream = wcd937x_codec_set_sdw_stream,
+};
+
+static struct snd_soc_dai_driver wcd937x_dais[] = {
+	[0] = {
+		.name = "wcd937x-sdw-rx",
+		.playback = {
+			.stream_name = "WCD AIF Playback",
+			.rates = WCD937X_RATES | WCD937X_FRAC_RATES,
+			.formats = WCD937X_FORMATS,
+			.rate_min = 8000,
+			.rate_max = 384000,
+			.channels_min = 1,
+			.channels_max = 4,
+		},
+		.ops = &wcd937x_sdw_dai_ops,
+	},
+	[1] = {
+		.name = "wcd937x-sdw-tx",
+		.capture = {
+			.stream_name = "WCD AIF Capture",
+			.rates = WCD937X_RATES,
+			.formats = WCD937X_FORMATS,
+			.rate_min = 8000,
+			.rate_max = 192000,
+			.channels_min = 1,
+			.channels_max = 4,
+		},
+		.ops = &wcd937x_sdw_dai_ops,
+	},
+};
+
+static int wcd937x_bind(struct device *dev)
+{
+	struct wcd937x_priv *wcd937x = dev_get_drvdata(dev);
+	int ret;
+
+	/* Give the SDW subdevices some more time to settle */
+	usleep_range(5000, 5010);
+
+	ret = component_bind_all(dev, wcd937x);
+	if (ret) {
+		dev_err(dev, "Slave bind failed, ret = %d\n", ret);
+		return ret;
+	}
+
+	wcd937x->rxdev = wcd937x_sdw_device_get(wcd937x->rxnode);
+	if (!wcd937x->rxdev) {
+		dev_err(dev, "could not find slave with matching of node\n");
+		return -EINVAL;
+	}
+
+	wcd937x->sdw_priv[AIF1_PB] = dev_get_drvdata(wcd937x->rxdev);
+	wcd937x->sdw_priv[AIF1_PB]->wcd937x = wcd937x;
+
+	wcd937x->txdev = wcd937x_sdw_device_get(wcd937x->txnode);
+	if (!wcd937x->txdev) {
+		dev_err(dev, "could not find txslave with matching of node\n");
+		return -EINVAL;
+	}
+
+	wcd937x->sdw_priv[AIF1_CAP] = dev_get_drvdata(wcd937x->txdev);
+	wcd937x->sdw_priv[AIF1_CAP]->wcd937x = wcd937x;
+	wcd937x->tx_sdw_dev = dev_to_sdw_dev(wcd937x->txdev);
+	if (!wcd937x->tx_sdw_dev) {
+		dev_err(dev, "could not get txslave with matching of dev\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * As TX is the main CSR reg interface, which should not be suspended first.
+	 * expicilty add the dependency link
+	 */
+	if (!device_link_add(wcd937x->rxdev, wcd937x->txdev,
+			     DL_FLAG_STATELESS | DL_FLAG_PM_RUNTIME)) {
+		dev_err(dev, "Could not devlink TX and RX\n");
+		return -EINVAL;
+	}
+
+	if (!device_link_add(dev, wcd937x->txdev,
+			     DL_FLAG_STATELESS | DL_FLAG_PM_RUNTIME)) {
+		dev_err(dev, "Could not devlink WCD and TX\n");
+		return -EINVAL;
+	}
+
+	if (!device_link_add(dev, wcd937x->rxdev,
+			     DL_FLAG_STATELESS | DL_FLAG_PM_RUNTIME)) {
+		dev_err(dev, "Could not devlink WCD and RX\n");
+		return -EINVAL;
+	}
+
+	wcd937x->regmap = dev_get_regmap(&wcd937x->tx_sdw_dev->dev, NULL);
+	if (!wcd937x->regmap) {
+		dev_err(dev, "could not get TX device regmap\n");
+		return -EINVAL;
+	}
+
+	ret = wcd937x_irq_init(wcd937x, dev);
+	if (ret) {
+		dev_err(dev, "IRQ init failed: %d\n", ret);
+		return ret;
+	}
+
+	wcd937x->sdw_priv[AIF1_PB]->slave_irq = wcd937x->virq;
+	wcd937x->sdw_priv[AIF1_CAP]->slave_irq = wcd937x->virq;
+
+	ret = wcd937x_set_micbias_data(wcd937x);
+	if (ret < 0) {
+		dev_err(dev, "Bad micbias pdata\n");
+		return ret;
+	}
+
+	ret = snd_soc_register_component(dev, &soc_codec_dev_wcd937x,
+					 wcd937x_dais, ARRAY_SIZE(wcd937x_dais));
+	if (ret)
+		dev_err(dev, "Codec registration failed\n");
+
+	return ret;
+}
+
+static void wcd937x_unbind(struct device *dev)
+{
+	struct wcd937x_priv *wcd937x = dev_get_drvdata(dev);
+
+	snd_soc_unregister_component(dev);
+	device_link_remove(dev, wcd937x->txdev);
+	device_link_remove(dev, wcd937x->rxdev);
+	device_link_remove(wcd937x->rxdev, wcd937x->txdev);
+	component_unbind_all(dev, wcd937x);
+	mutex_destroy(&wcd937x->micb_lock);
+}
+
+static const struct component_master_ops wcd937x_comp_ops = {
+	.bind = wcd937x_bind,
+	.unbind = wcd937x_unbind,
+};
+
+static int wcd937x_add_slave_components(struct wcd937x_priv *wcd937x,
+					struct device *dev,
+					struct component_match **matchptr)
+{
+	struct device_node *np = dev->of_node;
+
+	wcd937x->rxnode = of_parse_phandle(np, "qcom,rx-device", 0);
+	if (!wcd937x->rxnode) {
+		dev_err(dev, "Couldn't parse phandle to qcom,rx-device!\n");
+		return -ENODEV;
+	}
+	of_node_get(wcd937x->rxnode);
+	component_match_add_release(dev, matchptr, component_release_of,
+				    component_compare_of, wcd937x->rxnode);
+
+	wcd937x->txnode = of_parse_phandle(np, "qcom,tx-device", 0);
+	if (!wcd937x->txnode) {
+		dev_err(dev, "Couldn't parse phandle to qcom,tx-device\n");
+			return -ENODEV;
+	}
+	of_node_get(wcd937x->txnode);
+	component_match_add_release(dev, matchptr, component_release_of,
+				    component_compare_of, wcd937x->txnode);
+
+	return 0;
+}
+
+static int wcd937x_probe(struct platform_device *pdev)
+{
+	struct component_match *match = NULL;
+	struct device *dev = &pdev->dev;
+	struct wcd937x_priv *wcd937x;
+	struct wcd_mbhc_config *cfg;
+	int ret;
+
+	wcd937x = devm_kzalloc(dev, sizeof(*wcd937x), GFP_KERNEL);
+	if (!wcd937x)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, wcd937x);
+	mutex_init(&wcd937x->micb_lock);
+
+	wcd937x->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(wcd937x->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(wcd937x->reset_gpio),
+				     "failed to reset wcd gpio\n");
+
+	wcd937x->us_euro_gpio = devm_gpiod_get_optional(dev, "us-euro", GPIOD_OUT_LOW);
+	if (IS_ERR(wcd937x->us_euro_gpio))
+		return dev_err_probe(dev, PTR_ERR(wcd937x->us_euro_gpio),
+				"us-euro swap Control GPIO not found\n");
+
+	cfg = &wcd937x->mbhc_cfg;
+	cfg->swap_gnd_mic = wcd937x_swap_gnd_mic;
+
+	wcd937x->supplies[0].supply = "vdd-rxtx";
+	wcd937x->supplies[1].supply = "vdd-px";
+	wcd937x->supplies[2].supply = "vdd-mic-bias";
+	wcd937x->supplies[3].supply = "vdd-buck";
+
+	ret = devm_regulator_bulk_get(dev, WCD937X_MAX_BULK_SUPPLY, wcd937x->supplies);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get supplies\n");
+
+	ret = regulator_bulk_enable(WCD937X_MAX_BULK_SUPPLY, wcd937x->supplies);
+	if (ret) {
+		regulator_bulk_free(WCD937X_MAX_BULK_SUPPLY, wcd937x->supplies);
+		return dev_err_probe(dev, ret, "Failed to enable supplies\n");
+	}
+
+	wcd937x_dt_parse_micbias_info(dev, wcd937x);
+
+	cfg->mbhc_micbias = MIC_BIAS_2;
+	cfg->anc_micbias = MIC_BIAS_2;
+	cfg->v_hs_max = WCD_MBHC_HS_V_MAX;
+	cfg->num_btn = WCD937X_MBHC_MAX_BUTTONS;
+	cfg->micb_mv = wcd937x->micb2_mv;
+	cfg->linein_th = 5000;
+	cfg->hs_thr = 1700;
+	cfg->hph_thr = 50;
+
+	wcd_dt_parse_mbhc_data(dev, &wcd937x->mbhc_cfg);
+
+	ret = wcd937x_add_slave_components(wcd937x, dev, &match);
+	if (ret)
+		goto err_disable_regulators;
+
+	wcd937x_reset(wcd937x);
+
+	ret = component_master_add_with_match(dev, &wcd937x_comp_ops, match);
+	if (ret)
+		goto err_disable_regulators;
+
+	pm_runtime_set_autosuspend_delay(dev, 1000);
+	pm_runtime_use_autosuspend(dev);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+
+	return 0;
+
+err_disable_regulators:
+	regulator_bulk_disable(WCD937X_MAX_BULK_SUPPLY, wcd937x->supplies);
+	regulator_bulk_free(WCD937X_MAX_BULK_SUPPLY, wcd937x->supplies);
+
+	return ret;
+}
+
+static void wcd937x_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct wcd937x_priv *wcd937x = dev_get_drvdata(dev);
+
+	component_master_del(&pdev->dev, &wcd937x_comp_ops);
+
+	pm_runtime_disable(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_dont_use_autosuspend(dev);
+
+	regulator_bulk_disable(WCD937X_MAX_BULK_SUPPLY, wcd937x->supplies);
+	regulator_bulk_free(WCD937X_MAX_BULK_SUPPLY, wcd937x->supplies);
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id wcd937x_of_match[] = {
+	{ .compatible = "qcom,wcd9370-codec" },
+	{ .compatible = "qcom,wcd9375-codec" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, wcd937x_of_match);
+#endif
+
+static struct platform_driver wcd937x_codec_driver = {
+	.probe = wcd937x_probe,
+	.remove_new = wcd937x_remove,
+	.driver = {
+		.name = "wcd937x_codec",
+		.of_match_table = of_match_ptr(wcd937x_of_match),
+		.suppress_bind_attrs = true,
+	},
+};
+
+module_platform_driver(wcd937x_codec_driver);
+MODULE_DESCRIPTION("WCD937X Codec driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/wcd937x.h b/sound/soc/codecs/wcd937x.h
new file mode 100644
index 00000000000000..37bff16e88ddd5
--- /dev/null
+++ b/sound/soc/codecs/wcd937x.h
@@ -0,0 +1,624 @@
+/* SPDX-License-Identifier: GPL-2.0-only
+ * Copyright (c) 2023-2024 Qualcomm Innovation Center, Inc. All rights reserved.
+ */
+
+#ifndef _WCD937X_REGISTERS_H
+#define _WCD937X_REGISTERS_H
+
+#include <linux/soundwire/sdw.h>
+#include <linux/soundwire/sdw_type.h>
+
+#define WCD937X_BASE_ADDRESS			0x3000
+#define WCD937X_ANA_BIAS			0x3001
+#define WCD937X_ANA_RX_SUPPLIES			0x3008
+#define WCD937X_ANA_HPH				0x3009
+#define WCD937X_ANA_EAR				0x300A
+#define WCD937X_ANA_EAR_COMPANDER_CTL		0x300B
+#define WCD937X_EAR_GAIN_MASK			GENMASK(6, 2)
+#define WCD937X_ANA_TX_CH1			0x300E
+#define WCD937X_ANA_TX_CH2			0x300F
+#define WCD937X_ANA_TX_CH3			0x3010
+#define WCD937X_ANA_TX_CH3_HPF			0x3011
+#define WCD937X_ANA_MICB1_MICB2_DSP_EN_LOGIC	0x3012
+#define WCD937X_ANA_MICB3_DSP_EN_LOGIC		0x3013
+#define WCD937X_ANA_MBHC_MECH			0x3014
+#define WCD937X_MBHC_L_DET_EN_MASK		BIT(7)
+#define WCD937X_MBHC_L_DET_EN			BIT(7)
+#define WCD937X_MBHC_GND_DET_EN_MASK		BIT(6)
+#define WCD937X_MBHC_MECH_DETECT_TYPE_MASK	BIT(5)
+#define WCD937X_MBHC_MECH_DETECT_TYPE_INS	1
+#define WCD937X_MBHC_HPHL_PLUG_TYPE_MASK	BIT(4)
+#define WCD937X_MBHC_HPHL_PLUG_TYPE_NO		1
+#define WCD937X_MBHC_GND_PLUG_TYPE_MASK		BIT(3)
+#define WCD937X_MBHC_GND_PLUG_TYPE_NO		1
+#define WCD937X_MBHC_HSL_PULLUP_COMP_EN		BIT(2)
+#define WCD937X_MBHC_HSG_PULLUP_COMP_EN		BIT(1)
+#define WCD937X_MBHC_HPHL_100K_TO_GND_EN	BIT(0)
+#define WCD937X_ANA_MBHC_ELECT			0x3015
+#define WCD937X_ANA_MBHC_BD_ISRC_CTL_MASK	GENMASK(6, 4)
+#define WCD937X_ANA_MBHC_BD_ISRC_100UA		GENMASK(5, 4)
+#define WCD937X_ANA_MBHC_BD_ISRC_OFF		0
+#define WCD937X_ANA_MBHC_BIAS_EN_MASK		BIT(0)
+#define WCD937X_ANA_MBHC_BIAS_EN		BIT(0)
+#define WCD937X_ANA_MBHC_ZDET			0x3016
+#define WCD937X_ANA_MBHC_RESULT_1		0x3017
+#define WCD937X_ANA_MBHC_RESULT_2		0x3018
+#define WCD937X_ANA_MBHC_RESULT_3		0x3019
+#define WCD937X_MBHC_BTN_RESULT_MASK		GENMASK(2, 0)
+#define WCD937X_ANA_MBHC_BTN0			0x301A
+#define WCD937X_MBHC_BTN_VTH_MASK		GENMASK(7, 2)
+#define WCD937X_ANA_MBHC_BTN1			0x301B
+#define WCD937X_ANA_MBHC_BTN2			0x301C
+#define WCD937X_ANA_MBHC_BTN3			0x301D
+#define WCD937X_ANA_MBHC_BTN4			0x301E
+#define WCD937X_ANA_MBHC_BTN5			0x301F
+#define WCD937X_VTH_MASK			GENMASK(7, 2)
+#define WCD937X_ANA_MBHC_BTN6			0x3020
+#define WCD937X_ANA_MBHC_BTN7			0x3021
+#define WCD937X_ANA_MICB1			0x3022
+#define WCD937X_MICB_VOUT_MASK			GENMASK(5, 0)
+#define WCD937X_MICB_EN_MASK			GENMASK(7, 6)
+#define WCD937X_MICB_DISABLE			0
+#define WCD937X_MICB_ENABLE			1
+#define WCD937X_MICB_PULL_UP			2
+#define WCD937X_MICB_PULL_DOWN			3
+#define WCD937X_ANA_MICB2			0x3023
+#define WCD937X_ANA_MICB2_ENABLE		BIT(6)
+#define WCD937X_ANA_MICB2_ENABLE_MASK		GENMASK(7, 6)
+#define WCD937X_ANA_MICB2_VOUT_MASK		GENMASK(5, 0)
+#define WCD937X_ANA_MICB2_RAMP			0x3024
+#define WCD937X_RAMP_EN_MASK			BIT(7)
+#define WCD937X_RAMP_SHIFT_CTRL_MASK		GENMASK(4, 2)
+#define WCD937X_ANA_MICB3			0x3025
+#define WCD937X_ANA_MICB_EN			GENMASK(7, 6)
+#define WCD937X_MICB_DISABLE			0
+#define WCD937X_MICB_ENABLE			1
+#define WCD937X_MICB_PULL_UP			2
+#define WCD937X_ANA_MICB_VOUT			GENMASK(5, 0)
+#define WCD937X_BIAS_CTL			0x3028
+#define WCD937X_BIAS_VBG_FINE_ADJ		0x3029
+#define WCD937X_LDOL_VDDCX_ADJUST		0x3040
+#define WCD937X_LDOL_DISABLE_LDOL		0x3041
+#define WCD937X_MBHC_CTL_CLK			0x3056
+#define WCD937X_MBHC_CTL_ANA			0x3057
+#define WCD937X_MBHC_CTL_SPARE_1		0x3058
+#define WCD937X_MBHC_CTL_SPARE_2		0x3059
+#define WCD937X_MBHC_CTL_BCS			0x305A
+#define WCD937X_MBHC_MOISTURE_DET_FSM_STATUS	0x305B
+#define WCD937X_MBHC_TEST_CTL			0x305C
+#define WCD937X_LDOH_MODE			0x3067
+#define WCD937X_LDOH_BIAS			0x3068
+#define WCD937X_LDOH_STB_LOADS			0x3069
+#define WCD937X_LDOH_SLOWRAMP			0x306A
+#define WCD937X_MICB1_TEST_CTL_1		0x306B
+#define WCD937X_MICB1_TEST_CTL_2		0x306C
+#define WCD937X_MICB1_TEST_CTL_3		0x306D
+#define WCD937X_MICB2_TEST_CTL_1		0x306E
+#define WCD937X_MICB2_TEST_CTL_2		0x306F
+#define WCD937X_MICB2_TEST_CTL_3		0x3070
+#define WCD937X_MICB3_TEST_CTL_1		0x3071
+#define WCD937X_MICB3_TEST_CTL_2		0x3072
+#define WCD937X_MICB3_TEST_CTL_3		0x3073
+#define WCD937X_TX_COM_ADC_VCM			0x3077
+#define WCD937X_TX_COM_BIAS_ATEST		0x3078
+#define WCD937X_TX_COM_ADC_INT1_IB		0x3079
+#define WCD937X_TX_COM_ADC_INT2_IB		0x307A
+#define WCD937X_TX_COM_TXFE_DIV_CTL		0x307B
+#define WCD937X_TX_COM_TXFE_DIV_START		0x307C
+#define WCD937X_TX_COM_TXFE_DIV_STOP_9P6M	0x307D
+#define WCD937X_TX_COM_TXFE_DIV_STOP_12P288M	0x307E
+#define WCD937X_TX_1_2_TEST_EN			0x307F
+#define WCD937X_TX_1_2_ADC_IB			0x3080
+#define WCD937X_TX_1_2_ATEST_REFCTL		0x3081
+#define WCD937X_TX_1_2_TEST_CTL			0x3082
+#define WCD937X_TX_1_2_TEST_BLK_EN		0x3083
+#define WCD937X_TX_1_2_TXFE_CLKDIV		0x3084
+#define WCD937X_TX_1_2_SAR2_ERR			0x3085
+#define WCD937X_TX_1_2_SAR1_ERR			0x3086
+#define WCD937X_TX_3_TEST_EN			0x3087
+#define WCD937X_TX_3_ADC_IB			0x3088
+#define WCD937X_TX_3_ATEST_REFCTL		0x3089
+#define WCD937X_TX_3_TEST_CTL			0x308A
+#define WCD937X_TX_3_TEST_BLK_EN		0x308B
+#define WCD937X_TX_3_TXFE_CLKDIV		0x308C
+#define WCD937X_TX_3_SPARE_MONO			0x308D
+#define WCD937X_TX_3_SAR1_ERR			0x308E
+#define WCD937X_CLASSH_MODE_1			0x3097
+#define WCD937X_CLASSH_MODE_2			0x3098
+#define WCD937X_CLASSH_MODE_3			0x3099
+#define WCD937X_CLASSH_CTRL_VCL_1		0x309A
+#define WCD937X_CLASSH_CTRL_VCL_2		0x309B
+#define WCD937X_CLASSH_CTRL_CCL_1		0x309C
+#define WCD937X_CLASSH_CTRL_CCL_2		0x309D
+#define WCD937X_CLASSH_CTRL_CCL_3		0x309E
+#define WCD937X_CLASSH_CTRL_CCL_4		0x309F
+#define WCD937X_CLASSH_CTRL_CCL_5		0x30A0
+#define WCD937X_CLASSH_BUCK_TMUX_A_D		0x30A1
+#define WCD937X_CLASSH_BUCK_SW_DRV_CNTL		0x30A2
+#define WCD937X_CLASSH_SPARE			0x30A3
+#define WCD937X_FLYBACK_EN			0x30A4
+#define WCD937X_FLYBACK_VNEG_CTRL_1		0x30A5
+#define WCD937X_FLYBACK_VNEG_CTRL_2		0x30A6
+#define WCD937X_FLYBACK_VNEG_CTRL_3		0x30A7
+#define WCD937X_FLYBACK_VNEG_CTRL_4		0x30A8
+#define WCD937X_FLYBACK_VNEG_CTRL_5		0x30A9
+#define WCD937X_FLYBACK_VNEG_CTRL_6		0x30AA
+#define WCD937X_FLYBACK_VNEG_CTRL_7		0x30AB
+#define WCD937X_FLYBACK_VNEG_CTRL_8		0x30AC
+#define WCD937X_FLYBACK_VNEG_CTRL_9		0x30AD
+#define WCD937X_FLYBACK_VNEGDAC_CTRL_1		0x30AE
+#define WCD937X_FLYBACK_VNEGDAC_CTRL_2		0x30AF
+#define WCD937X_FLYBACK_VNEGDAC_CTRL_3		0x30B0
+#define WCD937X_FLYBACK_CTRL_1			0x30B1
+#define WCD937X_FLYBACK_TEST_CTL		0x30B2
+#define WCD937X_RX_AUX_SW_CTL			0x30B3
+#define WCD937X_RX_PA_AUX_IN_CONN		0x30B4
+#define WCD937X_RX_TIMER_DIV			0x30B5
+#define WCD937X_RX_OCP_CTL			0x30B6
+#define WCD937X_RX_OCP_COUNT			0x30B7
+#define WCD937X_RX_BIAS_EAR_DAC			0x30B8
+#define WCD937X_RX_BIAS_EAR_AMP			0x30B9
+#define WCD937X_RX_BIAS_HPH_LDO			0x30BA
+#define WCD937X_RX_BIAS_HPH_PA			0x30BB
+#define WCD937X_RX_BIAS_HPH_RDACBUFF_CNP2	0x30BC
+#define WCD937X_RX_BIAS_HPH_RDAC_LDO		0x30BD
+#define WCD937X_RX_BIAS_HPH_CNP1		0x30BE
+#define WCD937X_RX_BIAS_HPH_LOWPOWER		0x30BF
+#define WCD937X_RX_BIAS_AUX_DAC			0x30C0
+#define WCD937X_RX_BIAS_AUX_AMP			0x30C1
+#define WCD937X_RX_BIAS_VNEGDAC_BLEEDER		0x30C2
+#define WCD937X_RX_BIAS_MISC			0x30C3
+#define WCD937X_RX_BIAS_BUCK_RST		0x30C4
+#define WCD937X_RX_BIAS_BUCK_VREF_ERRAMP	0x30C5
+#define WCD937X_RX_BIAS_FLYB_ERRAMP		0x30C6
+#define WCD937X_RX_BIAS_FLYB_BUFF		0x30C7
+#define WCD937X_RX_BIAS_FLYB_MID_RST		0x30C8
+#define WCD937X_HPH_L_STATUS			0x30C9
+#define WCD937X_HPH_R_STATUS			0x30CA
+#define WCD937X_HPH_CNP_EN			0x30CB
+#define WCD937X_HPH_CNP_WG_CTL			0x30CC
+#define WCD937X_HPH_CNP_WG_TIME			0x30CD
+#define WCD937X_HPH_OCP_CTL			0x30CE
+#define WCD937X_HPH_AUTO_CHOP			0x30CF
+#define WCD937X_HPH_CHOP_CTL			0x30D0
+#define WCD937X_HPH_PA_CTL1			0x30D1
+#define WCD937X_HPH_PA_CTL2			0x30D2
+#define WCD937X_HPHPA_GND_R_MASK		BIT(6)
+#define WCD937X_HPHPA_GND_L_MASK		BIT(4)
+#define WCD937X_HPH_L_EN			0x30D3
+#define WCD937X_HPH_L_TEST			0x30D4
+#define WCD937X_HPH_L_ATEST			0x30D5
+#define WCD937X_HPH_R_EN			0x30D6
+#define WCD937X_GAIN_SRC_SEL_MASK		BIT(5)
+#define WCD937X_GAIN_SRC_SEL_REGISTER		1
+#define WCD937X_HPH_R_TEST			0x30D7
+#define WCD937X_HPH_R_ATEST			0x30D8
+#define WCD937X_HPH_RDAC_CLK_CTL1		0x30D9
+#define WCD937X_HPHPA_GND_OVR_MASK		BIT(1)
+#define WCD937X_CHOP_CLK_EN_MASK		BIT(7)
+#define WCD937X_HPH_RDAC_CLK_CTL2		0x30DA
+#define WCD937X_HPH_RDAC_LDO_CTL		0x30DB
+#define WCD937X_HPH_RDAC_CHOP_CLK_LP_CTL	0x30DC
+#define WCD937X_HPH_REFBUFF_UHQA_CTL		0x30DD
+#define WCD937X_HPH_REFBUFF_LP_CTL		0x30DE
+#define WCD937X_PREREF_FLIT_BYPASS_MASK		BIT(0)
+#define WCD937X_HPH_L_DAC_CTL			0x30DF
+#define WCD937X_HPH_R_DAC_CTL			0x30E0
+#define WCD937X_HPH_SURGE_HPHLR_SURGE_COMP_SEL	0x30E1
+#define WCD937X_HPH_SURGE_HPHLR_SURGE_EN	0x30E2
+#define WCD937X_HPH_SURGE_HPHLR_SURGE_MISC1	0x30E3
+#define WCD937X_HPH_SURGE_HPHLR_SURGE_STATUS	0x30E4
+#define WCD937X_EAR_EAR_EN_REG			0x30E9
+#define WCD937X_EAR_EAR_PA_CON			0x30EA
+#define WCD937X_EAR_EAR_SP_CON			0x30EB
+#define WCD937X_EAR_EAR_DAC_CON			0x30EC
+#define WCD937X_EAR_EAR_CNP_FSM_CON		0x30ED
+#define WCD937X_EAR_TEST_CTL			0x30EE
+#define WCD937X_EAR_STATUS_REG_1		0x30EF
+#define WCD937X_EAR_STATUS_REG_2		0x30F0
+#define WCD937X_ANA_NEW_PAGE_REGISTER		0x3100
+#define WCD937X_HPH_NEW_ANA_HPH2		0x3101
+#define WCD937X_HPH_NEW_ANA_HPH3		0x3102
+#define WCD937X_SLEEP_CTL			0x3103
+#define WCD937X_SLEEP_WATCHDOG_CTL		0x3104
+#define WCD937X_MBHC_NEW_ELECT_REM_CLAMP_CTL	0x311F
+#define WCD937X_MBHC_NEW_CTL_1			0x3120
+#define WCD937X_MBHC_CTL_RCO_EN_MASK		BIT(7)
+#define WCD937X_MBHC_CTL_RCO_EN			BIT(7)
+#define WCD937X_MBHC_BTN_DBNC_MASK		GENMASK(1, 0)
+#define WCD937X_MBHC_BTN_DBNC_T_16_MS		0x2
+#define WCD937X_MBHC_NEW_CTL_2			0x3121
+#define WCD937X_MBHC_NEW_PLUG_DETECT_CTL	0x3122
+#define WCD937X_MBHC_NEW_ZDET_ANA_CTL		0x3123
+#define WCD937X_M_RTH_CTL_MASK			GENMASK(3, 2)
+#define WCD937X_MBHC_HS_VREF_CTL_MASK		GENMASK(1, 0)
+#define WCD937X_MBHC_HS_VREF_1P5_V		0x1
+#define WCD937X_MBHC_DBNC_TIMER_INSREM_DBNC_T_96_MS	0x6
+#define WCD937X_ZDET_RANGE_CTL_MASK		GENMASK(3, 0)
+#define WCD937X_ZDET_MAXV_CTL_MASK		GENMASK(6, 4)
+#define WCD937X_MBHC_NEW_ZDET_RAMP_CTL		0x3124
+#define WCD937X_MBHC_NEW_FSM_STATUS		0x3125
+#define WCD937X_MBHC_NEW_ADC_RESULT		0x3126
+#define WCD937X_TX_NEW_TX_CH2_SEL		0x3127
+#define WCD937X_AUX_AUXPA			0x3128
+#define WCD937X_AUXPA_CLK_EN_MASK		BIT(4)
+#define WCD937X_AUXPA_CLK_EN_MASK		BIT(4)
+#define WCD937X_LDORXTX_MODE			0x3129
+#define WCD937X_LDORXTX_CONFIG			0x312A
+#define WCD937X_DIE_CRACK_DIE_CRK_DET_EN	0x312C
+#define WCD937X_DIE_CRACK_DIE_CRK_DET_OUT	0x312D
+#define WCD937X_HPH_NEW_INT_RDAC_GAIN_CTL	0x3132
+#define WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_L	0x3133
+#define WCD937X_HPH_NEW_INT_RDAC_VREF_CTL	0x3134
+#define WCD937X_HPH_NEW_INT_RDAC_OVERRIDE_CTL	0x3135
+#define WCD937X_HPH_NEW_INT_RDAC_HD2_CTL_R	0x3136
+#define WCD937X_HPH_NEW_INT_PA_MISC1		0x3137
+#define WCD937X_HPH_NEW_INT_PA_MISC2		0x3138
+#define WCD937X_HPH_NEW_INT_PA_RDAC_MISC	0x3139
+#define WCD937X_HPH_NEW_INT_HPH_TIMER1		0x313A
+#define WCD937X_HPH_NEW_INT_HPH_TIMER2		0x313B
+#define WCD937X_HPH_NEW_INT_HPH_TIMER3		0x313C
+#define WCD937X_HPH_NEW_INT_HPH_TIMER4		0x313D
+#define WCD937X_HPH_NEW_INT_PA_RDAC_MISC2	0x313E
+#define WCD937X_HPH_NEW_INT_PA_RDAC_MISC3	0x313F
+#define WCD937X_RX_NEW_INT_HPH_RDAC_BIAS_LOHIFI	0x3145
+#define WCD937X_RX_NEW_INT_HPH_RDAC_BIAS_ULP	0x3146
+#define WCD937X_RX_NEW_INT_HPH_RDAC_LDO_LP	0x3147
+#define WCD937X_MBHC_NEW_INT_MOISTURE_DET_DC_CTRL			0x31AF
+#define WCD937X_MBHC_NEW_INT_MOISTURE_DET_POLLING_CTRL			0x31B0
+#define WCD937X_MOISTURE_EN_POLLING_MASK	BIT(2)
+#define WCD937X_HSDET_PULLUP_C_MASK		GENMASK(4, 0)
+#define WCD937X_MBHC_NEW_INT_MECH_DET_CURRENT	0x31B1
+#define WCD937X_MBHC_NEW_INT_SPARE_2		0x31B2
+#define WCD937X_EAR_INT_NEW_EAR_CHOPPER_CON	0x31B7
+#define WCD937X_EAR_INT_NEW_CNP_VCM_CON1	0x31B8
+#define WCD937X_EAR_INT_NEW_CNP_VCM_CON2	0x31B9
+#define WCD937X_EAR_INT_NEW_EAR_DYNAMIC_BIAS	0x31BA
+#define WCD937X_AUX_INT_EN_REG			0x31BD
+#define WCD937X_AUX_INT_PA_CTRL			0x31BE
+#define WCD937X_AUX_INT_SP_CTRL			0x31BF
+#define WCD937X_AUX_INT_DAC_CTRL		0x31C0
+#define WCD937X_AUX_INT_CLK_CTRL		0x31C1
+#define WCD937X_AUX_INT_TEST_CTRL		0x31C2
+#define WCD937X_AUX_INT_STATUS_REG		0x31C3
+#define WCD937X_AUX_INT_MISC			0x31C4
+#define WCD937X_LDORXTX_INT_BIAS		0x31C5
+#define WCD937X_LDORXTX_INT_STB_LOADS_DTEST	0x31C6
+#define WCD937X_LDORXTX_INT_TEST0		0x31C7
+#define WCD937X_LDORXTX_INT_STARTUP_TIMER	0x31C8
+#define WCD937X_LDORXTX_INT_TEST1		0x31C9
+#define WCD937X_LDORXTX_INT_STATUS		0x31CA
+#define WCD937X_SLEEP_INT_WATCHDOG_CTL_1	0x31D0
+#define WCD937X_SLEEP_INT_WATCHDOG_CTL_2	0x31D1
+#define WCD937X_DIE_CRACK_INT_DIE_CRK_DET_INT1	0x31D3
+#define WCD937X_DIE_CRACK_INT_DIE_CRK_DET_INT2	0x31D4
+#define WCD937X_DIGITAL_PAGE_REGISTER		0x3400
+#define WCD937X_DIGITAL_CHIP_ID0		0x3401
+#define WCD937X_DIGITAL_CHIP_ID1		0x3402
+#define WCD937X_DIGITAL_CHIP_ID2		0x3403
+#define WCD937X_DIGITAL_CHIP_ID3		0x3404
+#define WCD937X_DIGITAL_CDC_RST_CTL		0x3406
+#define WCD937X_DIGITAL_TOP_CLK_CFG		0x3407
+#define WCD937X_DIGITAL_CDC_ANA_CLK_CTL		0x3408
+#define WCD937X_DIGITAL_CDC_DIG_CLK_CTL		0x3409
+#define WCD937X_DIGITAL_SWR_RST_EN		0x340A
+#define WCD937X_DIGITAL_CDC_PATH_MODE		0x340B
+#define WCD937X_DIGITAL_CDC_RX_RST		0x340C
+#define WCD937X_DIGITAL_CDC_RX0_CTL		0x340D
+#define WCD937X_DIGITAL_CDC_RX1_CTL		0x340E
+#define WCD937X_DIGITAL_CDC_RX2_CTL		0x340F
+#define WCD937X_DIGITAL_DEM_BYPASS_DATA0	0x3410
+#define WCD937X_DIGITAL_DEM_BYPASS_DATA1	0x3411
+#define WCD937X_DIGITAL_DEM_BYPASS_DATA2	0x3412
+#define WCD937X_DIGITAL_DEM_BYPASS_DATA3	0x3413
+#define WCD937X_DIGITAL_CDC_COMP_CTL_0		0x3414
+#define WCD937X_DIGITAL_CDC_RX_DELAY_CTL	0x3417
+#define WCD937X_DIGITAL_CDC_HPH_DSM_A1_0	0x3418
+#define WCD937X_DIGITAL_CDC_HPH_DSM_A1_1	0x3419
+#define WCD937X_DIGITAL_CDC_HPH_DSM_A2_0	0x341A
+#define WCD937X_DIGITAL_CDC_HPH_DSM_A2_1	0x341B
+#define WCD937X_DIGITAL_CDC_HPH_DSM_A3_0	0x341C
+#define WCD937X_DIGITAL_CDC_HPH_DSM_A3_1	0x341D
+#define WCD937X_DIGITAL_CDC_HPH_DSM_A4_0	0x341E
+#define WCD937X_DIGITAL_CDC_HPH_DSM_A4_1	0x341F
+#define WCD937X_DIGITAL_CDC_HPH_DSM_A5_0	0x3420
+#define WCD937X_DIGITAL_CDC_HPH_DSM_A5_1	0x3421
+#define WCD937X_DIGITAL_CDC_HPH_DSM_A6_0	0x3422
+#define WCD937X_DIGITAL_CDC_HPH_DSM_A7_0	0x3423
+#define WCD937X_DIGITAL_CDC_HPH_DSM_C_0		0x3424
+#define WCD937X_DIGITAL_CDC_HPH_DSM_C_1		0x3425
+#define WCD937X_DIGITAL_CDC_HPH_DSM_C_2		0x3426
+#define WCD937X_DIGITAL_CDC_HPH_DSM_C_3		0x3427
+#define WCD937X_DIGITAL_CDC_HPH_DSM_R1		0x3428
+#define WCD937X_DIGITAL_CDC_HPH_DSM_R2		0x3429
+#define WCD937X_DIGITAL_CDC_HPH_DSM_R3		0x342A
+#define WCD937X_DIGITAL_CDC_HPH_DSM_R4		0x342B
+#define WCD937X_DIGITAL_CDC_HPH_DSM_R5		0x342C
+#define WCD937X_DIGITAL_CDC_HPH_DSM_R6		0x342D
+#define WCD937X_DIGITAL_CDC_HPH_DSM_R7		0x342E
+#define WCD937X_DIGITAL_CDC_AUX_DSM_A1_0	0x342F
+#define WCD937X_DIGITAL_CDC_AUX_DSM_A1_1	0x3430
+#define WCD937X_DIGITAL_CDC_AUX_DSM_A2_0	0x3431
+#define WCD937X_DIGITAL_CDC_AUX_DSM_A2_1	0x3432
+#define WCD937X_DIGITAL_CDC_AUX_DSM_A3_0	0x3433
+#define WCD937X_DIGITAL_CDC_AUX_DSM_A3_1	0x3434
+#define WCD937X_DIGITAL_CDC_AUX_DSM_A4_0	0x3435
+#define WCD937X_DIGITAL_CDC_AUX_DSM_A4_1	0x3436
+#define WCD937X_DIGITAL_CDC_AUX_DSM_A5_0	0x3437
+#define WCD937X_DIGITAL_CDC_AUX_DSM_A5_1	0x3438
+#define WCD937X_DIGITAL_CDC_AUX_DSM_A6_0	0x3439
+#define WCD937X_DIGITAL_CDC_AUX_DSM_A7_0	0x343A
+#define WCD937X_DIGITAL_CDC_AUX_DSM_C_0		0x343B
+#define WCD937X_DIGITAL_CDC_AUX_DSM_C_1		0x343C
+#define WCD937X_DIGITAL_CDC_AUX_DSM_C_2		0x343D
+#define WCD937X_DIGITAL_CDC_AUX_DSM_C_3		0x343E
+#define WCD937X_DIGITAL_CDC_AUX_DSM_R1		0x343F
+#define WCD937X_DIGITAL_CDC_AUX_DSM_R2		0x3440
+#define WCD937X_DIGITAL_CDC_AUX_DSM_R3		0x3441
+#define WCD937X_DIGITAL_CDC_AUX_DSM_R4		0x3442
+#define WCD937X_DIGITAL_CDC_AUX_DSM_R5		0x3443
+#define WCD937X_DIGITAL_CDC_AUX_DSM_R6		0x3444
+#define WCD937X_DIGITAL_CDC_AUX_DSM_R7		0x3445
+#define WCD937X_DIGITAL_CDC_HPH_GAIN_RX_0	0x3446
+#define WCD937X_DIGITAL_CDC_HPH_GAIN_RX_1	0x3447
+#define WCD937X_DIGITAL_CDC_HPH_GAIN_DSD_0	0x3448
+#define WCD937X_DIGITAL_CDC_HPH_GAIN_DSD_1	0x3449
+#define WCD937X_DIGITAL_CDC_HPH_GAIN_DSD_2	0x344A
+#define WCD937X_DIGITAL_CDC_AUX_GAIN_DSD_0	0x344B
+#define WCD937X_DIGITAL_CDC_AUX_GAIN_DSD_1	0x344C
+#define WCD937X_DIGITAL_CDC_AUX_GAIN_DSD_2	0x344D
+#define WCD937X_DIGITAL_CDC_HPH_GAIN_CTL	0x344E
+#define WCD937X_DIGITAL_CDC_AUX_GAIN_CTL	0x344F
+#define WCD937X_DIGITAL_CDC_EAR_PATH_CTL	0x3450
+#define WCD937X_DIGITAL_CDC_SWR_CLH		0x3451
+#define WCD937X_DIGITAL_SWR_CLH_BYP		0x3452
+#define WCD937X_DIGITAL_CDC_TX0_CTL		0x3453
+#define WCD937X_DIGITAL_CDC_TX1_CTL		0x3454
+#define WCD937X_DIGITAL_CDC_TX2_CTL		0x3455
+#define WCD937X_DIGITAL_CDC_TX_RST		0x3456
+#define WCD937X_DIGITAL_CDC_REQ_CTL		0x3457
+#define WCD937X_DIGITAL_CDC_AMIC_CTL		0x345A
+#define WCD937X_DIGITAL_CDC_DMIC_CTL		0x345B
+#define WCD937X_DIGITAL_CDC_DMIC1_CTL		0x345C
+#define WCD937X_DIGITAL_CDC_DMIC2_CTL		0x345D
+#define WCD937X_DIGITAL_CDC_DMIC3_CTL		0x345E
+#define WCD937X_DIGITAL_EFUSE_CTL		0x345F
+#define WCD937X_DIGITAL_EFUSE_PRG_CTL		0x3460
+#define WCD937X_DIGITAL_EFUSE_TEST_CTL_0	0x3461
+#define WCD937X_DIGITAL_EFUSE_TEST_CTL_1	0x3462
+#define WCD937X_DIGITAL_EFUSE_T_DATA_0		0x3463
+#define WCD937X_DIGITAL_EFUSE_T_DATA_1		0x3464
+#define WCD937X_DIGITAL_PDM_WD_CTL0		0x3465
+#define WCD937X_DIGITAL_PDM_WD_CTL1		0x3466
+#define WCD937X_DIGITAL_PDM_WD_CTL2		0x3467
+#define WCD937X_DIGITAL_INTR_MODE		0x346A
+#define WCD937X_DIGITAL_INTR_MASK_0		0x346B
+#define WCD937X_DIGITAL_INTR_MASK_1		0x346C
+#define WCD937X_DIGITAL_INTR_MASK_2		0x346D
+#define WCD937X_DIGITAL_INTR_STATUS_0		0x346E
+#define WCD937X_DIGITAL_INTR_STATUS_1		0x346F
+#define WCD937X_DIGITAL_INTR_STATUS_2		0x3470
+#define WCD937X_DIGITAL_INTR_CLEAR_0		0x3471
+#define WCD937X_DIGITAL_INTR_CLEAR_1		0x3472
+#define WCD937X_DIGITAL_INTR_CLEAR_2		0x3473
+#define WCD937X_DIGITAL_INTR_LEVEL_0		0x3474
+#define WCD937X_DIGITAL_INTR_LEVEL_1		0x3475
+#define WCD937X_DIGITAL_INTR_LEVEL_2		0x3476
+#define WCD937X_DIGITAL_INTR_SET_0		0x3477
+#define WCD937X_DIGITAL_INTR_SET_1		0x3478
+#define WCD937X_DIGITAL_INTR_SET_2		0x3479
+#define WCD937X_DIGITAL_INTR_TEST_0		0x347A
+#define WCD937X_DIGITAL_INTR_TEST_1		0x347B
+#define WCD937X_DIGITAL_INTR_TEST_2		0x347C
+#define WCD937X_DIGITAL_CDC_CONN_RX0_CTL	0x347F
+#define WCD937X_DIGITAL_CDC_CONN_RX1_CTL	0x3480
+#define WCD937X_DIGITAL_CDC_CONN_RX2_CTL	0x3481
+#define WCD937X_DIGITAL_CDC_CONN_TX_CTL		0x3482
+#define WCD937X_DIGITAL_LOOP_BACK_MODE		0x3483
+#define WCD937X_DIGITAL_SWR_DAC_TEST		0x3484
+#define WCD937X_DIGITAL_SWR_HM_TEST_RX_0	0x3485
+#define WCD937X_DIGITAL_SWR_HM_TEST_TX_0	0x3491
+#define WCD937X_DIGITAL_SWR_HM_TEST_RX_1	0x3492
+#define WCD937X_DIGITAL_SWR_HM_TEST_TX_1	0x3493
+#define WCD937X_DIGITAL_SWR_HM_TEST		0x3494
+#define WCD937X_DIGITAL_PAD_CTL_PDM_RX0		0x3495
+#define WCD937X_DIGITAL_PAD_CTL_PDM_RX1		0x3496
+#define WCD937X_DIGITAL_PAD_CTL_PDM_TX0		0x3497
+#define WCD937X_DIGITAL_PAD_CTL_PDM_TX1		0x3498
+#define WCD937X_DIGITAL_PAD_INP_DIS_0		0x3499
+#define WCD937X_DIGITAL_PAD_INP_DIS_1		0x349A
+#define WCD937X_DIGITAL_DRIVE_STRENGTH_0	0x349B
+#define WCD937X_DIGITAL_DRIVE_STRENGTH_1	0x349C
+#define WCD937X_DIGITAL_DRIVE_STRENGTH_2	0x349D
+#define WCD937X_DIGITAL_RX_DATA_EDGE_CTL	0x349E
+#define WCD937X_DIGITAL_TX_DATA_EDGE_CTL	0x349F
+#define WCD937X_DIGITAL_GPIO_MODE		0x34A0
+#define WCD937X_DIGITAL_PIN_CTL_OE		0x34A1
+#define WCD937X_DIGITAL_PIN_CTL_DATA_0		0x34A2
+#define WCD937X_DIGITAL_PIN_CTL_DATA_1		0x34A3
+#define WCD937X_DIGITAL_PIN_STATUS_0		0x34A4
+#define WCD937X_DIGITAL_PIN_STATUS_1		0x34A5
+#define WCD937X_DIGITAL_DIG_DEBUG_CTL		0x34A6
+#define WCD937X_DIGITAL_DIG_DEBUG_EN		0x34A7
+#define WCD937X_DIGITAL_ANA_CSR_DBG_ADD		0x34A8
+#define WCD937X_DIGITAL_ANA_CSR_DBG_CTL		0x34A9
+#define WCD937X_DIGITAL_SSP_DBG			0x34AA
+#define WCD937X_DIGITAL_MODE_STATUS_0		0x34AB
+#define WCD937X_DIGITAL_MODE_STATUS_1		0x34AC
+#define WCD937X_DIGITAL_SPARE_0			0x34AD
+#define WCD937X_DIGITAL_SPARE_1			0x34AE
+#define WCD937X_DIGITAL_SPARE_2			0x34AF
+#define WCD937X_DIGITAL_EFUSE_REG_0		0x34B0
+#define WCD937X_DIGITAL_EFUSE_REG_1		0x34B1
+#define WCD937X_DIGITAL_EFUSE_REG_2		0x34B2
+#define WCD937X_DIGITAL_EFUSE_REG_3		0x34B3
+#define WCD937X_DIGITAL_EFUSE_REG_4		0x34B4
+#define WCD937X_DIGITAL_EFUSE_REG_5		0x34B5
+#define WCD937X_DIGITAL_EFUSE_REG_6		0x34B6
+#define WCD937X_DIGITAL_EFUSE_REG_7		0x34B7
+#define WCD937X_DIGITAL_EFUSE_REG_8		0x34B8
+#define WCD937X_DIGITAL_EFUSE_REG_9		0x34B9
+#define WCD937X_DIGITAL_EFUSE_REG_10		0x34BA
+#define WCD937X_DIGITAL_EFUSE_REG_11		0x34BB
+#define WCD937X_DIGITAL_EFUSE_REG_12		0x34BC
+#define WCD937X_DIGITAL_EFUSE_REG_13		0x34BD
+#define WCD937X_DIGITAL_EFUSE_REG_14		0x34BE
+#define WCD937X_DIGITAL_EFUSE_REG_15		0x34BF
+#define WCD937X_DIGITAL_EFUSE_REG_16		0x34C0
+#define WCD937X_DIGITAL_EFUSE_REG_17		0x34C1
+#define WCD937X_DIGITAL_EFUSE_REG_18		0x34C2
+#define WCD937X_DIGITAL_EFUSE_REG_19		0x34C3
+#define WCD937X_DIGITAL_EFUSE_REG_20		0x34C4
+#define WCD937X_DIGITAL_EFUSE_REG_21		0x34C5
+#define WCD937X_DIGITAL_EFUSE_REG_22		0x34C6
+#define WCD937X_DIGITAL_EFUSE_REG_23		0x34C7
+#define WCD937X_DIGITAL_EFUSE_REG_24		0x34C8
+#define WCD937X_DIGITAL_EFUSE_REG_25		0x34C9
+#define WCD937X_DIGITAL_EFUSE_REG_26		0x34CA
+#define WCD937X_DIGITAL_EFUSE_REG_27		0x34CB
+#define WCD937X_DIGITAL_EFUSE_REG_28		0x34CC
+#define WCD937X_DIGITAL_EFUSE_REG_29		0x34CD
+#define WCD937X_DIGITAL_EFUSE_REG_30		0x34CE
+#define WCD937X_DIGITAL_EFUSE_REG_31		0x34CF
+#define WCD937X_MAX_REGISTER			(WCD937X_DIGITAL_EFUSE_REG_31)
+
+#define WCD937X_MAX_MICBIAS			3
+#define WCD937X_MAX_BULK_SUPPLY			4
+#define WCD937X_MAX_TX_SWR_PORTS		4
+#define WCD937X_MAX_SWR_PORTS			5
+#define WCD937X_MAX_SWR_CH_IDS			15
+
+struct wcd937x_sdw_ch_info {
+	int port_num;
+	unsigned int ch_mask;
+};
+
+#define WCD_SDW_CH(id, pn, cmask)	\
+	[id] = {			\
+		.port_num = pn,		\
+		.ch_mask = cmask,	\
+	}
+
+struct wcd937x_priv;
+struct wcd937x_sdw_priv {
+	struct sdw_slave *sdev;
+	struct sdw_stream_config sconfig;
+	struct sdw_stream_runtime *sruntime;
+	struct sdw_port_config port_config[WCD937X_MAX_SWR_PORTS];
+	const struct wcd937x_sdw_ch_info *ch_info;
+	bool port_enable[WCD937X_MAX_SWR_CH_IDS];
+	int active_ports;
+	bool is_tx;
+	struct wcd937x_priv *wcd937x;
+	struct irq_domain *slave_irq;
+	struct regmap *regmap;
+};
+
+#if IS_ENABLED(CONFIG_SND_SOC_WCD937X_SDW)
+int wcd937x_sdw_free(struct wcd937x_sdw_priv *wcd,
+		     struct snd_pcm_substream *substream,
+		     struct snd_soc_dai *dai);
+int wcd937x_sdw_set_sdw_stream(struct wcd937x_sdw_priv *wcd,
+			       struct snd_soc_dai *dai,
+			       void *stream, int direction);
+int wcd937x_sdw_hw_params(struct wcd937x_sdw_priv *wcd,
+			  struct snd_pcm_substream *substream,
+			  struct snd_pcm_hw_params *params,
+			  struct snd_soc_dai *dai);
+
+struct device *wcd937x_sdw_device_get(struct device_node *np);
+
+#else
+int wcd937x_sdw_free(struct wcd937x_sdw_priv *wcd,
+		     struct snd_pcm_substream *substream,
+		     struct snd_soc_dai *dai)
+{
+	return -EOPNOTSUPP;
+}
+
+int wcd937x_sdw_set_sdw_stream(struct wcd937x_sdw_priv *wcd,
+			       struct snd_soc_dai *dai,
+			       void *stream, int direction)
+{
+	return -EOPNOTSUPP;
+}
+
+int wcd937x_sdw_hw_params(struct wcd937x_sdw_priv *wcd,
+			  struct snd_pcm_substream *substream,
+			  struct snd_pcm_hw_params *params,
+			  struct snd_soc_dai *dai)
+{
+	return -EOPNOTSUPP;
+}
+#endif
+
+enum {
+	/* INTR_CTRL_INT_MASK_0 */
+	WCD937X_IRQ_MBHC_BUTTON_PRESS_DET = 0,
+	WCD937X_IRQ_MBHC_BUTTON_RELEASE_DET,
+	WCD937X_IRQ_MBHC_ELECT_INS_REM_DET,
+	WCD937X_IRQ_MBHC_ELECT_INS_REM_LEG_DET,
+	WCD937X_IRQ_MBHC_SW_DET,
+	WCD937X_IRQ_HPHR_OCP_INT,
+	WCD937X_IRQ_HPHR_CNP_INT,
+	WCD937X_IRQ_HPHL_OCP_INT,
+
+	/* INTR_CTRL_INT_MASK_1 */
+	WCD937X_IRQ_HPHL_CNP_INT,
+	WCD937X_IRQ_EAR_CNP_INT,
+	WCD937X_IRQ_EAR_SCD_INT,
+	WCD937X_IRQ_AUX_CNP_INT,
+	WCD937X_IRQ_AUX_SCD_INT,
+	WCD937X_IRQ_HPHL_PDM_WD_INT,
+	WCD937X_IRQ_HPHR_PDM_WD_INT,
+	WCD937X_IRQ_AUX_PDM_WD_INT,
+
+	/* INTR_CTRL_INT_MASK_2 */
+	WCD937X_IRQ_LDORT_SCD_INT,
+	WCD937X_IRQ_MBHC_MOISTURE_INT,
+	WCD937X_IRQ_HPHL_SURGE_DET_INT,
+	WCD937X_IRQ_HPHR_SURGE_DET_INT,
+	WCD937X_NUM_IRQS,
+};
+
+enum wcd937x_tx_sdw_ports {
+	WCD937X_ADC_1_PORT = 1,
+	WCD937X_ADC_2_3_PORT,
+	WCD937X_DMIC_0_3_MBHC_PORT,
+	WCD937X_DMIC_4_6_PORT,
+};
+
+enum wcd937x_tx_sdw_channels {
+	WCD937X_ADC1,
+	WCD937X_ADC2,
+	WCD937X_ADC3,
+	WCD937X_DMIC0,
+	WCD937X_DMIC1,
+	WCD937X_MBHC,
+	WCD937X_DMIC2,
+	WCD937X_DMIC3,
+	WCD937X_DMIC4,
+	WCD937X_DMIC5,
+	WCD937X_DMIC6,
+};
+
+enum wcd937x_rx_sdw_ports {
+	WCD937X_HPH_PORT = 1,
+	WCD937X_CLSH_PORT,
+	WCD937X_COMP_PORT,
+	WCD937X_LO_PORT,
+	WCD937X_DSD_PORT,
+};
+
+enum wcd937x_rx_sdw_channels {
+	WCD937X_HPH_L,
+	WCD937X_HPH_R,
+	WCD937X_CLSH,
+	WCD937X_COMP_L,
+	WCD937X_COMP_R,
+	WCD937X_LO,
+	WCD937X_DSD_R,
+	WCD937X_DSD_L,
+};
+
+#endif
