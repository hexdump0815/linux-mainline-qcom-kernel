created via: https://github.com/sm7125-mainline/linux/compare/110fa4c8eee8d020e4d97bd86e97acafa0490f94...c08ea478e5dbea11f672f4b57c4fa8ab54257c99.diff

this is from the sm7125-mainline tree and the version closest to v6.12 (the
linux-6.12.1 branch) to maybe use as a reference for bringing the map22v
a52/a72 to v6.12

diff --git a/arch/arm64/boot/dts/qcom/Makefile b/arch/arm64/boot/dts/qcom/Makefile
index ae002c7cf1268a..cd6e60359347ac 100644
--- a/arch/arm64/boot/dts/qcom/Makefile
+++ b/arch/arm64/boot/dts/qcom/Makefile
@@ -232,8 +232,12 @@ dtb-$(CONFIG_ARCH_QCOM)	+= sm6125-sony-xperia-seine-pdx201.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm6125-xiaomi-laurel-sprout.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm6350-sony-xperia-lena-pdx213.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm6375-sony-xperia-murray-pdx225.dtb
-dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-xiaomi-curtana.dtb
-dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-xiaomi-joyeuse.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-xiaomi-curtana-huaxing.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-xiaomi-curtana-tianma.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-xiaomi-gram-huaxing.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-xiaomi-gram-tianma.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-xiaomi-joyeuse-huaxing.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-xiaomi-joyeuse-tianma.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm7225-fairphone-fp4.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8150-hdk.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8150-microsoft-surface-duo.dtb
diff --git a/arch/arm64/boot/dts/qcom/pm6150.dtsi b/arch/arm64/boot/dts/qcom/pm6150.dtsi
index 59524609fb1e8e..ff3837c15979f1 100644
--- a/arch/arm64/boot/dts/qcom/pm6150.dtsi
+++ b/arch/arm64/boot/dts/qcom/pm6150.dtsi
@@ -130,6 +130,22 @@
 				reg = <ADC5_DIE_TEMP>;
 				label = "die_temp";
 			};
+
+			bat_therm@4a {
+				reg = <ADC5_BAT_THERM_100K_PU>;
+				label = "bat_therm";
+				qcom,ratiometric;
+				qcom,hw-settle-time = <200>;
+				qcom,pre-scaling = <1 1>;
+			};
+
+			bat_id@4b {
+				reg = <ADC5_BAT_ID_100K_PU>;
+				label = "bat_id";
+				qcom,ratiometric;
+				qcom,hw-settle-time = <200>;
+				qcom,pre-scaling = <1 1>;
+			};
 		};
 
 		pm6150_adc_tm: adc-tm@3500 {
@@ -142,6 +158,18 @@
 			status = "disabled";
 		};
 
+		pm6150_qgauge: qgauge@4800 {
+			compatible = "qcom,pm6150-qg";
+			reg = <0x4800>;
+
+			io-channels = <&pm6150_adc ADC5_BAT_THERM_100K_PU>,
+				      <&pm6150_adc ADC5_BAT_ID_100K_PU>;
+			io-channel-names = "batt-therm",
+					   "batt-id";
+
+			status = "disabled";
+		};
+
 		pm6150_rtc: rtc@6000 {
 			compatible = "qcom,pm8941-rtc";
 			reg = <0x6000>, <0x6100>;
diff --git a/arch/arm64/boot/dts/qcom/sc7180.dtsi b/arch/arm64/boot/dts/qcom/sc7180.dtsi
index b5ebf898032512..749148ffe79367 100644
--- a/arch/arm64/boot/dts/qcom/sc7180.dtsi
+++ b/arch/arm64/boot/dts/qcom/sc7180.dtsi
@@ -5,6 +5,7 @@
  * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  */
 
+#include <dt-bindings/clock/qcom,camcc-sc7180.h>
 #include <dt-bindings/clock/qcom,dispcc-sc7180.h>
 #include <dt-bindings/clock/qcom,gcc-sc7180.h>
 #include <dt-bindings/clock/qcom,gpucc-sc7180.h>
@@ -2123,6 +2124,54 @@
 				pins = "gpio63", "gpio64", "gpio65", "gpio66";
 				function = "mi2s_2";
 			};
+
+			cci0_default: cci0-default-state {
+				/* SDA, SCL */
+				pins = "gpio17", "gpio18";
+				function = "cci_i2c";
+				drive-strength = <2>;
+				bias-pull-up;
+			};
+
+			cci0_sleep: cci0-sleep-state {
+				/* SDA, SCL */
+				pins = "gpio17", "gpio18";
+				function = "cci_i2c";
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+
+			cci1_default: cci1-default-state {
+				/* SDA, SCL */
+				pins = "gpio19", "gpio20";
+				function = "cci_i2c";
+				drive-strength = <2>;
+				bias-pull-up;
+			};
+
+			cci1_sleep: cci1-sleep-state {
+				/* SDA, SCL */
+				pins = "gpio19", "gpio20";
+				function = "cci_i2c";
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+
+			cci2_default: cci2-default-state {
+				/* SDA, SCL */
+				pins = "gpio27", "gpio28";
+				function = "cci_i2c";
+				drive-strength = <2>;
+				bias-pull-up;
+			};
+
+			cci2_sleep: cci2-sleep-state {
+				/* SDA, SCL */
+				pins = "gpio27", "gpio28";
+				function = "cci_i2c";
+				drive-strength = <2>;
+				bias-pull-down;
+			};
 		};
 
 		remoteproc_mpss: remoteproc@4080000 {
@@ -3150,6 +3199,230 @@
 			qcom,bcm-voters = <&apps_bcm_voter>;
 		};
 
+		camss: camss@acb3000 {
+			compatible = "qcom,sc7180-camss";
+
+			reg = <0 0xacb3000 0 0x1000>,
+				  <0 0xacba000 0 0x1000>,
+				  <0 0xacc8000 0 0x1000>,
+				  <0 0xac65000 0 0x1000>,
+				  <0 0xac66000 0 0x1000>,
+				  <0 0xac67000 0 0x1000>,
+				  <0 0xac68000 0 0x1000>,
+				  <0 0xacaf000 0 0x4000>,
+				  <0 0xacb6000 0 0x4000>,
+				  <0 0xacc4000 0 0x4000>;
+
+			reg-names = "csid0",
+						"csid1",
+						"csid2",
+						"csiphy0",
+						"csiphy1",
+						"csiphy2",
+						"csiphy3",
+						"vfe0",
+						"vfe1",
+						"vfe_lite";
+
+			clocks = <&camcc CAM_CC_CAMNOC_AXI_CLK>,
+					 <&camcc CAM_CC_CPAS_AHB_CLK>,
+					 <&camcc CAM_CC_IFE_0_CSID_CLK>,
+					 <&camcc CAM_CC_IFE_1_CSID_CLK>,
+					 <&camcc CAM_CC_IFE_LITE_CSID_CLK>,
+					 <&camcc CAM_CC_CSIPHY0_CLK>,
+					 <&camcc CAM_CC_CSI0PHYTIMER_CLK>,
+					 <&camcc CAM_CC_CSIPHY1_CLK>,
+					 <&camcc CAM_CC_CSI1PHYTIMER_CLK>,
+					 <&camcc CAM_CC_CSIPHY2_CLK>,
+					 <&camcc CAM_CC_CSI2PHYTIMER_CLK>,
+					 <&camcc CAM_CC_CSIPHY3_CLK>,
+					 <&camcc CAM_CC_CSI3PHYTIMER_CLK>,
+					 <&gcc GCC_CAMERA_AHB_CLK>,
+					 <&gcc GCC_CAMERA_HF_AXI_CLK>,
+					 <&camcc CAM_CC_SOC_AHB_CLK>,
+					 <&camcc CAM_CC_IFE_0_AXI_CLK>,
+					 <&camcc CAM_CC_IFE_0_CLK>,
+					 <&camcc CAM_CC_IFE_0_CPHY_RX_CLK>,
+					 <&camcc CAM_CC_IFE_1_AXI_CLK>,
+					 <&camcc CAM_CC_IFE_1_CLK>,
+					 <&camcc CAM_CC_IFE_1_CPHY_RX_CLK>,
+					 <&camcc CAM_CC_IFE_LITE_CLK>,
+					 <&camcc CAM_CC_IFE_LITE_CPHY_RX_CLK>;
+
+			clock-names = "camnoc_axi",
+						  "cpas_ahb",
+						  "csi0",
+						  "csi1",
+						  "csi2",
+						  "csiphy0",
+						  "csiphy0_timer",
+						  "csiphy1",
+						  "csiphy1_timer",
+						  "csiphy2",
+						  "csiphy2_timer",
+						  "csiphy3",
+						  "csiphy3_timer",
+						  "gcc_camera_ahb",
+						  "gcc_camera_axi",
+						  "soc_ahb",
+						  "vfe0_axi",
+						  "vfe0",
+						  "vfe0_cphy_rx",
+						  "vfe1_axi",
+						  "vfe1",
+						  "vfe1_cphy_rx",
+						  "vfe_lite",
+						  "vfe_lite_cphy_rx";
+
+			interrupts = <GIC_SPI 464 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 466 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 473 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 477 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 478 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 479 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 461 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 465 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 467 IRQ_TYPE_LEVEL_HIGH>,
+						 <GIC_SPI 472 IRQ_TYPE_LEVEL_HIGH>;
+
+			interrupt-names = "csid0",
+							  "csid1",
+							  "csid2",
+							  "csiphy0",
+							  "csiphy1",
+							  "csiphy2",
+							  "csiphy3",
+							  "vfe0",
+							  "vfe1",
+							  "vfe_lite";
+
+			iommus = <&apps_smmu 0x820 0x0>,
+					 <&apps_smmu 0x840 0x0>,
+					 <&apps_smmu 0x860 0x0>;
+
+			interconnects = <&gem_noc MASTER_APPSS_PROC 0 &config_noc SLAVE_CAMERA_CFG 0>,
+					<&camnoc_virt MASTER_CAMNOC_HF0_UNCOMP 0 &camnoc_virt SLAVE_CAMNOC_UNCOMP 0>,
+					<&camnoc_virt MASTER_CAMNOC_HF1_UNCOMP 0 &camnoc_virt SLAVE_CAMNOC_UNCOMP 0>,
+					<&camnoc_virt MASTER_CAMNOC_SF_UNCOMP 0 &camnoc_virt SLAVE_CAMNOC_UNCOMP 0>;
+			interconnect-names = "cam_ahb",
+					     "cam_hf_0_camnoc",
+					     "cam_hf_1_camnoc",
+					     "cam_sf_camnoc";
+
+			power-domains = <&camcc IFE_0_GDSC>,
+							<&camcc IFE_1_GDSC>,
+							<&camcc TITAN_TOP_GDSC>;
+
+			power-domain-names = "ife0", "ife1", "top";
+
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+				};
+
+				port@1 {
+					reg = <1>;
+				};
+
+				port@2 {
+					reg = <2>;
+				};
+
+				port@3 {
+					reg = <3>;
+				};
+			};
+		};
+
+		cci0: cci@ac4a000 {
+			compatible = "qcom,sc7180-cci", "qcom,msm8996-cci";
+			reg = <0 0x0ac4a000 0 0x1000>;
+			interrupts = <GIC_SPI 468 IRQ_TYPE_EDGE_RISING>;
+			power-domains = <&camcc TITAN_TOP_GDSC>;
+
+			clocks = <&camcc CAM_CC_CAMNOC_AXI_CLK>,
+				 <&camcc CAM_CC_SOC_AHB_CLK>,
+				 <&camcc CAM_CC_SLOW_AHB_CLK_SRC>,
+				 <&camcc CAM_CC_CPAS_AHB_CLK>,
+				 <&camcc CAM_CC_CCI_0_CLK>,
+				 <&camcc CAM_CC_CCI_0_CLK_SRC>;
+			clock-names = "camnoc_axi",
+				      "soc_ahb",
+				      "slow_ahb_src",
+				      "cpas_ahb",
+				      "cci",
+				      "cci_src";
+
+			pinctrl-0 = <&cci0_default &cci1_default>;
+			pinctrl-1 = <&cci0_sleep &cci1_sleep>;
+			pinctrl-names = "default", "sleep";
+
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			cci0_i2c0: i2c-bus@0 {
+				reg = <0>;
+				clock-frequency = <1000000>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+
+			cci0_i2c1: i2c-bus@1 {
+				reg = <1>;
+				clock-frequency = <1000000>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+		};
+
+		cci1: cci@ac4b000 {
+			compatible = "qcom,sc7180-cci", "qcom,msm8996-cci";
+			reg = <0 0x0ac4b000 0 0x1000>;
+			interrupts = <GIC_SPI 462 IRQ_TYPE_EDGE_RISING>;
+			power-domains = <&camcc TITAN_TOP_GDSC>;
+
+			clocks = <&camcc CAM_CC_CAMNOC_AXI_CLK>,
+				<&camcc CAM_CC_SOC_AHB_CLK>,
+				<&camcc CAM_CC_SLOW_AHB_CLK_SRC>,
+				<&camcc CAM_CC_CPAS_AHB_CLK>,
+				<&camcc CAM_CC_CCI_1_CLK>,
+				<&camcc CAM_CC_CCI_1_CLK_SRC>;
+			clock-names = "camnoc_axi",
+				"soc_ahb",
+				"slow_ahb_src",
+				"cpas_ahb",
+				"cci",
+				"cci_src";
+
+			pinctrl-0 = <&cci2_default>;
+			pinctrl-1 = <&cci2_sleep>;
+			pinctrl-names = "default", "sleep";
+
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			cci1_i2c0: i2c-bus@0 {
+				reg = <0>;
+				clock-frequency = <1000000>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+
+			cci1_i2c1: i2c-bus@1 {
+				reg = <1>;
+				clock-frequency = <1000000>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+		};
+
 		camcc: clock-controller@ad00000 {
 			compatible = "qcom,sc7180-camcc";
 			reg = <0 0x0ad00000 0 0x10000>;
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-common.dtsi b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-common.dtsi
index b9cff60efe6fc0..d1435e696c8699 100644
--- a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-common.dtsi
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-common.dtsi
@@ -8,7 +8,11 @@
 #include <dt-bindings/arm/qcom,ids.h>
 #include <dt-bindings/firmware/qcom,scm.h>
 #include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/dma/qcom-gpi.h>
 #include <dt-bindings/regulator/qcom,rpmh-regulator.h>
+#include <dt-bindings/usb/pd.h>
+#include <dt-bindings/sound/qcom,q6asm.h>
 #include "sm7125.dtsi"
 #include "pm6150.dtsi"
 #include "pm6150l.dtsi"
@@ -25,16 +29,21 @@
 		#address-cells = <2>;
 		#size-cells = <2>;
 		ranges;
+	};
 
-		framebuffer@9c000000 {
-			compatible = "simple-framebuffer";
-			reg = <0x0 0x9c000000 0x0 (1080 * 2400 * 4)>;
-			width = <1080>;
-			height = <2400>;
-			stride = <(1080 * 4)>;
-			format = "a8r8g8b8";
-			clocks = <&gcc GCC_DISP_HF_AXI_CLK>;
-		};
+	aliases {
+		bluetooth0 = &bluetooth;
+		hsuart0 = &uart3;
+		wifi0 = &wifi;
+	};
+
+	battery: battery {
+		compatible = "simple-battery";
+
+		charge-full-design-microamp-hours = <5020000>;
+
+		voltage-min-design-microvolt = <3400000>;
+		voltage-max-design-microvolt = <4400000>;
 	};
 
 	gpio_keys: gpio-keys {
@@ -108,6 +117,44 @@
 			qcom,vmid = <QCOM_SCM_VMID_MSS_MSA>;
 		};
 	};
+
+	wcd937x: codec {
+		compatible = "qcom,wcd9375-codec";
+
+		reset-gpios = <&tlmm 58 GPIO_ACTIVE_LOW>;
+
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&wcd_reset_n>;
+		pinctrl-1 = <&wcd_reset_n_sleep>;
+
+		vdd-buck-supply = <&vreg_l15a_1p8>;
+		vdd-rxtx-supply = <&vreg_l10a_1p8>;
+		vdd-px-supply = <&vreg_l10a_1p8>;
+		vdd-mic-bias-supply = <&vreg_bob>;
+
+		qcom,micbias1-microvolt = <1800000>;
+		qcom,micbias2-microvolt = <1800000>;
+		qcom,micbias3-microvolt = <1800000>;
+		qcom,micbias4-microvolt = <1800000>;
+		qcom,mbhc-buttons-vthreshold-microvolt = <75000 150000 237000 500000 500000 500000 500000 500000>;
+		qcom,mbhc-headset-vthreshold-microvolt = <1700000>;
+		qcom,mbhc-headphone-vthreshold-microvolt = <50000>;
+		qcom,rx-device = <&wcd_rx>;
+		qcom,tx-device = <&wcd_tx>;
+
+		#sound-dai-cells = <1>;
+	};
+};
+
+&pm6150l_gpios {
+	panel_reset_pins: panel-reset{
+		pins = "gpio3";
+		function = "func1";
+		qcom,drive-strength = <2>;
+		power-source = <0>;
+		bias-disable;
+		output-low;
+	};
 };
 
 &apps_rsc {
@@ -328,9 +375,131 @@
 	};
 };
 
-&dispcc {
-	/* HACK: disable until a panel driver is ready to retain simplefb */
-	status = "disabled";
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	vdda-supply = <&vreg_l3c_1p23>;
+	status = "okay";
+
+	panel: panel@0 {
+		reg = <0>;
+
+		vddio-supply = <&vreg_l18a_3p0>;
+
+		reset-gpios = <&pm6150l_gpios 3 GPIO_ACTIVE_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&panel_reset_pins &panel_te_pin>;
+
+		backlight = <&pm6150l_wled>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	remote-endpoint = <&panel_in>;
+	data-lanes = <0 1 2 3>;
+};
+
+&mdss_dsi0_phy {
+	status = "okay";
+};
+
+// Because miatoll uses SM7125-AB with reduced gpu frequencies
+/delete-node/ &gpu_opp_table;
+&gpu {
+	gpu_opp_table: opp-table {
+		compatible = "operating-points-v2";
+
+		opp-750000000 {
+			opp-hz = /bits/ 64 <750000000>;
+			opp-level = <RPMH_REGULATOR_LEVEL_NOM_L1>;
+			opp-peak-kBps = <7216000>;
+			opp-supported-hw = <0x08>;
+		};
+
+		opp-650000000 {
+			opp-hz = /bits/ 64 <650000000>;
+			opp-level = <RPMH_REGULATOR_LEVEL_NOM_L1>;
+			opp-peak-kBps = <7216000>;
+			opp-supported-hw = <0x08>;
+		};
+
+		opp-565000000 {
+			opp-hz = /bits/ 64 <565000000>;
+			opp-level = <RPMH_REGULATOR_LEVEL_NOM>;
+			opp-peak-kBps = <5412000>;
+			opp-supported-hw = <0x08>;
+		};
+
+		opp-430000000 {
+			opp-hz = /bits/ 64 <430000000>;
+			opp-level = <RPMH_REGULATOR_LEVEL_SVS_L1>;
+			opp-peak-kBps = <5412000>;
+			opp-supported-hw = <0x08>;
+		};
+
+		opp-355000000 {
+			opp-hz = /bits/ 64 <355000000>;
+			opp-level = <RPMH_REGULATOR_LEVEL_SVS>;
+			opp-peak-kBps = <3072000>;
+			opp-supported-hw = <0x08>;
+		};
+
+		opp-267000000 {
+			opp-hz = /bits/ 64 <267000000>;
+			opp-level = <RPMH_REGULATOR_LEVEL_LOW_SVS>;
+			opp-peak-kBps = <3072000>;
+			opp-supported-hw = <0x08>;
+		};
+
+		opp-180000000 {
+			opp-hz = /bits/ 64 <180000000>;
+			opp-level = <RPMH_REGULATOR_LEVEL_MIN_SVS>;
+			opp-peak-kBps = <1804000>;
+			opp-supported-hw = <0x08>;
+		};
+	};
+
+	zap-shader {
+		firmware-name = "qcom/sm7125/miatoll/a615_zap.mbn";
+		memory-region = <&gpu_mem>;
+	};
+};
+
+&ipa {
+	firmware-name = "qcom/sm7125/miatoll/ipa_fws.mbn";
+	memory-region = <&ipa_fw_mem>;
+	status = "okay";
+};
+
+&pm6150l_lpg {
+	status = "okay";
+
+	led@1 {
+		reg = <1>;
+		color = <LED_COLOR_ID_WHITE>;
+		function = LED_FUNCTION_STATUS;
+	};
+};
+
+&pm6150l_wled {
+	qcom,cabc;
+	qcom,cabc-sel = <1>;
+	qcom,num-strings = <3>;
+	status = "okay";
+};
+
+&pm6150_qgauge {
+	monitored-battery = <&battery>;
+	status = "okay";
 };
 
 &pm6150_resin {
@@ -342,6 +511,96 @@
 	status = "okay";
 };
 
+&pm6150_typec {
+	vdd-vbus-supply = <&pm6150_vbus>;
+	vdd-pdphy-supply = <&vreg_l17a_3p1>;
+	status = "okay";
+
+	connector {
+		compatible = "usb-c-connector";
+
+		power-role = "source";
+		data-role = "dual";
+		self-powered;
+
+		source-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_DUAL_ROLE |
+				PDO_FIXED_USB_COMM | PDO_FIXED_DATA_SWAP)>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				pm6150_role_switch_in: endpoint {
+					remote-endpoint = <&usb_1_dwc3_hs>;
+				};
+			};
+		};
+	};
+};
+
+&pm6150_vbus {
+	regulator-min-microamp = <500000>;
+	regulator-max-microamp = <3000000>;
+	status = "okay";
+};
+
+&pm6150l_flash {
+	status = "okay";
+
+	led-1 {
+		function = LED_FUNCTION_FLASH;
+		color = <LED_COLOR_ID_WHITE>;
+		led-sources = <1>;
+		led-max-microamp = <150000>;
+		flash-max-microamp = <1000000>;
+		flash-max-timeout-us = <1280000>;
+	};
+};
+
+&wifi {
+	status = "okay";
+
+	vdd-0.8-cx-mx-supply = <&vreg_l9a_0p664>;
+	vdd-1.8-xo-supply = <&vreg_l1c_1p8>;
+	vdd-1.3-rfa-supply = <&vreg_l2c_1p3>;
+	vdd-3.3-ch0-supply = <&vreg_l10c_3p3>;
+	vdd-3.3-ch1-supply = <&vreg_l11c_3p3>;
+};
+
+&qupv3_id_0 {
+	status = "okay";
+};
+
+&qupv3_id_1 {
+	status = "okay";
+};
+
+&gpi_dma0 {
+	status = "okay";
+};
+
+&gpi_dma1 {
+	status = "okay";
+};
+
+&remoteproc_adsp {
+	memory-region = <&adsp_mem>;
+	firmware-name = "qcom/sm7125/miatoll/adsp.mbn";
+	status = "okay";
+};
+
+&remoteproc_cdsp {
+	firmware-name = "qcom/sm7125/miatoll/cdsp.mbn";
+	status = "okay";
+};
+
+&remoteproc_mpss {
+	firmware-name = "qcom/sm7125/miatoll/modem.mbn";
+	status = "okay";
+};
+
 &sdhc_2 {
 	cd-gpios = <&tlmm 69 GPIO_ACTIVE_HIGH>;
 	pinctrl-names = "default","sleep";
@@ -408,6 +667,345 @@
 			drive-strength = <2>;
 		};
 	};
+
+	qup_uart3_sleep: qup-uart3-sleep-state {
+		pinmux {
+			pins = "gpio38", "gpio39",
+				"gpio40", "gpio41";
+			function = "gpio";
+		};
+
+		pinconf-cts {
+			/*
+			 * Configure a pull-down on CTS to match the pull of
+			 * the Bluetooth module.
+			 */
+			pins = "gpio38";
+			bias-pull-down;
+		};
+
+		pinconf-rts {
+			/*
+			 * Configure pull-down on RTS. As RTS is active low
+			 * signal, pull it low to indicate the BT SoC that it
+			 * can wakeup the system anytime from suspend state by
+			 * pulling RX low (by sending wakeup bytes).
+			 */
+			pins = "gpio39";
+			bias-pull-down;
+		};
+
+		pinconf-tx {
+			/*
+			 * Configure pull-up on TX when it isn't actively driven
+			 * to prevent BT SoC from receiving garbage during sleep.
+			 */
+			pins = "gpio40";
+			bias-pull-up;
+		};
+
+		pinconf-rx {
+			/*
+			 * Configure a pull-up on RX. This is needed to avoid
+			 * garbage data when the TX pin of the Bluetooth module
+			 * is floating which may cause spurious wakeups.
+			 */
+			pins = "gpio41";
+			bias-pull-up;
+		};
+	};
+
+	ts_reset_active: ts-reset-active-state {
+		pins = "gpio8";
+		function = "gpio";
+		drive-strength = <16>;
+		bias-pull-up;
+	};
+
+	ts_reset_suspend: ts-reset-suspend-state {
+		pins = "gpio8";
+		function = "gpio";
+		drive-strength = <16>;
+		bias-disable;
+		output-high;
+	};
+
+	ts_int_active: ts-int-active-state {
+		pins = "gpio9";
+		function = "gpio";
+		drive-strength = <16>;
+		bias-pull-up;
+	};
+
+	ts_int_suspend: ts-int-suspend-state {
+		pins = "gpio9";
+		function = "gpio";
+		drive-strength = <16>;
+		input-enable;
+		bias-disable;
+	};
+
+	panel_te_pin: panel-te {
+		mux {
+			pins = "gpio10";
+			function = "mdp_vsync";
+			drive-strength = <2>;
+			bias-pull-down;
+		};
+	};
+
+	ter_mi2s_active: ter-mi2s-active-state {
+		pins = "gpio63", "gpio64", "gpio65", "gpio66";
+		function = "mi2s_2";
+	};
+
+	wcd_reset_n: wcd-reset-n-state {
+		pins = "gpio58";
+		function = "gpio";
+		drive-strength = <8>;
+	};
+
+	wcd_reset_n_sleep: wcd-reset-n-sleep-state {
+		pins = "gpio58";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+};
+
+&i2c9 {
+	status = "okay";
+	clock-frequency = <100000>;
+
+	dmas = <&gpi_dma1 0 3 QCOM_GPI_I2C>,
+			<&gpi_dma1 1 3 QCOM_GPI_I2C>;
+	dma-names = "tx", "rx";
+
+	tas2562: codec@4c {
+			compatible = "ti,tas2562";
+			reg = <0x4c>;
+			#sound-dai-cells = <0>;
+			interrupt-parent = <&tlmm>;
+			interrupts = <33 0>;
+			shutdown-gpios = <&tlmm 51 0>;
+			ti,vmon-slot-no = <2>;
+			ti,imon-slot-no = <0>;
+	};
+};
+
+&spi10 {
+	status = "okay";
+	clock-frequency = <50000000>;
+
+	dmas = <&gpi_dma1 0 4 QCOM_GPI_SPI>,
+		<&gpi_dma1 1 4 QCOM_GPI_SPI>;
+	dma-names = "tx", "rx";
+
+	irled@0 {
+		compatible = "ir-spi-led";
+		reg = <0x0>;
+
+		spi-max-frequency = <19200000>;
+		power-supply = <&vreg_bob>;
+		duty-cycle = /bits/ 8 <60>;
+		led-active-low;
+	};
+};
+
+&spi11 {
+	status = "okay";
+	clock-frequency = <8000000>;
+
+	dmas = <&gpi_dma1 0 5 QCOM_GPI_SPI>,
+		<&gpi_dma1 1 5 QCOM_GPI_SPI>;
+	dma-names = "tx", "rx";
+
+	touchscreen: touchscreen@0 {
+		reg = <0>;
+
+		spi-max-frequency = <8000000>;
+
+		pinctrl-0 = <&ts_int_active &ts_reset_active>;
+		pinctrl-1 = <&ts_int_suspend &ts_reset_suspend>;
+		pinctrl-names = "default", "sleep";
+
+		irq-gpio = <&tlmm 9 IRQ_TYPE_EDGE_FALLING>;
+
+		vio-supply = <&vreg_l18a_3p0>;
+
+		panel = <&panel>;
+	};
+};
+
+&sound {
+	compatible = "qcom,sm8250-sndcard";
+	pinctrl-0 = <&ter_mi2s_active>;
+	pinctrl-names = "default";
+	model = "Xiaomi-miatoll";
+	audio-routing =
+		"IN1_HPHL", "HPHL_OUT",
+		"IN2_HPHR", "HPHR_OUT",
+		"AMIC1", "MIC BIAS1",
+		"AMIC2", "MIC BIAS2",
+		"AMIC3", "MIC BIAS3",
+		"TX SWR_ADC0", "ADC1_OUTPUT",
+		"TX SWR_ADC2", "ADC2_OUTPUT";
+
+	mm1-dai-link {
+		link-name = "MultiMedia1";
+		cpu {
+			sound-dai = <&q6asmdai MSM_FRONTEND_DAI_MULTIMEDIA1>;
+		};
+	};
+
+	mm2-dai-link {
+		link-name = "MultiMedia2";
+		cpu {
+			sound-dai = <&q6asmdai MSM_FRONTEND_DAI_MULTIMEDIA2>;
+		};
+	};
+
+	mm3-dai-link {
+		link-name = "MultiMedia3";
+		cpu {
+			sound-dai = <&q6asmdai MSM_FRONTEND_DAI_MULTIMEDIA3>;
+		};
+	};
+
+	i2s-dai-link {
+		link-name = "I2S Playback";
+		cpu {
+			sound-dai = <&q6afedai TERTIARY_MI2S_RX>;
+		};
+
+		platform {
+			sound-dai = <&q6routing>;
+		};
+
+		codec {
+			sound-dai = <&tas2562>;
+		};
+	};
+
+	wcd-playback-dai-link {
+		link-name = "WCD Playback";
+		cpu {
+			sound-dai = <&q6afedai RX_CODEC_DMA_RX_0>;
+		};
+
+		codec {
+			sound-dai = <&wcd937x 0>, <&swr1 0>, <&rxmacro 0>;
+		};
+
+		platform {
+			sound-dai = <&q6routing>;
+		};
+	};
+
+	wcd-capture-dai-link {
+		link-name = "WCD Capture";
+		cpu {
+			sound-dai = <&q6afedai TX_CODEC_DMA_TX_3>;
+		};
+
+		codec {
+			sound-dai = <&wcd937x 1>, <&swr2 0>, <&txmacro 0>;
+		};
+
+		platform {
+			sound-dai = <&q6routing>;
+		};
+	};
+};
+
+&swr1 {
+	status = "okay";
+
+	wcd_rx: codec@0,4 {
+		compatible = "sdw20217010a00";
+		reg = <0 4>;
+
+		qcom,rx-port-mapping = <1 2 3 4 5>;
+	};
+};
+
+&swr2 {
+	status = "okay";
+	wcd_tx: codec@0,3 {
+		compatible = "sdw20217010a00";
+		reg = <0 3>;
+
+		qcom,tx-port-mapping = <2 3 4 5>;
+	};
+};
+
+&q6afedai {
+	dai@20 {
+		reg = <TERTIARY_MI2S_RX>;
+		qcom,sd-lines = <0>;
+	};
+
+	dai@113 {
+		reg = <RX_CODEC_DMA_RX_0>;
+	};
+
+	dai@120 {
+		reg = <TX_CODEC_DMA_TX_3>;
+	};
+};
+
+&q6asmdai {
+	dai@0 {
+		reg = <0>;
+	};
+
+	dai@1 {
+		reg = <1>;
+	};
+
+	dai@2 {
+		reg = <2>;
+	};
+};
+
+&qfprom {
+	vcc-supply = <&vreg_l11a_1p8>;
+};
+
+&rxmacro {
+	status = "okay";
+};
+
+&txmacro {
+	status = "okay";
+};
+
+&vamacro {
+	qcom,dmic-sample-rate = <600000>;
+	status = "okay";
+};
+
+&uart3 {
+	/delete-property/interrupts;
+	interrupts-extended = <&intc GIC_SPI 604 IRQ_TYPE_LEVEL_HIGH>,
+				<&tlmm 41 IRQ_TYPE_EDGE_FALLING>;
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-1 = <&qup_uart3_sleep>;
+
+	status = "okay";
+
+	bluetooth: bluetooth {
+		compatible = "qcom,wcn3991-bt";
+
+		vddio-supply = <&vreg_l10a_1p8>;
+		vddxo-supply = <&vreg_l1c_1p8>;
+		vddrf-supply = <&vreg_l2c_1p3>;
+		vddch0-supply = <&vreg_l10c_3p3>;
+		swctrl-gpios = <&tlmm 73 GPIO_ACTIVE_HIGH>;
+
+		max-speed = <3200000>;
+	};
 };
 
 &ufs_mem_hc {
@@ -432,11 +1030,16 @@
 };
 
 &usb_1_dwc3 {
-	dr_mode = "peripheral";
+	dr_mode = "otg";
+	usb-role-switch;
 	maximum-speed = "high-speed";
 	status = "okay";
 };
 
+&usb_1_dwc3_hs {
+	remote-endpoint = <&pm6150_role_switch_in>;
+};
+
 &usb_1_hsphy {
 	vdd-supply = <&vreg_l4a_0p88>;
 	vdda-phy-dpdm-supply = <&vreg_l17a_3p1>;
@@ -449,3 +1052,8 @@
 	vdda-pll-supply = <&vreg_l3c_1p23>;
 	status = "okay";
 };
+
+&venus {
+	firmware-name = "qcom/sm7125/miatoll/venus.mbn";
+	status = "okay";
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana-huaxing.dts b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana-huaxing.dts
new file mode 100644
index 00000000000000..ecba5812a5b907
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana-huaxing.dts
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023, Joe Mason <buddyjojo06@outlook.com>
+ */
+
+/dts-v1/;
+
+#include "sm7125-xiaomi-curtana.dtsi"
+
+/ {
+	model = "Xiaomi Redmi Note 9S (Huaxing)";
+};
+
+&panel { compatible = "mdss,ft8756-huaxing"; };
+&touchscreen {
+	compatible = "focaltech,ft8756-spi";
+	firmware-name = "focaltech_ts_fw_huaxing.bin";
+	reset-gpio = <&tlmm 8 GPIO_ACTIVE_LOW>;
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana-tianma.dts b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana-tianma.dts
new file mode 100644
index 00000000000000..14e74f4a48cc00
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana-tianma.dts
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023, Joe Mason <buddyjojo06@outlook.com>
+ */
+
+/dts-v1/;
+
+#include "sm7125-xiaomi-curtana.dtsi"
+
+/ {
+	model = "Xiaomi Redmi Note 9S (Tianma)";
+};
+
+&panel { compatible = "mdss,nt36675-tianma"; };
+&touchscreen {
+	compatible = "novatek,nt36xxx-spi";
+	firmware-name = "novatek_ts_tianma_fw.bin";
+	reset-gpio = <&tlmm 8 GPIO_ACTIVE_HIGH>;
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana.dtsi b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana.dtsi
new file mode 100644
index 00000000000000..22a28933a777be
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana.dtsi
@@ -0,0 +1,287 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023, Joe Mason <buddyjojo06@outlook.com>
+ */
+
+/dts-v1/;
+
+#include "sm7125-xiaomi-common.dtsi"
+
+/ {
+	compatible = "xiaomi,curtana", "qcom,sm7125";
+	/* required for bootloader to select correct board */
+	qcom,board-id = <0x20022 1>;
+
+	ultra_avdd_2p8: regulator-ultra-avdd-2p8 {
+		compatible = "regulator-fixed";
+		regulator-name = "ultra_avdd_2p8";
+		regulator-min-microvolt = <2800000>;
+		regulator-max-microvolt = <2800000>;
+		regulator-enable-ramp-delay = <100>;
+		enable-active-high;
+		gpio = <&pm6150l_gpios 8 0>;
+		vin-supply = <&vreg_bob>;
+	};
+
+	ultra_dvdd_1p2: regulator-ultra-dvdd-1p2 {
+		compatible = "regulator-fixed";
+		regulator-name = "ultra_dvdd_1p2";
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+		regulator-enable-ramp-delay = <100>;
+		enable-active-high;
+		gpio = <&tlmm 72 0>;
+		vin-supply = <&vreg_s5a_2p0>;
+	};
+
+	wide_afvdd_2p8: regulator-wide-afvdd-2p8 {
+		compatible = "regulator-fixed";
+		regulator-name = "wide_afvdd_2p8";
+		regulator-min-microvolt = <2800000>;
+		regulator-max-microvolt = <2800000>;
+		regulator-enable-ramp-delay = <100>;
+		enable-active-high;
+		gpio = <&pm6150l_gpios 6 0>;
+		vin-supply = <&vreg_bob>;
+	};
+
+	wide_avdd1_2p8: regulator-wide-avdd1-2p8 {
+		compatible = "regulator-fixed";
+		regulator-name = "wide_avdd1_2p8";
+		regulator-min-microvolt = <2800000>;
+		regulator-max-microvolt = <2800000>;
+		regulator-enable-ramp-delay = <100>;
+		enable-active-high;
+		gpio = <&pm6150l_gpios 9 0>;
+		vin-supply = <&vreg_bob>;
+	};
+
+	wide_dvdd_1p2: regulator-wide-dvdd1-1p2 {
+		compatible = "regulator-fixed";
+		regulator-name = "wide_dvdd_1p2";
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+		regulator-enable-ramp-delay = <100>;
+		enable-active-high;
+		gpio = <&tlmm 42 0>;
+		vin-supply = <&vreg_s5a_2p0>;
+	};
+};
+
+&camss {
+	vdda-phy-supply = <&vreg_l4a_0p88>;
+	vdda-pll-supply = <&vreg_l3c_1p23>;
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			csiphy1_ep: endpoint {
+				data-lanes = <0 1 2 3>;
+				remote-endpoint = <&cam_s5kgm2_ep>;
+			};
+		};
+
+		port@2 {
+			csiphy2_ep: endpoint {
+				data-lanes = <0 1>;
+				remote-endpoint = <&cam_s5k5e9_ep>;
+			};
+		};
+
+		port@3 {
+			csiphy3_ep: endpoint {
+				data-lanes = <0 1 2 3>;
+				remote-endpoint = <&cam_ov16a1q_ep>;
+			};
+		};
+	};
+};
+
+&cci0 {
+	status = "okay";
+};
+
+&cci1 {
+	status = "okay";
+};
+
+&cci0_i2c0 {
+	status = "okay";
+
+	/* S5KGM2 EEPROM @ 0x51 */
+	/* S5KGM2 dw9800 VCM @ 0xC */
+
+	s5kgm2@10 {
+		compatible = "samsung,s5kgm2";
+		reg = <0x10>;
+
+		vio-supply = <&vreg_l13a_1p8>;
+		vana-supply = <&wide_avdd1_2p8>;
+		vdig-supply = <&wide_dvdd_1p2>;
+
+		clocks = <&camcc CAM_CC_MCLK1_CLK>;
+		clock-names = "xvclk";
+		clock-frequency = <19200000>;
+		assigned-clocks = <&camcc CAM_CC_MCLK1_CLK>;
+		assigned-clock-rates = <19200000>;
+
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&cam_s5kgm2_default>;
+
+		orientation = <1>;
+		rotation = <270>;
+
+		port {
+			cam_s5kgm2_ep: endpoint {
+				data-lanes = <0 1 2 3>;
+				link-frequencies = /bits/ 64 <720000000>;
+				remote-endpoint = <&csiphy1_ep>;
+			};
+		};
+	};
+};
+
+&cci0_i2c1 {
+	status = "okay";
+
+	/* S5K5E9 EEPROM @ 0x51 */
+
+	s5k5e9_vcm: dw9714@c {
+		compatible = "dongwoon,dw9714";
+		reg = <0x0c>;
+		vcc-supply = <&wide_afvdd_2p8>;
+		vcc2-supply = <&vreg_l13a_1p8>;
+	};
+
+	s5k5e9@2d {
+		compatible = "samsung,s5k5e9";
+		reg = <0x2d>;
+
+		vio-supply = <&vreg_l13a_1p8>;
+		vana-supply = <&ultra_avdd_2p8>;
+		vdig-supply = <&ultra_dvdd_1p2>;
+
+		clocks = <&camcc CAM_CC_MCLK2_CLK>;
+		clock-names = "xvclk";
+		clock-frequency = <19200000>;
+		assigned-clocks = <&camcc CAM_CC_MCLK2_CLK>;
+		assigned-clock-rates = <19200000>;
+
+		reset-gpios = <&tlmm 24 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&cam_s5k5e9_default>;
+
+		orientation = <1>;
+		rotation = <270>;
+
+		lens-focus = <&s5k5e9_vcm>;
+
+		port {
+			cam_s5k5e9_ep: endpoint {
+				data-lanes = <0 1>;
+				link-frequencies = /bits/ 64 <480000000>;
+				remote-endpoint = <&csiphy2_ep>;
+			};
+		};
+	};
+
+	/* OV8856 EEPROM @ 0x54 */
+	/* OV8856 SENSOR @ 0x36 */
+};
+
+&cci1_i2c0 {
+	status = "okay";
+
+	/* GC02M1 EEPROM @ 0x54 */
+	/* GC02M1 @ 0x37 */
+
+	/* OV16A1Q EEPROM @ 0x50 */
+
+	ov16a1q@10 {
+		compatible = "ovti,ov16a1q";
+		reg = <0x10>;
+
+		vio-supply = <&vreg_l13a_1p8>;
+		vana-supply = <&ultra_avdd_2p8>;
+		vdig-supply = <&ultra_dvdd_1p2>;
+
+		clocks = <&camcc CAM_CC_MCLK0_CLK>;
+		clock-names = "xvclk";
+		clock-frequency = <19200000>;
+		assigned-clocks = <&camcc CAM_CC_MCLK0_CLK>;
+		assigned-clock-rates = <19200000>;
+
+		reset-gpios = <&tlmm 32 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&cam_ov16a1q_default>;
+
+		orientation = <0>;
+		rotation = <90>;
+
+		port {
+			cam_ov16a1q_ep: endpoint {
+				data-lanes = <0 1 2 3>;
+				link-frequencies = /bits/ 64 <180000000>;
+				remote-endpoint = <&csiphy3_ep>;
+			};
+		};
+	};
+};
+
+&cci1_i2c1 {
+	status = "disabled";
+};
+
+&tlmm {
+	cam_s5kgm2_default: cam-s5kgm2-default-state {
+		rst-pins {
+			pins = "gpio25";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-disable;
+		};
+
+		mclk1-pins {
+			pins = "gpio14";
+			function = "cam_mclk";
+			drive-strength = <2>;
+			bias-disable;
+		};
+	};
+
+	cam_s5k5e9_default: cam-s5k5e9-default-state {
+		rst-pins {
+			pins = "gpio24";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-disable;
+		};
+
+		mclk2-pins {
+			pins = "gpio15";
+			function = "cam_mclk";
+			drive-strength = <2>;
+			bias-disable;
+		};
+	};
+
+	cam_ov16a1q_default: cam-ov16a1q-default-state {
+		rst-pins {
+			pins = "gpio32";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-disable;
+		};
+
+		mclk0-pins {
+			pins = "gpio13";
+			function = "cam_mclk";
+			drive-strength = <2>;
+			bias-disable;
+		};
+	};
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram-huaxing.dts b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram-huaxing.dts
new file mode 100644
index 00000000000000..d8fb6023049090
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram-huaxing.dts
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023, Joe Mason <buddyjojo06@outlook.com>
+ */
+
+/dts-v1/;
+
+#include "sm7125-xiaomi-gram.dtsi"
+
+/ {
+	model = "Xiaomi POCO M2 Pro (Huaxing)";
+};
+
+&panel { compatible = "mdss,ft8756-huaxing"; };
+&touchscreen {
+	compatible = "focaltech,ft8756-spi";
+	firmware-name = "focaltech_ts_fw_huaxing.bin";
+	reset-gpio = <&tlmm 8 GPIO_ACTIVE_LOW>;
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram-tianma.dts b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram-tianma.dts
new file mode 100644
index 00000000000000..d2a33ca377adcb
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram-tianma.dts
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023, Joe Mason <buddyjojo06@outlook.com>
+ */
+
+/dts-v1/;
+
+#include "sm7125-xiaomi-gram.dtsi"
+
+/ {
+	model = "Xiaomi POCO M2 Pro (Tianma)";
+};
+
+&panel { compatible = "mdss,nt36675-tianma"; };
+&touchscreen {
+	compatible = "novatek,nt36xxx-spi";
+	firmware-name = "novatek_ts_tianma_fw.bin";
+	reset-gpio = <&tlmm 8 GPIO_ACTIVE_HIGH>;
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana.dts b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram.dtsi
similarity index 64%
rename from arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana.dts
rename to arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram.dtsi
index 12f517a8492c37..3ee5d1e3d6a780 100644
--- a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-curtana.dts
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-gram.dtsi
@@ -8,9 +8,7 @@
 #include "sm7125-xiaomi-common.dtsi"
 
 / {
-	model = "Xiaomi Redmi Note 9S";
-	compatible = "xiaomi,curtana", "qcom,sm7125";
-
+	compatible = "xiaomi,gram", "qcom,sm7125";
 	/* required for bootloader to select correct board */
-	qcom,board-id = <0x20022 1>;
-};
+	qcom,board-id = <0x60022 1>;
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse-huaxing.dts b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse-huaxing.dts
new file mode 100644
index 00000000000000..2da09dbf3602a0
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse-huaxing.dts
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021, The Linux Foundation. All rights reserved.
+ */
+
+/dts-v1/;
+
+#include "sm7125-xiaomi-joyeuse.dtsi"
+
+/ {
+	model = "Xiaomi Redmi Note 9 Pro (Global, Huaxing)";
+};
+
+&panel { compatible = "mdss,ft8756-huaxing"; };
+&touchscreen {
+	compatible = "focaltech,ft8756-spi";
+	firmware-name = "focaltech_ts_fw_huaxing.bin";
+	reset-gpio = <&tlmm 8 GPIO_ACTIVE_LOW>;
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse-tianma.dts b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse-tianma.dts
new file mode 100644
index 00000000000000..d2d57a18965a26
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse-tianma.dts
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021, The Linux Foundation. All rights reserved.
+ */
+
+/dts-v1/;
+
+#include "sm7125-xiaomi-joyeuse.dtsi"
+
+/ {
+	model = "Xiaomi Redmi Note 9 Pro (Global, Tianma)";
+};
+
+&panel { compatible = "mdss,nt36675-tianma"; };
+&touchscreen {
+	compatible = "novatek,nt36xxx-spi";
+	firmware-name = "novatek_ts_tianma_fw.bin";
+	reset-gpio = <&tlmm 8 GPIO_ACTIVE_HIGH>;
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse.dts b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse.dts
deleted file mode 100644
index e010d195750936..00000000000000
--- a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse.dts
+++ /dev/null
@@ -1,16 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- */
-
-/dts-v1/;
-
-#include "sm7125-xiaomi-common.dtsi"
-
-/ {
-	model = "Xiaomi Redmi Note 9 Pro (Global)";
-	compatible = "xiaomi,joyeuse", "qcom,sm7125";
-
-	/* required for bootloader to select correct board */
-	qcom,board-id = <0x50022 1>;
-};
diff --git a/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse.dtsi b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse.dtsi
new file mode 100644
index 00000000000000..d62f2e4ccd6dba
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-xiaomi-joyeuse.dtsi
@@ -0,0 +1,214 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021, The Linux Foundation. All rights reserved.
+ */
+
+/dts-v1/;
+
+#include "sm7125-xiaomi-common.dtsi"
+
+/ {
+	compatible = "xiaomi,joyeuse", "qcom,sm7125";
+	/* required for bootloader to select correct board */
+	qcom,board-id = <0x50022 1>;
+
+	ultra_avdd_2p8: regulator-ultra-avdd-2p8 {
+		compatible = "regulator-fixed";
+		regulator-name = "ultra_avdd_2p8";
+		regulator-min-microvolt = <2800000>;
+		regulator-max-microvolt = <2800000>;
+		regulator-enable-ramp-delay = <100>;
+		enable-active-high;
+		gpio = <&pm6150l_gpios 8 0>;
+		vin-supply = <&vreg_bob>;
+	};
+
+	ultra_dvdd_1p2: regulator-ultra-dvdd-1p2 {
+		compatible = "regulator-fixed";
+		regulator-name = "ultra_dvdd_1p2";
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+		regulator-enable-ramp-delay = <100>;
+		enable-active-high;
+		gpio = <&tlmm 72 0>;
+		vin-supply = <&vreg_s5a_2p0>;
+	};
+
+	wide_afvdd_2p8: regulator-wide-afvdd-2p8 {
+		compatible = "regulator-fixed";
+		regulator-name = "wide_afvdd_2p8";
+		regulator-min-microvolt = <2800000>;
+		regulator-max-microvolt = <2800000>;
+		regulator-enable-ramp-delay = <100>;
+		enable-active-high;
+		gpio = <&pm6150l_gpios 6 0>;
+		vin-supply = <&vreg_bob>;
+	};
+};
+
+&camss {
+	vdda-phy-supply = <&vreg_l4a_0p88>;
+	vdda-pll-supply = <&vreg_l3c_1p23>;
+
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@2 {
+			csiphy2_ep: endpoint {
+				data-lanes = <0 1>;
+				remote-endpoint = <&cam_s5k5e9_ep>;
+			};
+		};
+
+		port@3 {
+			csiphy3_ep: endpoint {
+				data-lanes = <0 1 2 3>;
+				remote-endpoint = <&cam_ov16a1q_ep>;
+			};
+		};
+	};
+};
+
+&cci0 {
+	status = "okay";
+};
+
+&cci1 {
+	status = "okay";
+};
+
+&cci0_i2c0 {
+	status = "okay";
+
+	/* S5KGW1 EEPROM @ 0x51 */
+	/* S5KGW1 dw9800 VCM @ 0xC */
+	/* S5KGW1 @ 0x3D */
+};
+
+&cci0_i2c1 {
+	status = "okay";
+
+	/* S5K5E9 EEPROM @ 0x51 */
+
+	s5k5e9_vcm: dw9714@c {
+		compatible = "dongwoon,dw9714";
+		reg = <0x0c>;
+		vcc-supply = <&wide_afvdd_2p8>;
+		vcc2-supply = <&vreg_l13a_1p8>;
+	};
+
+	s5k5e9@2d {
+		compatible = "samsung,s5k5e9";
+		reg = <0x2d>;
+
+		vio-supply = <&vreg_l13a_1p8>;
+		vana-supply = <&ultra_avdd_2p8>;
+		vdig-supply = <&ultra_dvdd_1p2>;
+
+		clocks = <&camcc CAM_CC_MCLK2_CLK>;
+		clock-names = "xvclk";
+		clock-frequency = <19200000>;
+		assigned-clocks = <&camcc CAM_CC_MCLK2_CLK>;
+		assigned-clock-rates = <19200000>;
+
+		reset-gpios = <&tlmm 24 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&cam_s5k5e9_default>;
+
+		orientation = <1>;
+		rotation = <270>;
+
+		lens-focus = <&s5k5e9_vcm>;
+
+		port {
+			cam_s5k5e9_ep: endpoint {
+				data-lanes = <0 1>;
+				link-frequencies = /bits/ 64 <480000000>;
+				remote-endpoint = <&csiphy2_ep>;
+			};
+		};
+	};
+
+	/* GC8034 EEPROM @ 0x54 */
+	/* GC8034 SENSOR @ 0x37 */
+};
+
+&cci1_i2c0 {
+	status = "okay";
+
+	/* OV2180 EEPROM @ 0x54 */
+	/* OV2180 @ 0x36 */
+
+	/* OV16A1Q EEPROM @ 0x50 */
+
+	ov16a1q@10 {
+		compatible = "ovti,ov16a1q";
+		reg = <0x10>;
+
+		vio-supply = <&vreg_l13a_1p8>;
+		vana-supply = <&ultra_avdd_2p8>;
+		vdig-supply = <&ultra_dvdd_1p2>;
+
+		clocks = <&camcc CAM_CC_MCLK0_CLK>;
+		clock-names = "xvclk";
+		clock-frequency = <19200000>;
+		assigned-clocks = <&camcc CAM_CC_MCLK0_CLK>;
+		assigned-clock-rates = <19200000>;
+
+		reset-gpios = <&tlmm 32 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&cam_ov16a1q_default>;
+
+		orientation = <0>;
+		rotation = <90>;
+
+		port {
+			cam_ov16a1q_ep: endpoint {
+				data-lanes = <0 1 2 3>;
+				link-frequencies = /bits/ 64 <720000000>;
+				remote-endpoint = <&csiphy3_ep>;
+			};
+		};
+	};
+};
+
+&cci1_i2c1 {
+	status = "disabled";
+};
+
+&tlmm {
+	cam_s5k5e9_default: cam-s5k5e9-default-state {
+		rst-pins {
+			pins = "gpio24";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-disable;
+		};
+
+		mclk2-pins {
+			pins = "gpio15";
+			function = "cam_mclk";
+			drive-strength = <2>;
+			bias-disable;
+		};
+	};
+
+	cam_ov16a1q_default: cam-ov16a1q-default-state {
+		rst-pins {
+			pins = "gpio32";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-disable;
+		};
+
+		mclk0-pins {
+			pins = "gpio13";
+			function = "cam_mclk";
+			drive-strength = <2>;
+			bias-disable;
+		};
+	};
+};
\ No newline at end of file
diff --git a/arch/arm64/boot/dts/qcom/sm7125.dtsi b/arch/arm64/boot/dts/qcom/sm7125.dtsi
index 12dd72859a433b..8e1f36aca4f791 100644
--- a/arch/arm64/boot/dts/qcom/sm7125.dtsi
+++ b/arch/arm64/boot/dts/qcom/sm7125.dtsi
@@ -4,6 +4,8 @@
  */
 
 #include "sc7180.dtsi"
+#include <dt-bindings/clock/qcom,sm8250-lpass-aoncc.h>
+#include <dt-bindings/clock/qcom,sm8250-lpass-audiocc.h>
 
 /* SM7125 uses Kryo 465 instead of Kryo 468 */
 &CPU0 { compatible = "qcom,kryo465"; };
@@ -14,3 +16,435 @@
 &CPU5 { compatible = "qcom,kryo465"; };
 &CPU6 { compatible = "qcom,kryo465"; };
 &CPU7 { compatible = "qcom,kryo465"; };
+
+&soc {
+	wsamacro: codec@62640000 {
+		compatible = "qcom,sm8250-lpass-wsa-macro";
+		reg = <0 0x62640000 0 0x1000>;
+		status = "disabled";
+		clocks = <&audiocc LPASS_CDC_WSA_MCLK>,
+				<&audiocc LPASS_CDC_WSA_NPL>,
+				<&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&lpass_aoncc LPASS_CDC_VA_MCLK>,
+				<&vamacro>;
+
+		clock-names = "mclk", "npl", "macro", "dcodec", "va", "fsgen";
+
+		#clock-cells = <0>;
+		clock-frequency = <19200000>;
+		clock-output-names = "mclk";
+		#sound-dai-cells = <1>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&wsa_swr_active>;
+	};
+
+	swr0: soundwire-controller@62650000 {
+		reg = <0 0x62650000 0 0x2000>;
+		compatible = "qcom,soundwire-v1.5.1";
+		status = "disabled";
+		interrupts = <GIC_SPI 295 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&wsamacro>;
+		clock-names = "iface";
+
+		qcom,din-ports = <2>;
+		qcom,dout-ports = <6>;
+
+		qcom,ports-sinterval-low =	/bits/ 8 <0x07 0x1f 0x3f 0x07 0x1f 0x3f 0x0f 0x0f>;
+		qcom,ports-offset1 =		/bits/ 8 <0x01 0x02 0x0c 0x06 0x12 0x0d 0x07 0x0a>;
+		qcom,ports-offset2 =		/bits/ 8 <0xff 0x00 0x1f 0xff 0x00 0x1f 0x00 0x00>;
+		qcom,ports-block-pack-mode =	/bits/ 8 <0x0 0x0 0x1 0x0 0x0 0x1 0x0 0x0>;
+
+		#sound-dai-cells = <1>;
+		#address-cells = <2>;
+		#size-cells = <0>;
+	};
+
+	audiocc: clock-controller@62700000 {
+		compatible = "qcom,sm8250-lpass-audiocc";
+		reg = <0 0x62700000 0 0x30000>;
+		#clock-cells = <1>;
+		clocks = <&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+			<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+			<&q6afecc LPASS_CLK_ID_TX_CORE_MCLK LPASS_CLK_ATTRIBUTE_COUPLE_NO>;
+		clock-names = "core", "audio", "bus";
+	};
+
+	vamacro: codec@62770000 {
+		compatible = "qcom,sm8250-lpass-va-macro";
+		reg = <0 0x62770000 0 0x1000>;
+		status = "disabled";
+		clocks = <&lpass_aoncc LPASS_CDC_VA_MCLK>,
+			<&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+			<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>;
+
+		clock-names = "mclk", "macro", "dcodec";
+
+		#clock-cells = <0>;
+		clock-frequency = <9600000>;
+		clock-output-names = "fsgen";
+		#sound-dai-cells = <1>;
+	};
+
+	rxmacro: rxmacro@62600000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&rx_swr_active>;
+		compatible = "qcom,sm8250-lpass-rx-macro";
+		reg = <0 0x62600000 0 0x1000>;
+		status = "disabled";
+
+		clocks = <&q6afecc LPASS_CLK_ID_TX_CORE_MCLK LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&q6afecc LPASS_CLK_ID_TX_CORE_NPL_MCLK LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&vamacro>;
+
+		clock-names = "mclk", "npl", "macro", "dcodec", "fsgen";
+
+		#clock-cells = <0>;
+		clock-frequency = <9600000>;
+		clock-output-names = "mclk";
+		#sound-dai-cells = <1>;
+	};
+
+	swr1: soundwire-controller@62610000 {
+		reg = <0 0x62610000 0 0x2000>;
+		compatible = "qcom,soundwire-v1.5.1";
+		status = "disabled";
+		interrupts = <GIC_SPI 297 IRQ_TYPE_LEVEL_HIGH>;
+
+		clocks = <&rxmacro>;
+		clock-names = "iface";
+		label = "RX";
+
+		qcom,din-ports = <0>;
+		qcom,dout-ports = <5>;
+		qcom,ports-sinterval-low =	/bits/ 8 <0x03 0x1F 0x1F 0x07 0x00>;
+		qcom,ports-offset1 =		/bits/ 8 <0x00 0x00 0x0B 0x01 0x00>;
+		qcom,ports-offset2 =		/bits/ 8 <0x00 0x00 0x0B 0x00 0x00>;
+		qcom,ports-hstart =		/bits/ 8 <0xFF 0x03 0xFF 0xFF 0xFF>;
+		qcom,ports-hstop =		/bits/ 8 <0xFF 0x06 0xFF 0xFF 0xFF>;
+		qcom,ports-word-length =	/bits/ 8 <0x01 0x07 0x04 0xFF 0xFF>;
+		qcom,ports-block-pack-mode =	/bits/ 8 <0xFF 0x00 0x01 0xFF 0xFF>;
+		qcom,ports-block-group-count =	/bits/ 8 <0xFF 0xFF 0xFF 0xFF 0x00>;
+		qcom,ports-lane-control =	/bits/ 8 <0x01 0x00 0x00 0x00 0x00>;
+
+		#sound-dai-cells = <1>;
+		#address-cells = <2>;
+		#size-cells = <0>;
+	};
+
+	txmacro: txmacro@62620000 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&tx_swr_active>;
+		compatible = "qcom,sm8250-lpass-tx-macro";
+		reg = <0 0x62620000 0 0x1000>;
+		status = "disabled";
+
+		clocks = <&q6afecc LPASS_CLK_ID_TX_CORE_MCLK LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&q6afecc LPASS_CLK_ID_TX_CORE_NPL_MCLK LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+				<&vamacro>;
+
+		clock-names = "mclk", "npl", "macro", "dcodec", "fsgen";
+
+		#clock-cells = <0>;
+		clock-frequency = <9600000>;
+		clock-output-names = "mclk";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		#sound-dai-cells = <1>;
+	};
+
+	swr2: soundwire-controller@62630000 {
+		reg = <0 0x62630000 0 0x2000>;
+		compatible = "qcom,soundwire-v1.5.1";
+		status = "disabled";
+		interrupts = <GIC_SPI 296 IRQ_TYPE_LEVEL_HIGH>;
+
+		clocks = <&txmacro>;
+		clock-names = "iface";
+		label = "TX";
+
+		qcom,din-ports = <5>;
+		qcom,dout-ports = <0>;
+		qcom,ports-sinterval-low =	/bits/ 8 <0xFF 0x01 0x01 0x03 0x03>;
+		qcom,ports-offset1 =		/bits/ 8 <0xFF 0x01 0x00 0x02 0x00>;
+		qcom,ports-offset2 =		/bits/ 8 <0xFF 0x00 0x00 0x00 0x00>;
+		qcom,ports-block-pack-mode =	/bits/ 8 <0xFF 0xFF 0xFF 0xFF 0xFF>;
+		qcom,ports-hstart =		/bits/ 8 <0xFF 0xFF 0xFF 0xFF 0xFF>;
+		qcom,ports-hstop =		/bits/ 8 <0xFF 0xFF 0xFF 0xFF 0xFF>;
+		qcom,ports-word-length =	/bits/ 8 <0xFF 0xFF 0xFF 0xFF 0xFF>;
+		qcom,ports-block-group-count =	/bits/ 8 <0xFF 0xFF 0xFF 0xFF 0xFF>;
+		qcom,ports-lane-control =	/bits/ 8 <0xFF 0x00 0x01 0x00 0x01>;
+		qcom,port-offset = <1>;
+
+		#sound-dai-cells = <1>;
+		#address-cells = <2>;
+		#size-cells = <0>;
+	};
+
+	lpass_aoncc: clock-controller@62780000 {
+		compatible = "qcom,sm8250-lpass-aoncc";
+		reg = <0 0x62780000 0 0x40000>;
+		#clock-cells = <1>;
+		clocks = <&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+			<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+			<&q6afecc LPASS_CLK_ID_TX_CORE_NPL_MCLK LPASS_CLK_ATTRIBUTE_COUPLE_NO>;
+		clock-names = "core", "audio", "bus";
+	};
+
+	lpass_tlmm: pinctrl@627c0000 {
+		compatible = "qcom,sm7125-lpass-lpi-pinctrl", "qcom,sc7280-lpass-lpi-pinctrl";
+		reg = <0 0x627c0000 0x0 0x20000>,
+				<0 0x62950000 0x0 0x10000>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		gpio-ranges = <&lpass_tlmm 0 0 15>;
+
+		clocks = <&q6afecc LPASS_HW_MACRO_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>,
+			<&q6afecc LPASS_HW_DCODEC_VOTE LPASS_CLK_ATTRIBUTE_COUPLE_NO>;
+		clock-names = "core", "audio";
+
+		i2s1_active: i2s1-active-pins {
+			clk {
+				pins = "gpio6";
+				function = "i2s1_clk";
+				drive-strength = <8>;
+				bias-disable;
+				output-high;
+			};
+			ws {
+				pins = "gpio7";
+				function = "i2s1_ws";
+				drive-strength = <8>;
+				bias-disable;
+				output-high;
+			};
+			data {
+				pins = "gpio8", "gpio9";
+				function = "i2s1_data";
+				drive-strength = <8>;
+				bias-disable;
+				output-high;
+			};
+		};
+
+		wsa_swr_active: wsa-swr-active-pins {
+			clk {
+				pins = "gpio10";
+				function = "wsa_swr_clk";
+				drive-strength = <10>;
+				slew-rate = <3>;
+				bias-disable;
+			};
+
+			data {
+				pins = "gpio11";
+				function = "wsa_swr_data";
+				drive-strength = <10>;
+				slew-rate = <3>;
+				bias-bus-hold;
+
+			};
+		};
+
+		rx_swr_active: rx_swr-active-pins {
+			clk {
+				pins = "gpio3";
+				function = "swr_rx_clk";
+				drive-strength = <10>;
+				slew-rate = <3>;
+				bias-disable;
+			};
+			data {
+				pins = "gpio4", "gpio5";
+				function = "swr_rx_data";
+				drive-strength = <10>;
+				slew-rate = <3>;
+				bias-bus-hold;
+			};
+		};
+
+		tx_swr_active: tx_swr-active-pins {
+			clk {
+				pins = "gpio0";
+				function = "swr_tx_clk";
+				drive-strength = <10>;
+				slew-rate = <3>;
+				bias-disable;
+			};
+			data {
+				pins = "gpio1", "gpio2", "gpio14";
+				function = "swr_tx_data";
+				drive-strength = <10>;
+				slew-rate = <3>;
+				bias-bus-hold;
+			};
+		};
+	};
+
+	sound: sound {
+	};
+	
+	remoteproc_cdsp: remoteproc@8300000 {
+		compatible = "qcom,sm7125-cdsp-pas", "qcom,sm6350-cdsp-pas";
+		reg = <0 0x08300000 0 0x10000>;
+
+		interrupts-extended = <&intc GIC_SPI 578 IRQ_TYPE_LEVEL_HIGH>,
+						<&cdsp_smp2p_in 0 IRQ_TYPE_EDGE_RISING>,
+						<&cdsp_smp2p_in 1 IRQ_TYPE_EDGE_RISING>,
+						<&cdsp_smp2p_in 2 IRQ_TYPE_EDGE_RISING>,
+						<&cdsp_smp2p_in 3 IRQ_TYPE_EDGE_RISING>;
+		interrupt-names = "wdog", "fatal", "ready",
+					"handover", "stop-ack";
+
+		clocks = <&rpmhcc RPMH_CXO_CLK>;
+		clock-names = "xo";
+
+		power-domains = <&rpmhpd SC7180_CX>,
+				<&rpmhpd SC7180_MX>;
+		power-domain-names = "cx", "mx";
+
+		memory-region = <&cdsp_mem>;
+
+		qcom,qmp = <&aoss_qmp>;
+
+		qcom,smem-states = <&cdsp_smp2p_out 0>;
+		qcom,smem-state-names = "stop";
+
+		status = "disabled";
+
+		glink-edge {
+			interrupts = <GIC_SPI 574 IRQ_TYPE_EDGE_RISING>;
+			label = "cdsp";
+			qcom,remote-pid = <5>;
+			mboxes = <&apss_shared 4>;
+
+			fastrpc {
+				compatible = "qcom,fastrpc";
+				qcom,glink-channels = "fastrpcglink-apps-dsp";
+				label = "cdsp";
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				compute-cb@1 {
+					compatible = "qcom,fastrpc-compute-cb";
+					reg = <1>;
+					iommus = <&apps_smmu 0x1401 0x20>;
+				};
+
+				compute-cb@2 {
+					compatible = "qcom,fastrpc-compute-cb";
+					reg = <2>;
+					iommus = <&apps_smmu 0x1402 0x20>;
+				};
+
+				compute-cb@3 {
+					compatible = "qcom,fastrpc-compute-cb";
+					reg = <3>;
+					iommus = <&apps_smmu 0x1403 0x20>;
+				};
+
+				compute-cb@4 {
+					compatible = "qcom,fastrpc-compute-cb";
+					reg = <4>;
+					iommus = <&apps_smmu 0x1404 0x20>;
+				};
+
+				compute-cb@5 {
+					compatible = "qcom,fastrpc-compute-cb";
+					reg = <5>;
+					iommus = <&apps_smmu 0x1405 0x20>;
+				};
+
+				compute-cb@6 {
+					compatible = "qcom,fastrpc-compute-cb";
+					reg = <6>;
+					iommus = <&apps_smmu 0x1406 0x20>;
+				};
+
+				compute-cb@7 {
+					compatible = "qcom,fastrpc-compute-cb";
+					reg = <7>;
+					iommus = <&apps_smmu 0x1407 0x20>;
+				};
+
+				compute-cb@8 {
+					compatible = "qcom,fastrpc-compute-cb";
+					reg = <8>;
+					iommus = <&apps_smmu 0x1408 0x20>;
+				};
+
+				/* note: secure cb9 in downstream */
+			};
+		};
+	};
+
+    gpi_dma0: dma-controller@800000  {
+		compatible = "qcom,sm6350-gpi-dma";
+		reg = <0 0x00800000 0 0x60000>;
+		interrupts = <GIC_SPI 244 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 245 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 246 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 247 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 248 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 249 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 250 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 251 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 252 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 253 IRQ_TYPE_LEVEL_HIGH>;
+		dma-channels = <10>;
+		dma-channel-mask = <0x1f>;
+		iommus = <&apps_smmu 0x56 0x0>;
+		#dma-cells = <3>;
+		status = "disabled";
+	};
+
+	gpi_dma1: dma-controller@a00000 {
+		compatible = "qcom,sm6350-gpi-dma";
+		reg = <0 0x00a00000 0 0x60000>;
+		interrupts = <GIC_SPI 645 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 646 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 647 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 648 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 649 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 650 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 651 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 652 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 653 IRQ_TYPE_LEVEL_HIGH>,
+					<GIC_SPI 654 IRQ_TYPE_LEVEL_HIGH>;
+		dma-channels = <10>;
+		dma-channel-mask = <0x3f>;
+		iommus = <&apps_smmu 0x4d6 0x0>;
+		#dma-cells = <3>;
+		status = "disabled";
+	};
+};
+
+&remoteproc_adsp {
+	glink-edge {
+		fastrpc {
+			qcom,non-secure-domain;
+		};
+	};
+};
+
+&usb_1_dwc3 {
+    ports {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        port@0 {
+            reg = <0>;
+            usb_1_dwc3_hs: endpoint { };
+        };
+
+        port@1 {
+            reg = <1>;
+            usb_1_dwc3_ss: endpoint { };
+        };
+    };
+};
\ No newline at end of file
diff --git a/arch/arm64/configs/sm7125.config b/arch/arm64/configs/sm7125.config
new file mode 100644
index 00000000000000..89ae3747ace84d
--- /dev/null
+++ b/arch/arm64/configs/sm7125.config
@@ -0,0 +1,798 @@
+# Qualcomm Snapdragon SM7125 config fragment
+CONFIG_LOCALVERSION="-sm7125"
+# CONFIG_LOCALVERSION_AUTO is not set
+
+# Common for SM7125 devices
+CONFIG_BATTERY_QCOM_QG=m
+
+# Redmi Note 9S / Redmi Note 9 Pro (Global)
+CONFIG_DRM_PANEL_HUAXING_FT8756=m
+CONFIG_DRM_PANEL_TIANMA_NT36675=m
+CONFIG_SND_SOC_TAS2562=m
+CONFIG_TOUCHSCREEN_NT36XXX_SPI=m
+CONFIG_TOUCHSCREEN_FT8756=m
+CONFIG_VIDEO_S5K5E9=m
+CONFIG_VIDEO_S5KGM2=m
+CONFIG_VIDEO_OV16A1Q=m
+CONFIG_VIDEO_DW9714=m
+
+# SM7125 SoC
+CONFIG_INTERCONNECT_QCOM_OSM_L3=y
+CONFIG_INTERCONNECT_QCOM_SC7180=y
+CONFIG_PINCTRL_SC7180=y
+CONFIG_SC_GPUCC_7180=y
+CONFIG_SC_CAMCC_7180=y
+CONFIG_SC_DISPCC_7180=y
+CONFIG_SC_GCC_7180=y
+CONFIG_SC_VIDEOCC_7180=y
+
+# Qualcomm SoC drivers
+CONFIG_QCOM_LLCC=y
+CONFIG_QCOM_OCMEM=y
+CONFIG_QCOM_RMTFS_MEM=y
+CONFIG_QCOM_SOCINFO=y
+CONFIG_QCOM_APR=y
+
+# Console ramoops & USB debug
+CONFIG_PSTORE=y
+CONFIG_PSTORE_CONSOLE=y
+CONFIG_PSTORE_PMSG=y
+CONFIG_PSTORE_RAM=y
+CONFIG_U_SERIAL_CONSOLE=y
+
+# Remoteproc
+CONFIG_SLIMBUS=y
+CONFIG_SLIM_QCOM_CTRL=y
+CONFIG_SLIM_QCOM_NGD_CTRL=y
+CONFIG_REMOTEPROC_CDEV=y
+
+# Graphics
+CONFIG_FB_SIMPLE=y
+CONFIG_DRM=y
+CONFIG_DRM_DISPLAY_HELPER=y
+CONFIG_DRM_MSM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_QCOM_WLED=m
+
+# Power management
+CONFIG_PM_AUTOSLEEP=y
+CONFIG_PM_WAKELOCKS=y
+
+# I2C system bus drivers
+CONFIG_I2C_QCOM_GENI=y
+
+# SPI Master Controller Drivers
+CONFIG_SPI_QCOM_GENI=y
+
+# DMA Devices
+CONFIG_QCOM_GPI_DMA=y
+
+# Input Device Drivers
+#CONFIG_INPUT_UINPUT=m
+
+# Generic Driver Options
+CONFIG_UEVENT_HELPER=y
+
+# MMC/SD/SDIO Host Controller Drivers
+CONFIG_SCSI_UFS_QCOM=y
+
+# PHY Subsystem
+CONFIG_PHY_QCOM_QMP=y
+CONFIG_PHY_QCOM_QMP_COMBO=y
+CONFIG_PHY_QCOM_QMP_UFS=y
+CONFIG_PHY_QCOM_QMP_USB=y
+CONFIG_PHY_QCOM_QUSB2=y
+CONFIG_PHY_QCOM_USB_HS=y
+CONFIG_PHY_QCOM_USB_SNPS_FEMTO_V2=y
+CONFIG_PHY_QCOM_USB_SS=y
+
+# USB
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+# USB Type-C 
+CONFIG_TYPEC=y
+CONFIG_TYPEC_TCPM=y
+CONFIG_TYPEC_QCOM_PMIC=y
+
+# REGULATOR
+CONFIG_REGULATOR_QCOM_USB_VBUS=y
+CONFIG_REGULATOR_VCTRL=n
+
+# Bluetooth device drivers
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=m
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HS=y
+CONFIG_BT_LE=y
+
+# HID
+CONFIG_HID_BATTERY_STRENGTH=y
+CONFIG_HIDRAW=y
+
+# HID/Input
+CONFIG_HID_GENERIC=m
+CONFIG_UHID=m
+CONFIG_USB_HID=m
+CONFIG_INPUT_EVDEV=y
+CONFIG_BT_HIDP=m
+CONFIG_INPUT_JOYDEV=m
+
+# Sound
+CONFIG_SND_SOC_QDSP6_Q6VOICE=m
+CONFIG_SND_SOC_WCD937X_SDW=m
+CONFIG_SND_SOC_LPASS_RX_MACRO=m
+CONFIG_SND_SOC_LPASS_TX_MACRO=m
+CONFIG_PINCTRL_SC7280_LPASS_LPI=m
+CONFIG_CLK_GFM_LPASS_SM8250=m
+
+# LED Triggers
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_ACTIVITY=y
+
+# libcamera
+CONFIG_DMABUF_HEAPS_CMA=y
+CONFIG_DMABUF_HEAPS=y
+CONFIG_DMA_CMA=y
+CONFIG_CMA=y
+CONFIG_CMA_SIZE_MBYTES=256
+
+# Misc useful things
+CONFIG_UDMABUF=y
+CONFIG_DMABUF_HEAPS_SYSTEM=y
+CONFIG_POWER_RESET_QCOM_PON=y
+CONFIG_SCHED_CLUSTER=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_BLK_DEV_RAM=y
+
+# Needed for mounting userdata on android
+CONFIG_QFMT_V2=y
+
+# Anbox
+CONFIG_BRIDGE_NETFILTER=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX_DIAG=y
+CONFIG_NETLINK_DIAG=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_SQUASHFS_XATTR=y
+CONFIG_SQUASHFS_LZ4=y
+CONFIG_SQUASHFS_LZO=y
+CONFIG_SQUASHFS_XZ=y
+
+# Waydroid
+CONFIG_PSI=y
+
+# WLAN
+CONFIG_QRTR=y
+
+# WLAN debugging
+CONFIG_ATH10K_DEBUG=y
+CONFIG_ATH10K_DEBUGFS=y
+CONFIG_ATH10K_SPECTRAL=y
+
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_PRIO=y
+CONFIG_NET_SCH_MULTIQ=y
+
+# Debugging stuff
+CONFIG_STACKTRACE=y
+
+# Firmware loading
+CONFIG_FW_LOADER_COMPRESS=y
+CONFIG_FW_LOADER_COMPRESS_XZ=n
+CONFIG_FW_LOADER_COMPRESS_ZSTD=y
+
+#pmOS Related
+CONFIG_VT=y
+CONFIG_CRYPTO_XTS=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_DM_CRYPT=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_BINFMT_MISC=m
+
+CONFIG_NF_TABLES=m
+CONFIG_NF_TABLES_INET=y
+CONFIG_NFT_CT=m
+CONFIG_NFT_COUNTER=m
+CONFIG_NFT_LOG=m
+CONFIG_NFT_LIMIT=m
+CONFIG_NFT_MASQ=m
+CONFIG_NFT_NAT=m
+CONFIG_NFT_REJECT=m
+CONFIG_NF_TABLES_IPV4=y
+CONFIG_NF_TABLES_IPV6=y
+
+CONFIG_WIREGUARD=m
+CONFIG_DRM_GUD=m
+
+# pmos containers kconfig
+CONFIG_CGROUP_FREEZER=y
+CONFIG_NETFILTER_XT_MATCH_IPVS=m
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_DUMMY=m
+CONFIG_BLK_DEV_THROTTLING=y
+CONFIG_NET_CLS_CGROUP=m
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_VS=m
+CONFIG_IP_VS_NFCT=y
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_RR=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_DM_THIN_PROVISIONING=y
+CONFIG_VXLAN=m
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_IPVLAN=m
+
+# pmOS ZRAM kconfig
+CONFIG_ZSMALLOC=m
+CONFIG_ZSMALLOC_STAT=y
+CONFIG_ZRAM=m
+CONFIG_ZRAM_MEMORY_TRACKING=y
+CONFIG_CRYPTO_LZ4=m
+CONFIG_LZ4_COMPRESS=m
+CONFIG_CRYPTO_LZO=m
+CONFIG_CRYPTO_ZSTD=m
+
+# pmOS iwd kconfig
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+CONFIG_KEY_DH_OPERATIONS=y
+CONFIG_CRYPTO_KPP=y
+CONFIG_PKCS8_PRIVATE_KEY_PARSER=y
+
+# LEDs
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_CLASS_FLASH=y
+CONFIG_LEDS_QCOM_FLASH=y
+
+#Sony PlayStation controllers
+CONFIG_HID_SONY=m
+CONFIG_SONY_FF=y
+
+# Disable all unrelated stuffs afaik
+CONFIG_ACPI=n
+CONFIG_VIRTUALIZATION=n
+CONFIG_PSTORE_DEFLATE_COMPRESS=n
+CONFIG_HIBERNATION=n
+CONFIG_FW_LOADER_USER_HELPER=n
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=n
+CONFIG_BLK_DEV_NVME=n
+CONFIG_ATA=n
+CONFIG_MTD=n
+CONFIG_SRAM=n
+CONFIG_MEGARAID_SAS=n
+CONFIG_EEPROM_AT25=n
+CONFIG_SCSI_MPT3SAS=n
+CONFIG_BLK_DEV_MD=n
+CONFIG_DM_MIRROR=n
+CONFIG_DM_ZERO=n
+CONFIG_EXT2_FS=n
+CONFIG_EXT3_FS=n
+CONFIG_BTRFS_FS=n
+CONFIG_USB_DWC2=n
+CONFIG_USB_CHIPIDEA=n
+CONFIG_USB_MUSB_HDRC=n
+CONFIG_USB_ISP1760=n
+CONFIG_USB_HSIC_USB3503=n
+CONFIG_USB_NET_PLUSB=n
+CONFIG_TYPEC_FUSB302=n
+CONFIG_TYPEC_MUX_NB7VPQ904M=n
+CONFIG_EXTCON_PTN5150=n
+CONFIG_REALTEK_PHY=n
+CONFIG_NET_VENDOR_NI=n
+CONFIG_NET_9P=n
+CONFIG_CAN=n
+CONFIG_BNX2X=n
+CONFIG_MACB=n
+CONFIG_IGB=n
+CONFIG_IGBVF=n
+CONFIG_SMC91X=n
+CONFIG_MLX4_EN=n
+CONFIG_MLX5_CORE=n
+CONFIG_STMMAC_ETH=n
+CONFIG_ATL1C=n
+CONFIG_BRCMFMAC=n
+CONFIG_WL18XX=n
+CONFIG_WLCORE=n
+CONFIG_ATH10K_PCI=n
+CONFIG_NET_SCH_CBS=n
+CONFIG_NET_SCH_ETF=n
+CONFIG_NET_SCH_TAPRIO=n
+CONFIG_NET_SCH_MQPRIO=n
+CONFIG_NET_CLS_BASIC=n
+CONFIG_NET_CLS_FLOWER=n
+CONFIG_NET_CLS_ACT=n
+CONFIG_NET_ACT_GACT=n
+CONFIG_NET_ACT_MIRRED=n
+CONFIG_NET_ACT_GATE=n
+CONFIG_MDIO_BUS_MUX_MMIOREG=n
+CONFIG_MDIO_BUS_MUX_MULTIPLEXER=n
+CONFIG_GPIO_AGGREGATOR=n
+CONFIG_GPIO_DWAPB=n
+CONFIG_COMMON_CLK_XGENE=n
+CONFIG_TCG_TPM=n
+CONFIG_BATTERY_SBS=n
+CONFIG_THUNDER_NIC_BGX=n
+CONFIG_THUNDER_NIC_RGX=n
+CONFIG_MDIO_THUNDER=n
+CONFIG_HW_RANDOM_CAVIUM=n
+CONFIG_EEPROM_AT24=n
+CONFIG_NET_DSA=n
+CONFIG_VITESSE_PHY=n
+CONFIG_PCI_PASID=n
+CONFIG_UACCE=n
+CONFIG_NOP_USB_XCEIV=n
+CONFIG_SURFACE_PLATFORMS=n
+CONFIG_USB_CONN_GPIO=n
+CONFIG_MICREL_PHY=n
+CONFIG_COMMON_CLK_VC5=n
+CONFIG_CRYPTO_DEV_CCREE=n
+CONFIG_SND_SIMPLE_CARD=n
+CONFIG_SND_SIMPLE_CARD_UTILS=n
+CONFIG_SND_AUDIO_GRAPH_CARD=n
+CONFIG_TYPEC_HD3SS3220=n
+CONFIG_COMMON_CLK_CS2000_CP=n
+CONFIG_PL330_DMA=n
+CONFIG_NET_VENDOR_SOCIONEXT=n
+
+# Disable Native drivers
+CONFIG_SENSORS_ARM_SCPI=n
+CONFIG_SENSORS_LM90=n
+CONFIG_SENSORS_INA2XX=n
+CONFIG_SENSORS_LM75=n
+CONFIG_SENSORS_PWM_FAN=n
+CONFIG_SENSORS_INA3221=n
+CONFIG_SENSORS_ISL29018=n
+
+# Disable Batteries
+CONFIG_BATTERY_QCOM_BATTMGR=n
+CONFIG_BATTERY_MAX17042=n
+
+# Disable Chargers
+CONFIG_CHARGER_BQ25890=n
+CONFIG_CHARGER_BQ25980=n
+CONFIG_CHARGER_RK817=n
+
+# Disable MII PHY device drivers
+CONFIG_AQUANTIA_PHY=n
+CONFIG_MICROSEMI_PHY=n
+
+# Disable Multiplexer I2C Chip support
+CONFIG_I2C_MUX_PCA954x=n
+
+# Disable pressure sensors
+CONFIG_MPL3115=n
+
+# Disable Display Panels
+CONFIG_DRM_PANEL_BOE_TV101WUM_NL6=n
+CONFIG_DRM_PANEL_ILITEK_ILI9882T=n
+CONFIG_DRM_PANEL_LVDS=n
+CONFIG_DRM_PANEL_MANTIX_MLAF057WE51=n
+CONFIG_DRM_PANEL_RAYDIUM_RM67191=n
+CONFIG_DRM_PANEL_SITRONIX_ST7703=n
+CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA=n
+CONFIG_DRM_PANEL_VISIONOX_VTDR6130=n
+
+# Disable I2C GPIO expanders
+CONFIG_GPIO_MAX732X=n
+CONFIG_GPIO_PCA953X=n
+
+# Disable Backlight & LCD device support
+CONFIG_BACKLIGHT_LP855X=n
+
+# Disable IR I2C driver auto-selected by 'Autoselect ancillary drivers'
+CONFIG_VIDEO_IMX219=n
+CONFIG_VIDEO_IMX412=n
+CONFIG_VIDEO_OV5640=n
+CONFIG_VIDEO_OV5645=n
+
+# Disable Common SoC Audio options for Freescale CPUs:
+CONFIG_SND_SOC_FSL_ASRC=n
+CONFIG_SND_SOC_FSL_SAI=n
+CONFIG_SND_SOC_FSL_AUDMIX=n
+CONFIG_SND_SOC_FSL_SPDIF=n
+CONFIG_SND_SOC_FSL_MICFIL=n
+
+# Disable Input Device Drivers
+CONFIG_KEYBOARD_ADC=n
+CONFIG_KEYBOARD_GPIO_POLLED=n
+CONFIG_MOUSE_ELAN_I2C=n
+CONFIG_TOUCHSCREEN_ATMEL_MXT=n
+CONFIG_TOUCHSCREEN_GOODIX=n
+CONFIG_TOUCHSCREEN_ELAN=n
+CONFIG_TOUCHSCREEN_EDT_FT5X06=n
+
+# Disable I2C RTC drivers
+CONFIG_RTC_DRV_DS1307=n
+CONFIG_RTC_DRV_RK808=n
+CONFIG_RTC_DRV_HYM8563=n
+CONFIG_RTC_DRV_ISL1208=n
+CONFIG_RTC_DRV_PCF85063=n
+CONFIG_RTC_DRV_PCF85363=n
+CONFIG_RTC_DRV_PCF8563=n
+CONFIG_RTC_DRV_M41T80=n
+CONFIG_RTC_DRV_BQ32K=n
+CONFIG_RTC_DRV_RX8581=n
+CONFIG_RTC_DRV_RV3028=n
+CONFIG_RTC_DRV_RV8803=n
+
+# Disable SPI and I2C RTC drivers
+CONFIG_RTC_DRV_DS3232=n
+CONFIG_RTC_DRV_PCF2127=n
+
+# Disable on-CPU RTC drivers
+CONFIG_RTC_DRV_PL031=n
+
+# Disable ARM errata workarounds via the alternatives framework
+CONFIG_CAVIUM_ERRATUM_22375=n
+CONFIG_CAVIUM_ERRATUM_23144=n
+CONFIG_CAVIUM_ERRATUM_23154=n
+CONFIG_CAVIUM_ERRATUM_27456=n
+CONFIG_CAVIUM_ERRATUM_30115=n
+CONFIG_CAVIUM_TX2_ERRATUM_219=n
+CONFIG_FUJITSU_ERRATUM_010001=n
+CONFIG_HISILICON_ERRATUM_161600802=n
+CONFIG_NVIDIA_CARMEL_CNP_ERRATUM=n
+CONFIG_ROCKCHIP_ERRATUM_3588001=n
+CONFIG_SOCIONEXT_SYNQUACER_PREITS=n
+
+# Disable platforms
+CONFIG_ARCH_ACTIONS=n
+CONFIG_ARCH_SUNXI=n
+CONFIG_ARCH_ALPINE=n
+CONFIG_ARCH_APPLE=n
+CONFIG_ARCH_BCM=n
+CONFIG_ARCH_BCM2835=n
+CONFIG_ARCH_BCM_IPROC=n
+CONFIG_ARCH_BCMBCA=n
+CONFIG_ARCH_BRCMSTB=n
+CONFIG_ARCH_BERLIN=n
+CONFIG_ARCH_BITMAIN=n
+CONFIG_ARCH_EXYNOS=n
+CONFIG_ARCH_SPARX5=n
+CONFIG_ARCH_K3=n
+CONFIG_ARCH_LG1K=n
+CONFIG_ARCH_HISI=n
+CONFIG_ARCH_KEEMBAY=n
+CONFIG_ARCH_MEDIATEK=n
+CONFIG_ARCH_MESON=n
+CONFIG_ARCH_MVEBU=n
+CONFIG_ARCH_NXP=n
+CONFIG_ARCH_LAYERSCAPE=n
+CONFIG_ARCH_MXC=n
+CONFIG_ARCH_S32=n
+CONFIG_ARCH_MA35=n
+CONFIG_ARCH_NPCM=n
+CONFIG_ARCH_REALTEK=n
+CONFIG_ARCH_RENESAS=n
+CONFIG_ARCH_ROCKCHIP=n
+CONFIG_ARCH_SEATTLE=n
+CONFIG_ARCH_INTEL_SOCFPGA=n
+CONFIG_ARCH_STM32=n
+CONFIG_ARCH_SYNQUACER=n
+CONFIG_ARCH_TEGRA=n
+CONFIG_ARCH_SPRD=n
+CONFIG_ARCH_THUNDER=n
+CONFIG_ARCH_THUNDER2=n
+CONFIG_ARCH_UNIPHIER=n
+CONFIG_ARCH_VEXPRESS=n
+CONFIG_ARCH_VISCONTI=n
+CONFIG_ARCH_XGENE=n
+CONFIG_ARCH_ZYNQMP=n
+
+# Disable PCI controller drivers
+CONFIG_PCIE_ALTERA=n
+CONFIG_PCI_HOST_THUNDER_PEM=n
+CONFIG_PCI_HOST_THUNDER_ECAM=n
+CONFIG_PCI_XGENE=n
+
+# Disable DesignWare-based PCIe controllers
+CONFIG_PCI_MESON=n
+CONFIG_PCI_HISI=n
+CONFIG_PCIE_KIRIN=n
+
+CONFIG_HIX5HD2_GMAC=n
+CONFIG_HNS_DSAF=n
+CONFIG_HNS_ENET=n
+CONFIG_HNS3=n
+
+# Disable serial drivers
+CONFIG_SERIAL_XILINX_PS_UART=n
+CONFIG_SERIAL_FSL_LPUART=n
+CONFIG_SERIAL_FSL_LINFLEXUART=n
+
+# Disable I2C system bus drivers (mostly embedded / system-on-chip)
+CONFIG_I2C_DESIGNWARE_PLATFORM=n
+CONFIG_I2C_RK3X=n
+
+# Disable SPI Master Controller Drivers
+CONFIG_SPI_CADENCE_QUADSPI=n
+CONFIG_SPI_DESIGNWARE=n
+CONFIG_SPI_PL022=n
+
+# Disable pinctrls
+CONFIG_PINCTRL_RK805=n
+CONFIG_PINCTRL_IPQ5018=n
+CONFIG_PINCTRL_IPQ5332=n
+CONFIG_PINCTRL_IPQ8074=n
+CONFIG_PINCTRL_IPQ6018=n
+CONFIG_PINCTRL_IPQ9574=n
+CONFIG_PINCTRL_MSM8916=n
+CONFIG_PINCTRL_MSM8953=n
+CONFIG_PINCTRL_MSM8976=n
+CONFIG_PINCTRL_MSM8994=n
+CONFIG_PINCTRL_MSM8996=n
+CONFIG_PINCTRL_MSM8998=n
+CONFIG_PINCTRL_QCM2290=n
+CONFIG_PINCTRL_QCS404=n
+CONFIG_PINCTRL_QDU1000=n
+CONFIG_PINCTRL_SA8775P=n
+CONFIG_PINCTRL_SM7150=n
+CONFIG_PINCTRL_SC7280=n
+CONFIG_PINCTRL_SC8180X=n
+CONFIG_PINCTRL_SC8280XP=n
+CONFIG_PINCTRL_SDM660=n
+CONFIG_PINCTRL_SDM670=n
+CONFIG_PINCTRL_SDM845=n
+CONFIG_PINCTRL_SDX75=n
+CONFIG_PINCTRL_SM4450=n
+CONFIG_PINCTRL_SM6115=n
+CONFIG_PINCTRL_SM6125=n
+CONFIG_PINCTRL_SM6350=n
+CONFIG_PINCTRL_SM6375=n
+CONFIG_PINCTRL_SM8150=n
+CONFIG_PINCTRL_SM8250=n
+CONFIG_PINCTRL_SM8350=n
+CONFIG_PINCTRL_SM8450=n
+CONFIG_PINCTRL_SM8550=n
+CONFIG_PINCTRL_SM8650=n
+CONFIG_PINCTRL_X1E80100=n
+CONFIG_PINCTRL_SM6115_LPASS_LPI=n
+CONFIG_PINCTRL_SM8250_LPASS_LPI=n
+CONFIG_PINCTRL_SM8350_LPASS_LPI=n
+CONFIG_PINCTRL_SM8450_LPASS_LPI=n
+CONFIG_PINCTRL_SC8280XP_LPASS_LPI=n
+CONFIG_PINCTRL_SM8550_LPASS_LPI=n
+CONFIG_PINCTRL_SM8650_LPASS_LPI=n
+
+# Disable clock drivers
+CONFIG_CLK_X1E80100_CAMCC=n
+CONFIG_CLK_X1E80100_DISPCC=n
+CONFIG_CLK_X1E80100_GCC=n
+CONFIG_CLK_X1E80100_GPUCC=n
+CONFIG_CLK_X1E80100_TCSRCC=n
+CONFIG_QCOM_CLK_APCS_MSM8916=n
+CONFIG_QCOM_CLK_APCC_MSM8996=n
+CONFIG_IPQ_GCC_5018=n
+CONFIG_IPQ_GCC_5332=n
+CONFIG_IPQ_GCC_6018=n
+CONFIG_IPQ_GCC_8074=n
+CONFIG_IPQ_GCC_9574=n
+CONFIG_MSM_GCC_8916=n
+CONFIG_MSM_MMCC_8994=n
+CONFIG_MSM_GCC_8994=n
+CONFIG_MSM_GCC_8996=n
+CONFIG_MSM_MMCC_8996=n
+CONFIG_MSM_GCC_8998=n
+CONFIG_MSM_MMCC_8998=n
+CONFIG_QCM_GCC_2290=n
+CONFIG_QCM_DISPCC_2290=n
+CONFIG_QCS_GCC_404=n
+CONFIG_QDU_GCC_1000=n
+CONFIG_SC_CAMCC_8280XP=n
+CONFIG_SC_DISPCC_8280XP=n
+CONFIG_SA_GCC_8775P=n
+CONFIG_SA_GPUCC_8775P=n
+CONFIG_SC_GCC_7150=n
+CONFIG_SC_GCC_7280=n
+CONFIG_SC_GCC_8180X=n
+CONFIG_SC_GCC_8280XP=n
+CONFIG_SC_GPUCC_8280XP=n
+CONFIG_SC_LPASSCC_8280XP=n
+CONFIG_SDM_CAMCC_845=n
+CONFIG_SDM_GCC_845=n
+CONFIG_SDM_GPUCC_845=n
+CONFIG_SDM_VIDEOCC_845=n
+CONFIG_SDM_DISPCC_845=n
+CONFIG_SDM_LPASSCC_845=n
+CONFIG_SDX_GCC_75=n
+CONFIG_SM_CAMCC_8250=n
+CONFIG_SM_DISPCC_6115=n
+CONFIG_SM_DISPCC_8250=n
+CONFIG_SM_DISPCC_8450=n
+CONFIG_SM_DISPCC_8550=n
+CONFIG_SM_GCC_6115=n
+CONFIG_SM_GCC_8150=n
+CONFIG_SM_GCC_8250=n
+CONFIG_SM_GCC_8350=n
+CONFIG_SM_GCC_8450=n
+CONFIG_SM_GCC_8550=n
+CONFIG_SM_GCC_8650=n
+CONFIG_SM_GPUCC_6115=n
+CONFIG_SM_GPUCC_8150=n
+CONFIG_SM_GPUCC_8250=n
+CONFIG_SM_GPUCC_8450=n
+CONFIG_SM_GPUCC_8550=n
+CONFIG_SM_GPUCC_8650=n
+CONFIG_SM_TCSRCC_8550=n
+CONFIG_SM_TCSRCC_8650=n
+CONFIG_SM_VIDEOCC_8250=n
+
+# Disable interconnect drivers
+CONFIG_INTERCONNECT_QCOM_MSM8916=n
+CONFIG_INTERCONNECT_QCOM_MSM8996=n
+CONFIG_INTERCONNECT_QCOM_QCM2290=n
+CONFIG_INTERCONNECT_QCOM_QCS404=n
+CONFIG_INTERCONNECT_QCOM_SA8775P=n
+CONFIG_INTERCONNECT_QCOM_SM7150=n
+CONFIG_INTERCONNECT_QCOM_SC7280=n
+CONFIG_INTERCONNECT_QCOM_SC8180X=n
+CONFIG_INTERCONNECT_QCOM_SC8280XP=n
+CONFIG_INTERCONNECT_QCOM_SDM845=n
+CONFIG_INTERCONNECT_QCOM_SDX75=n
+CONFIG_INTERCONNECT_QCOM_SM8150=n
+CONFIG_INTERCONNECT_QCOM_SM8250=n
+CONFIG_INTERCONNECT_QCOM_SM8350=n
+CONFIG_INTERCONNECT_QCOM_SM8450=n
+CONFIG_INTERCONNECT_QCOM_SM8550=n
+CONFIG_INTERCONNECT_QCOM_SM8650=n
+CONFIG_INTERCONNECT_QCOM_X1E80100=n
+
+# Disable memory mapped GPIO drivers
+CONFIG_GPIO_ALTERA=n
+CONFIG_GPIO_MB86S7X=n
+CONFIG_GPIO_PL061=n
+CONFIG_GPIO_WCD934X=n
+CONFIG_GPIO_XGENE=n
+
+# Disable Virtual GPIO drivers
+CONFIG_POWER_RESET_XGENE=n
+CONFIG_POWER_RESET_SYSCON=n
+CONFIG_GNSS_MTK_SERIAL=n
+
+# Disable Watchdog Device Drivers
+CONFIG_ARM_SP805_WATCHDOG=n
+CONFIG_ARM_SBSA_WATCHDOG=n
+CONFIG_DW_WATCHDOG=n
+CONFIG_ARM_SMC_WATCHDOG=n
+
+# Disable Multifunction device drivers
+CONFIG_MFD_BD9571MWV=n
+CONFIG_MFD_AXP20X_I2C=n
+CONFIG_MFD_HI6421_PMIC=n
+CONFIG_MFD_MAX77620=n
+CONFIG_MFD_MT6360=n
+CONFIG_MFD_MT6397=n
+CONFIG_MFD_RK8XX=n
+CONFIG_MFD_SEC_CORE=n
+CONFIG_MFD_TI_AM335X_TSCADC=n
+CONFIG_MFD_TPS65219=n
+CONFIG_MFD_TPS6594_I2C=n
+CONFIG_MFD_WM8994=n
+CONFIG_MFD_ROHM_BD718XX=n
+CONFIG_MFD_WCD934X=n
+
+CONFIG_REGULATOR_FAN53555=n
+CONFIG_REGULATOR_MAX8973=n
+CONFIG_REGULATOR_MP8859=n
+CONFIG_REGULATOR_MT6315=n
+CONFIG_REGULATOR_MT6360=n
+CONFIG_REGULATOR_PCA9450=n
+CONFIG_REGULATOR_PF8X00=n
+CONFIG_REGULATOR_PFUZE100=n
+CONFIG_REGULATOR_RAA215300=n
+CONFIG_REGULATOR_RK808=n
+CONFIG_REGULATOR_TPS65132=n
+CONFIG_REGULATOR_TPS65219=n
+
+# Disable media device types
+CONFIG_MEDIA_ANALOG_TV_SUPPORT=n
+CONFIG_MEDIA_DIGITAL_TV_SUPPORT=n
+CONFIG_MEDIA_SDR_SUPPORT=n
+
+# Disable I2C encoder or helper chips
+CONFIG_DRM_I2C_NXP_TDA998X=n
+
+# Disable ARM devices
+CONFIG_DRM_MALI_DISPLAY=n
+CONFIG_DRM_KOMEDA=n
+
+# Disable DRM Drivers
+CONFIG_DRM_NOUVEAU=n
+
+# Disable display Interface Bridges
+CONFIG_DRM_LONTIUM_LT8912B=n
+CONFIG_DRM_LONTIUM_LT9611=n
+CONFIG_DRM_LONTIUM_LT9611UXC=n
+CONFIG_DRM_ITE_IT66121=n
+CONFIG_DRM_NWL_MIPI_DSI=n
+CONFIG_DRM_PARADE_PS8640=n
+CONFIG_DRM_SAMSUNG_DSIM=n
+CONFIG_DRM_SII902X=n
+CONFIG_DRM_THINE_THC63LVD1024=n
+CONFIG_DRM_TOSHIBA_TC358768=n
+CONFIG_DRM_TI_TFP410=n
+CONFIG_DRM_TI_SN65DSI83=n
+CONFIG_DRM_TI_SN65DSI86=n
+CONFIG_DRM_ANALOGIX_ANX7625=n
+CONFIG_DRM_I2C_ADV7511=n
+CONFIG_DRM_CDNS_MHDP8546=n
+
+CONFIG_DRM_ETNAVIV=n
+CONFIG_DRM_HISI_HIBMC=n
+CONFIG_DRM_HISI_KIRIN=n
+CONFIG_DRM_PL111=n
+CONFIG_DRM_LIMA=n
+CONFIG_DRM_PANFROST=n
+
+# Disable CODEC drivers
+CONFIG_SND_SOC_ADAU7002=n
+CONFIG_SND_SOC_AK4613=n
+CONFIG_SND_SOC_DA7213=n
+CONFIG_SND_SOC_ES7134=n
+CONFIG_SND_SOC_ES7241=n
+CONFIG_SND_SOC_ES8316=n
+CONFIG_SND_SOC_GTM601=n
+CONFIG_SND_SOC_MAX98357A=n
+CONFIG_SND_SOC_MAX98927=n
+CONFIG_SND_SOC_MSM8916_WCD_ANALOG=n
+CONFIG_SND_SOC_MSM8916_WCD_DIGITAL=n
+CONFIG_SND_SOC_PCM3168A_I2C=n
+CONFIG_SND_SOC_RK817=n
+CONFIG_SND_SOC_RL6231=n
+CONFIG_SND_SOC_RT5640=n
+CONFIG_SND_SOC_RT5659=n
+CONFIG_SND_SOC_RT5663=n
+CONFIG_SND_SOC_RT5682=n
+CONFIG_SND_SOC_SGTL5000=n
+CONFIG_SND_SOC_TAS2552=n
+CONFIG_SND_SOC_TAS571X=n
+CONFIG_SND_SOC_TLV320AIC31XX=n
+CONFIG_SND_SOC_TLV320AIC32X4=n
+CONFIG_SND_SOC_TLV320AIC3X=n
+CONFIG_SND_SOC_TS3A227E=n
+CONFIG_SND_SOC_WCD9335=n
+CONFIG_SND_SOC_WCD934X=n
+CONFIG_SND_SOC_WCD938X=n
+CONFIG_SND_SOC_WM8524=n
+CONFIG_SND_SOC_WM8904=n
+CONFIG_SND_SOC_WM8960=n
+CONFIG_SND_SOC_WM8962=n
+CONFIG_SND_SOC_WM8978=n
+CONFIG_SND_SOC_WSA881X=n
+CONFIG_SND_SOC_MT6358=n
+CONFIG_SND_SOC_NAU8822=n
+
+# Disable USB Host Controller Drivers
+CONFIG_USB_XHCI_PCI_RENESAS=n
+
+# Disable MMC/SD/SDIO Host Controller Drivers
+CONFIG_MMC_SDHCI_OF_ARASAN=n
+CONFIG_MMC_SDHCI_CADENCE=n
+CONFIG_MMC_SDHCI_F_SDH30=n
+CONFIG_MMC_DW_EXYNOS=n
+CONFIG_MMC_DW_HI3798CV200=n
+CONFIG_MMC_DW_K3=n
+CONFIG_MMC_MTK=n
+CONFIG_MMC_SDHCI_XENON=n
+CONFIG_MMC_SDHCI_AM654=n
+
+CONFIG_FSL_EDMA=n
+CONFIG_MV_XOR_V2=n
+CONFIG_COMMON_CLK_RK808=n
+CONFIG_FSL_RCPM=n
+CONFIG_ARCH_R9A07G044=n
+CONFIG_MAX9611=n
+CONFIG_NVMEM_RMEM=n
+CONFIG_FPGA=n
\ No newline at end of file
diff --git a/drivers/cpufreq/cpufreq-dt-platdev.c b/drivers/cpufreq/cpufreq-dt-platdev.c
index 18942bfe9c95f7..4e68a1e7155a57 100644
--- a/drivers/cpufreq/cpufreq-dt-platdev.c
+++ b/drivers/cpufreq/cpufreq-dt-platdev.c
@@ -165,6 +165,7 @@ static const struct of_device_id blocklist[] __initconst = {
 	{ .compatible = "qcom,sm6115", },
 	{ .compatible = "qcom,sm6350", },
 	{ .compatible = "qcom,sm6375", },
+	{ .compatible = "qcom,sm7125", },
 	{ .compatible = "qcom,sm7225", },
 	{ .compatible = "qcom,sm7325", },
 	{ .compatible = "qcom,sm8150", },
diff --git a/drivers/firmware/qcom/qcom_tzmem.c b/drivers/firmware/qcom/qcom_tzmem.c
index 92b3651782355f..07f623b25bd12e 100644
--- a/drivers/firmware/qcom/qcom_tzmem.c
+++ b/drivers/firmware/qcom/qcom_tzmem.c
@@ -79,6 +79,7 @@ static const char *const qcom_tzmem_blacklist[] = {
 	"qcom,sc8180x",
 	"qcom,sdm670", /* failure in GPU firmware loading */
 	"qcom,sdm845", /* reset in rmtfs memory assignment */
+	"qcom,sm7125",
 	"qcom,sm8150", /* reset in rmtfs memory assignment */
 	NULL
 };
diff --git a/drivers/gpu/drm/msm/adreno/a6xx_catalog.c b/drivers/gpu/drm/msm/adreno/a6xx_catalog.c
index 0312b6ee0356be..5266d7d46029be 100644
--- a/drivers/gpu/drm/msm/adreno/a6xx_catalog.c
+++ b/drivers/gpu/drm/msm/adreno/a6xx_catalog.c
@@ -771,7 +771,9 @@ static const struct adreno_info a6xx_gpus[] = {
 		.inactive_period = DRM_MSM_INACTIVE_PERIOD,
 		.quirks = ADRENO_QUIRK_HAS_CACHED_COHERENT,
 		.init = a6xx_gpu_init,
+		.zapfw = "a615_zap.mbn",
 		.a6xx = &(const struct a6xx_info) {
+			.hwcg = a615_hwcg,
 			.protect = &a630_protect,
 			.gmu_cgc_mode = 0x00000222,
 			.prim_fifo_threshold = 0x00180000,
@@ -780,6 +782,7 @@ static const struct adreno_info a6xx_gpus[] = {
 			{ 0,   0 },
 			{ 169, 1 },
 			{ 174, 2 },
+			{ 159, 3 },
 		),
 	}, {
 		.machine = "qcom,sm4350",
diff --git a/drivers/gpu/drm/msm/disp/dpu1/dpu_encoder_phys_cmd.c b/drivers/gpu/drm/msm/disp/dpu1/dpu_encoder_phys_cmd.c
index 6fc31d47cd1dc8..b9d4c552758c46 100644
--- a/drivers/gpu/drm/msm/disp/dpu1/dpu_encoder_phys_cmd.c
+++ b/drivers/gpu/drm/msm/disp/dpu1/dpu_encoder_phys_cmd.c
@@ -474,6 +474,14 @@ static void dpu_encoder_phys_cmd_enable(struct dpu_encoder_phys *phys_enc)
 		return;
 	}
 
+	phys_enc->irq[INTR_IDX_CTL_START] = phys_enc->hw_ctl->caps->intr_start;
+	phys_enc->irq[INTR_IDX_PINGPONG] = phys_enc->hw_pp->caps->intr_done;
+
+	if (phys_enc->has_intf_te)
+		phys_enc->irq[INTR_IDX_RDPTR] = phys_enc->hw_intf->cap->intr_tear_rd_ptr;
+	else
+		phys_enc->irq[INTR_IDX_RDPTR] = phys_enc->hw_pp->caps->intr_rdptr;
+
 	dpu_encoder_phys_cmd_enable_helper(phys_enc);
 	phys_enc->enable_state = DPU_ENC_ENABLED;
 }
@@ -565,6 +573,10 @@ static void dpu_encoder_phys_cmd_disable(struct dpu_encoder_phys *phys_enc)
 		ctl->ops.update_pending_flush_intf(ctl, phys_enc->hw_intf->idx);
 	}
 
+	phys_enc->irq[INTR_IDX_CTL_START] = 0;
+	phys_enc->irq[INTR_IDX_PINGPONG] = 0;
+	phys_enc->irq[INTR_IDX_RDPTR] = 0;
+
 	phys_enc->enable_state = DPU_ENC_DISABLED;
 }
 
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index d3a9a9fafe4ec7..44d070fdd01541 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -135,6 +135,14 @@ config DRM_PANEL_FEIYANG_FY07024DI26A30D
 	  Say Y if you want to enable support for panels based on the
 	  Feiyang FY07024DI26A30-D MIPI-DSI interface.
 
+config DRM_PANEL_HUAXING_FT8756
+	tristate "Huaxing FT8756 DSI panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y here if you want to enable support for the Huaxing FT8756 DSI panel.
+
 config DRM_PANEL_DSI_CM
 	tristate "Generic DSI command mode panels"
 	depends on OF
@@ -497,6 +505,14 @@ config DRM_PANEL_NOVATEK_NT36672E
 	  LCD panel module. The panel has a resolution of 1080x2408 and uses 24 bit
 	  RGB per pixel.
 
+config DRM_PANEL_TIANMA_NT36675
+	tristate "Tianma NT36675 DSI panel"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y here if you want to enable support for the Tianma NT36675 DSI panel.
+
 config DRM_PANEL_NOVATEK_NT39016
 	tristate "Novatek NT39016 RGB/SPI panel"
 	depends on OF && SPI
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 987a0870241035..b2790576b4f33b 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -19,6 +19,7 @@ obj-$(CONFIG_DRM_PANEL_FEIYANG_FY07024DI26A30D) += panel-feiyang-fy07024di26a30d
 obj-$(CONFIG_DRM_PANEL_HIMAX_HX83102) += panel-himax-hx83102.o
 obj-$(CONFIG_DRM_PANEL_HIMAX_HX83112A) += panel-himax-hx83112a.o
 obj-$(CONFIG_DRM_PANEL_HIMAX_HX8394) += panel-himax-hx8394.o
+obj-$(CONFIG_DRM_PANEL_HUAXING_FT8756) += panel-ft8756-huaxing.o
 obj-$(CONFIG_DRM_PANEL_ILITEK_IL9322) += panel-ilitek-ili9322.o
 obj-$(CONFIG_DRM_PANEL_ILITEK_ILI9341) += panel-ilitek-ili9341.o
 obj-$(CONFIG_DRM_PANEL_ILITEK_ILI9805) += panel-ilitek-ili9805.o
@@ -49,6 +50,7 @@ obj-$(CONFIG_DRM_PANEL_NOVATEK_NT35950) += panel-novatek-nt35950.o
 obj-$(CONFIG_DRM_PANEL_NOVATEK_NT36523) += panel-novatek-nt36523.o
 obj-$(CONFIG_DRM_PANEL_NOVATEK_NT36672A) += panel-novatek-nt36672a.o
 obj-$(CONFIG_DRM_PANEL_NOVATEK_NT36672E) += panel-novatek-nt36672e.o
+obj-$(CONFIG_DRM_PANEL_TIANMA_NT36675) += panel-nt36675-tianma.o
 obj-$(CONFIG_DRM_PANEL_NOVATEK_NT39016) += panel-novatek-nt39016.o
 obj-$(CONFIG_DRM_PANEL_MANTIX_MLAF057WE51) += panel-mantix-mlaf057we51.o
 obj-$(CONFIG_DRM_PANEL_OLIMEX_LCD_OLINUXINO) += panel-olimex-lcd-olinuxino.o
diff --git a/drivers/gpu/drm/panel/panel-ft8756-huaxing.c b/drivers/gpu/drm/panel/panel-ft8756-huaxing.c
new file mode 100644
index 00000000000000..b2addd0348dc70
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-ft8756-huaxing.c
@@ -0,0 +1,283 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct ft8756_huaxing {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct ft8756_huaxing *to_ft8756_huaxing(struct drm_panel *panel)
+{
+	return container_of(panel, struct ft8756_huaxing, panel);
+}
+
+static void ft8756_huaxing_reset(struct ft8756_huaxing *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(4000, 5000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int ft8756_huaxing_on(struct ft8756_huaxing *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x87, 0x56, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x87, 0x56);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0xca,
+			       0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+			       0x80, 0x80, 0x80, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_dcs_write_seq(dsi, 0xca,
+			       0xfe, 0xff, 0x66, 0xf6, 0xff, 0x66, 0xfb, 0xff,
+			       0x32);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x00b8);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xb5);
+	mipi_dsi_dcs_write_seq(dsi, 0xca, 0x04);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(90);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(5000, 6000);
+
+	return 0;
+}
+
+static int ft8756_huaxing_off(struct ft8756_huaxing *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(150);
+
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf7, 0x5a, 0xa5, 0x95, 0x27);
+
+	return 0;
+}
+
+static int ft8756_huaxing_prepare(struct drm_panel *panel)
+{
+	struct ft8756_huaxing *ctx = to_ft8756_huaxing(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	ft8756_huaxing_reset(ctx);
+
+	ret = ft8756_huaxing_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int ft8756_huaxing_unprepare(struct drm_panel *panel)
+{
+	struct ft8756_huaxing *ctx = to_ft8756_huaxing(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = ft8756_huaxing_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode ft8756_huaxing_mode = {
+	.clock = (1080 + 20 + 4 + 20) * (2400 + 8 + 4 + 32) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 20,
+	.hsync_end = 1080 + 20 + 4,
+	.htotal = 1080 + 20 + 4 + 20,
+	.vdisplay = 2400,
+	.vsync_start = 2400 + 8,
+	.vsync_end = 2400 + 8 + 4,
+	.vtotal = 2400 + 8 + 4 + 32,
+	.width_mm = 83,
+	.height_mm = 147,
+};
+
+static int ft8756_huaxing_get_modes(struct drm_panel *panel,
+				    struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &ft8756_huaxing_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs ft8756_huaxing_panel_funcs = {
+	.prepare = ft8756_huaxing_prepare,
+	.unprepare = ft8756_huaxing_unprepare,
+	.get_modes = ft8756_huaxing_get_modes,
+};
+
+static int ft8756_huaxing_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct ft8756_huaxing *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "vddio");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get vddio regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO;
+
+	drm_panel_init(&ctx->panel, dev, &ft8756_huaxing_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void ft8756_huaxing_remove(struct mipi_dsi_device *dsi)
+{
+	struct ft8756_huaxing *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id ft8756_huaxing_of_match[] = {
+	{ .compatible = "mdss,ft8756-huaxing" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ft8756_huaxing_of_match);
+
+static struct mipi_dsi_driver ft8756_huaxing_driver = {
+	.probe = ft8756_huaxing_probe,
+	.remove = ft8756_huaxing_remove,
+	.driver = {
+		.name = "panel-ft8756-huaxing",
+		.of_match_table = ft8756_huaxing_of_match,
+	},
+};
+module_mipi_dsi_driver(ft8756_huaxing_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for ft8756 video mode dsi huaxing panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/panel-nt36675-tianma.c b/drivers/gpu/drm/panel/panel-nt36675-tianma.c
new file mode 100644
index 00000000000000..c737cedc6743db
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-nt36675-tianma.c
@@ -0,0 +1,324 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct nt36675_tianma {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct nt36675_tianma *to_nt36675_tianma(struct drm_panel *panel)
+{
+	return container_of(panel, struct nt36675_tianma, panel);
+}
+
+static void nt36675_tianma_reset(struct nt36675_tianma *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int nt36675_tianma_on(struct nt36675_tianma *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0x03, 0x1e, 0x0a, 0x04, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x00);
+
+	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set tear on: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x00b8);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x27);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_VSYNC_TIMING, 0x25);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x23);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0a, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0x0b, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0x0c, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0x0d, 0x2a);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x50);
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x95);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0x68);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x0b);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PARTIAL_ROWS, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PARTIAL_COLUMNS, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x32, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x33, 0xfe);
+	mipi_dsi_dcs_write_seq(dsi, 0x34, 0xfd);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0xfa);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0xf6);
+	mipi_dsi_dcs_write_seq(dsi, 0x37, 0xf2);
+	mipi_dsi_dcs_write_seq(dsi, 0x38, 0xf0);
+	mipi_dsi_dcs_write_seq(dsi, 0x39, 0xee);
+
+	ret = mipi_dsi_dcs_set_pixel_format(dsi, 0xec);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set pixel format: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0xea);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_3D_CONTROL, 0xe8);
+	mipi_dsi_dcs_write_seq(dsi, 0x3f, 0xe7);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_VSYNC_TIMING, 0xe6);
+	mipi_dsi_dcs_write_seq(dsi, 0x41, 0xe5);
+	mipi_dsi_dcs_write_seq(dsi, 0xa0, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(80);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(5000, 6000);
+
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x27);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x3f, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x43, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x10);
+
+	return 0;
+}
+
+static int nt36675_tianma_off(struct nt36675_tianma *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x10);
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(140);
+
+	return 0;
+}
+
+static int nt36675_tianma_prepare(struct drm_panel *panel)
+{
+	struct nt36675_tianma *ctx = to_nt36675_tianma(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	nt36675_tianma_reset(ctx);
+
+	ret = nt36675_tianma_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int nt36675_tianma_unprepare(struct drm_panel *panel)
+{
+	struct nt36675_tianma *ctx = to_nt36675_tianma(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = nt36675_tianma_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode nt36675_tianma_mode = {
+	.clock = (1080 + 20 + 4 + 22) * (2400 + 10 + 2 + 30) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 20,
+	.hsync_end = 1080 + 20 + 4,
+	.htotal = 1080 + 20 + 4 + 22,
+	.vdisplay = 2400,
+	.vsync_start = 2400 + 10,
+	.vsync_end = 2400 + 10 + 2,
+	.vtotal = 2400 + 10 + 2 + 30,
+	.width_mm = 83,
+	.height_mm = 147,
+};
+
+static int nt36675_tianma_get_modes(struct drm_panel *panel,
+				    struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &nt36675_tianma_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs nt36675_tianma_panel_funcs = {
+	.prepare = nt36675_tianma_prepare,
+	.unprepare = nt36675_tianma_unprepare,
+	.get_modes = nt36675_tianma_get_modes,
+};
+
+static int nt36675_tianma_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct nt36675_tianma *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "vddio");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get vddio regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &nt36675_tianma_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void nt36675_tianma_remove(struct mipi_dsi_device *dsi)
+{
+	struct nt36675_tianma *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id nt36675_tianma_of_match[] = {
+	{ .compatible = "mdss,nt36675-tianma" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, nt36675_tianma_of_match);
+
+static struct mipi_dsi_driver nt36675_tianma_driver = {
+	.probe = nt36675_tianma_probe,
+	.remove = nt36675_tianma_remove,
+	.driver = {
+		.name = "panel-nt36675-tianma",
+		.of_match_table = nt36675_tianma_of_match,
+	},
+};
+module_mipi_dsi_driver(nt36675_tianma_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for nt36675 video mode dsi tianma panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/adc/qcom-spmi-adc5.c b/drivers/iio/adc/qcom-spmi-adc5.c
index 9b69f40beed8ea..44722f252217f0 100644
--- a/drivers/iio/adc/qcom-spmi-adc5.c
+++ b/drivers/iio/adc/qcom-spmi-adc5.c
@@ -543,6 +543,8 @@ static const struct adc5_channels adc5_chans_pmic[ADC5_MAX_CHANNEL] = {
 					SCALE_HW_CALIB_DEFAULT)
 	[ADC5_XO_THERM_100K_PU]	= ADC5_CHAN_TEMP("xo_therm", 0,
 					SCALE_HW_CALIB_XOTHERM)
+	[ADC5_BAT_THERM_100K_PU] = ADC5_CHAN_TEMP("bat_therm", 0,
+					SCALE_HW_CALIB_THERM_100K_PULLUP)
 	[ADC5_BAT_ID_100K_PU]	= ADC5_CHAN_TEMP("bat_id", 0,
 					SCALE_HW_CALIB_DEFAULT)
 	[ADC5_AMUX_THM1_100K_PU] = ADC5_CHAN_TEMP("amux_thm1_100k_pu", 0,
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 1ac26fc2e3eb94..bbebdb7d3e3a75 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -663,6 +663,19 @@ config TOUCHSCREEN_IMAGIS
 	  To compile this driver as a module, choose M here: the
 	  module will be called imagis.
 
+config TOUCHSCREEN_NT36XXX_SPI
+	tristate "Novatek NT36XXX In-Cell SPI touchscreen controller"
+	depends on SPI_MASTER
+	select REGMAP
+        help
+          Say Y here if you have a Novatek NT36xxx series In-Cell
+          touchscreen connected to your system over SPI.
+
+          If unsure, say N.
+
+          To compile this driver as a module, choose M here: the
+          module will be called nt36xxx_ts_spi.
+
 config TOUCHSCREEN_IMX6UL_TSC
 	tristate "Freescale i.MX6UL touchscreen controller"
 	depends on ((OF && GPIOLIB) || COMPILE_TEST) && HAS_IOMEM
@@ -960,6 +973,19 @@ config TOUCHSCREEN_MX25
 	  To compile this driver as a module, choose M here: the
 	  module will be called fsl-imx25-tcq.
 
+config TOUCHSCREEN_FT8756
+	tristate "Focaltech FT8756 SPI touchscreen controller"
+	depends on SPI_MASTER
+	select REGMAP
+        help
+          Say Y here if you have a Focaltech FT8756
+          touchscreen connected to your system over SPI.
+
+          If unsure, say N.
+
+          To compile this driver as a module, choose M here: the
+          module will be called ft8756.
+
 config TOUCHSCREEN_MC13783
 	tristate "Freescale MC13783 touchscreen input driver"
 	depends on MFD_MC13XXX
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 82bc837ca01e2e..186da3c1d0fcc4 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -7,6 +7,7 @@
 
 wm97xx-ts-y := wm97xx-core.o
 goodix_ts-y := goodix.o goodix_fwupload.o
+nt36xxx_spi_ts-y := nt36xxx_spi.o nt36xxx_core.o
 
 obj-$(CONFIG_TOUCHSCREEN_88PM860X)	+= 88pm860x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_AD7877)	+= ad7877.o
@@ -59,6 +60,7 @@ obj-$(CONFIG_TOUCHSCREEN_LPC32XX)	+= lpc32xx_ts.o
 obj-$(CONFIG_TOUCHSCREEN_MAX11801)	+= max11801_ts.o
 obj-$(CONFIG_TOUCHSCREEN_MXS_LRADC)     += mxs-lradc-ts.o
 obj-$(CONFIG_TOUCHSCREEN_MX25)		+= fsl-imx25-tcq.o
+obj-$(CONFIG_TOUCHSCREEN_FT8756)		+= ft8756.o
 obj-$(CONFIG_TOUCHSCREEN_MC13783)	+= mc13783_ts.o
 obj-$(CONFIG_TOUCHSCREEN_MELFAS_MIP4)	+= melfas_mip4.o
 obj-$(CONFIG_TOUCHSCREEN_MIGOR)		+= migor_ts.o
@@ -67,6 +69,7 @@ obj-$(CONFIG_TOUCHSCREEN_MSG2638)	+= msg2638.o
 obj-$(CONFIG_TOUCHSCREEN_MTOUCH)	+= mtouch.o
 obj-$(CONFIG_TOUCHSCREEN_MK712)		+= mk712.o
 obj-$(CONFIG_TOUCHSCREEN_NOVATEK_NVT_TS)	+= novatek-nvt-ts.o
+obj-$(CONFIG_TOUCHSCREEN_NT36XXX_SPI)	+= nt36xxx_spi_ts.o
 obj-$(CONFIG_TOUCHSCREEN_HP600)		+= hp680_ts_input.o
 obj-$(CONFIG_TOUCHSCREEN_HP7XX)		+= jornada720_ts.o
 obj-$(CONFIG_TOUCHSCREEN_IPAQ_MICRO)	+= ipaq-micro-ts.o
diff --git a/drivers/input/touchscreen/ft8756.c b/drivers/input/touchscreen/ft8756.c
new file mode 100644
index 00000000000000..daf7486e258325
--- /dev/null
+++ b/drivers/input/touchscreen/ft8756.c
@@ -0,0 +1,923 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Driver for Focaltech FT8756 touchscreen
+ *
+ * Copyright (c) 2012-2019, FocalTech Systems, Ltd.
+ * Copyright (C) 2020 XiaoMi, Inc.
+ * Copyright (C) 2024 Nikroks <www.github.com/N1kroks>
+ *
+ */
+
+#include <linux/unaligned.h>
+#include <linux/input/mt.h>
+#include <linux/input/touchscreen.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <drm/drm_panel.h>
+#include <linux/pm_runtime.h>
+#include <linux/devm-helpers.h>
+#include <linux/regulator/consumer.h>
+#include <linux/firmware.h>
+
+/* Misc */
+#define FT8756_NUM_SUPPLIES 3
+#define FT8756_MAX_RETRIES	3
+
+#define DATA_CRC_EN 0x20
+#define WRITE_CMD   0x00
+#define READ_CMD    (0x80 | DATA_CRC_EN)
+
+#define CS_HIGH_DELAY 150
+
+/* Touch info */
+#define TOUCH_DEFAULT_MAX_WIDTH  1080
+#define TOUCH_DEFAULT_MAX_HEIGHT 2400
+#define TOUCH_MAX_FINGER_NUM	 10
+#define TOUCH_MAX_PRESSURE	     255
+
+#define FT8756_CMD_START1  0x55
+#define FT8756_CMD_START2  0xAA
+#define FT8756_CMD_READ_ID 0x90
+
+#define FT8756_ROMBOOT_CMD_SET_PRAM_ADDR     0xAD
+#define FT8756_ROMBOOT_CMD_SET_PRAM_ADDR_LEN 3
+#define FT8756_ROMBOOT_CMD_WRITE             0xAE
+#define FT8756_ROMBOOT_CMD_START_APP         0x08
+#define FT8756_PRAM_SADDR                    0x000000
+#define FT8756_DRAM_SADDR                    0xD00000
+
+#define FT8756_ROMBOOT_CMD_ECC        0xCC
+#define FT8756_ROMBOOT_CMD_ECC_LEN    6
+#define FT8756_ECC_FINISH_TIMEOUT     100
+#define FT8756_ROMBOOT_CMD_ECC_FINISH 0xCE
+#define FT8756_ROMBOOT_CMD_ECC_READ   0xCD
+
+#define FT8756_REG_POWER_MODE       0xA5
+#define FT8756_REG_POWER_MODE_SLEEP 0x03
+
+#define FT8756_APP_INFO_OFFSET 0x100
+
+/* Point data length */
+#define POINT_DATA_LEN 62
+
+static struct drm_panel_follower_funcs ft8756_panel_follower_funcs;
+
+struct ft8756_abs_object {
+	u16 x;
+	u16 y;
+	u16 p;
+	u8 area;
+};
+
+struct ft8756_ts {
+	struct regmap *regmap;
+
+	struct input_dev *input;
+	struct regulator_bulk_data *supplies;
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *irq_gpio;
+	int irq;
+	struct device *dev;
+
+#define FT8756_STATUS_SUSPEND			BIT(0)
+#define FT8756_STATUS_DOWNLOAD_COMPLETE	BIT(1)
+#define FT8756_STATUS_DOWNLOAD_RECOVER	BIT(2)
+	unsigned int status;
+
+	struct touchscreen_properties prop;
+	struct ft8756_abs_object abs_obj;
+
+	struct drm_panel_follower panel_follower;
+
+	struct delayed_work work;
+
+	struct firmware fw_entry; /* containing request fw data */
+	const char *firmware_path;
+};
+
+/*
+ * this function is nearly direct copy from vendor source
+*/
+static int ft8756_spi_write(void *dev, const void *data, size_t len)
+{
+	struct spi_device *spi = to_spi_device((struct device *)dev);
+    int ret;
+    u32 datalen = len - 1;
+    u32 txlen = 0;
+    u8 *txBuf = devm_kzalloc(dev, len + 9, GFP_KERNEL);
+    if (!txBuf)
+		return -ENOMEM;
+    u8 *rxBuf = devm_kzalloc(dev, len + 9, GFP_KERNEL);
+    if (!rxBuf)
+		return -ENOMEM;
+
+    txBuf[txlen++] = ((u8*)data)[0];
+    txBuf[txlen++] = WRITE_CMD;
+    txBuf[txlen++] = (datalen >> 8) & 0xFF;
+    txBuf[txlen++] = datalen & 0xFF;
+
+    if (datalen > 0) {
+        txlen += 3; // dummy byte
+        memcpy(&txBuf[txlen], data + 1, datalen);
+        txlen += datalen;
+    }
+
+	struct spi_message	msg;
+	struct spi_transfer xfer = {
+		.tx_buf = txBuf,
+		.rx_buf = rxBuf,
+		.len = txlen,
+	};
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfer, &msg);
+
+    for(int i = 0; i < FT8756_MAX_RETRIES; i++) {
+        ret = spi_sync(spi, &msg);
+        if(ret) {
+            dev_err(dev, "transfer error: %d", ret);
+            usleep_range(CS_HIGH_DELAY, CS_HIGH_DELAY + 100);
+            continue;
+        }
+        if ((rxBuf[3] &0xA0) == 0) {
+            break;
+        } else {
+            dev_err(dev, "Failed to write data status: 0x%X", rxBuf[3]);
+            ret = -EIO;
+            usleep_range(CS_HIGH_DELAY, CS_HIGH_DELAY + 100);
+        }
+    }
+
+    usleep_range(CS_HIGH_DELAY, CS_HIGH_DELAY + 100);
+	return ret;
+}
+
+/*
+ * this function is nearly direct copy from vendor source
+*/
+static int ft8756_spi_read(void *dev, const void *reg_buf, size_t reg_size, void *val_buf, size_t val_size)
+{
+	struct spi_device *spi = to_spi_device((struct device *)dev);
+    int ret, i, j;
+    u32 txlen = 0;
+    u8 *txBuf = devm_kzalloc(dev, 4, GFP_KERNEL);
+    if (!txBuf)
+		return -ENOMEM;
+    u8 *rxBuf = devm_kzalloc(dev, val_size + 9, GFP_KERNEL);
+    if (!rxBuf)
+		return -ENOMEM;
+    u32 dp = 0;
+    u16 crc = 0xFFFF;
+
+    txBuf[txlen++] = ((u8*)reg_buf)[0];
+    txBuf[txlen++] = READ_CMD;
+    txBuf[txlen++] = (val_size >> 8) & 0xFF;
+    txBuf[txlen++] = val_size & 0xFF;
+    dp = txlen + 3;
+    txlen = dp + val_size;
+    if(txBuf[1] & DATA_CRC_EN)
+        txlen += 2;
+
+    struct spi_message	msg;
+	struct spi_transfer xfer = {
+		.tx_buf = txBuf,
+		.rx_buf = rxBuf,
+		.len = txlen,
+	};
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfer, &msg);
+
+    for(i = 0; i < FT8756_MAX_RETRIES; i++) {
+        ret = spi_sync(spi, &msg);
+        if(ret) {
+            dev_err(dev, "transfer error: %d", ret);
+            usleep_range(CS_HIGH_DELAY, CS_HIGH_DELAY + 100);
+            continue;
+        }
+        if ((rxBuf[3] & 0xA0) == 0) {
+            memcpy(val_buf, &rxBuf[dp], val_size);
+            if(txBuf[1] & DATA_CRC_EN) {
+                for(j = 0; j < (txlen - dp - 2); j++) {
+                    crc ^= rxBuf[dp + j];
+                    for(u8 k = 0; k < 8; k++)
+                        crc = crc & 1 ? (crc >> 1) ^ 0x8408 : crc >> 1;
+                }
+                u16 crc_read = (u16) (rxBuf[txlen - 1] << 8) + rxBuf[txlen - 2];
+                if (crc != crc_read) {
+                    dev_err(dev, "crc error: 0x%02x expected, got 0x%02x", crc, crc_read);
+                    usleep_range(CS_HIGH_DELAY, CS_HIGH_DELAY + 100);
+                    continue;
+                }
+            }
+            break;
+        } else {
+            dev_err(dev, "Failed to read data status: 0x%X", rxBuf[3]);
+            ret = -EIO;
+            usleep_range(CS_HIGH_DELAY, CS_HIGH_DELAY + 100);
+        }
+    }
+
+    usleep_range(CS_HIGH_DELAY, CS_HIGH_DELAY + 100);
+	return ret;
+}
+
+const struct regmap_config ft8756_regmap_config_32bit = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.read = ft8756_spi_read,
+	.write = ft8756_spi_write,
+
+	.zero_flag_mask = true, /* this is needed to make sure addr is not write_masked */
+	.cache_type = REGCACHE_NONE,
+};
+
+static void ft8756_disable_regulators(void *data)
+{
+	struct ft8756_ts *ts = data;
+
+	regulator_bulk_disable(FT8756_NUM_SUPPLIES, ts->supplies);
+}
+
+static void ft8756_reset(struct ft8756_ts *ts)
+{
+	gpiod_set_value_cansleep(ts->reset_gpio, 1);
+    msleep(1);
+	gpiod_set_value_cansleep(ts->reset_gpio, 0);
+    msleep(200);
+}
+
+static int ft8756_check_chip_id(struct ft8756_ts *ts)
+{
+    u16 chip_id = 0;
+    int ret;
+
+    ft8756_reset(ts);
+
+    ret = regmap_write(ts->regmap, FT8756_CMD_START1, FT8756_CMD_START2);
+    if (ret)
+        goto exit;
+
+    msleep(15);
+
+    ret = regmap_raw_read(ts->regmap, FT8756_CMD_READ_ID, &chip_id, 2);
+    chip_id = cpu_to_be16(chip_id);
+    if (chip_id != 0x8756 || ret) {
+        dev_err(ts->dev, "Chip ID mismatch: expected 0x%x, got 0x%x", 0x8756, chip_id);
+        ret = -ENODEV;
+        goto exit;
+    }
+
+exit:
+    return ret;
+}
+
+static int ft8756_input_dev_config(struct ft8756_ts *ts)
+{
+	struct device *dev = ts->dev;
+	int ret;
+
+    /* Allocate memory for the input device structure */
+	ts->input = devm_input_allocate_device(dev);
+	if (!ts->input)
+		return -ENOMEM;
+
+	/* Set the device-specific data to the allocated input device structure */
+	input_set_drvdata(ts->input, ts);
+
+    /* Set physical path for the input device */
+	ts->input->phys = devm_kasprintf(dev, GFP_KERNEL,
+				     "%s/input0", dev_name(dev));
+	if (!ts->input->phys)
+		return -ENOMEM;
+
+	/* Set input device properties */
+	ts->input->name = "Focaltech FT8756 Touchscreen";
+	ts->input->dev.parent = dev;
+
+    /* Set absolute parameters for touch events */
+	input_set_abs_params(ts->input, ABS_MT_PRESSURE, 0, 255, 0, 0);
+	input_set_abs_params(ts->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+
+	/* Set absolute parameters for touch position */
+	input_set_abs_params(ts->input, ABS_MT_POSITION_X, 0,
+						 TOUCH_DEFAULT_MAX_WIDTH - 1, 0, 0);
+	input_set_abs_params(ts->input, ABS_MT_POSITION_Y, 0,
+						TOUCH_DEFAULT_MAX_HEIGHT - 1, 0, 0);
+
+    /* Parse touchscreen properties */
+	touchscreen_parse_properties(ts->input, true, &ts->prop);
+
+	/* Check if the maximum x-coordinate is valid */
+	WARN_ON(ts->prop.max_x < 1);
+
+    /* Initialize multitouch slots for the input device */
+	ret = input_mt_init_slots(ts->input, TOUCH_MAX_FINGER_NUM,
+				  INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);
+	if (ret) {
+		dev_err(dev, "Cannot init MT slots (%d)\n", ret);
+		return ret;
+	}
+
+	/* Register the input device */
+	ret = input_register_device(ts->input);
+	if (ret) {
+		dev_err(dev, "Failed to register input device: %d\n",
+			ret);
+		return ret;
+	}
+
+    return 0;
+}
+
+static void ft8756_report(struct ft8756_ts *ts)
+{
+    struct ft8756_abs_object* obj = &ts->abs_obj;
+	struct input_dev *input = ts->input;
+	u8 input_id = 0;
+    u8 point[POINT_DATA_LEN] = { 0 };
+    unsigned int base = 0;
+    int ret, i;
+
+    ret = regmap_raw_read(ts->regmap, 0x01, point, POINT_DATA_LEN);
+    if (ret < 0) {
+		dev_err(ts->dev,
+			"Cannot read touch point data: %d\n", ret);
+		goto exit;
+	}
+
+    for(i = 0; i < 6; i++) {
+        if((point[i] != 0xEF && point[i] != 0xFF))
+            break;
+
+        ts->status |= FT8756_STATUS_DOWNLOAD_RECOVER;
+        goto exit;
+    }
+
+    for(i = 0; i < TOUCH_MAX_FINGER_NUM; i++) {
+        base = 6 * i;
+        input_id = point[base + 4] >> 4;
+        if (input_id >= 10)
+            continue;
+
+        if ((point[base + 2] >> 6) == 0x0 || (point[base + 2] >> 6) == 0x2) {
+            obj->x = ((point[base + 2] & 0xF) << 8) + (point[base + 3] & 0xFF);
+            obj->y = ((point[base + 4] & 0xF) << 8) + (point[base + 5] & 0xFF);
+
+            if ((obj->x > ts->prop.max_x) ||
+                (obj->y > ts->prop.max_y))
+                continue;
+
+            obj->p = point[base + 6];
+            obj->area = point[base + 7] >> 4;
+
+            if (obj->area == 0)
+                obj->area = 1;
+
+            if (obj->p > TOUCH_MAX_PRESSURE)
+                obj->p = TOUCH_MAX_PRESSURE;
+
+            if (obj->p == 0)
+                obj->p = 1;
+
+            input_mt_slot(input, input_id);
+            input_mt_report_slot_state(input,
+                            MT_TOOL_FINGER, true);
+            touchscreen_report_pos(input, &ts->prop,
+                        obj->x,
+                        obj->y, true);
+
+            input_report_abs(input, ABS_MT_TOUCH_MAJOR, obj->area);
+            input_report_abs(input, ABS_MT_PRESSURE, obj->p);
+        }
+    }
+
+	input_mt_sync_frame(input);
+
+	input_sync(input);
+
+exit:
+    return;
+}
+
+static irqreturn_t ft8756_irq_handler(int irq, void *dev_id)
+{
+	struct ft8756_ts *ts = dev_id;
+
+    disable_irq_nosync(ts->irq);
+
+    ft8756_report(ts);
+
+    enable_irq(ts->irq);
+
+    if (ts->status & FT8756_STATUS_DOWNLOAD_RECOVER) {
+		ts->status &= ~FT8756_STATUS_DOWNLOAD_RECOVER;
+		schedule_delayed_work(&ts->work, 40000);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int ft8756_enter_boot(struct ft8756_ts *ts) {
+    u16 chip_id = 0;
+    int ret;
+
+    ft8756_reset(ts);
+    mdelay(8);
+
+    ret = regmap_write(ts->regmap, FT8756_CMD_START1, 0x0);
+    if (ret)
+        goto exit;
+
+    msleep(15);
+
+    ret = regmap_raw_read(ts->regmap, FT8756_CMD_READ_ID, &chip_id, 2);
+    chip_id = cpu_to_be16(chip_id);
+    if (chip_id != 0x8756 || ret) {
+        dev_err(ts->dev, "Chip ID mismatch: expected 0x%x, got 0x%x", 0x8756, chip_id);
+        ret = -ENODEV;
+        goto exit;
+    }
+
+exit:
+    return ret;
+}
+
+static int ft8756_calc_ecc(struct ft8756_ts *ts, const u32 addr, u32 size, u16* ecc_value) {
+    int ret, i;
+    u8 cmd[FT8756_ROMBOOT_CMD_ECC_LEN] = { 0 };
+	u8 value[2] = { 0 };
+
+	cmd[0] = (u8)(((addr) >> 16) & 0xFF);
+	cmd[1] = (u8)(((addr) >> 8) & 0xFF);
+	cmd[2] = (u8)((addr) & 0xFF);
+	cmd[3] = (u8)(((size) >> 16) & 0xFF);
+	cmd[4] = (u8)(((size) >> 8) & 0xFF);
+	cmd[5] = (u8)((size) & 0xFF);
+
+    ret = regmap_raw_write(ts->regmap, FT8756_ROMBOOT_CMD_ECC, &cmd, FT8756_ROMBOOT_CMD_ECC_LEN);
+    if (ret) {
+        dev_err(ts->dev, "Failed to calc ecc: %d", ret);
+        goto exit;
+    }
+    msleep(2);
+
+    for(i = 0; i < FT8756_ECC_FINISH_TIMEOUT; i++) {
+        ret = regmap_raw_read(ts->regmap, FT8756_ROMBOOT_CMD_ECC_FINISH, value, 1);
+        if (ret) {
+            dev_err(ts->dev, "ECC Finish command failed: %d", ret);
+            goto exit;
+        }
+        if (value[0] == 0xA5)
+            break;
+        msleep(1);
+    }
+    if (i >= FT8756_ECC_FINISH_TIMEOUT) {
+        dev_err(ts->dev, "Timeout while waiting for ECC calculation to complete");
+        ret = -EIO;
+        goto exit;
+    }
+
+    ret = regmap_raw_read(ts->regmap, FT8756_ROMBOOT_CMD_ECC_READ, value, 2);
+    if (ret) {
+        dev_err(ts->dev, "Failed to read ECC: %d", ret);
+        goto exit;
+    }
+    *ecc_value = ((u16)(value[0] << 8) + value[1]) & 0x0000FFFF;
+
+exit:
+    return ret;
+}
+
+static int ft8756_dpram_write(struct ft8756_ts *ts, const u8* fwdata, u32 fwsize, bool wpram) {
+    int offset, packet_number, packet_remainder, packet_length, addr, ret, i, j, k;
+    u32 packet_size = (32 * 1024 - 16);
+    u32 base_addr = wpram ? FT8756_PRAM_SADDR : FT8756_DRAM_SADDR;
+    u16 eccTP, ecc;
+    u8 *cmd;
+
+    cmd = devm_kzalloc(ts->dev, packet_size + 7, GFP_KERNEL);
+    if (cmd == NULL) {
+		dev_err(ts->dev, "%s: kzalloc for cmd failed!\n", __func__);
+		return -ENOMEM;
+	}
+
+    packet_number = fwsize / packet_size;
+    packet_remainder = fwsize % packet_size;
+    if (packet_remainder > 0)
+        packet_number++;
+
+    packet_length = packet_size;
+    for(i = 0; i < packet_number; i++) {
+        offset = i * packet_size;
+		addr = offset + base_addr;
+        if ((i == (packet_number - 1)) && packet_remainder)
+            packet_length = packet_remainder;
+
+		cmd[0] = (u8)(((addr) >> 16) & 0xFF);
+		cmd[1] = (u8)(((addr) >> 8) & 0xFF);
+		cmd[2] = (u8)((addr) & 0xFF);
+        ret = regmap_raw_write(ts->regmap, FT8756_ROMBOOT_CMD_SET_PRAM_ADDR, cmd, FT8756_ROMBOOT_CMD_SET_PRAM_ADDR_LEN);
+        if (ret) {
+		    dev_err(ts->dev, "Failed to set pram address: %d", ret);
+            goto exit;
+        }
+
+        memcpy(cmd, fwdata + offset, packet_length);
+
+        ret = regmap_bulk_write(ts->regmap, FT8756_ROMBOOT_CMD_WRITE, cmd, packet_length);
+        if (ret) {
+		    dev_err(ts->dev, "%s: failed write to pram\n", __func__);
+            goto exit;
+        }
+
+        ecc = 0;
+
+        for(j = 0; j < packet_length; j += 2) {
+            ecc ^= (fwdata[j + offset] << 8) | (fwdata[j + offset + 1]);
+            for(k = 0; k < 16; k++)
+                ecc = ecc & 1 ? (u16) ((ecc >> 1) ^ ((1 << 15) + (1 << 10) + (1 << 3))) : ecc >> 1;
+        }
+
+        ret = ft8756_calc_ecc(ts, offset, packet_length, &eccTP);
+        if (ret)
+            goto exit;
+
+        if(ecc != eccTP) {
+            dev_err(ts->dev, "ECC error: 0x%02x expected, got 0x%02x", ecc, eccTP);
+            ret = -EIO;
+            goto exit;
+        }
+    }
+
+exit:
+    return ret;
+}
+
+static void _ft8756_download_firmware(struct ft8756_ts *ts) {
+	const struct firmware *fw_entry;
+    int ret;
+
+    if (ts->fw_entry.data)
+		goto upload;
+
+    ret = request_firmware(&fw_entry, ts->firmware_path, ts->dev);
+	if (ret) {
+		dev_err(ts->dev, "failed to request fw: %s\n", ts->firmware_path);
+		goto exit;
+	}
+
+    /*
+	 * must allocate in DMA buffer otherwise fail spi tx DMA
+	 * so we need to manage our own fw struct
+	 * pm_resume need to re-upload fw for FT8756 IC
+	 */
+	ts->fw_entry.data = devm_kmemdup(ts->dev, fw_entry->data, fw_entry->size, GFP_KERNEL | GFP_DMA);
+
+    if (!ts->fw_entry.data) {
+		dev_err(ts->dev, "Failed to allocate fw data\n");
+		goto exit;
+	}
+
+	ts->fw_entry.size = fw_entry->size;
+
+	WARN_ON(ts->fw_entry.data[0] != fw_entry->data[0]);
+
+    release_firmware(fw_entry);
+
+upload:
+    ret = ft8756_enter_boot(ts);
+    if (ret) {
+		dev_err(ts->dev, "Failed to enter boot mode\n");
+		goto release_fw;
+    }
+
+    {
+        u16 code_len = ((u16)ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 0] << 8) + ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 1];
+        u16 code_len_n = ((u16)ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 2] << 8) + ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 3];
+        if ((code_len + code_len_n) != 0xFFFF) {
+            dev_err(ts->dev, "PRAM code length is invalid");
+            goto release_fw;
+        }
+
+        ret = ft8756_dpram_write(ts, ts->fw_entry.data, code_len * 2, true);
+        if (ret) {
+            dev_err(ts->dev, "Failed to write to PRAM: %d", ret);
+            goto release_fw;
+        }
+    }
+
+    {
+        u16 code_len = ((u16)ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 0x8] << 8) + ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 0x9];
+        u16 code_len_n = ((u16)ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 0xA] << 8) + ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 0xB];
+        if ((code_len + code_len_n) != 0xFFFF) {
+            dev_err(ts->dev, "DRAM code length is invalid");
+            goto release_fw;
+        }
+
+	    u32 PramAppSize = ((u32)(((u16)ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 0] << 8) + ts->fw_entry.data[FT8756_APP_INFO_OFFSET + 1])) * 2;
+
+        ret = ft8756_dpram_write(ts, ts->fw_entry.data + PramAppSize, code_len * 2, false);
+        if (ret) {
+            dev_err(ts->dev, "Failed to write to DRAM: %d", ret);
+            goto release_fw;
+        }
+    }
+
+    ret = regmap_write(ts->regmap, FT8756_ROMBOOT_CMD_START_APP, 0x0);
+    if (ret) {
+        dev_err(ts->dev, "Failed to start FW: %d", ret);
+        goto exit;
+    }
+
+    ts->status |= FT8756_STATUS_DOWNLOAD_COMPLETE;
+	dev_info(ts->dev, "Touch IC FW loaded successfully");
+    goto exit;
+
+release_fw:
+	kfree(ts->fw_entry.data);
+	ts->fw_entry.data = NULL;
+	ts->fw_entry.size = 0;
+exit:
+    return;
+}
+
+static void ft8756_download_firmware(struct work_struct *work) {
+    struct ft8756_ts *ts = container_of(work, struct ft8756_ts, work.work);
+
+    /* Disable power management runtime for the device */
+	pm_runtime_disable(ts->dev);
+
+	/* Disable the touch screen IRQ to prevent further interrupts */
+	disable_irq_nosync(ts->irq);
+
+	/* Cancel any pending delayed work */
+	cancel_delayed_work(&ts->work);
+
+    _ft8756_download_firmware(ts);
+
+    /* Enable touch screen IRQ and power management runtime */
+    enable_irq(ts->irq);
+	pm_runtime_enable(ts->dev);
+
+	/* If the download is not complete, reschedule the delayed work after 4000ms */
+    if (!(ts->status & FT8756_STATUS_DOWNLOAD_COMPLETE)) {
+		cancel_delayed_work(&ts->work);
+		schedule_delayed_work(&ts->work, 4000);
+	}
+}
+
+static int ft8756_spi_probe(struct spi_device *spi)
+{
+	struct device *dev = &spi->dev;
+	struct regmap_config *regmap_config;
+	size_t max_size;
+	int ret = 0;
+
+    dev_info(dev, "enter %s", __func__);
+
+    /* Allocate memory for the touchscreen data structure */
+    struct ft8756_ts *ts = devm_kzalloc(dev, sizeof(struct ft8756_ts), GFP_KERNEL);
+	if (!ts)
+		return -ENOMEM;
+
+	/* Set SPI mode and bits per word, and perform SPI setup */
+    spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	ret = spi_setup(spi);
+	if (ret)
+		return ret;
+
+    /* Allocate and copy the default regmap configuration */
+    regmap_config = devm_kmemdup(dev, &ft8756_regmap_config_32bit,
+				     sizeof(*regmap_config), GFP_KERNEL);
+	if (!regmap_config) {
+		dev_err(dev, "memdup regmap_config fail\n");
+		return -ENOMEM;
+	}
+
+    /* Calculate the maximum raw read and write sizes based on SPI transfer size */
+	max_size = spi_max_transfer_size(spi);
+	regmap_config->max_raw_read = max_size - 9;
+	regmap_config->max_raw_write = max_size - 9;
+
+	/* Initialize the regmap using the provided configuration */
+    ts->regmap = devm_regmap_init(dev, NULL, spi, regmap_config);
+	if (IS_ERR(ts->regmap))
+		return PTR_ERR(ts->regmap);
+
+    /* Set the device-specific data to the allocated structure */
+	dev_set_drvdata(dev, ts);
+
+    ts->dev = dev;
+    ts->irq = spi->irq;
+
+    /* Allocate memory for GPIO supplies */
+	ts->supplies = devm_kcalloc(dev, FT8756_NUM_SUPPLIES,
+				    sizeof(*ts->supplies), GFP_KERNEL);
+    if (!ts->supplies)
+		return -ENOMEM;
+
+    /* Get and configure the optional reset GPIO */
+	ts->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ts->reset_gpio))
+		return PTR_ERR(ts->reset_gpio);
+
+	gpiod_set_consumer_name(ts->reset_gpio, "ft8756 reset");
+
+    /* Get and configure the optional IRQ GPIO */
+	ts->irq_gpio = devm_gpiod_get_optional(dev, "irq", GPIOD_IN);
+	if (IS_ERR(ts->irq_gpio))
+		return PTR_ERR(ts->irq_gpio);
+
+    /* If IRQ is not specified, try to obtain it from the IRQ GPIO */
+	if (ts->irq <= 0) {
+		ts->irq = gpiod_to_irq(ts->irq_gpio);
+		if (ts->irq <= 0) {
+			dev_err(dev, "either need irq or irq-gpio specified in devicetree node!\n");
+			return -EINVAL;
+		}
+
+		dev_info(ts->dev, "Interrupts GPIO: %#x\n", ts->irq); // todo change to dbg
+	}
+
+	gpiod_set_consumer_name(ts->irq_gpio, "ft8756 irq");
+
+    /* If the device follows a DRM panel, skip regulator initialization */
+	if (drm_is_panel_follower(dev))
+		goto skip_regulators;
+
+    ts->supplies[0].supply = "vio";
+	ts->supplies[1].supply = "lab";
+	ts->supplies[2].supply = "ibb";
+	ret = devm_regulator_bulk_get(dev,
+				      FT8756_NUM_SUPPLIES,
+				      ts->supplies);
+	if (ret)
+		return dev_err_probe(dev, ret,
+				     "Cannot get supplies: %d\n", ret);
+
+	ret = regulator_bulk_enable(FT8756_NUM_SUPPLIES, ts->supplies);
+	if (ret)
+		return ret;
+
+
+	/* Delay for regulators to stabilize */
+	usleep_range(10000, 11000);
+
+	ret = devm_add_action_or_reset(dev, ft8756_disable_regulators, ts);
+	if (ret)
+		return ret;
+
+skip_regulators:
+    ret = ft8756_check_chip_id(ts);
+    if (ret)
+        return ret;
+
+    /* Parse the firmware path from the device tree */
+	ret = of_property_read_string(dev->of_node, "firmware-name", &ts->firmware_path);
+	if (ret) {
+		dev_err(dev, "Failed to read firmware-name property\n");
+		return ret;
+	}
+
+    ret = ft8756_input_dev_config(ts);
+	if (ret) {
+        dev_err(dev, "failed set input device: %d\n", ret);
+        return ret;
+	}
+
+    /* Request threaded IRQ for touch screen interrupts */
+	ret = devm_request_threaded_irq(dev, ts->irq, NULL, ft8756_irq_handler,
+			 IRQ_TYPE_EDGE_RISING | IRQF_ONESHOT, dev_name(dev), ts);
+	if (ret) {
+        dev_err(dev, "request irq failed: %d\n", ret);
+        return ret;
+	}
+
+    /* Set up delayed work for firmware download */
+	devm_delayed_work_autocancel(dev, &ts->work, ft8756_download_firmware);
+
+	/* Schedule the delayed work */
+	schedule_delayed_work(&ts->work, 0);
+
+    /* If the device follows a DRM panel, configure panel follower */
+	if (drm_is_panel_follower(dev)) {
+		ts->panel_follower.funcs = &ft8756_panel_follower_funcs;
+		devm_drm_panel_add_follower(dev, &ts->panel_follower);
+	}
+
+	dev_info(dev, "FT8756 touchscreen initialized\n");
+    return 0;
+}
+
+static int __maybe_unused ft8756_internal_pm_suspend(struct device *dev)
+{
+	struct ft8756_ts *ts = dev_get_drvdata(dev);
+	int ret = 0;
+
+	ts->status |= FT8756_STATUS_SUSPEND;
+
+	cancel_delayed_work_sync(&ts->work);
+
+	regmap_write(ts->regmap, FT8756_REG_POWER_MODE_SLEEP, FT8756_REG_POWER_MODE_SLEEP);
+	if (ret)
+		dev_err(ts->dev, "Cannot enter sleep!\n");
+	return 0;
+}
+
+static int __maybe_unused ft8756_pm_suspend(struct device *dev)
+{
+	struct ft8756_ts *ts = dev_get_drvdata(dev);
+	int ret=0;
+
+	if (drm_is_panel_follower(dev))
+		return 0;
+
+	disable_irq_nosync(ts->irq);
+
+	ret = ft8756_internal_pm_suspend(dev);
+	return ret;
+}
+
+static int __maybe_unused ft8756_internal_pm_resume(struct device *dev)
+{
+	struct ft8756_ts *ts = dev_get_drvdata(dev);
+
+	/* some how reduced some kind of cpu, but remove checking should no harm */
+	if (ts->status & FT8756_STATUS_SUSPEND)
+		schedule_delayed_work(&ts->work, 0);
+
+	ts->status &= ~FT8756_STATUS_SUSPEND;
+
+	return 0;
+}
+
+static int __maybe_unused ft8756_pm_resume(struct device *dev)
+{
+	struct ft8756_ts *ts = dev_get_drvdata(dev);
+	int ret=0;
+
+	if (drm_is_panel_follower(dev))
+		return 0;
+
+	enable_irq(ts->irq);
+
+	ret = ft8756_internal_pm_resume(dev);
+	return ret;
+}
+
+EXPORT_GPL_SIMPLE_DEV_PM_OPS(ft8756_pm_ops,
+			     ft8756_pm_suspend,
+			     ft8756_pm_resume);
+
+static int panel_prepared(struct drm_panel_follower *follower)
+{
+	struct ft8756_ts *ts = container_of(follower, struct ft8756_ts, panel_follower);
+
+	if (ts->status & FT8756_STATUS_SUSPEND)
+		enable_irq(ts->irq);
+
+	return ft8756_internal_pm_resume(ts->dev);
+}
+
+static int panel_unpreparing(struct drm_panel_follower *follower)
+{
+	struct ft8756_ts *ts = container_of(follower, struct ft8756_ts, panel_follower);
+
+	ts->status |= FT8756_STATUS_SUSPEND;
+
+	disable_irq(ts->irq);
+
+	return ft8756_internal_pm_suspend(ts->dev);
+}
+
+static struct drm_panel_follower_funcs ft8756_panel_follower_funcs = {
+	.panel_prepared = panel_prepared,
+	.panel_unpreparing = panel_unpreparing,
+};
+
+static const struct spi_device_id ft8756_spi_ids[] = {
+	{ "ft8756-spi", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, ft8756_spi_ids);
+
+static struct spi_driver ft8756_spi_driver = {
+	.driver = {
+		.name   = "ft8756-spi",
+		.pm = pm_sleep_ptr(&ft8756_pm_ops),
+	},
+	.probe = ft8756_spi_probe,
+	.id_table = ft8756_spi_ids,
+};
+module_spi_driver(ft8756_spi_driver);
+
+MODULE_DESCRIPTION("FT8756 touchscreen driver");
+MODULE_AUTHOR("Nikroks <nikroksm@mail.ru>");
+MODULE_LICENSE("GPL");
\ No newline at end of file
diff --git a/drivers/input/touchscreen/nt36xxx.h b/drivers/input/touchscreen/nt36xxx.h
new file mode 100644
index 00000000000000..d953d4c3b35c1a
--- /dev/null
+++ b/drivers/input/touchscreen/nt36xxx.h
@@ -0,0 +1,136 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2010 - 2017 Novatek, Inc.
+ * Copyright (C) 2020 AngeloGioacchino Del Regno <kholk11@gmail.com>
+ * Copyright (C) 2023 99degree <www.github.com/99degree>
+ */
+
+#ifndef NT36XXX_H
+#define NT36XXX_H
+
+#define NT36XXX_INPUT_DEVICE_NAME	"Novatek NT36XXX Touch Sensor"
+#define MAX_SPI_FREQ_HZ 8000000
+
+/* FW Param address */
+#define NT36XXX_FW_ADDR		0x01
+
+#define NT36XXX_TRANSFER_LEN	(63*1024)
+
+/* due to extra framework layer, the transfer trunk is as small as
+ * 128 otherwize dma error happened, all routed to spi_sync()
+*/
+
+/* Number of bytes for chip identification */
+#define NT36XXX_ID_LEN_MAX	6
+
+/* Touch info */
+#define TOUCH_DEFAULT_MAX_WIDTH  1080
+#define TOUCH_DEFAULT_MAX_HEIGHT 2246
+#define TOUCH_MAX_FINGER_NUM	 10
+#define TOUCH_MAX_PRESSURE	 1000
+
+/* Point data length */
+#define POINT_DATA_LEN		65
+
+/* Misc */
+#define NT36XXX_NUM_SUPPLIES	 2
+#define NT36XXX_MAX_RETRIES	 5
+#define NT36XXX_MAX_FW_RST_RETRY 50
+
+enum nt36xxx_chips {
+        NT36525_IC = 0x40,
+        NT36672A_IC,
+        NT36676F_IC,
+        NT36772_IC,
+        NT36675_IC,
+        NT36870_IC,
+        NTMAX_IC,
+};
+
+enum nt36xxx_cmds {
+	NT36XXX_CMD_ENTER_SLEEP = 0x11,
+	NT36XXX_CMD_BOOTLOADER_RESET = 0x69,
+};
+
+enum nt36xxx_events {
+        NT36XXX_EVT_REPORT              = 0x00,
+        NT36XXX_EVT_CRC                 = 0x35,
+        NT36XXX_EVT_HOST_CMD            = 0x50,
+        NT36XXX_EVT_HS_OR_SUBCMD        = 0x51, /* Handshake or subcommand byte */
+        NT36XXX_EVT_RESET_COMPLETE      = 0x60,
+        NT36XXX_EVT_FWINFO              = 0x78,
+        NT36XXX_EVT_READ_PID            = 0x80,
+        NT36XXX_EVT_PROJECTID           = 0x9a, /* Excess 0x80 write bit, messed trouble, ignored */
+};
+
+enum nt36xxx_fw_state {
+        NT36XXX_STATE_INIT = 0xa0,              /* IC Reset */
+        NT36XXX_STATE_REK = 0xa1,               /* ReK baseline */
+        NT36XXX_STATE_REK_FINISH = 0xa2,        /* Baseline is ready */
+        NT36XXX_STATE_NORMAL_RUN = 0xa3,        /* Firmware is running */
+        NT36XXX_STATE_MAX = 0xaf
+};
+
+struct nt36xxx_ts;
+
+struct nvt_fw_parse_data {
+	uint8_t partition;
+	uint8_t ilm_dlm_num;
+};
+
+struct nvt_ts_bin_map {
+	char name[12];
+	uint32_t bin_addr;
+	uint32_t sram_addr;
+	uint32_t size;
+	uint32_t crc;
+	uint32_t loaded;
+};
+
+struct nvt_ts_hw_info {
+	uint8_t carrier_system;
+	uint8_t hw_crc;
+};
+
+struct nt36xxx_abs_object {
+	u16 x;
+	u16 y;
+	u16 z;
+	u8 tm;
+};
+
+struct nt36xxx_fw_info {
+	u8 fw_ver;
+	u8 x_num;
+	u8 y_num;
+	u8 max_buttons;
+	u16 abs_x_max;
+	u16 abs_y_max;
+	u16 nvt_pid;
+};
+
+struct nt36xxx_chip_data {
+	const u32 *mmap;
+	const struct regmap_config *config;
+
+	unsigned int abs_x_max;
+	unsigned int abs_y_max;
+	unsigned int max_button;
+	const struct input_id *id;
+};
+
+struct nt36xxx_trim_table {
+	u8 id[NT36XXX_ID_LEN_MAX];
+	u8 mask[NT36XXX_ID_LEN_MAX];
+	enum nt36xxx_chips mapid;
+	uint8_t carrier_system;
+	uint8_t hw_crc;
+};
+
+int nt36xxx_probe(struct device *dev, int irq, const struct input_id *id,
+			struct regmap *regmap);
+
+extern const struct dev_pm_ops nt36xxx_pm_ops;
+extern const u32 nt36675_memory_maps[];
+
+#endif
diff --git a/drivers/input/touchscreen/nt36xxx_core.c b/drivers/input/touchscreen/nt36xxx_core.c
new file mode 100644
index 00000000000000..698677b7db50a0
--- /dev/null
+++ b/drivers/input/touchscreen/nt36xxx_core.c
@@ -0,0 +1,1220 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Driver for Novatek NT36xxx series touchscreens
+ *
+ * Copyright (C) 2010 - 2018 Novatek, Inc.
+ * Copyright (C) 2020 XiaoMi, Inc.
+ * Copyright (C) 2020 AngeloGioacchino Del Regno <kholk11@gmail.com>
+ * Copyright (C) 2023 99degree <www.github.com/99degree>
+ *
+ * Based on nt36xxx.c i2c driver from AngeloGioacchino Del Regno
+ */
+
+#include <linux/unaligned.h>
+#include <asm/byteorder.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/gpio/consumer.h>
+#include <linux/input/mt.h>
+#include <linux/input/touchscreen.h>
+#include <linux/interrupt.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/printk.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/device.h>
+#include <linux/devm-helpers.h>
+#include <drm/drm_panel.h>
+#include <linux/irqnr.h>
+
+#include "nt36xxx.h"
+
+/* Main mmap to spi addr */
+enum {
+	MMAP_BASELINE_ADDR,
+	MMAP_BASELINE_BTN_ADDR,
+	MMAP_BLD_CRC_EN_ADDR,
+	MMAP_BLD_DES_ADDR,
+	MMAP_BLD_ILM_DLM_CRC_ADDR,
+	MMAP_BLD_LENGTH_ADDR,
+	MMAP_BOOT_RDY_ADDR,
+	MMAP_DIFF_BTN_PIPE0_ADDR,
+	MMAP_DIFF_BTN_PIPE1_ADDR,
+	MMAP_DIFF_PIPE0_ADDR,
+	MMAP_DIFF_PIPE1_ADDR,
+	MMAP_DLM_DES_ADDR,
+	MMAP_DLM_LENGTH_ADDR,
+	MMAP_DMA_CRC_EN_ADDR,
+	MMAP_DMA_CRC_FLAG_ADDR,
+	MMAP_ENG_RST_ADDR,
+	MMAP_EVENT_BUF_ADDR,
+	MMAP_G_DLM_CHECKSUM_ADDR,
+	MMAP_G_ILM_CHECKSUM_ADDR,
+	MMAP_ILM_DES_ADDR,
+	MMAP_ILM_LENGTH_ADDR,
+	MMAP_POR_CD_ADDR,
+	MMAP_RAW_BTN_PIPE0_ADDR,
+	MMAP_RAW_BTN_PIPE1_ADDR,
+	MMAP_RAW_PIPE0_ADDR,
+	MMAP_RAW_PIPE1_ADDR,
+	MMAP_READ_FLASH_CHECKSUM_ADDR,
+	MMAP_RW_FLASH_DATA_ADDR,
+	MMAP_R_DLM_CHECKSUM_ADDR,
+	MMAP_R_ILM_CHECKSUM_ADDR,
+	MMAP_SPI_RD_FAST_ADDR,
+	MMAP_SWRST_N8_ADDR,
+
+	/* below are magic numbers in source code */
+	MMAP_MAGIC_NUMBER_0X1F64E_ADDR,
+
+	/* this addr is not specific to */
+	MMAP_TOP_ADDR,
+	MMAP_MAX_ADDR = MMAP_TOP_ADDR,
+} nt36xxx_ts_mem_map;
+
+static struct drm_panel_follower_funcs nt36xxx_panel_follower_funcs;
+
+struct nt36xxx_ts {
+	struct regmap *regmap;
+
+	struct input_dev *input;
+	struct regulator_bulk_data *supplies;
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *irq_gpio;
+	int irq;
+	struct device *dev;
+
+	struct mutex lock;
+
+#define NT36XXX_STATUS_SUSPEND			BIT(0)
+#define NT36XXX_STATUS_DOWNLOAD_COMPLETE	BIT(1)
+#define NT36XXX_STATUS_DOWNLOAD_RECOVER		BIT(2)
+	unsigned int status;
+
+	struct touchscreen_properties prop;
+	struct nt36xxx_fw_info fw_info;
+	struct nt36xxx_abs_object abs_obj;
+
+	struct drm_panel_follower panel_follower;
+
+	struct delayed_work work;
+
+	/* this is a duplicate with nt36xxx_chip_data and since the address might
+	 * change in boot/init/download stages so make it a copy of initial map and
+	 * update accordingly
+	 */
+	u32 *mmap;
+	u32 mmap_data[MMAP_MAX_ADDR];
+
+	struct nvt_fw_parse_data fw_data;
+	struct nvt_ts_bin_map *bin_map;
+
+	uint8_t hw_crc;
+
+	struct firmware fw_entry; /* containing request fw data */
+	const char *firmware_path;
+	const struct nt36xxx_chip_data *data;
+};
+
+static const struct nt36xxx_trim_table trim_id_table[] = {
+#if 0
+	/* TODO: port and test all related module */
+	{
+		.id = { 0x0A, 0xFF, 0xFF, 0x72, 0x66, 0x03 },
+		.mask = { 1, 0, 0, 1, 1, 1 },
+		.mapid = NT36672A_IC,
+	},
+	{
+		.id = { 0x55, 0x00, 0xFF, 0x00, 0x00, 0x00 },
+		.mask = { 1, 1, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0x55, 0x72, 0xFF, 0x00, 0x00, 0x00 },
+		.mask = { 1, 1, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xAA, 0x00, 0xFF, 0x00, 0x00, 0x00 },
+		.mask = { 1, 1, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xAA, 0x72, 0xFF, 0x00, 0x00, 0x00 },
+		.mask = { 1, 1, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xFF, 0xFF, 0xFF, 0x72, 0x67, 0x03 },
+		.mask = { 0, 0, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xFF, 0xFF, 0xFF, 0x70, 0x66, 0x03 },
+		.mask = { 0, 0, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xFF, 0xFF, 0xFF, 0x70, 0x67, 0x03 },
+		.mask = { 0, 0, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xFF, 0xFF, 0xFF, 0x72, 0x66, 0x03 },
+		.mask = { 0, 0, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xFF, 0xFF, 0xFF, 0x25, 0x65, 0x03 },
+		.mask = { 0, 0, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xFF, 0xFF, 0xFF, 0x70, 0x68, 0x03 },
+		.mask = { 0, 0, 0, 1, 1, 1 },
+		.mapid = NT36772_IC,
+	},
+	{
+		.id = { 0xFF, 0xFF, 0xFF, 0x76, 0x66, 0x03 },
+		.mask = { 0, 0, 0, 1, 1, 1 },
+		.mapid = NT36676F_IC,
+	},
+#endif
+	{
+		.id = { 0xFF, 0xFF, 0xFF, 0x75, 0x66, 0x03 },
+		.mask = { 0, 0, 0, 1, 1, 1 },
+		.mapid = NT36675_IC,
+		.hw_crc = 2,  /* 3Bytes */
+	},
+	{
+		.id = { 0x0C, 0xFF, 0xFF, 0x72, 0x66, 0x03 },
+		.mask = { 1, 0, 0, 1, 1, 1 },
+		.mapid = NT36675_IC,
+		.hw_crc = 2,  /* 3Bytes */
+	},
+	{ },
+};
+
+const u32 nt36675_memory_maps[] = {
+	[MMAP_EVENT_BUF_ADDR] = 0x22D00,
+	[MMAP_RAW_PIPE0_ADDR] = 0x24000,
+	[MMAP_RAW_PIPE1_ADDR] = 0x24000,
+	[MMAP_BASELINE_ADDR] = 0x21B90,
+	[MMAP_DIFF_PIPE0_ADDR] = 0x20C60,
+	[MMAP_DIFF_PIPE1_ADDR] = 0x24C60,
+	[MMAP_READ_FLASH_CHECKSUM_ADDR] = 0x24000,
+	[MMAP_RW_FLASH_DATA_ADDR] = 0x24002,
+	[MMAP_BOOT_RDY_ADDR] = 0x3F10D,
+	[MMAP_BLD_LENGTH_ADDR] = 0x3F138,
+	[MMAP_ILM_LENGTH_ADDR] = 0x3F118,
+	[MMAP_DLM_LENGTH_ADDR] = 0x3F130,
+	[MMAP_BLD_DES_ADDR] = 0x3F114,
+	[MMAP_ILM_DES_ADDR] = 0x3F128,
+	[MMAP_DLM_DES_ADDR] = 0x3F12C,
+	[MMAP_G_ILM_CHECKSUM_ADDR] = 0x3F100,
+	[MMAP_G_DLM_CHECKSUM_ADDR] = 0x3F104,
+	[MMAP_R_ILM_CHECKSUM_ADDR] = 0x3F120,
+	[MMAP_R_DLM_CHECKSUM_ADDR] = 0x3F124,
+	[MMAP_BLD_CRC_EN_ADDR] = 0x3F30E,
+	[MMAP_DMA_CRC_EN_ADDR] = 0x3F136,
+	[MMAP_BLD_ILM_DLM_CRC_ADDR] = 0x3F133,
+	[MMAP_DMA_CRC_FLAG_ADDR] = 0x3F134,
+
+	/* below are specified by dts), so it might change by project-based */
+	[MMAP_SPI_RD_FAST_ADDR] = 0x03F310,
+	[MMAP_SWRST_N8_ADDR] = 0x03F0FE,
+
+	[MMAP_ENG_RST_ADDR] = 0x7FFF80,
+	[MMAP_MAGIC_NUMBER_0X1F64E_ADDR] = 0x1F64E,
+
+	[MMAP_TOP_ADDR] = 0xffffff,
+};
+
+void _debug_irq(struct nt36xxx_ts *ts, int line){
+	struct irq_desc *desc;
+	desc = irq_data_to_desc( irq_get_irq_data(ts->irq));
+	dev_info(ts->dev, "%d irq_desc depth=%d", line, desc->depth );
+}
+
+#define debug_irq(a) _debug_irq(a, __LINE__)
+
+static int nt36xxx_eng_reset_idle(struct nt36xxx_ts *ts)
+{
+	int ret;
+
+	if(!ts) {
+		dev_err(ts->dev, "%s %s empty", __func__, "nt36xxx_ts");
+		return -EINVAL;
+	}
+
+	if(!ts->mmap) {
+		dev_err(ts->dev, "%s %s empty", __func__, "ts->mmap");
+		return -EINVAL;
+	}
+
+	if(ts->mmap[MMAP_ENG_RST_ADDR] == 0) {
+		dev_err(ts->dev, "%s %s empty", __func__, "MMAP_ENG_RST_ADDR");
+		return -EINVAL;
+	}
+
+	/* HACK to output something without read */
+	ret = regmap_write(ts->regmap, ts->mmap[MMAP_ENG_RST_ADDR],
+					   0x5a);
+	if (ret) {
+		dev_err(ts->dev, "%s regmap write error\n", __func__);
+		return ret;
+	}
+
+	/* Wait until the MCU resets the fw state */
+	usleep_range(15000, 16000);
+
+	/* seemed not long enough */
+	msleep(30);
+	return ret;
+}
+
+/**
+ * nt36xxx_bootloader_reset - Reset MCU to bootloader
+ * @ts: Main driver structure
+ *
+ * Return: Always zero for success, negative number for error
+ */
+static int nt36xxx_bootloader_reset(struct nt36xxx_ts *ts)
+{
+	int ret = 0;
+
+	//in spi version, need to set page to SWRST_N8_ADDR
+	if (ts->mmap[MMAP_SWRST_N8_ADDR]) {
+		ret = regmap_write(ts->regmap, ts->mmap[MMAP_SWRST_N8_ADDR],
+			   NT36XXX_CMD_BOOTLOADER_RESET);
+		if (ret)
+			return ret;
+	} else {
+		pr_info("plz make sure MMAP_SWRST_N8_ADDR is set!\n");
+		return -EINVAL;
+	}
+
+	/* MCU has to reboot from bootloader: this is the typical boot time */
+	msleep(35);
+
+	if (ts->mmap[MMAP_SPI_RD_FAST_ADDR]) {
+		ret = regmap_write(ts->regmap, ts->mmap[MMAP_SPI_RD_FAST_ADDR], 0);
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+/**
+ * nt36xxx_check_reset_state - Check the boot state during reset
+ * @ts: Main driver structure
+ * @fw_state: Enumeration containing firmware states
+ *
+ * Return: Always zero for success, negative number for error
+ */
+static int nt36xxx_check_reset_state(struct nt36xxx_ts *ts,
+				     enum nt36xxx_fw_state fw_state)
+{
+	u8 buf[8] = { 0 };
+	int ret = 0, retry = NT36XXX_MAX_FW_RST_RETRY;
+
+	do {
+		ret = regmap_raw_read(ts->regmap, ts->mmap[MMAP_EVENT_BUF_ADDR]
+				 | NT36XXX_EVT_RESET_COMPLETE, buf, 6);
+		if (likely(ret == 0) &&
+		    (buf[1] >= fw_state) &&
+		    (buf[1] <= NT36XXX_STATE_MAX)) {
+			ret = 0;
+			break;
+		}
+		usleep_range(10000, 11000);
+	} while (--retry);
+
+	if (!retry) {
+		dev_err(ts->dev, "Firmware reset failed.\n");
+		ret = -EBUSY;
+	}
+
+	return ret;
+}
+
+/**
+ * nt36xxx_report - Report touch events
+ * @ts: Main driver structure
+ *
+ * Return: Always zero for success, negative number for error
+ */
+static void nt36xxx_report(struct nt36xxx_ts *ts)
+{
+	struct nt36xxx_abs_object *obj = &ts->abs_obj;
+	struct input_dev *input = ts->input;
+	u8 input_id = 0;
+	u8 point[POINT_DATA_LEN + 1] = { 0 };
+	unsigned int ppos = 0;
+	int i, ret, finger_cnt = 0;
+	uint8_t press_id[TOUCH_MAX_FINGER_NUM] = {0};
+
+	ret = regmap_raw_read(ts->regmap, ts->mmap[MMAP_EVENT_BUF_ADDR],
+				point, sizeof(point));
+	if (ret < 0) {
+		dev_err(ts->dev,
+			"Cannot read touch point data: %d\n", ret);
+		goto xfer_error;
+	}
+
+	/* wdt recovery and esd check */
+	for (i = 0; i < 7; i++) {
+		if ((point[i] != 0xFD) && (point[i] != 0xFE) && (point[i] != 0x77)) {
+			break;
+		}
+
+		cancel_delayed_work(&ts->work);
+		schedule_delayed_work(&ts->work, 100);
+		goto xfer_error;
+	}
+
+	for (i = 0; i < TOUCH_MAX_FINGER_NUM; i++) {
+		ppos = 6 * i + 1;
+		input_id = point[ppos + 0] >> 3;
+
+		if ((input_id == 0) || (input_id > TOUCH_MAX_FINGER_NUM)) {
+			continue;
+		}
+
+		if (((point[ppos] & 0x07) == 0x01) ||
+		    ((point[ppos] & 0x07) == 0x02)) {
+			obj->x = (point[ppos + 1] << 4) +
+				 (point[ppos + 3] >> 4);
+			obj->y = (point[ppos + 2] << 4) +
+				 (point[ppos + 3] & 0xf);
+
+			if ((obj->x > ts->prop.max_x) ||
+			    (obj->y > ts->prop.max_y))
+				continue;
+
+			obj->tm = point[ppos + 4];
+			if (obj->tm == 0)
+				obj->tm = 1;
+
+			obj->z = point[ppos + 5];
+			if (i < 2) {
+				obj->z += point[i + 63] << 8;
+				if (obj->z > TOUCH_MAX_PRESSURE)
+					obj->z = TOUCH_MAX_PRESSURE;
+			}
+
+			if (obj->z == 0)
+				obj->z = 1;
+
+			press_id[input_id - 1] = 1;
+
+			input_mt_slot(input, input_id - 1);
+			input_mt_report_slot_state(input,
+						   MT_TOOL_FINGER, true);
+			touchscreen_report_pos(input, &ts->prop,
+						obj->x,
+						obj->y, true);
+
+			input_report_abs(input, ABS_MT_TOUCH_MAJOR, obj->tm);
+			input_report_abs(input, ABS_MT_PRESSURE, obj->z);
+
+			finger_cnt++;
+		}
+	}
+
+	input_mt_sync_frame(input);
+
+	input_sync(input);
+
+xfer_error:
+	return;
+}
+
+static irqreturn_t nt36xxx_irq_handler(int irq, void *dev_id)
+{
+	struct nt36xxx_ts *ts = dev_id;
+
+	if (!ts->mmap)
+		goto exit;
+
+	disable_irq_nosync(ts->irq);
+
+	nt36xxx_report(ts);
+
+	enable_irq(ts->irq);
+
+exit:
+	if (ts->status & NT36XXX_STATUS_DOWNLOAD_RECOVER) {
+		ts->status &= ~NT36XXX_STATUS_DOWNLOAD_RECOVER;
+		schedule_delayed_work(&ts->work, 40000);
+	}
+
+	return IRQ_HANDLED;
+}
+
+
+/**
+ * nt36xxx_chip_version_init - Detect Novatek NT36xxx family IC
+ * @ts: Main driver structure
+ *
+ * This function reads the ChipID from the IC and sets the right
+ * memory map for the detected chip.
+ *
+ * Return: Always zero for success, negative number for error
+ */
+static int nt36xxx_chip_version_init(struct nt36xxx_ts *ts)
+{
+	u8 buf[32] = { 0 };
+	int retry = NT36XXX_MAX_RETRIES;
+	int sz = sizeof(trim_id_table) / sizeof(struct nt36xxx_trim_table);
+	int i, list, mapid, ret;
+
+	ret = nt36xxx_bootloader_reset(ts);
+	if (ret) {
+		dev_err(ts->dev, "Can't reset the nvt IC\n");
+		return ret;
+	}
+
+	do {
+		ret = regmap_raw_read(ts->regmap, ts->mmap[MMAP_MAGIC_NUMBER_0X1F64E_ADDR], buf, 7);
+
+		if (ret)
+			continue;
+
+		dev_dbg(ts->dev, "%s buf[0]=0x%02X, buf[1]=0x%02X, buf[2]=0x%02X, buf[3]=0x%02X, buf[4]=0x%02X, buf[5]=0x%02X, buf[6]=0x%02X sz=%d\n",
+			__func__, buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], sz);
+
+		/* Compare read chip id with trim list */
+		for (list = 0; list < sz; list++) {
+
+			/* Compare each not masked byte */
+			for (i = 0; i < NT36XXX_ID_LEN_MAX; i++) {
+				if (trim_id_table[list].mask[i] &&
+				    buf[i + 1] != trim_id_table[list].id[i])
+					break;
+			}
+
+			/* found and match with mask */
+			if (i == NT36XXX_ID_LEN_MAX) {
+				mapid = trim_id_table[list].mapid;
+				ret = 0;
+				ts->hw_crc = trim_id_table[list].hw_crc;
+
+				if (mapid == 0) {
+					dev_info(ts->dev, "NVT touch IC hw not found i=%d list=%d\n", i, list);
+					ret = -ENOENT;
+					goto exit;
+				}
+
+				WARN_ON(ts->hw_crc < 1);
+
+				dev_dbg(ts->dev, "hw crc support=%d\n", ts->hw_crc);
+
+				dev_info(ts->dev, "This is NVT touch IC, %x, mapid %d", *(int*)&buf[4], mapid);
+				return 0;
+			}
+
+			ret = -ENOENT;
+		}
+
+		usleep_range(10000, 11000);
+	} while (--retry);
+
+exit:
+	return ret;
+}
+
+/*
+ * this function is nearly direct copy from vendor source
+*/
+static int32_t nvt_bin_header_parser(struct device *dev, int hw_crc, const u8 *fwdata, size_t fwsize, struct nvt_ts_bin_map **bin_map_ptr, uint8_t *partition_ptr, uint8_t ilm_dlm_num)
+{
+	uint8_t list = 0;
+	uint32_t pos = 0x00;
+	uint32_t end = 0x00;
+	uint8_t info_sec_num = 0;
+	uint8_t ovly_sec_num = 0;
+	uint8_t ovly_info = 0;
+	uint8_t partition;
+	struct nvt_ts_bin_map *bin_map;
+
+	/* Find the header size */
+	end = fwdata[0] + (fwdata[1] << 8) + (fwdata[2] << 16) + (fwdata[3] << 24);
+	pos = 0x30;	// info section start at 0x30 offset
+	while (pos < end) {
+		info_sec_num ++;
+		pos += 0x10;	/* each header info is 16 bytes */
+	}
+
+	/*
+	 * Find the DLM OVLY section
+	 * [0:3] Overlay Section Number
+	 * [4]   Overlay Info
+	 */
+	ovly_info = (fwdata[0x28] & 0x10) >> 4;
+	ovly_sec_num = (ovly_info) ? (fwdata[0x28] & 0x0F) : 0;
+
+	/*
+	 * calculate all partition number
+	 * ilm_dlm_num (ILM & DLM) + ovly_sec_num + info_sec_num
+	 */
+	*partition_ptr = partition = ilm_dlm_num + ovly_sec_num + info_sec_num;
+	dev_dbg(dev, "ovly_info = %d, ilm_dlm_num = %d, ovly_sec_num = %d, info_sec_num = %d, partition = %d\n",
+			ovly_info, ilm_dlm_num, ovly_sec_num, info_sec_num, partition);
+
+	/* allocated memory for header info */
+	*bin_map_ptr = bin_map = (struct nvt_ts_bin_map *)devm_kzalloc(dev, (partition + 1) * sizeof(struct nvt_ts_bin_map), GFP_KERNEL);
+	if(bin_map == NULL) {
+		dev_err(dev, "kzalloc for bin_map failed!\n");
+		return -ENOMEM;
+	}
+
+
+	for (list = 0; list < partition; list++) {
+		/*
+		 * [1] parsing ILM & DLM header info
+		 * bin_addr : sram_addr : size (12-bytes)
+		 * crc located at 0x18 & 0x1C
+		 */
+		if (list < ilm_dlm_num) {
+			memcpy(&bin_map[list].bin_addr, &(fwdata[0 + list*12]), 4);
+			memcpy(&bin_map[list].sram_addr, &(fwdata[4 + list*12]), 4);
+			memcpy(&bin_map[list].size, &(fwdata[8 + list*12]), 4);
+			memcpy(&bin_map[list].crc, &(fwdata[0x18 + list*4]), 4);
+
+			if (!hw_crc) {
+				dev_err(dev, "%s %d sw-crc not support", __func__, __LINE__);
+				return -EINVAL;
+			}
+
+			if (list == 0)
+				sprintf(bin_map[list].name, "ILM");
+			else if (list == 1)
+				sprintf(bin_map[list].name, "DLM");
+		}
+
+		/*
+		 * [2] parsing others header info
+		 * sram_addr : size : bin_addr : crc (16-bytes)
+		 */
+		if ((list >= ilm_dlm_num) && (list < (ilm_dlm_num + info_sec_num))) {
+
+			/* others partition located at 0x30 offset */
+			pos = 0x30 + (0x10 * (list - ilm_dlm_num));
+
+			memcpy(&bin_map[list].sram_addr, &(fwdata[pos]), 4);
+			memcpy(&bin_map[list].size, &(fwdata[pos+4]), 4);
+			memcpy(&bin_map[list].bin_addr, &(fwdata[pos+8]), 4);
+			memcpy(&bin_map[list].crc, &(fwdata[pos+12]), 4);
+
+			if (!hw_crc) {
+				dev_info(dev, "ok, hw_crc not presents!");
+				return -EINVAL;
+			}
+
+			/* detect header end to protect parser function */
+			if ((bin_map[list].bin_addr == 0) && (bin_map[list].size != 0)) {
+				sprintf(bin_map[list].name, "Header");
+			} else {
+				sprintf(bin_map[list].name, "Info-%d", (list - ilm_dlm_num));
+			}
+		}
+
+		/*
+		 * [3] parsing overlay section header info
+		 * sram_addr : size : bin_addr : crc (16-bytes)
+		 */
+		if (list >= (ilm_dlm_num + info_sec_num)) {
+			/* overlay info located at DLM (list = 1) start addr */
+			pos = bin_map[1].bin_addr + (0x10 * (list- ilm_dlm_num - info_sec_num));
+
+			memcpy(&bin_map[list].sram_addr, &(fwdata[pos]), 4);
+			memcpy(&bin_map[list].size, &(fwdata[pos+4]), 4);
+			memcpy(&bin_map[list].bin_addr, &(fwdata[pos+8]), 4);
+			memcpy(&bin_map[list].crc, &(fwdata[pos+12]), 4);
+
+			if (!hw_crc) {
+				dev_err(dev, "%s %d sw_crc not support", __func__, __LINE__);
+				return -EINVAL;
+			}
+
+			sprintf(bin_map[list].name, "Overlay-%d", (list- ilm_dlm_num - info_sec_num));
+		}
+
+		/* BIN size error detect */
+		if ((bin_map[list].bin_addr + bin_map[list].size) > fwsize) {
+			dev_err(dev, "access range (0x%08X to 0x%08X) is larger than bin size!\n",
+					bin_map[list].bin_addr, bin_map[list].bin_addr + bin_map[list].size);
+			return -EINVAL;
+		}
+
+		dev_dbg(dev, "[%d][%s] SRAM (0x%08X), SIZE (0x%08X), BIN (0x%08X), CRC (0x%08X)\n",
+			      list, bin_map[list].name,
+			      bin_map[list].sram_addr, bin_map[list].size,  bin_map[list].bin_addr, bin_map[list].crc);
+	}
+
+	return 0;
+}
+
+static int32_t nt36xxx_download_firmware_hw_crc(struct nt36xxx_ts *ts) {
+	uint32_t list = 0;
+	uint32_t bin_addr, sram_addr, size;
+	struct nvt_ts_bin_map *bin_map = ts->bin_map;
+
+	nt36xxx_bootloader_reset(ts);
+
+	for (list = 0; list < ts->fw_data.partition; list++) {
+		int j;
+
+		/* initialize variable */
+		sram_addr = bin_map[list].sram_addr;
+		size = bin_map[list].size;
+		bin_addr = bin_map[list].bin_addr;
+
+		/* ignore reserved partition (Reserved Partition size is zero) */
+		if (!size) {
+			dev_dbg(ts->dev, "found empty part %d. skipping ", list);
+			continue;
+		} else {
+			size = size + 1;
+			dev_dbg(ts->dev, "found useful part %d. size 0x%x ", list, size);
+		}
+
+		bin_map[list].loaded = 1;
+
+		if (size / NT36XXX_TRANSFER_LEN)
+			dev_dbg(ts->dev, "%s %d paged write [%s] 0x%x, window 0x%x, residue 0x%x",
+					__func__, __LINE__, bin_map[list].name, size,
+					NT36XXX_TRANSFER_LEN, size % NT36XXX_TRANSFER_LEN);
+
+		for (j = 0; j < size; j += NT36XXX_TRANSFER_LEN) {
+			int window_size = ((size - j) / NT36XXX_TRANSFER_LEN) ? NT36XXX_TRANSFER_LEN :
+						((size - j) % NT36XXX_TRANSFER_LEN);
+
+			regmap_bulk_write(ts->regmap, sram_addr + j, &ts->fw_entry.data[bin_addr + j],
+							 window_size);
+		}
+
+	}
+
+	return 0;
+}
+
+static void _nt36xxx_boot_download_firmware(struct nt36xxx_ts *ts) {
+	int i, ret, retry = 0;
+	size_t fw_need_write_size = 0;
+	const struct firmware *fw_entry;
+	u8 val[8 * 4] = {0};
+
+	WARN_ON(ts->hw_crc != 2);
+
+	/* supposed we need to load once and use many time */
+	if (ts->fw_entry.data)
+		goto upload;
+
+	ret = request_firmware(&fw_entry, ts->firmware_path, ts->dev);
+	if (ret) {
+		dev_err(ts->dev, "request fw fail name=%s\n", ts->firmware_path);
+		goto exit;
+	}
+
+	/*
+	 * must allocate in DMA buffer otherwise fail spi tx DMA
+	 * so we need to manage our own fw struct
+	 * pm_resume need to re-upload fw for NT36675 IC
+	 *
+	 */
+	ts->fw_entry.data = devm_kmemdup(ts->dev, fw_entry->data, fw_entry->size, GFP_KERNEL | GFP_DMA);
+
+	release_firmware(fw_entry);
+
+	if (!ts->fw_entry.data) {
+		dev_err(ts->dev, "memdup fw_data fail\n");
+		goto exit;
+	}
+	ts->fw_entry.size = fw_entry->size;
+
+	WARN_ON(ts->fw_entry.data[0] != fw_entry->data[0]);
+
+	for (i = (ts->fw_entry.size / 4096); i > 0; i--) {
+		if (strncmp(&ts->fw_entry.data[i * 4096 - 3], "NVT", 3) == 0) {
+			fw_need_write_size = i * 4096;
+			break;
+		}
+
+		if (strncmp(&ts->fw_entry.data[i * 4096 - 3], "MOD", 3) == 0) {
+			fw_need_write_size = i * 4096;
+			break;
+		}
+	}
+
+	if (fw_need_write_size == 0) {
+		dev_err(ts->dev, "fw parsing error\n");
+		goto release_fw;
+	}
+
+	if (*(ts->fw_entry.data + (fw_need_write_size - 4096)) + *(ts->fw_entry.data +
+						((fw_need_write_size - 4096) + 1)) != 0xFF) {
+		dev_err(ts->dev, "bin file FW_VER + FW_VER_BAR should be 0xFF!");
+		dev_err(ts->dev, "FW_VER=0x%02X, FW_VER_BAR=0x%02X\n",
+					*(ts->fw_entry.data+(fw_need_write_size - 4096)),
+					*(ts->fw_entry.data+(fw_need_write_size - 4096 + 1)));
+		goto release_fw;
+	}
+
+	ts->fw_data.ilm_dlm_num = 2;
+
+	ret = nvt_bin_header_parser(ts->dev, ts->hw_crc, ts->fw_entry.data, ts->fw_entry.size,
+			&ts->bin_map, &ts->fw_data.partition, ts->fw_data.ilm_dlm_num);
+	if (ret) {
+		if(ret != -ENOMEM)
+			goto release_fw_buf;
+		goto release_fw;
+	}
+
+upload:
+	if (ts->hw_crc) {
+		ret = nt36xxx_download_firmware_hw_crc(ts);
+		if (ret) {
+			dev_err(ts->dev, "nt36xxx_download_firmware_hw_crc fail!");
+			goto release_fw_buf;
+		}
+
+	} else {
+		dev_err(ts->dev, "non-hw_crc model is not support yet!");
+		goto release_fw_buf;
+	}
+
+	/* set ilm & dlm reg bank */
+	for (i = 0; i < ts->fw_data.partition; i++) {
+		if (0 == strncmp(ts->bin_map[i].name, "ILM", 3)) {
+			regmap_raw_write(ts->regmap, ts->mmap[MMAP_ILM_DES_ADDR], &ts->bin_map[i].sram_addr, 3);
+			regmap_raw_write(ts->regmap, ts->mmap[MMAP_ILM_LENGTH_ADDR], &ts->bin_map[i].size, 3);
+
+			/* crc > 1 then len = 4, crc = 1 then len = 3 */
+			regmap_raw_write(ts->regmap, ts->mmap[MMAP_G_ILM_CHECKSUM_ADDR], &ts->bin_map[i].crc,
+						sizeof(ts->bin_map[i].crc));
+		}
+		if (0 == strncmp(ts->bin_map[i].name, "DLM", 3)) {
+			regmap_raw_write(ts->regmap, ts->mmap[MMAP_DLM_DES_ADDR], &ts->bin_map[i].sram_addr, 3);
+			regmap_raw_write(ts->regmap, ts->mmap[MMAP_DLM_LENGTH_ADDR], &ts->bin_map[i].size, 3);
+
+			/* crc > 1 then len = 4, crc = 1 then len = 3 */
+			regmap_raw_write(ts->regmap, ts->mmap[MMAP_G_DLM_CHECKSUM_ADDR], &ts->bin_map[i].crc,
+						sizeof(ts->bin_map[i].crc));
+		}
+	}
+
+	/* nvt_bld_crc_enable() */
+	/* crc enable */
+	regmap_raw_read(ts->regmap, ts->mmap[MMAP_BLD_CRC_EN_ADDR], val, 1);
+
+	val[0] |= 1 << 7;
+	regmap_raw_write(ts->regmap, ts->mmap[MMAP_BLD_CRC_EN_ADDR], val, 1);
+
+	/* enable fw crc */
+	val[0] = 0;
+	regmap_raw_write(ts->regmap, ts->mmap[MMAP_EVENT_BUF_ADDR] | NT36XXX_EVT_RESET_COMPLETE, val, 1);
+
+	val[0] = 0xae;
+	regmap_raw_write(ts->regmap, ts->mmap[MMAP_EVENT_BUF_ADDR] | NT36XXX_EVT_HOST_CMD, val, 1);
+
+	/* nvt_boot_ready() */
+	/* Set Boot Ready Bit */
+	val[0] = 0x1;
+	regmap_raw_write(ts->regmap, ts->mmap[MMAP_BOOT_RDY_ADDR], val, 1);
+
+	/* old logic 5ms, retention to 10ms */
+	usleep_range(10000, 11000);
+
+	/* nvt_check_fw_reset_state() */
+	ret = nt36xxx_check_reset_state(ts, NT36XXX_STATE_INIT);
+	if (ret)
+		goto release_fw_buf;
+
+check_fw:
+	/* nvt_get_fw_info() */
+	ret = regmap_raw_read(ts->regmap, ts->mmap[MMAP_EVENT_BUF_ADDR] | NT36XXX_EVT_FWINFO, val, 16);
+	if (ret)
+		goto release_fw_buf;
+
+	dev_dbg(ts->dev, "Get default fw_ver=%d, max_x=%d, max_y=%d\n",
+				val[2], ts->prop.max_x, ts->prop.max_y);
+
+	if (val[0] != 0xff && retry < 5) {
+		dev_err(ts->dev, "FW info is broken! fw_ver=0x%02X, ~fw_ver=0x%02X\n", val[1], val[2]);
+		retry++;
+		goto check_fw;
+	}
+
+	dev_info(ts->dev, "Touch IC fw loaded ok");
+
+	ts->status |= NT36XXX_STATUS_DOWNLOAD_COMPLETE;
+	goto exit;
+
+release_fw_buf:
+	kfree(ts->bin_map);
+	ts->bin_map = NULL;
+release_fw:
+	kfree(ts->fw_entry.data);
+	ts->fw_entry.data = NULL;
+	ts->fw_entry.size = 0;
+exit:
+	return;
+}
+
+/*yell*/
+static void nt36xxx_download_firmware(struct work_struct *work) {
+	struct nt36xxx_ts *ts = container_of(work, struct nt36xxx_ts, work.work);
+	int ret;
+
+	/* Disable power management runtime for the device */
+	pm_runtime_disable(ts->dev);
+
+	/* Disable the touch screen IRQ to prevent further interrupts */
+	disable_irq_nosync(ts->irq);
+
+	/* Cancel any pending delayed work */
+	cancel_delayed_work(&ts->work);
+
+	/* Check and configure the touch screen chip after disabling interrupts */
+	ret = nt36xxx_eng_reset_idle(ts);
+	if (ret) {
+		dev_err(ts->dev, "Failed to check chip version\n");
+		goto skip;
+	}
+
+	/* Set memory maps for the specific chip version */
+	ret = nt36xxx_chip_version_init(ts);
+	if (ret) {
+		dev_err(ts->dev, "Failed to check chip version\n");
+		goto skip;
+	}
+
+	/* Download firmware using the internal function */
+	_nt36xxx_boot_download_firmware(ts);
+
+skip:
+	/* Enable touch screen IRQ and power management runtime */
+	enable_irq(ts->irq);
+	pm_runtime_enable(ts->dev);
+
+	/* If the download is not complete, reschedule the delayed work after 4000ms */
+	if (!(ts->status & NT36XXX_STATUS_DOWNLOAD_COMPLETE)) {
+		cancel_delayed_work(&ts->work);
+		schedule_delayed_work(&ts->work, 4000);
+	}
+}
+
+static void nt36xxx_disable_regulators(void *data)
+{
+	struct nt36xxx_ts *ts = data;
+
+	regulator_bulk_disable(NT36XXX_NUM_SUPPLIES, ts->supplies);
+}
+
+static int nt36xxx_input_dev_config(struct nt36xxx_ts *ts, const struct input_id *id)
+{
+	struct device *dev = ts->dev;
+	int ret;
+
+	/* Allocate memory for the input device structure */
+	ts->input = devm_input_allocate_device(dev);
+	if (!ts->input)
+		return -ENOMEM;
+
+	/* Set the device-specific data to the allocated input device structure */
+	input_set_drvdata(ts->input, ts);
+
+	/* Set physical path for the input device */
+	ts->input->phys = devm_kasprintf(dev, GFP_KERNEL,
+				     "%s/input0", dev_name(dev));
+	if (!ts->input->phys)
+		return -ENOMEM;
+
+	/* Set input device properties */
+	ts->input->name = "Novatek NT36XXX Touchscreen";
+	ts->input->dev.parent = dev;
+	ts->input->id = *id;
+
+	/* Set absolute parameters for touch events */
+	input_set_abs_params(ts->input, ABS_MT_PRESSURE, 0,
+						 TOUCH_MAX_PRESSURE, 0, 0);
+	input_set_abs_params(ts->input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+
+	/* Set absolute parameters for touch position */
+	input_set_abs_params(ts->input, ABS_MT_POSITION_X, 0,
+						 ts->data->abs_x_max - 1, 0, 0);
+	input_set_abs_params(ts->input, ABS_MT_POSITION_Y, 0,
+						 ts->data->abs_y_max - 1, 0, 0);
+
+	/* Parse touchscreen properties */
+	touchscreen_parse_properties(ts->input, true, &ts->prop);
+
+	/* Check if the maximum x-coordinate is valid */
+	WARN_ON(ts->prop.max_x < 1);
+
+	/* Initialize multitouch slots for the input device */
+	ret = input_mt_init_slots(ts->input, TOUCH_MAX_FINGER_NUM,
+				  INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);
+	if (ret) {
+		dev_err(dev, "Cannot init MT slots (%d)\n", ret);
+		return ret;
+	}
+
+	/* Register the input device */
+	ret = input_register_device(ts->input);
+	if (ret) {
+		dev_err(dev, "Failed to register input device: %d\n",
+			ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int nt36xxx_probe(struct device *dev, int irq, const struct input_id *id,
+			struct regmap *regmap)
+{
+	const struct nt36xxx_chip_data *chip_data;
+	int ret;
+
+	/* Allocate memory for the touchscreen data structure */
+	struct nt36xxx_ts *ts = devm_kzalloc(dev, sizeof(struct nt36xxx_ts), GFP_KERNEL);
+	if (!ts)
+		return -ENOMEM;
+
+	/* Set the device-specific data to the allocated structure */
+	dev_set_drvdata(dev, ts);
+
+	/* Retrieve chip-specific data from the device tree */
+	chip_data = of_device_get_match_data(dev);
+	if(!chip_data)
+		return -EINVAL;
+
+	/* Initialize the touchscreen structure with relevant data */
+	ts->dev = dev;
+	ts->regmap = regmap;
+	ts->irq = irq;
+
+	ts->data = chip_data;
+	memcpy(ts->mmap_data, chip_data->mmap, sizeof(ts->mmap_data));
+	ts->mmap = ts->mmap_data;
+
+	/* Allocate memory for GPIO supplies */
+	ts->supplies = devm_kcalloc(dev, NT36XXX_NUM_SUPPLIES,
+				    sizeof(*ts->supplies), GFP_KERNEL);
+	if (!ts->supplies)
+		return -ENOMEM;
+
+	/* Get and configure the optional reset GPIO */
+	ts->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ts->reset_gpio))
+		return PTR_ERR(ts->reset_gpio);
+
+	gpiod_set_consumer_name(ts->reset_gpio, "nt36xxx reset");
+
+	/* Get and configure the optional IRQ GPIO */
+	ts->irq_gpio = devm_gpiod_get_optional(dev, "irq", GPIOD_IN);
+	if (IS_ERR(ts->irq_gpio))
+		return PTR_ERR(ts->irq_gpio);
+
+	/* If IRQ is not specified, try to obtain it from the IRQ GPIO */
+	if (irq <= 0) {
+		ts->irq = gpiod_to_irq(ts->irq_gpio);
+		if (ts->irq <=0) {
+			dev_err(dev, "either need irq or irq-gpio specified in devicetree node!\n");
+			return -EINVAL;
+		}
+
+		dev_dbg(ts->dev, "Interrupts GPIO: %#x\n", ts->irq);
+	}
+
+	gpiod_set_consumer_name(ts->irq_gpio, "nt36xxx irq");
+
+	/* If the device follows a DRM panel, skip regulator initialization */
+	if (drm_is_panel_follower(dev))
+		goto skip_regulators;
+
+	/* These supplies are optional, also shared with LCD panel */
+	ts->supplies[0].supply = "vdd";
+	ts->supplies[1].supply = "vio";
+	ret = devm_regulator_bulk_get(dev,
+				      NT36XXX_NUM_SUPPLIES,
+				      ts->supplies);
+	if (ret)
+		return dev_err_probe(dev, ret,
+				     "Cannot get supplies: %d\n", ret);
+
+	ret = regulator_bulk_enable(NT36XXX_NUM_SUPPLIES, ts->supplies);
+	if (ret)
+		return ret;
+
+	/* Delay for regulators to stabilize */
+	usleep_range(10000, 11000);
+
+	ret = devm_add_action_or_reset(dev, nt36xxx_disable_regulators, ts);
+	if (ret)
+		return ret;
+
+skip_regulators:
+	/* Initialize mutex for synchronization */
+	mutex_init(&ts->lock);
+
+	/* Check and configure the touch screen chip */
+	ret = nt36xxx_eng_reset_idle(ts);
+	if (ret) {
+		dev_err(dev, "Failed to check chip version\n");
+		return ret;
+	}
+
+	/* Set memory maps for the specific chip version */
+	ret = nt36xxx_chip_version_init(ts);
+	if (ret) {
+		dev_err(dev, "Failed to check chip version\n");
+		return ret;
+	}
+
+	/* Parse the firmware path from the device tree */
+	ret = of_property_read_string(dev->of_node, "firmware-name", &ts->firmware_path);
+	if (ret) {
+		dev_err(dev, "Failed to read firmware-name property\n");
+		return ret;
+	}
+
+	/* Сopy the const mmap into drvdata */
+	memcpy(ts->mmap_data, ts->data->mmap, sizeof(ts->mmap_data));
+	ts->mmap = ts->mmap_data;
+
+	ret = nt36xxx_input_dev_config(ts, ts->data->id);
+	if (ret) {
+			dev_err(dev, "failed set input device: %d\n", ret);
+			return ret;
+	}
+
+	/* Request threaded IRQ for touch screen interrupts */
+	ret = devm_request_threaded_irq(dev, ts->irq, NULL, nt36xxx_irq_handler,
+			 IRQ_TYPE_EDGE_RISING | IRQF_ONESHOT, dev_name(dev), ts);
+	if (ret) {
+			dev_err(dev, "request irq failed: %d\n", ret);
+			return ret;
+	}
+
+	/* Set up delayed work for firmware download */
+	devm_delayed_work_autocancel(dev, &ts->work, nt36xxx_download_firmware);
+
+	/* Schedule the delayed work */
+	schedule_delayed_work(&ts->work, 0);
+
+	/* If the device follows a DRM panel, configure panel follower */
+	if (drm_is_panel_follower(dev)) {
+		ts->panel_follower.funcs = &nt36xxx_panel_follower_funcs;
+		devm_drm_panel_add_follower(dev, &ts->panel_follower);
+	}
+
+	dev_info(dev, "Novatek touchscreen initialized\n");
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(nt36xxx_probe);
+
+static int __maybe_unused nt36xxx_internal_pm_suspend(struct device *dev)
+{
+	struct nt36xxx_ts *ts = dev_get_drvdata(dev);
+	int ret = 0;
+
+	ts->status |= NT36XXX_STATUS_SUSPEND;
+
+	cancel_delayed_work_sync(&ts->work);
+
+	if (ts->mmap[MMAP_EVENT_BUF_ADDR]) {
+		ret = regmap_write(ts->regmap, ts->mmap[MMAP_EVENT_BUF_ADDR], NT36XXX_CMD_ENTER_SLEEP);
+	}
+
+	if (ret)
+		dev_err(ts->dev, "Cannot enter suspend!\n");
+	return 0;
+}
+
+static int __maybe_unused nt36xxx_pm_suspend(struct device *dev)
+{
+	struct nt36xxx_ts *ts = dev_get_drvdata(dev);
+	int ret=0;
+
+	if (drm_is_panel_follower(dev))
+		return 0;
+
+	disable_irq_nosync(ts->irq);
+
+	ret = nt36xxx_internal_pm_suspend(dev);
+	return ret;
+}
+
+static int __maybe_unused nt36xxx_internal_pm_resume(struct device *dev)
+{
+	struct nt36xxx_ts *ts = dev_get_drvdata(dev);
+
+	/* some how reduced some kind of cpu, but remove checking should no harm */
+	if(ts->status & NT36XXX_STATUS_SUSPEND)
+		schedule_delayed_work(&ts->work, 0);
+
+	ts->status &= ~NT36XXX_STATUS_SUSPEND;
+
+	return 0;
+}
+
+static int __maybe_unused nt36xxx_pm_resume(struct device *dev)
+{
+	struct nt36xxx_ts *ts = dev_get_drvdata(dev);
+	int ret=0;
+
+	if (drm_is_panel_follower(dev))
+		return 0;
+
+	enable_irq(ts->irq);
+
+	ret = nt36xxx_internal_pm_resume(dev);
+	return ret;
+}
+
+EXPORT_GPL_SIMPLE_DEV_PM_OPS(nt36xxx_pm_ops,
+			     nt36xxx_pm_suspend,
+			     nt36xxx_pm_resume);
+
+static int panel_prepared(struct drm_panel_follower *follower)
+{
+	struct nt36xxx_ts *ts = container_of(follower, struct nt36xxx_ts, panel_follower);
+
+	if (ts->status & NT36XXX_STATUS_SUSPEND)
+		enable_irq(ts->irq);
+
+	/* supposed to clear the flag, but leave to internal_pm_resume
+	for greater purpose */
+	/* ts->status &= ~NT36XXX_STATUS_SUSPEND; */
+
+	return nt36xxx_internal_pm_resume(ts->dev);
+}
+
+static int panel_unpreparing(struct drm_panel_follower *follower)
+{
+	struct nt36xxx_ts *ts = container_of(follower, struct nt36xxx_ts, panel_follower);
+
+	ts->status |= NT36XXX_STATUS_SUSPEND;
+
+	disable_irq(ts->irq);
+
+	return nt36xxx_internal_pm_suspend(ts->dev);
+}
+
+static struct drm_panel_follower_funcs nt36xxx_panel_follower_funcs = {
+	.panel_prepared = panel_prepared,
+	.panel_unpreparing = panel_unpreparing,
+};
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("NT36XXX Touchscreen driver");
+MODULE_AUTHOR("AngeloGioacchino Del Regno <kholk11@gmail.com>");
+MODULE_AUTHOR("99degree <www.github.com/99degree>");
diff --git a/drivers/input/touchscreen/nt36xxx_spi.c b/drivers/input/touchscreen/nt36xxx_spi.c
new file mode 100644
index 00000000000000..da47778c99b291
--- /dev/null
+++ b/drivers/input/touchscreen/nt36xxx_spi.c
@@ -0,0 +1,204 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * NT36XXX SPI Touchscreen Driver
+ *
+ * Copyright (C) 2020 - 2021 Goodix, Inc.
+ * Copyright (C) 2023 Linaro Ltd.
+ * Copyright (C) 2023 99degree <www.github.com/99degree>
+ *
+ * Based on goodix_ts_berlin driver.
+ */
+#include <linux/unaligned.h>
+#include <linux/input/touchscreen.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+
+#include "nt36xxx.h"
+
+#define SPI_READ_PREFIX_LEN	1
+#define SPI_WRITE_PREFIX_LEN	1
+
+#define DEBUG 0
+
+/*
+ * there are two kinds of spi read/write:
+ * 	(a)spi_read()/spi_write()/spi_write_then_read(),
+ * 	(b)and the spi_sync itself.
+ *
+ * we have to choose one and stick together, cross-use otherwise caused problem.
+ * the addressing mode is | 0xff 0xXX 0xYY | 0xZ1 ... data1...| 0xZ2 ...data2... | ...
+ * 	0xXX is bit[23..16]
+ * 	0xYY is bit[15..7]
+ * above describe a 'page select' ops
+ * 	0xZ1 is bit[7..0], addr for read ops
+ *	0xZ2 is bit[7..0] | 0x80, addr for write ops
+ * there is no restriction on the read write order.
+*/
+static int nt36xxx_spi_write(void *dev, const void *data,
+                                   size_t len)
+{
+	struct spi_device *spi = to_spi_device((struct device *)dev);
+	int32_t ret;
+
+	u8 addr[4] = { 0xff, *(u32 *)data >> 15, *(u32 *)data >> 7,  (*(u32 *)data & 0x7f) | 0x80};
+
+	memcpy((void *)data, addr, 4);
+
+	dev_dbg(dev, "%s len=0x%lx", __func__, len);
+
+	spi_write(spi, data, 3);
+	ret = spi_write(spi, (u8 *)data + 3, len - 3);
+	if (ret)
+		dev_err(dev, "transfer err %d\n ", ret);
+	else if (DEBUG) {
+
+		print_hex_dump(KERN_INFO, __func__, DUMP_PREFIX_OFFSET,
+			16, 1, data, 3, true);
+
+		print_hex_dump(KERN_INFO, __func__, DUMP_PREFIX_OFFSET,
+			16, 1, data + 3, (len - 3) > 0x20 ? 0x20 : len - 3 , true);
+	}
+
+	return ret;
+}
+
+static int nt36xxx_spi_read(void *dev, const void *reg_buf,
+                                  size_t reg_size, void *val_buf,
+                                  size_t val_size)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	int ret;
+	u8 addr[4] = { 0xff, *(u32 *)reg_buf >> 15, *(u32 *)reg_buf >> 7,  *(u32 *)reg_buf & 0x7f };
+
+	ret = spi_write(spi, addr, 3);
+	if (ret) {
+		dev_err(dev, "transfer0 err %s %d ret=%d", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	ret = spi_write_then_read(spi, &addr[3] , 1, val_buf, val_size);
+	if (ret) {
+		dev_err(dev, "transfer1 err %s %d ret=%d", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	if (DEBUG) {
+		print_hex_dump(KERN_INFO, __func__, DUMP_PREFIX_OFFSET,
+			16, 1, addr, 3, true);
+
+		print_hex_dump(KERN_INFO, __func__, DUMP_PREFIX_OFFSET,
+			16, 1, addr, (val_size) > 0x20 ? 0x20 : val_size % 0x20 , true);
+
+		print_hex_dump(KERN_INFO, __func__, DUMP_PREFIX_OFFSET,
+			16, 1, val_buf, (val_size > 0x20) ? 0x20 : val_size % 0x20 , true);
+	}
+
+	return ret;
+}
+
+const struct regmap_config nt36xxx_regmap_config_32bit = {
+	.name = "nt36xxx_hw",
+	.reg_bits = 32,
+	.val_bits = 8,
+	.read = nt36xxx_spi_read,
+	.write = nt36xxx_spi_write,
+
+	.max_raw_read = NT36XXX_TRANSFER_LEN + 8,
+	.max_raw_write = NT36XXX_TRANSFER_LEN + 8,
+
+	.zero_flag_mask = true, /* this is needed to make sure addr is not write_masked */
+	.cache_type = REGCACHE_NONE,
+};
+
+static const struct input_id nt36xxx_spi_input_id = {
+	.bustype = BUS_SPI,
+};
+
+static int nt36xxx_spi_probe(struct spi_device *spi)
+{
+	struct regmap_config *regmap_config;
+	struct regmap *regmap;
+	size_t max_size;
+	int ret = 0;
+
+	/* Debug log indicating entry into the probe function */
+	dev_dbg(&spi->dev, "%s %d", __func__, __LINE__);
+
+	/* Allocate and copy the default regmap configuration */
+	regmap_config = devm_kmemdup(&spi->dev, &nt36xxx_regmap_config_32bit,
+				     sizeof(*regmap_config), GFP_KERNEL);
+	if (!regmap_config) {
+		dev_err(&spi->dev, "memdup regmap_config fail\n");
+		return -ENOMEM;
+	}
+
+	/* Set SPI mode and bits per word, and perform SPI setup */
+	spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	ret = spi_setup(spi);
+	if (ret) {
+		dev_err(&spi->dev, "SPI setup error %d\n", ret);
+		return ret;
+	}
+
+	/* Ensure SPI CLK frequency does not exceed the maximum specified frequency */
+	if (spi->max_speed_hz > MAX_SPI_FREQ_HZ) {
+		dev_err(&spi->dev, "SPI CLK %d Hz?\n", spi->max_speed_hz);
+		return -EINVAL;
+	}
+
+	/* Calculate the maximum raw read and write sizes based on SPI transfer size */
+	max_size = spi_max_transfer_size(spi);
+	regmap_config->max_raw_read = max_size - SPI_READ_PREFIX_LEN;
+	regmap_config->max_raw_write = max_size - SPI_WRITE_PREFIX_LEN;
+
+	/* Initialize the regmap using the provided configuration */
+	regmap = devm_regmap_init(&spi->dev, NULL, spi, regmap_config);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	/* Call the main probe function for nt36xxx devices */
+	return nt36xxx_probe(&spi->dev, spi->irq,
+				   &nt36xxx_spi_input_id, regmap);
+}
+
+const struct nt36xxx_chip_data novatek_nt36xxx = {
+	.config = &nt36xxx_regmap_config_32bit,
+	.mmap = nt36675_memory_maps,
+	.abs_x_max = 1080,
+	.abs_y_max = 2400,
+	.id = &nt36xxx_spi_input_id,
+};
+
+static const struct spi_device_id nt36xxx_spi_ids[] = {
+	{ "nt36xxx-spi", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(spi, nt36xxx_spi_ids);
+
+static const struct of_device_id nt36xxx_spi_of_match[] = {
+	{ .compatible = "novatek,nt36xxx-spi", .data = &novatek_nt36xxx, },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, nt36xxx_spi_of_match);
+
+static struct spi_driver nt36xxx_spi_driver = {
+	.driver = {
+		.name   = "nt36xxx-spi",
+		.of_match_table = nt36xxx_spi_of_match,
+		.pm = pm_sleep_ptr(&nt36xxx_pm_ops),
+	},
+	.probe = nt36xxx_spi_probe,
+	.id_table = nt36xxx_spi_ids,
+};
+module_spi_driver(nt36xxx_spi_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("NT36XXX SPI Touchscreen driver");
+MODULE_AUTHOR("Neil Armstrong <neil.armstrong@linaro.org>");
+MODULE_AUTHOR("99degree <www.github.com/99degree>");
diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 8ba096b8ebca24..2aa57aa61145f7 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -385,6 +385,15 @@ config VIDEO_OV13B10
 	  This is a Video4Linux2 sensor driver for the OmniVision
 	  OV13B10 camera.
 
+config VIDEO_OV16A1Q
+	tristate "OmniVision OV16A1Q sensor support"
+	help
+	  This is a Video4Linux2 sensor driver for the OmniVision
+	  OV16A1Q camera.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ov16a1q.
+
 config VIDEO_OV2640
 	tristate "OmniVision OV2640 sensor support"
 	help
@@ -684,12 +693,30 @@ config VIDEO_S5K5BAF
 	  This is a V4L2 sensor driver for Samsung S5K5BAF 2M
 	  camera sensor with an embedded SoC image signal processor.
 
+config VIDEO_S5K5E9
+	tristate "Samsung S5K5E9 sensor support"
+	help
+	  This is a V4L2 sensor driver for Samsung S5K5E9 raw
+	  camera sensor.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called s5k5e9.
+
 config VIDEO_S5K6A3
 	tristate "Samsung S5K6A3 sensor support"
 	help
 	  This is a V4L2 sensor driver for Samsung S5K6A3 raw
 	  camera sensor.
 
+config VIDEO_S5KGM2
+	tristate "Samsung S5KGM2 sensor support"
+	help
+	  This is a V4L2 sensor driver for Samsung S5KGM2 raw
+	  camera sensor.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called s5kgm2.
+
 config VIDEO_VGXY61
 	tristate "ST VGXY61 sensor support"
 	select V4L2_CCI_I2C
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index fbb988bd067a1b..5262156426fd13 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -86,6 +86,7 @@ obj-$(CONFIG_VIDEO_OV08D10) += ov08d10.o
 obj-$(CONFIG_VIDEO_OV08X40) += ov08x40.o
 obj-$(CONFIG_VIDEO_OV13858) += ov13858.o
 obj-$(CONFIG_VIDEO_OV13B10) += ov13b10.o
+obj-$(CONFIG_VIDEO_OV16A1Q) += ov16a1q.o
 obj-$(CONFIG_VIDEO_OV2640) += ov2640.o
 obj-$(CONFIG_VIDEO_OV2659) += ov2659.o
 obj-$(CONFIG_VIDEO_OV2680) += ov2680.o
@@ -119,7 +120,9 @@ obj-$(CONFIG_VIDEO_RDACM21) += rdacm21.o
 obj-$(CONFIG_VIDEO_RJ54N1) += rj54n1cb0c.o
 obj-$(CONFIG_VIDEO_S5C73M3) += s5c73m3/
 obj-$(CONFIG_VIDEO_S5K5BAF) += s5k5baf.o
+obj-$(CONFIG_VIDEO_S5K5E9) += s5k5e9.o
 obj-$(CONFIG_VIDEO_S5K6A3) += s5k6a3.o
+obj-$(CONFIG_VIDEO_S5KGM2) += s5kgm2.o
 obj-$(CONFIG_VIDEO_SAA6588) += saa6588.o
 obj-$(CONFIG_VIDEO_SAA6752HS) += saa6752hs.o
 obj-$(CONFIG_VIDEO_SAA7110) += saa7110.o
diff --git a/drivers/media/i2c/dw9714.c b/drivers/media/i2c/dw9714.c
index 2ddd7daa79e28a..bbcb9f42fa75ad 100644
--- a/drivers/media/i2c/dw9714.c
+++ b/drivers/media/i2c/dw9714.c
@@ -32,12 +32,17 @@
 #define DW9714_DEFAULT_S 0x0
 #define DW9714_VAL(data, s) ((data) << 4 | (s))
 
+static const char * const dw9714_supply_names[] = {
+	"vcc2",
+	"vcc",
+};
+
 /* dw9714 device structure */
 struct dw9714_device {
 	struct v4l2_ctrl_handler ctrls_vcm;
 	struct v4l2_subdev sd;
 	u16 current_val;
-	struct regulator *vcc;
+	struct regulator_bulk_data supplies[ARRAY_SIZE(dw9714_supply_names)];
 };
 
 static inline struct dw9714_device *to_dw9714_vcm(struct v4l2_ctrl *ctrl)
@@ -147,13 +152,20 @@ static int dw9714_probe(struct i2c_client *client)
 	if (dw9714_dev == NULL)
 		return -ENOMEM;
 
-	dw9714_dev->vcc = devm_regulator_get(&client->dev, "vcc");
-	if (IS_ERR(dw9714_dev->vcc))
-		return PTR_ERR(dw9714_dev->vcc);
+	for (unsigned int i = 0; i < ARRAY_SIZE(dw9714_supply_names); i++)
+		dw9714_dev->supplies[i].supply = dw9714_supply_names[i];
+
+	rval = devm_regulator_bulk_get(&client->dev, ARRAY_SIZE(dw9714_supply_names),
+				      dw9714_dev->supplies);
+	if (rval) {
+		dev_err(&client->dev, "failed to get regulators\n");
+		return rval;
+	}
 
-	rval = regulator_enable(dw9714_dev->vcc);
+	rval = regulator_bulk_enable(ARRAY_SIZE(dw9714_supply_names),
+				    dw9714_dev->supplies);
 	if (rval < 0) {
-		dev_err(&client->dev, "failed to enable vcc: %d\n", rval);
+		dev_err(&client->dev, "failed to enable regulators: %d\n", rval);
 		return rval;
 	}
 
@@ -185,7 +197,8 @@ static int dw9714_probe(struct i2c_client *client)
 	return 0;
 
 err_cleanup:
-	regulator_disable(dw9714_dev->vcc);
+	regulator_bulk_disable(ARRAY_SIZE(dw9714_supply_names),
+			       dw9714_dev->supplies);
 	v4l2_ctrl_handler_free(&dw9714_dev->ctrls_vcm);
 	media_entity_cleanup(&dw9714_dev->sd.entity);
 
@@ -200,10 +213,11 @@ static void dw9714_remove(struct i2c_client *client)
 
 	pm_runtime_disable(&client->dev);
 	if (!pm_runtime_status_suspended(&client->dev)) {
-		ret = regulator_disable(dw9714_dev->vcc);
+		ret = regulator_bulk_disable(ARRAY_SIZE(dw9714_supply_names),
+			       dw9714_dev->supplies);
 		if (ret) {
 			dev_err(&client->dev,
-				"Failed to disable vcc: %d\n", ret);
+				"Failed to disable regulators: %d\n", ret);
 		}
 	}
 	pm_runtime_set_suspended(&client->dev);
@@ -234,9 +248,10 @@ static int __maybe_unused dw9714_vcm_suspend(struct device *dev)
 		usleep_range(DW9714_CTRL_DELAY_US, DW9714_CTRL_DELAY_US + 10);
 	}
 
-	ret = regulator_disable(dw9714_dev->vcc);
+	ret = regulator_bulk_disable(ARRAY_SIZE(dw9714_supply_names),
+			       dw9714_dev->supplies);
 	if (ret)
-		dev_err(dev, "Failed to disable vcc: %d\n", ret);
+		dev_err(dev, "Failed to disable regulators: %d\n", ret);
 
 	return ret;
 }
@@ -257,9 +272,10 @@ static int  __maybe_unused dw9714_vcm_resume(struct device *dev)
 	if (pm_runtime_suspended(&client->dev))
 		return 0;
 
-	ret = regulator_enable(dw9714_dev->vcc);
+	ret = regulator_bulk_enable(ARRAY_SIZE(dw9714_supply_names),
+				    dw9714_dev->supplies);
 	if (ret) {
-		dev_err(dev, "Failed to enable vcc: %d\n", ret);
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
 		return ret;
 	}
 	usleep_range(1000, 2000);
diff --git a/drivers/media/i2c/ov16a1q.c b/drivers/media/i2c/ov16a1q.c
new file mode 100644
index 00000000000000..078c18db0612b3
--- /dev/null
+++ b/drivers/media/i2c/ov16a1q.c
@@ -0,0 +1,1376 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2024 Vitalii Skorkin <nikroksm@mail.ru>
+ */
+
+#include <linux/unaligned.h>
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+
+#define to_ov16a1q(_sd) container_of(_sd, struct ov16a1q, sd)
+
+struct ov16a1q_reg {
+	u16 address;
+	u32 val;
+};
+
+struct ov16a1q_reg_list {
+	u32 num_of_regs;
+	const struct ov16a1q_reg *regs;
+};
+
+struct ov16a1q_mode {
+	u32 width;
+	u32 height;
+	u32 hts;
+	u32 vts;
+	s64 link_freq;
+	u32 lane_count;
+	u32 depth;
+	const struct ov16a1q_reg_list reg_list;
+	u32 mbus_code;
+};
+
+static const struct ov16a1q_reg ov16a1q_regs[] = {
+	{0x0103, 0x0001},
+	{0x0102, 0x0000},
+	{0x0301, 0x0048},
+	{0x0302, 0x0031},
+	{0x0303, 0x0004},
+	{0x0305, 0x00c2},
+	{0x0306, 0x0000},
+	{0x0320, 0x0002},
+	{0x0323, 0x0005},
+	{0x0324, 0x0002},
+	{0x0325, 0x00ee},
+	{0x0326, 0x00d8},
+	{0x0327, 0x000b},
+	{0x0329, 0x0001},
+	{0x0343, 0x0004},
+	{0x0344, 0x0001},
+	{0x0345, 0x0077},
+	{0x0346, 0x00c0},
+	{0x034a, 0x0007},
+	{0x300e, 0x0022},
+	{0x3012, 0x0041},
+	{0x3016, 0x00d2},
+	{0x3018, 0x0070},
+	{0x301e, 0x0098},
+	{0x3025, 0x0003},
+	{0x3026, 0x0010},
+	{0x3027, 0x0008},
+	{0x3102, 0x0000},
+	{0x3400, 0x0004},
+	{0x3406, 0x0004},
+	{0x3408, 0x0004},
+	{0x3421, 0x0009},
+	{0x3422, 0x0020},
+	{0x3423, 0x0015},
+	{0x3424, 0x0040},
+	{0x3425, 0x0014},
+	{0x3426, 0x0004},
+	{0x3504, 0x0008},
+	{0x3508, 0x0001},
+	{0x3509, 0x0000},
+	{0x350a, 0x0001},
+	{0x350b, 0x0000},
+	{0x350c, 0x0000},
+	{0x3548, 0x0001},
+	{0x3549, 0x0000},
+	{0x354a, 0x0001},
+	{0x354b, 0x0000},
+	{0x354c, 0x0000},
+	{0x3600, 0x00ff},
+	{0x3602, 0x0042},
+	{0x3603, 0x007b},
+	{0x3608, 0x009b},
+	{0x360a, 0x0069},
+	{0x360b, 0x0053},
+	{0x3618, 0x00c0},
+	{0x361a, 0x008b},
+	{0x361d, 0x0020},
+	{0x361e, 0x0030},
+	{0x361f, 0x0001},
+	{0x3620, 0x0089},
+	{0x3624, 0x008f},
+	{0x3629, 0x0009},
+	{0x362e, 0x0050},
+	{0x3631, 0x00e2},
+	{0x3632, 0x00e2},
+	{0x3634, 0x0010},
+	{0x3635, 0x0010},
+	{0x3636, 0x0010},
+	{0x3639, 0x00a6},
+	{0x363a, 0x00aa},
+	{0x363b, 0x000c},
+	{0x363c, 0x0016},
+	{0x363d, 0x0029},
+	{0x363e, 0x004f},
+	{0x3642, 0x00a8},
+	{0x3652, 0x0000},
+	{0x3653, 0x0000},
+	{0x3654, 0x008a},
+	{0x3656, 0x000c},
+	{0x3657, 0x008e},
+	{0x3660, 0x0080},
+	{0x3663, 0x0000},
+	{0x3664, 0x0000},
+	{0x3668, 0x0005},
+	{0x3669, 0x0005},
+	{0x370d, 0x0010},
+	{0x370e, 0x0005},
+	{0x370f, 0x0010},
+	{0x3711, 0x0001},
+	{0x3712, 0x0009},
+	{0x3713, 0x0040},
+	{0x3714, 0x00e4},
+	{0x3716, 0x0004},
+	{0x3717, 0x0001},
+	{0x3718, 0x0002},
+	{0x3719, 0x0001},
+	{0x371a, 0x0002},
+	{0x371b, 0x0002},
+	{0x371c, 0x0001},
+	{0x371d, 0x0002},
+	{0x371e, 0x0012},
+	{0x371f, 0x0002},
+	{0x3720, 0x0014},
+	{0x3721, 0x0012},
+	{0x3722, 0x0044},
+	{0x3723, 0x0060},
+	{0x372f, 0x0034},
+	{0x3726, 0x0021},
+	{0x37d0, 0x0002},
+	{0x37d1, 0x0010},
+	{0x37db, 0x0008},
+	{0x3808, 0x0012},
+	{0x3809, 0x0030},
+	{0x380a, 0x000d},
+	{0x380b, 0x00a8},
+	{0x380c, 0x0003},
+	{0x380d, 0x0052},
+	{0x380e, 0x000f},
+	{0x380f, 0x0051},
+	{0x3814, 0x0011},
+	{0x3815, 0x0011},
+	{0x3820, 0x0000},
+	{0x3821, 0x0006},
+	{0x3822, 0x0000},
+	{0x3823, 0x0004},
+	{0x3837, 0x0010},
+	{0x383c, 0x0034},
+	{0x383d, 0x00ff},
+	{0x383e, 0x000d},
+	{0x383f, 0x0022},
+	{0x3857, 0x0000},
+	{0x388f, 0x0000},
+	{0x3890, 0x0000},
+	{0x3891, 0x0000},
+	{0x3d81, 0x0010},
+	{0x3d83, 0x000c},
+	{0x3d84, 0x0000},
+	{0x3d85, 0x001b},
+	{0x3d88, 0x0000},
+	{0x3d89, 0x0000},
+	{0x3d8a, 0x0000},
+	{0x3d8b, 0x0001},
+	{0x3d8c, 0x0077},
+	{0x3d8d, 0x00a0},
+	{0x3f00, 0x0002},
+	{0x3f0c, 0x0007},
+	{0x3f0d, 0x002f},
+	{0x4012, 0x000d},
+	{0x4015, 0x0004},
+	{0x4016, 0x001b},
+	{0x4017, 0x0004},
+	{0x4018, 0x000b},
+	{0x401b, 0x001f},
+	{0x401e, 0x0001},
+	{0x401f, 0x0038},
+	{0x4500, 0x0020},
+	{0x4501, 0x006a},
+	{0x4502, 0x00b4},
+	{0x4586, 0x0000},
+	{0x4588, 0x0002},
+	{0x4640, 0x0001},
+	{0x4641, 0x0004},
+	{0x4643, 0x0000},
+	{0x4645, 0x0003},
+	{0x4806, 0x0040},
+	{0x480e, 0x0000},
+	{0x4815, 0x002b},
+	{0x481b, 0x003c},
+	{0x4833, 0x0018},
+	{0x4837, 0x0008},
+	{0x484b, 0x0007},
+	{0x4850, 0x0041},
+	{0x4860, 0x0000},
+	{0x4861, 0x00ec},
+	{0x4864, 0x0000},
+	{0x4883, 0x0000},
+	{0x4888, 0x0010},
+	{0x4a00, 0x0010},
+	{0x4e00, 0x0000},
+	{0x4e01, 0x0004},
+	{0x4e02, 0x0001},
+	{0x4e03, 0x0000},
+	{0x4e04, 0x0008},
+	{0x4e05, 0x0004},
+	{0x4e06, 0x0000},
+	{0x4e07, 0x0013},
+	{0x4e08, 0x0001},
+	{0x4e09, 0x0000},
+	{0x4e0a, 0x0015},
+	{0x4e0b, 0x000e},
+	{0x4e0c, 0x0000},
+	{0x4e0d, 0x0017},
+	{0x4e0e, 0x0007},
+	{0x4e0f, 0x0000},
+	{0x4e10, 0x0019},
+	{0x4e11, 0x0006},
+	{0x4e12, 0x0000},
+	{0x4e13, 0x001b},
+	{0x4e14, 0x0008},
+	{0x4e15, 0x0000},
+	{0x4e16, 0x001f},
+	{0x4e17, 0x0008},
+	{0x4e18, 0x0000},
+	{0x4e19, 0x0021},
+	{0x4e1a, 0x000e},
+	{0x4e1b, 0x0000},
+	{0x4e1c, 0x002d},
+	{0x4e1d, 0x0030},
+	{0x4e1e, 0x0000},
+	{0x4e1f, 0x006a},
+	{0x4e20, 0x0005},
+	{0x4e21, 0x0000},
+	{0x4e22, 0x006c},
+	{0x4e23, 0x0005},
+	{0x4e24, 0x0000},
+	{0x4e25, 0x006e},
+	{0x4e26, 0x0039},
+	{0x4e27, 0x0000},
+	{0x4e28, 0x007a},
+	{0x4e29, 0x006d},
+	{0x4e2a, 0x0000},
+	{0x4e2b, 0x0000},
+	{0x4e2c, 0x0000},
+	{0x4e2d, 0x0000},
+	{0x4e2e, 0x0000},
+	{0x4e2f, 0x0000},
+	{0x4e30, 0x0000},
+	{0x4e31, 0x0000},
+	{0x4e32, 0x0000},
+	{0x4e33, 0x0000},
+	{0x4e34, 0x0000},
+	{0x4e35, 0x0000},
+	{0x4e36, 0x0000},
+	{0x4e37, 0x0000},
+	{0x4e38, 0x0000},
+	{0x4e39, 0x0000},
+	{0x4e3a, 0x0000},
+	{0x4e3b, 0x0000},
+	{0x4e3c, 0x0000},
+	{0x4e3d, 0x0000},
+	{0x4e3e, 0x0000},
+	{0x4e3f, 0x0000},
+	{0x4e40, 0x0000},
+	{0x4e41, 0x0000},
+	{0x4e42, 0x0000},
+	{0x4e43, 0x0000},
+	{0x4e44, 0x0000},
+	{0x4e45, 0x0000},
+	{0x4e46, 0x0000},
+	{0x4e47, 0x0000},
+	{0x4e48, 0x0000},
+	{0x4e49, 0x0000},
+	{0x4e4a, 0x0000},
+	{0x4e4b, 0x0000},
+	{0x4e4c, 0x0000},
+	{0x4e4d, 0x0000},
+	{0x4e4e, 0x0000},
+	{0x4e4f, 0x0000},
+	{0x4e50, 0x0000},
+	{0x4e51, 0x0000},
+	{0x4e52, 0x0000},
+	{0x4e53, 0x0000},
+	{0x4e54, 0x0000},
+	{0x4e55, 0x0000},
+	{0x4e56, 0x0000},
+	{0x4e57, 0x0000},
+	{0x4e58, 0x0000},
+	{0x4e59, 0x0000},
+	{0x4e5a, 0x0000},
+	{0x4e5b, 0x0000},
+	{0x4e5c, 0x0000},
+	{0x4e5d, 0x0000},
+	{0x4e5e, 0x0000},
+	{0x4e5f, 0x0000},
+	{0x4e60, 0x0000},
+	{0x4e61, 0x0000},
+	{0x4e62, 0x0000},
+	{0x4e63, 0x0000},
+	{0x4e64, 0x0000},
+	{0x4e65, 0x0000},
+	{0x4e66, 0x0000},
+	{0x4e67, 0x0000},
+	{0x4e68, 0x0000},
+	{0x4e69, 0x0000},
+	{0x4e6a, 0x0000},
+	{0x4e6b, 0x0000},
+	{0x4e6c, 0x0000},
+	{0x4e6d, 0x0000},
+	{0x4e6e, 0x0000},
+	{0x4e6f, 0x0000},
+	{0x4e70, 0x0000},
+	{0x4e71, 0x0000},
+	{0x4e72, 0x0000},
+	{0x4e73, 0x0000},
+	{0x4e74, 0x0000},
+	{0x4e75, 0x0000},
+	{0x4e76, 0x0000},
+	{0x4e77, 0x0000},
+	{0x4e78, 0x001c},
+	{0x4e79, 0x001e},
+	{0x4e7a, 0x0000},
+	{0x4e7b, 0x0000},
+	{0x4e7c, 0x002c},
+	{0x4e7d, 0x002f},
+	{0x4e7e, 0x0079},
+	{0x4e7f, 0x007b},
+	{0x4e80, 0x000a},
+	{0x4e81, 0x0031},
+	{0x4e82, 0x0066},
+	{0x4e83, 0x0081},
+	{0x4e84, 0x0003},
+	{0x4e85, 0x0040},
+	{0x4e86, 0x0002},
+	{0x4e87, 0x0009},
+	{0x4e88, 0x0043},
+	{0x4e89, 0x0053},
+	{0x4e8a, 0x0032},
+	{0x4e8b, 0x0067},
+	{0x4e8c, 0x0005},
+	{0x4e8d, 0x0083},
+	{0x4e8e, 0x0000},
+	{0x4e8f, 0x0000},
+	{0x4e90, 0x0000},
+	{0x4e91, 0x0000},
+	{0x4e92, 0x0000},
+	{0x4e93, 0x0000},
+	{0x4e94, 0x0000},
+	{0x4e95, 0x0000},
+	{0x4e96, 0x0000},
+	{0x4e97, 0x0000},
+	{0x4e98, 0x0000},
+	{0x4e99, 0x0000},
+	{0x4e9a, 0x0000},
+	{0x4e9b, 0x0000},
+	{0x4e9c, 0x0000},
+	{0x4e9d, 0x0000},
+	{0x4e9e, 0x0000},
+	{0x4e9f, 0x0000},
+	{0x4ea0, 0x0000},
+	{0x4ea1, 0x0000},
+	{0x4ea2, 0x0000},
+	{0x4ea3, 0x0000},
+	{0x4ea4, 0x0000},
+	{0x4ea5, 0x0000},
+	{0x4ea6, 0x001e},
+	{0x4ea7, 0x0020},
+	{0x4ea8, 0x0032},
+	{0x4ea9, 0x006d},
+	{0x4eaa, 0x0018},
+	{0x4eab, 0x007f},
+	{0x4eac, 0x0000},
+	{0x4ead, 0x0000},
+	{0x4eae, 0x007c},
+	{0x4eaf, 0x0007},
+	{0x4eb0, 0x007c},
+	{0x4eb1, 0x0007},
+	{0x4eb2, 0x0007},
+	{0x4eb3, 0x001c},
+	{0x4eb4, 0x0007},
+	{0x4eb5, 0x001c},
+	{0x4eb6, 0x0007},
+	{0x4eb7, 0x001c},
+	{0x4eb8, 0x0007},
+	{0x4eb9, 0x001c},
+	{0x4eba, 0x0007},
+	{0x4ebb, 0x0014},
+	{0x4ebc, 0x0007},
+	{0x4ebd, 0x001c},
+	{0x4ebe, 0x0007},
+	{0x4ebf, 0x001c},
+	{0x4ec0, 0x0007},
+	{0x4ec1, 0x001c},
+	{0x4ec2, 0x0007},
+	{0x4ec3, 0x001c},
+	{0x4ec4, 0x002c},
+	{0x4ec5, 0x002f},
+	{0x4ec6, 0x0079},
+	{0x4ec7, 0x007b},
+	{0x4ec8, 0x007c},
+	{0x4ec9, 0x0007},
+	{0x4eca, 0x007c},
+	{0x4ecb, 0x0007},
+	{0x4ecc, 0x0000},
+	{0x4ecd, 0x0000},
+	{0x4ece, 0x0007},
+	{0x4ecf, 0x0031},
+	{0x4ed0, 0x0069},
+	{0x4ed1, 0x007f},
+	{0x4ed2, 0x0067},
+	{0x4ed3, 0x0000},
+	{0x4ed4, 0x0000},
+	{0x4ed5, 0x0000},
+	{0x4ed6, 0x007c},
+	{0x4ed7, 0x0007},
+	{0x4ed8, 0x007c},
+	{0x4ed9, 0x0007},
+	{0x4eda, 0x0033},
+	{0x4edb, 0x007f},
+	{0x4edc, 0x0000},
+	{0x4edd, 0x0016},
+	{0x4ede, 0x0000},
+	{0x4edf, 0x0000},
+	{0x4ee0, 0x0032},
+	{0x4ee1, 0x0070},
+	{0x4ee2, 0x0001},
+	{0x4ee3, 0x0030},
+	{0x4ee4, 0x0022},
+	{0x4ee5, 0x0028},
+	{0x4ee6, 0x006f},
+	{0x4ee7, 0x0075},
+	{0x4ee8, 0x0000},
+	{0x4ee9, 0x0000},
+	{0x4eea, 0x0030},
+	{0x4eeb, 0x007f},
+	{0x4eec, 0x0000},
+	{0x4eed, 0x0000},
+	{0x4eee, 0x0000},
+	{0x4eef, 0x0000},
+	{0x4ef0, 0x0069},
+	{0x4ef1, 0x007f},
+	{0x4ef2, 0x0007},
+	{0x4ef3, 0x0030},
+	{0x4ef4, 0x0032},
+	{0x4ef5, 0x0009},
+	{0x4ef6, 0x007d},
+	{0x4ef7, 0x0065},
+	{0x4ef8, 0x0000},
+	{0x4ef9, 0x0000},
+	{0x4efa, 0x0000},
+	{0x4efb, 0x0000},
+	{0x4efc, 0x007f},
+	{0x4efd, 0x0009},
+	{0x4efe, 0x007f},
+	{0x4eff, 0x0009},
+	{0x4f00, 0x001e},
+	{0x4f01, 0x007c},
+	{0x4f02, 0x007f},
+	{0x4f03, 0x0009},
+	{0x4f04, 0x007f},
+	{0x4f05, 0x000b},
+	{0x4f06, 0x007c},
+	{0x4f07, 0x0002},
+	{0x4f08, 0x007c},
+	{0x4f09, 0x0002},
+	{0x4f0a, 0x0032},
+	{0x4f0b, 0x0064},
+	{0x4f0c, 0x0032},
+	{0x4f0d, 0x0064},
+	{0x4f0e, 0x0032},
+	{0x4f0f, 0x0064},
+	{0x4f10, 0x0032},
+	{0x4f11, 0x0064},
+	{0x4f12, 0x0031},
+	{0x4f13, 0x004f},
+	{0x4f14, 0x0083},
+	{0x4f15, 0x0084},
+	{0x4f16, 0x0063},
+	{0x4f17, 0x0064},
+	{0x4f18, 0x0083},
+	{0x4f19, 0x0084},
+	{0x4f1a, 0x0031},
+	{0x4f1b, 0x0032},
+	{0x4f1c, 0x007b},
+	{0x4f1d, 0x007c},
+	{0x4f1e, 0x002f},
+	{0x4f1f, 0x0030},
+	{0x4f20, 0x0030},
+	{0x4f21, 0x0069},
+	{0x4d06, 0x0008},
+	{0x5000, 0x0001},
+	{0x5001, 0x0040},
+	{0x5002, 0x0053},
+	{0x5003, 0x0042},
+	{0x5005, 0x0000},
+	{0x5038, 0x0000},
+	{0x5081, 0x0000},
+	{0x5180, 0x0000},
+	{0x5181, 0x0010},
+	{0x5182, 0x0007},
+	{0x5183, 0x008f},
+	{0x5820, 0x00c5},
+	{0x5854, 0x0000},
+	{0x58cb, 0x0003},
+	{0x5bd0, 0x0015},
+	{0x5bd1, 0x0002},
+	{0x5c0e, 0x0011},
+	{0x5c11, 0x0000},
+	{0x5c16, 0x0002},
+	{0x5c17, 0x0001},
+	{0x5c1a, 0x0004},
+	{0x5c1b, 0x0003},
+	{0x5c21, 0x0010},
+	{0x5c22, 0x0010},
+	{0x5c23, 0x0004},
+	{0x5c24, 0x000c},
+	{0x5c25, 0x0004},
+	{0x5c26, 0x000c},
+	{0x5c27, 0x0004},
+	{0x5c28, 0x000c},
+	{0x5c29, 0x0004},
+	{0x5c2a, 0x000c},
+	{0x5c2b, 0x0001},
+	{0x5c2c, 0x0001},
+	{0x5c2e, 0x0008},
+	{0x5c30, 0x0004},
+	{0x5c35, 0x0003},
+	{0x5c36, 0x0003},
+	{0x5c37, 0x0003},
+	{0x5c38, 0x0003},
+	{0x5d00, 0x00ff},
+	{0x5d01, 0x000f},
+	{0x5d02, 0x0080},
+	{0x5d03, 0x0044},
+	{0x5d05, 0x00fc},
+	{0x5d06, 0x000b},
+	{0x5d08, 0x0010},
+	{0x5d09, 0x0010},
+	{0x5d0a, 0x0004},
+	{0x5d0b, 0x000c},
+	{0x5d0c, 0x0004},
+	{0x5d0d, 0x000c},
+	{0x5d0e, 0x0004},
+	{0x5d0f, 0x000c},
+	{0x5d10, 0x0004},
+	{0x5d11, 0x000c},
+	{0x5d12, 0x0001},
+	{0x5d13, 0x0001},
+	{0x5d15, 0x0010},
+	{0x5d16, 0x0010},
+	{0x5d17, 0x0010},
+	{0x5d18, 0x0010},
+	{0x5d1a, 0x0010},
+	{0x5d1b, 0x0010},
+	{0x5d1c, 0x0010},
+	{0x5d1d, 0x0010},
+	{0x5d1e, 0x0004},
+	{0x5d1f, 0x0004},
+	{0x5d20, 0x0004},
+	{0x5d27, 0x0064},
+	{0x5d28, 0x00c8},
+	{0x5d29, 0x0096},
+	{0x5d2a, 0x00ff},
+	{0x5d2b, 0x00c8},
+	{0x5d2c, 0x00ff},
+	{0x5d2d, 0x0004},
+	{0x5d34, 0x0000},
+	{0x5d35, 0x0008},
+	{0x5d36, 0x0000},
+	{0x5d37, 0x0004},
+	{0x5d4a, 0x0000},
+	{0x5d4c, 0x0000},
+};
+
+static const struct ov16a1q_reg ov16a1q_2304x1728_4lane_regs[] = {
+	{0x0305, 0x00e1},
+	{0x0307, 0x0001},
+	{0x4837, 0x0014},
+	{0x0329, 0x0001},
+	{0x0344, 0x0001},
+	{0x0345, 0x0077},
+	{0x034a, 0x0007},
+	{0x3608, 0x0075},
+	{0x360a, 0x0069},
+	{0x361a, 0x008b},
+	{0x361e, 0x0030},
+	{0x3639, 0x0093},
+	{0x363a, 0x0099},
+	{0x3642, 0x0098},
+	{0x3654, 0x008a},
+	{0x3656, 0x000c},
+	{0x3663, 0x0001},
+	{0x370e, 0x0005},
+	{0x3712, 0x0008},
+	{0x3713, 0x00c0},
+	{0x3714, 0x00e2},
+	{0x37d0, 0x0002},
+	{0x37d1, 0x0010},
+	{0x37db, 0x0004},
+	{0x3808, 0x0009},
+	{0x3809, 0x0000},
+	{0x380a, 0x0006},
+	{0x380b, 0x00c0},
+	{0x380c, 0x0003},
+	{0x380d, 0x0052},
+	{0x380e, 0x000f},
+	{0x380f, 0x0050},
+	{0x3814, 0x0022},
+	{0x3815, 0x0022},
+	{0x3820, 0x0001},
+	{0x3821, 0x000c},
+	{0x3822, 0x0000},
+	{0x383c, 0x0022},
+	{0x383f, 0x0033},
+	{0x4015, 0x0002},
+	{0x4016, 0x000d},
+	{0x4017, 0x0000},
+	{0x4018, 0x0007},
+	{0x401b, 0x001f},
+	{0x401f, 0x00fe},
+	{0x4500, 0x0020},
+	{0x4501, 0x006a},
+	{0x4502, 0x00e4},
+	{0x4e05, 0x0004},
+	{0x4e11, 0x0006},
+	{0x4e1d, 0x0025},
+	{0x4e26, 0x0044},
+	{0x4e29, 0x006d},
+	{0x5000, 0x0009},
+	{0x5001, 0x0042},
+	{0x5003, 0x0042},
+	{0x5820, 0x00c5},
+	{0x5854, 0x0000},
+	{0x5bd0, 0x0019},
+	{0x5c0e, 0x0013},
+	{0x5c11, 0x0000},
+	{0x5c16, 0x0001},
+	{0x5c17, 0x0000},
+	{0x5c1a, 0x0000},
+	{0x5c1b, 0x0000},
+	{0x5c21, 0x0008},
+	{0x5c22, 0x0008},
+	{0x5c23, 0x0002},
+	{0x5c24, 0x0006},
+	{0x5c25, 0x0002},
+	{0x5c26, 0x0006},
+	{0x5c27, 0x0002},
+	{0x5c28, 0x0006},
+	{0x5c29, 0x0002},
+	{0x5c2a, 0x0006},
+	{0x5c2b, 0x0000},
+	{0x5c2c, 0x0000},
+	{0x5d01, 0x0007},
+	{0x5d08, 0x0008},
+	{0x5d09, 0x0008},
+	{0x5d0a, 0x0002},
+	{0x5d0b, 0x0006},
+	{0x5d0c, 0x0002},
+	{0x5d0d, 0x0006},
+	{0x5d0e, 0x0002},
+	{0x5d0f, 0x0006},
+	{0x5d10, 0x0002},
+	{0x5d11, 0x0006},
+	{0x5d12, 0x0000},
+	{0x5d13, 0x0000},
+	{0x3500, 0x0000},
+	{0x3501, 0x0007},
+	{0x3502, 0x003c},
+	{0x3508, 0x0001},
+	{0x3509, 0x0000},
+};
+
+static struct ov16a1q_mode ov16a1q_modes[] = {
+	{
+		.width = 2304,
+		.height = 1728,
+		.hts = 2550,
+		.vts = 3920,
+		.link_freq = 180000000,
+		.lane_count = 4,
+		.depth = 10,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(ov16a1q_2304x1728_4lane_regs),
+			.regs = ov16a1q_2304x1728_4lane_regs,
+		},
+		.mbus_code = MEDIA_BUS_FMT_SBGGR10_1X10,
+	},
+};
+
+static const char * const ov16a1q_supply_names[] = {
+	"vana",
+	"vdig",
+	"vio",
+};
+
+struct ov16a1q {
+	struct clk *xvclk;
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *exposure;
+	struct ov16a1q_mode *cur_mode;
+	struct regulator_bulk_data supplies[ARRAY_SIZE(ov16a1q_supply_names)];
+	struct gpio_desc *reset_gpio;
+};
+
+static int ov16a1q_write(struct ov16a1q *ov16a1q, u16 reg, u16 len, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov16a1q->sd);
+	u8 buf[6];
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
+	if (i2c_master_send(client, buf, len + 2) != len + 2) {
+		dev_err(&client->dev,
+				"Cannot write register %u!\n", reg);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int ov16a1q_write_reg_list(struct ov16a1q *ov16a1q, const struct ov16a1q_reg_list *reg_list)
+{
+	int ret = 0;
+
+	for (unsigned int i = 0; i < reg_list->num_of_regs; i++)
+		ret = ov16a1q_write(ov16a1q, reg_list->regs[i].address, 1, reg_list->regs[i].val);
+
+	return ret;
+}
+
+static int ov16a1q_read(struct ov16a1q *ov16a1q, u16 reg, u16 len, u32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov16a1q->sd);
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2];
+	u8 data_buf[4] = {0};
+	int ret;
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, addr_buf);
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = sizeof(addr_buf);
+	msgs[0].buf = addr_buf;
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[4 - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs)) {
+		dev_err(&client->dev,
+				"Cannot read register %u!\n", reg);
+		return -EIO;
+	}
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+static int ov16a1q_start_stream(struct ov16a1q *ov16a1q,
+				   struct v4l2_subdev_state *state)
+{
+	int ret;
+	const struct ov16a1q_reg_list regs = {
+		.num_of_regs = ARRAY_SIZE(ov16a1q_regs),
+		.regs = ov16a1q_regs,
+	};
+
+	ret = ov16a1q_write_reg_list(ov16a1q, &regs);
+	if (ret)
+		return ret;
+
+	ret = ov16a1q_write_reg_list(ov16a1q, &ov16a1q->cur_mode->reg_list);
+	if (ret)
+		return ret;
+
+	ret = __v4l2_ctrl_handler_setup(&ov16a1q->ctrl_handler);
+	if (ret)
+		return ret;
+
+	ret = ov16a1q_write(ov16a1q, 0x0100, 1, 0x01);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int ov16a1q_stop_stream(struct ov16a1q *ov16a1q)
+{
+	int ret;
+
+	ret = ov16a1q_write(ov16a1q, 0x0100, 1, 0x00);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int ov16a1q_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov16a1q *ov16a1q = to_ov16a1q(sd);
+	struct v4l2_subdev_state *state;
+	int ret = 0;
+
+	state = v4l2_subdev_lock_and_get_active_state(sd);
+
+	if (on) {
+		ret = pm_runtime_resume_and_get(&client->dev);
+		if (ret < 0)
+			goto unlock_and_return;
+
+		ret = ov16a1q_start_stream(ov16a1q, state);
+		if (ret) {
+			dev_err(&client->dev, "Failed to start streaming\n");
+			pm_runtime_put_sync(&client->dev);
+			goto unlock_and_return;
+		}
+	} else {
+		ov16a1q_stop_stream(ov16a1q);
+		pm_runtime_mark_last_busy(&client->dev);
+		pm_runtime_put_autosuspend(&client->dev);
+	}
+
+unlock_and_return:
+	v4l2_subdev_unlock_state(state);
+
+	return ret;
+}
+
+static int ov16a1q_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *state,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct ov16a1q *ov16a1q = to_ov16a1q(sd);
+	struct ov16a1q_mode *mode;
+	u64 pixel_rate;
+	u32 v_blank;
+	u32 h_blank;
+
+	mode = v4l2_find_nearest_size(ov16a1q_modes, ARRAY_SIZE(ov16a1q_modes),
+					  width, height, fmt->format.width,
+					  fmt->format.height);
+
+	fmt->format.code = mode->mbus_code;
+	fmt->format.width = mode->width;
+	fmt->format.height = mode->height;
+	fmt->format.field = V4L2_FIELD_NONE;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_state_get_format(state, 0) =  fmt->format;
+	} else {
+		ov16a1q->cur_mode = mode;
+		pixel_rate = mode->link_freq * 2 * mode->lane_count / mode->depth;
+		__v4l2_ctrl_s_ctrl_int64(ov16a1q->pixel_rate, pixel_rate);
+		/* Update limits and set FPS to default */
+		v_blank = mode->vts - mode->height;
+		__v4l2_ctrl_modify_range(ov16a1q->vblank, v_blank,
+					 0xffff - mode->height,
+					 1, v_blank);
+		__v4l2_ctrl_s_ctrl(ov16a1q->vblank, v_blank);
+		h_blank = mode->hts - mode->width;
+		__v4l2_ctrl_modify_range(ov16a1q->hblank, h_blank,
+					 h_blank, 1, h_blank);
+	}
+
+	return 0;
+}
+
+static int ov16a1q_get_selection(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_selection *sel)
+{
+	struct ov16a1q *ov16a1q = to_ov16a1q(sd);
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP:
+		sel->r = *v4l2_subdev_state_get_crop(sd_state, sel->pad);
+		return 0;
+
+	case V4L2_SEL_TGT_NATIVE_SIZE:
+		sel->r.top = 0;
+		sel->r.left = 0;
+		sel->r.width = ov16a1q->cur_mode->width;
+		sel->r.height = ov16a1q->cur_mode->height;
+		return 0;
+
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.top = 0;
+		sel->r.left = 0;
+		sel->r.width = ov16a1q->cur_mode->width;
+		sel->r.height = ov16a1q->cur_mode->height;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int ov16a1q_enum_frame_sizes(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *state,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(ov16a1q_modes))
+		return -EINVAL;
+
+	if (fse->code != ov16a1q_modes[fse->index].mbus_code)
+		return -EINVAL;
+
+	fse->min_width  = ov16a1q_modes[fse->index].width;
+	fse->max_width  = ov16a1q_modes[fse->index].width;
+	fse->max_height = ov16a1q_modes[fse->index].height;
+	fse->min_height = ov16a1q_modes[fse->index].height;
+
+	return 0;
+}
+
+static int ov16a1q_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct ov16a1q *ov16a1q = to_ov16a1q(sd);
+
+	if (code->index != 0)
+		return -EINVAL;
+
+	code->code = ov16a1q->cur_mode->mbus_code;
+
+	return 0;
+}
+
+static int ov16a1q_init_state(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state)
+{
+	struct ov16a1q *ov16a1q = to_ov16a1q(sd);
+	struct v4l2_subdev_format fmt = {
+		.which = V4L2_SUBDEV_FORMAT_TRY,
+		.format = {
+			.width = ov16a1q->cur_mode->width,
+			.height = ov16a1q->cur_mode->height,
+		},
+	};
+
+	ov16a1q_set_fmt(sd, sd_state, &fmt);
+
+	return 0;
+}
+
+static int ov16a1q_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov16a1q *ov16a1q = container_of(ctrl->handler,
+						 struct ov16a1q, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&ov16a1q->sd);
+	struct v4l2_mbus_framefmt *format;
+	struct v4l2_subdev_state *state;
+	u32 exposure_max;
+	int ret;
+
+	state = v4l2_subdev_get_locked_active_state(&ov16a1q->sd);
+	format = v4l2_subdev_state_get_format(state, 0);
+
+	/* Propagate change of current control to all related controls */
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = ov16a1q->cur_mode->height + ctrl->val - 2;
+		__v4l2_ctrl_modify_range(ov16a1q->exposure,
+					 ov16a1q->exposure->minimum,
+					 exposure_max, ov16a1q->exposure->step,
+					 exposure_max);
+	}
+
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_EXPOSURE:
+		ret = ov16a1q_write(ov16a1q, 0x3500, 3, ctrl->val);
+		break;
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ov16a1q_write(ov16a1q, 0x3508, 2, ctrl->val);
+		break;
+	case V4L2_CID_VBLANK:
+		ret = ov16a1q_write(ov16a1q, 0x380e, 2, ov16a1q->cur_mode->height + ctrl->val);
+		break;
+	default:
+		ret = -EINVAL;
+		dev_warn(&client->dev, "%s Unhandled id: 0x%x\n",
+			 __func__, ctrl->id);
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_subdev_core_ops ov16a1q_core_ops = { };
+
+static const struct v4l2_subdev_video_ops ov16a1q_video_ops = {
+	.s_stream = ov16a1q_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov16a1q_pad_ops = {
+	.enum_mbus_code = ov16a1q_enum_mbus_code,
+	.enum_frame_size = ov16a1q_enum_frame_sizes,
+	.get_fmt = v4l2_subdev_get_fmt,
+	.set_fmt = ov16a1q_set_fmt,
+	.get_selection = ov16a1q_get_selection,
+};
+
+static const struct v4l2_subdev_ops ov16a1q_subdev_ops = {
+	.core	= &ov16a1q_core_ops,
+	.video	= &ov16a1q_video_ops,
+	.pad	= &ov16a1q_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops ov16a1q_internal_ops = {
+	.init_state = ov16a1q_init_state,
+};
+
+static const struct v4l2_ctrl_ops ov16a1q_ctrl_ops = {
+	.s_ctrl = ov16a1q_set_ctrl,
+};
+
+static int ov16a1q_power_on(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct ov16a1q *ov16a1q = to_ov16a1q(sd);
+	int ret;
+
+	gpiod_set_value_cansleep(ov16a1q->reset_gpio, 0);
+
+	ret = clk_prepare_enable(ov16a1q->xvclk);
+	if (ret) {
+		dev_err(dev, "Failed to enable xvclk\n");
+		return ret;
+	}
+	usleep_range(2000, 3000);
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ov16a1q_supply_names),
+					ov16a1q->supplies);
+	if (ret) {
+		dev_err(dev, "failed to enable regulators\n");
+		goto disable_clk;
+	}
+
+	gpiod_set_value_cansleep(ov16a1q->reset_gpio, 1);
+	usleep_range(1000, 2000);
+
+	return 0;
+
+disable_clk:
+	clk_disable_unprepare(ov16a1q->xvclk);
+	return ret;
+};
+
+static int ov16a1q_power_off(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct ov16a1q *ov16a1q = to_ov16a1q(sd);
+
+	gpiod_set_value_cansleep(ov16a1q->reset_gpio, 0);
+	usleep_range(2000, 3000);
+
+	clk_disable_unprepare(ov16a1q->xvclk);
+	usleep_range(2000, 3000);
+
+	regulator_bulk_disable(ARRAY_SIZE(ov16a1q_supply_names),
+				   ov16a1q->supplies);
+	return 0;
+};
+
+static int ov16a1q_init_ctrls(struct ov16a1q *ov16a1q)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov16a1q->sd);
+	struct v4l2_ctrl_handler *handler = &ov16a1q->ctrl_handler;
+	struct v4l2_fwnode_device_properties props;
+	struct v4l2_ctrl *ctrl;
+	struct ov16a1q_mode *mode = ov16a1q->cur_mode;
+	u64 pixel_rate;
+	u32 h_blank;
+	u32 v_blank;
+	u32 exposure_max;
+	int ret;
+	static s64 link_freq[] = {
+		0
+	};
+	link_freq[0] = mode->link_freq;
+
+	ret = v4l2_ctrl_handler_init(handler, 5);
+	if (ret)
+		return ret;
+
+	ctrl = v4l2_ctrl_new_int_menu(handler, NULL, V4L2_CID_LINK_FREQ,
+					  ARRAY_SIZE(link_freq) - 1, 0, link_freq);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	pixel_rate = mode->link_freq * 2 * mode->lane_count / mode->depth;
+	ov16a1q->pixel_rate = v4l2_ctrl_new_std(handler, NULL, V4L2_CID_PIXEL_RATE,
+			  0, pixel_rate, 1, pixel_rate);
+
+	h_blank = mode->hts - mode->width;
+	ov16a1q->hblank = v4l2_ctrl_new_std(handler, NULL, V4L2_CID_HBLANK,
+					   h_blank, h_blank, 1, h_blank);
+	if (ov16a1q->hblank)
+		ov16a1q->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	v_blank = mode->vts - mode->height;
+	ov16a1q->vblank = v4l2_ctrl_new_std(handler, &ov16a1q_ctrl_ops,
+					   V4L2_CID_VBLANK, v_blank,
+					   0x7ff7 - mode->height,
+					   1, v_blank);
+
+	exposure_max = mode->vts - 4;
+	ov16a1q->exposure = v4l2_ctrl_new_std(handler, &ov16a1q_ctrl_ops,
+						 V4L2_CID_EXPOSURE,
+						 0,
+						 exposure_max, 1,
+						 exposure_max);
+
+	v4l2_ctrl_new_std(handler, &ov16a1q_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			  128, 1984, 1, 128);
+
+	if (handler->error) {
+		ret = handler->error;
+		goto err_free_handler;
+	}
+
+	ret = v4l2_fwnode_device_parse(&client->dev, &props);
+	if (ret)
+		goto err_free_handler;
+
+	ret = v4l2_ctrl_new_fwnode_properties(handler, &ov16a1q_ctrl_ops,
+						  &props);
+	if (ret)
+		goto err_free_handler;
+
+	ov16a1q->sd.ctrl_handler = handler;
+
+	return 0;
+
+err_free_handler:
+	dev_err(&client->dev, "Failed to init controls: %d\n", ret);
+	v4l2_ctrl_handler_free(handler);
+
+	return ret;
+}
+
+static int ov16a1q_check_sensor_id(struct ov16a1q *ov16a1q)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&ov16a1q->sd);
+	u32 id = 0;
+	int ret;
+
+	ret = ov16a1q_read(ov16a1q, 0x300b, 2, &id);
+	if (ret)
+		return ret;
+
+	if (id != 0x1641) {
+		dev_err(&client->dev, "Chip ID mismatch: expected 0x%x, got 0x%x\n", 0x1641, id);
+		return -ENODEV;
+	}
+
+	dev_info(&client->dev, "Detected ov16a1q sensor\n");
+	return 0;
+}
+
+static int ov16a1q_parse_of(struct ov16a1q *ov16a1q)
+{
+	struct v4l2_fwnode_endpoint vep = { .bus_type = V4L2_MBUS_CSI2_DPHY };
+	struct i2c_client *client = v4l2_get_subdevdata(&ov16a1q->sd);
+	struct device *dev = &client->dev;
+	struct fwnode_handle *endpoint;
+	int ret;
+
+	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);
+	if (!endpoint) {
+		dev_err(dev, "Failed to get endpoint\n");
+		return -EINVAL;
+	}
+
+	ret = v4l2_fwnode_endpoint_parse(endpoint, &vep);
+	fwnode_handle_put(endpoint);
+	if (ret) {
+		dev_err(dev, "Failed to parse endpoint: %d\n", ret);
+		return ret;
+	}
+
+	for (unsigned int i = 0; i < ARRAY_SIZE(ov16a1q_modes); i++) {
+		struct ov16a1q_mode *mode = &ov16a1q_modes[i];
+
+		if (mode->lane_count != vep.bus.mipi_csi2.num_data_lanes)
+			continue;
+
+		ov16a1q->cur_mode = mode;
+		break;
+	}
+
+	if (!ov16a1q->cur_mode) {
+		dev_err(dev, "Unsupported number of data lanes %u\n",
+			vep.bus.mipi_csi2.num_data_lanes);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ov16a1q_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct ov16a1q *ov16a1q;
+	struct v4l2_subdev *sd;
+	int ret;
+
+	ov16a1q = devm_kzalloc(dev, sizeof(*ov16a1q), GFP_KERNEL);
+	if (!ov16a1q)
+		return -ENOMEM;
+
+	ov16a1q->xvclk = devm_clk_get(dev, "xvclk");
+	if (IS_ERR(ov16a1q->xvclk))
+		return dev_err_probe(dev, PTR_ERR(ov16a1q->xvclk),
+					 "Failed to get xvclk\n");
+
+	ov16a1q->reset_gpio = devm_gpiod_get(dev, "reset",
+							 GPIOD_OUT_LOW);
+	if (IS_ERR(ov16a1q->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ov16a1q->reset_gpio),
+					 "Failed to get reset gpio\n");
+
+	v4l2_i2c_subdev_init(&ov16a1q->sd, client, &ov16a1q_subdev_ops);
+	ov16a1q->sd.internal_ops = &ov16a1q_internal_ops;
+
+	for (unsigned int i = 0; i < ARRAY_SIZE(ov16a1q_supply_names); i++)
+		ov16a1q->supplies[i].supply = ov16a1q_supply_names[i];
+
+	ret = devm_regulator_bulk_get(&client->dev,
+					   ARRAY_SIZE(ov16a1q_supply_names),
+					   ov16a1q->supplies);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ret = ov16a1q_parse_of(ov16a1q);
+	if (ret)
+		return ret;
+
+	ret = ov16a1q_init_ctrls(ov16a1q);
+	if (ret)
+		return ret;
+
+	sd = &ov16a1q->sd;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	ov16a1q->pad.flags = MEDIA_PAD_FL_SOURCE;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&sd->entity, 1, &ov16a1q->pad);
+	if (ret < 0)
+		goto err_free_handler;
+
+	sd->state_lock = ov16a1q->ctrl_handler.lock;
+	ret = v4l2_subdev_init_finalize(sd);
+	if (ret < 0) {
+		dev_err(&client->dev, "Subdev initialization error %d\n", ret);
+		goto err_clean_entity;
+	}
+
+	ret = ov16a1q_power_on(dev);
+	if (ret)
+		goto err_clean_entity;
+
+	pm_runtime_set_active(dev);
+	pm_runtime_get_noresume(dev);
+	pm_runtime_enable(dev);
+
+	ret = ov16a1q_check_sensor_id(ov16a1q);
+	if (ret)
+		goto err_power_off;
+
+	pm_runtime_set_autosuspend_delay(dev, 1000);
+	pm_runtime_use_autosuspend(dev);
+
+	ret = v4l2_async_register_subdev_sensor(sd);
+	if (ret) {
+		dev_err(dev, "v4l2 async register subdev failed\n");
+		goto err_power_off;
+	}
+
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return 0;
+
+err_power_off:
+	pm_runtime_disable(dev);
+	pm_runtime_put_noidle(dev);
+	ov16a1q_power_off(dev);
+err_clean_entity:
+	media_entity_cleanup(&sd->entity);
+err_free_handler:
+	v4l2_ctrl_handler_free(&ov16a1q->ctrl_handler);
+
+	return ret;
+};
+
+static void ov16a1q_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov16a1q *ov16a1q = to_ov16a1q(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_ctrl_handler_free(&ov16a1q->ctrl_handler);
+
+	pm_runtime_disable(&client->dev);
+	if (!pm_runtime_status_suspended(&client->dev))
+		ov16a1q_power_off(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+}
+
+static const struct dev_pm_ops ov16a1q_pm_ops = {
+	SET_RUNTIME_PM_OPS(ov16a1q_power_off, ov16a1q_power_on, NULL)
+};
+
+static const struct of_device_id ov16a1q_of_match[] = {
+	{ .compatible = "ovti,ov16a1q" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ov16a1q_of_match);
+
+static struct i2c_driver ov16a1q_i2c_driver = {
+	.driver = {
+		.of_match_table = ov16a1q_of_match,
+		.pm = &ov16a1q_pm_ops,
+		.name = "ov16a1q",
+	},
+	.probe  = ov16a1q_probe,
+	.remove = ov16a1q_remove,
+};
+
+module_i2c_driver(ov16a1q_i2c_driver)
+
+MODULE_DESCRIPTION("Omnivision OV16A1Q image sensor subdev driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/ov8856.c b/drivers/media/i2c/ov8856.c
index 3b94338f55ed39..09a60105461d7a 100644
--- a/drivers/media/i2c/ov8856.c
+++ b/drivers/media/i2c/ov8856.c
@@ -2174,9 +2174,10 @@ static int ov8856_get_format(struct v4l2_subdev *sd,
 	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY)
 		fmt->format = *v4l2_subdev_state_get_format(sd_state,
 							    fmt->pad);
-	else
+	else {
+		fmt->format.code = ov8856_mbus_codes[ov8856->cur_mbus_index];
 		ov8856_update_pad_format(ov8856, ov8856->cur_mode, &fmt->format);
-
+	}
 	mutex_unlock(&ov8856->mutex);
 
 	return 0;
diff --git a/drivers/media/i2c/s5k5e9.c b/drivers/media/i2c/s5k5e9.c
new file mode 100644
index 00000000000000..5a18b8b1cb495a
--- /dev/null
+++ b/drivers/media/i2c/s5k5e9.c
@@ -0,0 +1,829 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2024 Vitalii Skorkin <nikroksm@mail.ru>
+ */
+
+#include <linux/unaligned.h>
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+
+#define to_s5k5e9(_sd) container_of(_sd, struct s5k5e9, sd)
+
+struct s5k5e9_reg {
+	u16 address;
+	u32 val;
+};
+
+struct s5k5e9_reg_list {
+	u32 num_of_regs;
+	const struct s5k5e9_reg *regs;
+};
+
+struct s5k5e9_mode {
+	u32 width;
+	u32 height;
+	u32 hts;
+	u32 vts;
+	s64 link_freq;
+	u32 lane_count;
+	u32 depth;
+	const struct s5k5e9_reg_list reg_list;
+	u32 mbus_code;
+};
+
+static const struct s5k5e9_reg s5k5e9_regs[] = {
+	{0x0100, 0x0000},
+	{0x3b45, 0x0001},
+	{0x0b05, 0x0001},
+	{0x392f, 0x0001},
+	{0x3930, 0x0000},
+	{0x3924, 0x007f},
+	{0x3925, 0x00fd},
+	{0x3c08, 0x00ff},
+	{0x3c09, 0x00ff},
+	{0x3c0a, 0x0005},
+	{0x3c31, 0x00ff},
+	{0x3c32, 0x00ff},
+	{0x3290, 0x0010},
+	{0x3200, 0x0001},
+	{0x3074, 0x0006},
+	{0x3075, 0x002f},
+	{0x308a, 0x0020},
+	{0x308b, 0x0008},
+	{0x308c, 0x000b},
+	{0x3081, 0x0007},
+	{0x307b, 0x0085},
+	{0x307a, 0x000a},
+	{0x3079, 0x000a},
+	{0x306e, 0x0071},
+	{0x306f, 0x0028},
+	{0x301f, 0x0020},
+	{0x3012, 0x004e},
+	{0x306b, 0x009a},
+	{0x3091, 0x0016},
+	{0x30c4, 0x0006},
+	{0x306a, 0x0079},
+	{0x30b0, 0x00ff},
+	{0x306d, 0x0008},
+	{0x3084, 0x0016},
+	{0x3070, 0x000f},
+	{0x30c2, 0x0005},
+	{0x3069, 0x0087},
+	{0x3c0f, 0x0000},
+	{0x3083, 0x0014},
+	{0x3080, 0x0008},
+	{0x3c34, 0x00ea},
+	{0x3c35, 0x005c},
+};
+
+static const struct s5k5e9_reg s5k5e9_2592x1944_2lane_regs[] = {
+	{0x0100, 0x0000},
+	{0x0136, 0x0013},
+	{0x0137, 0x0033},
+	{0x0305, 0x0003},
+	{0x0306, 0x0000},
+	{0x0307, 0x0059},
+	{0x030d, 0x0003},
+	{0x030e, 0x0000},
+	{0x030f, 0x0089},
+	{0x3c1f, 0x0000},
+	{0x3c17, 0x0000},
+	{0x0112, 0x000a},
+	{0x0113, 0x000a},
+	{0x0114, 0x0001},
+	{0x0820, 0x0003},
+	{0x0821, 0x006c},
+	{0x0822, 0x0000},
+	{0x0823, 0x0000},
+	{0x3929, 0x000f},
+	{0x0344, 0x0000},
+	{0x0345, 0x0008},
+	{0x0346, 0x0000},
+	{0x0347, 0x0008},
+	{0x0348, 0x000a},
+	{0x0349, 0x0027},
+	{0x034a, 0x0007},
+	{0x034b, 0x009f},
+	{0x034c, 0x000a},
+	{0x034d, 0x0020},
+	{0x034e, 0x0007},
+	{0x034f, 0x0098},
+	{0x0900, 0x0000},
+	{0x0901, 0x0000},
+	{0x0381, 0x0001},
+	{0x0383, 0x0001},
+	{0x0385, 0x0001},
+	{0x0387, 0x0001},
+	{0x0101, 0x0000},
+	{0x0340, 0x0007},
+	{0x0341, 0x00ee},
+	{0x0342, 0x000c},
+	{0x0343, 0x0028},
+	{0x0200, 0x000b},
+	{0x0201, 0x009c},
+	{0x0202, 0x0000},
+	{0x0203, 0x0002},
+	{0x30b8, 0x002e},
+	{0x30ba, 0x0036},
+};
+
+static struct s5k5e9_mode s5k5e9_modes[] = {
+	{
+		.width = 2592,
+		.height = 1944,
+		.hts = 3112,
+		.vts = 2030,
+		.link_freq = 480000000,
+		.lane_count = 2,
+		.depth = 10,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(s5k5e9_2592x1944_2lane_regs),
+			.regs = s5k5e9_2592x1944_2lane_regs,
+		},
+		.mbus_code = MEDIA_BUS_FMT_SGRBG10_1X10,
+	},
+};
+
+static const char * const s5k5e9_supply_names[] = {
+	"vana",
+	"vdig",
+	"vio",
+};
+
+struct s5k5e9 {
+	struct clk *xvclk;
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *exposure;
+	struct s5k5e9_mode *cur_mode;
+	struct regulator_bulk_data supplies[ARRAY_SIZE(s5k5e9_supply_names)];
+	struct gpio_desc *reset_gpio;
+};
+
+static int s5k5e9_write(struct s5k5e9 *s5k5e9, u16 reg, u16 len, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&s5k5e9->sd);
+	u8 buf[6];
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
+	if (i2c_master_send(client, buf, len + 2) != len + 2) {
+		dev_err(&client->dev,
+			"Cannot write register %u!\n", reg);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int s5k5e9_write_reg_list(struct s5k5e9 *s5k5e9, const struct s5k5e9_reg_list *reg_list)
+{
+	int ret = 0;
+
+	for (unsigned int i = 0; i < reg_list->num_of_regs; i++)
+		ret = s5k5e9_write(s5k5e9, reg_list->regs[i].address, 1, reg_list->regs[i].val);
+
+	return ret;
+}
+
+static int s5k5e9_read(struct s5k5e9 *s5k5e9, u16 reg, u16 len, u32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&s5k5e9->sd);
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2];
+	u8 data_buf[4] = {0};
+	int ret;
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, addr_buf);
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = sizeof(addr_buf);
+	msgs[0].buf = addr_buf;
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[4 - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs)) {
+		dev_err(&client->dev,
+			"Cannot read register %u!\n", reg);
+		return -EIO;
+	}
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+static int s5k5e9_start_stream(struct s5k5e9 *s5k5e9,
+				   struct v4l2_subdev_state *state)
+{
+	int ret;
+	const struct s5k5e9_reg_list regs = {
+		.num_of_regs = ARRAY_SIZE(s5k5e9_regs),
+		.regs = s5k5e9_regs,
+	};
+
+	ret = s5k5e9_write_reg_list(s5k5e9, &regs);
+	if (ret)
+		return ret;
+
+	ret = s5k5e9_write_reg_list(s5k5e9, &s5k5e9->cur_mode->reg_list);
+	if (ret)
+		return ret;
+
+	ret = __v4l2_ctrl_handler_setup(&s5k5e9->ctrl_handler);
+	if (ret)
+		return ret;
+
+	ret = s5k5e9_write(s5k5e9, 0x0100, 1, 0x01);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int s5k5e9_stop_stream(struct s5k5e9 *s5k5e9)
+{
+	int ret;
+
+	ret = s5k5e9_write(s5k5e9, 0x0100, 1, 0x00);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int s5k5e9_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct s5k5e9 *s5k5e9 = to_s5k5e9(sd);
+	struct v4l2_subdev_state *state;
+	int ret = 0;
+
+	state = v4l2_subdev_lock_and_get_active_state(sd);
+
+	if (on) {
+		ret = pm_runtime_resume_and_get(&client->dev);
+		if (ret < 0)
+			goto unlock_and_return;
+
+		ret = s5k5e9_start_stream(s5k5e9, state);
+		if (ret) {
+			dev_err(&client->dev, "Failed to start streaming\n");
+			pm_runtime_put_sync(&client->dev);
+			goto unlock_and_return;
+		}
+	} else {
+		s5k5e9_stop_stream(s5k5e9);
+		pm_runtime_mark_last_busy(&client->dev);
+		pm_runtime_put_autosuspend(&client->dev);
+	}
+
+unlock_and_return:
+	v4l2_subdev_unlock_state(state);
+
+	return ret;
+}
+
+static int s5k5e9_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *state,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct s5k5e9 *s5k5e9 = to_s5k5e9(sd);
+	struct s5k5e9_mode *mode;
+	u64 pixel_rate;
+	u32 v_blank;
+	u32 h_blank;
+
+	mode = v4l2_find_nearest_size(s5k5e9_modes, ARRAY_SIZE(s5k5e9_modes),
+					  width, height, fmt->format.width,
+					  fmt->format.height);
+
+	fmt->format.code = mode->mbus_code;
+	fmt->format.width = mode->width;
+	fmt->format.height = mode->height;
+	fmt->format.field = V4L2_FIELD_NONE;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_state_get_format(state, 0) =  fmt->format;
+	} else {
+		s5k5e9->cur_mode = mode;
+		pixel_rate = mode->link_freq * 2 * mode->lane_count / mode->depth;
+		__v4l2_ctrl_s_ctrl_int64(s5k5e9->pixel_rate, pixel_rate);
+		/* Update limits and set FPS to default */
+		v_blank = mode->vts - mode->height;
+		__v4l2_ctrl_modify_range(s5k5e9->vblank, v_blank,
+					 0xffff - mode->height,
+					 1, v_blank);
+		__v4l2_ctrl_s_ctrl(s5k5e9->vblank, v_blank);
+		h_blank = mode->hts - mode->width;
+		__v4l2_ctrl_modify_range(s5k5e9->hblank, h_blank,
+					 h_blank, 1, h_blank);
+	}
+
+	return 0;
+}
+
+static int s5k5e9_get_selection(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_selection *sel)
+{
+	struct s5k5e9 *s5k5e9 = to_s5k5e9(sd);
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP:
+		sel->r = *v4l2_subdev_state_get_crop(sd_state, sel->pad);
+		return 0;
+
+	case V4L2_SEL_TGT_NATIVE_SIZE:
+		sel->r.top = 0;
+		sel->r.left = 0;
+		sel->r.width = s5k5e9->cur_mode->width;
+		sel->r.height = s5k5e9->cur_mode->height;
+		return 0;
+
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.top = 0;
+		sel->r.left = 0;
+		sel->r.width = s5k5e9->cur_mode->width;
+		sel->r.height = s5k5e9->cur_mode->height;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int s5k5e9_enum_frame_sizes(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *state,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(s5k5e9_modes))
+		return -EINVAL;
+
+	if (fse->code != s5k5e9_modes[fse->index].mbus_code)
+		return -EINVAL;
+
+	fse->min_width  = s5k5e9_modes[fse->index].width;
+	fse->max_width  = s5k5e9_modes[fse->index].width;
+	fse->max_height = s5k5e9_modes[fse->index].height;
+	fse->min_height = s5k5e9_modes[fse->index].height;
+
+	return 0;
+}
+
+static int s5k5e9_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct s5k5e9 *s5k5e9 = to_s5k5e9(sd);
+
+	if (code->index != 0)
+		return -EINVAL;
+
+	code->code = s5k5e9->cur_mode->mbus_code;
+
+	return 0;
+}
+
+static int s5k5e9_init_state(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state)
+{
+	struct s5k5e9 *s5k5e9 = to_s5k5e9(sd);
+	struct v4l2_subdev_format fmt = {
+		.which = V4L2_SUBDEV_FORMAT_TRY,
+		.format = {
+			.width = s5k5e9->cur_mode->width,
+			.height = s5k5e9->cur_mode->height,
+		},
+	};
+
+	s5k5e9_set_fmt(sd, sd_state, &fmt);
+
+	return 0;
+}
+
+static int s5k5e9_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct s5k5e9 *s5k5e9 = container_of(ctrl->handler,
+						 struct s5k5e9, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&s5k5e9->sd);
+	struct v4l2_mbus_framefmt *format;
+	struct v4l2_subdev_state *state;
+	u32 exposure_max;
+	int ret;
+
+	state = v4l2_subdev_get_locked_active_state(&s5k5e9->sd);
+	format = v4l2_subdev_state_get_format(state, 0);
+
+	/* Propagate change of current control to all related controls */
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = s5k5e9->cur_mode->height + ctrl->val - 2;
+		__v4l2_ctrl_modify_range(s5k5e9->exposure,
+					 s5k5e9->exposure->minimum,
+					 exposure_max, s5k5e9->exposure->step,
+					 exposure_max);
+	}
+
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_EXPOSURE:
+		ret = s5k5e9_write(s5k5e9, 0x0104, 1, 0x01);
+		ret = s5k5e9_write(s5k5e9, 0x0202, 2, ctrl->val);
+		ret = s5k5e9_write(s5k5e9, 0x0104, 1, 0x00);
+		break;
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = s5k5e9_write(s5k5e9, 0x0104, 1, 0x01);
+		ret = s5k5e9_write(s5k5e9, 0x0204, 2, ctrl->val);
+		ret = s5k5e9_write(s5k5e9, 0x0104, 1, 0x00);
+		break;
+	case V4L2_CID_VBLANK:
+		ret = s5k5e9_write(s5k5e9, 0x0104, 1, 0x01);
+		ret = s5k5e9_write(s5k5e9, 0x0340, 2, s5k5e9->cur_mode->height + ctrl->val);
+		ret = s5k5e9_write(s5k5e9, 0x0104, 1, 0x00);
+		break;
+	default:
+		ret = -EINVAL;
+		dev_warn(&client->dev, "%s Unhandled id: 0x%x\n",
+			 __func__, ctrl->id);
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_subdev_core_ops s5k5e9_core_ops = { };
+
+static const struct v4l2_subdev_video_ops s5k5e9_video_ops = {
+	.s_stream = s5k5e9_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops s5k5e9_pad_ops = {
+	.enum_mbus_code = s5k5e9_enum_mbus_code,
+	.enum_frame_size = s5k5e9_enum_frame_sizes,
+	.get_fmt = v4l2_subdev_get_fmt,
+	.set_fmt = s5k5e9_set_fmt,
+	.get_selection = s5k5e9_get_selection,
+};
+
+static const struct v4l2_subdev_ops s5k5e9_subdev_ops = {
+	.core	= &s5k5e9_core_ops,
+	.video	= &s5k5e9_video_ops,
+	.pad	= &s5k5e9_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops s5k5e9_internal_ops = {
+	.init_state = s5k5e9_init_state,
+};
+
+static const struct v4l2_ctrl_ops s5k5e9_ctrl_ops = {
+	.s_ctrl = s5k5e9_set_ctrl,
+};
+
+static int s5k5e9_power_on(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct s5k5e9 *s5k5e9 = to_s5k5e9(sd);
+	int ret;
+
+	gpiod_set_value_cansleep(s5k5e9->reset_gpio, 0);
+	usleep_range(1000, 2000);
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(s5k5e9_supply_names),
+					s5k5e9->supplies);
+	if (ret) {
+		dev_err(dev, "failed to enable regulators\n");
+		return ret;
+	}
+	usleep_range(1000, 2000);
+
+	ret = clk_prepare_enable(s5k5e9->xvclk);
+	if (ret) {
+		dev_err(dev, "Failed to enable xvclk\n");
+		goto disable_regulator;
+	}
+	usleep_range(10000, 11000);
+
+	gpiod_set_value_cansleep(s5k5e9->reset_gpio, 1);
+	usleep_range(18000, 19000);
+
+	return 0;
+
+disable_regulator:
+	regulator_bulk_disable(ARRAY_SIZE(s5k5e9_supply_names),
+				   s5k5e9->supplies);
+	return ret;
+};
+
+static int s5k5e9_power_off(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct s5k5e9 *s5k5e9 = to_s5k5e9(sd);
+
+	clk_disable_unprepare(s5k5e9->xvclk);
+	usleep_range(1000, 2000);
+
+	gpiod_set_value_cansleep(s5k5e9->reset_gpio, 0);
+	usleep_range(1000, 2000);
+
+	regulator_bulk_disable(ARRAY_SIZE(s5k5e9_supply_names),
+					  s5k5e9->supplies);
+	return 0;
+};
+
+static int s5k5e9_init_ctrls(struct s5k5e9 *s5k5e9)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&s5k5e9->sd);
+	struct v4l2_ctrl_handler *handler = &s5k5e9->ctrl_handler;
+	struct v4l2_fwnode_device_properties props;
+	struct v4l2_ctrl *ctrl;
+	struct s5k5e9_mode *mode = s5k5e9->cur_mode;
+	u64 pixel_rate;
+	u32 h_blank;
+	u32 v_blank;
+	u32 exposure_max;
+	int ret;
+	static s64 link_freq[] = {
+		0
+	};
+	link_freq[0] = mode->link_freq;
+
+	ret = v4l2_ctrl_handler_init(handler, 5);
+	if (ret)
+		return ret;
+
+	ctrl = v4l2_ctrl_new_int_menu(handler, NULL, V4L2_CID_LINK_FREQ,
+					  ARRAY_SIZE(link_freq) - 1, 0, link_freq);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	pixel_rate = mode->link_freq * 2 * mode->lane_count / mode->depth;
+	s5k5e9->pixel_rate = v4l2_ctrl_new_std(handler, NULL, V4L2_CID_PIXEL_RATE,
+			  0, pixel_rate, 1, pixel_rate);
+
+	h_blank = mode->hts - mode->width;
+	s5k5e9->hblank = v4l2_ctrl_new_std(handler, NULL, V4L2_CID_HBLANK,
+					   h_blank, h_blank, 1, h_blank);
+	if (s5k5e9->hblank)
+		s5k5e9->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	v_blank = mode->vts - mode->height;
+	s5k5e9->vblank = v4l2_ctrl_new_std(handler, &s5k5e9_ctrl_ops,
+					   V4L2_CID_VBLANK, v_blank,
+					   0xffff - mode->height,
+					   1, v_blank);
+
+	exposure_max = mode->vts - 2;
+	s5k5e9->exposure = v4l2_ctrl_new_std(handler, &s5k5e9_ctrl_ops,
+						 V4L2_CID_EXPOSURE,
+						 0,
+						 exposure_max, 1,
+						 exposure_max);
+
+	v4l2_ctrl_new_std(handler, &s5k5e9_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			  32, 1024, 1, 1024);
+
+	if (handler->error) {
+		ret = handler->error;
+		goto err_free_handler;
+	}
+
+	ret = v4l2_fwnode_device_parse(&client->dev, &props);
+	if (ret)
+		goto err_free_handler;
+
+	ret = v4l2_ctrl_new_fwnode_properties(handler, &s5k5e9_ctrl_ops,
+						  &props);
+	if (ret)
+		goto err_free_handler;
+
+	s5k5e9->sd.ctrl_handler = handler;
+
+	return 0;
+
+err_free_handler:
+	dev_err(&client->dev, "Failed to init controls: %d\n", ret);
+	v4l2_ctrl_handler_free(handler);
+
+	return ret;
+}
+
+static int s5k5e9_check_sensor_id(struct s5k5e9 *s5k5e9)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&s5k5e9->sd);
+	u32 id = 0;
+	int ret;
+
+	ret = s5k5e9_read(s5k5e9, 0x0000, 2, &id);
+	if (ret)
+		return ret;
+
+	if (id != 0x559b) {
+		dev_err(&client->dev, "Chip ID mismatch: expected 0x%x, got 0x%x\n", 0x559b, id);
+		return -ENODEV;
+	}
+
+	dev_info(&client->dev, "Detected s5k5e9 sensor\n");
+	return 0;
+}
+
+static int s5k5e9_parse_of(struct s5k5e9 *s5k5e9)
+{
+	struct v4l2_fwnode_endpoint vep = { .bus_type = V4L2_MBUS_CSI2_DPHY };
+	struct i2c_client *client = v4l2_get_subdevdata(&s5k5e9->sd);
+	struct device *dev = &client->dev;
+	struct fwnode_handle *endpoint;
+	int ret;
+
+	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);
+	if (!endpoint) {
+		dev_err(dev, "Failed to get endpoint\n");
+		return -EINVAL;
+	}
+
+	ret = v4l2_fwnode_endpoint_parse(endpoint, &vep);
+	fwnode_handle_put(endpoint);
+	if (ret) {
+		dev_err(dev, "Failed to parse endpoint: %d\n", ret);
+		return ret;
+	}
+
+	for (unsigned int i = 0; i < ARRAY_SIZE(s5k5e9_modes); i++) {
+		struct s5k5e9_mode *mode = &s5k5e9_modes[i];
+
+		if (mode->lane_count != vep.bus.mipi_csi2.num_data_lanes)
+			continue;
+
+		s5k5e9->cur_mode = mode;
+		break;
+	}
+
+	if (!s5k5e9->cur_mode) {
+		dev_err(dev, "Unsupported number of data lanes %u\n",
+			vep.bus.mipi_csi2.num_data_lanes);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int s5k5e9_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct s5k5e9 *s5k5e9;
+	struct v4l2_subdev *sd;
+	int ret;
+
+	s5k5e9 = devm_kzalloc(dev, sizeof(*s5k5e9), GFP_KERNEL);
+	if (!s5k5e9)
+		return -ENOMEM;
+
+	s5k5e9->xvclk = devm_clk_get(dev, "xvclk");
+	if (IS_ERR(s5k5e9->xvclk))
+		return dev_err_probe(dev, PTR_ERR(s5k5e9->xvclk),
+					 "Failed to get xvclk\n");
+
+	s5k5e9->reset_gpio = devm_gpiod_get(dev, "reset",
+							 GPIOD_OUT_LOW);
+	if (IS_ERR(s5k5e9->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(s5k5e9->reset_gpio),
+					 "Failed to get reset gpio\n");
+
+	v4l2_i2c_subdev_init(&s5k5e9->sd, client, &s5k5e9_subdev_ops);
+	s5k5e9->sd.internal_ops = &s5k5e9_internal_ops;
+
+	for (unsigned int i = 0; i < ARRAY_SIZE(s5k5e9_supply_names); i++)
+		s5k5e9->supplies[i].supply = s5k5e9_supply_names[i];
+
+	ret = devm_regulator_bulk_get(&client->dev,
+					   ARRAY_SIZE(s5k5e9_supply_names),
+					   s5k5e9->supplies);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ret = s5k5e9_parse_of(s5k5e9);
+	if (ret)
+		return ret;
+
+	ret = s5k5e9_init_ctrls(s5k5e9);
+	if (ret)
+		return ret;
+
+	sd = &s5k5e9->sd;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	s5k5e9->pad.flags = MEDIA_PAD_FL_SOURCE;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&sd->entity, 1, &s5k5e9->pad);
+	if (ret < 0)
+		goto err_free_handler;
+
+	sd->state_lock = s5k5e9->ctrl_handler.lock;
+	ret = v4l2_subdev_init_finalize(sd);
+	if (ret < 0) {
+		dev_err(&client->dev, "Subdev initialization error %d\n", ret);
+		goto err_clean_entity;
+	}
+
+	ret = s5k5e9_power_on(dev);
+	if (ret)
+		goto err_clean_entity;
+
+	pm_runtime_set_active(dev);
+	pm_runtime_get_noresume(dev);
+	pm_runtime_enable(dev);
+
+	ret = s5k5e9_check_sensor_id(s5k5e9);
+	if (ret)
+		goto err_power_off;
+
+	pm_runtime_set_autosuspend_delay(dev, 1000);
+	pm_runtime_use_autosuspend(dev);
+
+	ret = v4l2_async_register_subdev_sensor(sd);
+	if (ret) {
+		dev_err(dev, "v4l2 async register subdev failed\n");
+		goto err_power_off;
+	}
+
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return 0;
+
+err_power_off:
+	pm_runtime_disable(dev);
+	pm_runtime_put_noidle(dev);
+	s5k5e9_power_off(dev);
+err_clean_entity:
+	media_entity_cleanup(&sd->entity);
+err_free_handler:
+	v4l2_ctrl_handler_free(&s5k5e9->ctrl_handler);
+
+	return ret;
+};
+
+static void s5k5e9_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct s5k5e9 *s5k5e9 = to_s5k5e9(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_ctrl_handler_free(&s5k5e9->ctrl_handler);
+
+	pm_runtime_disable(&client->dev);
+	if (!pm_runtime_status_suspended(&client->dev))
+		s5k5e9_power_off(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+}
+
+static const struct dev_pm_ops s5k5e9_pm_ops = {
+	SET_RUNTIME_PM_OPS(s5k5e9_power_off, s5k5e9_power_on, NULL)
+};
+
+static const struct of_device_id s5k5e9_of_match[] = {
+	{ .compatible = "samsung,s5k5e9" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, s5k5e9_of_match);
+
+static struct i2c_driver s5k5e9_i2c_driver = {
+	.driver = {
+		.of_match_table = s5k5e9_of_match,
+		.pm = &s5k5e9_pm_ops,
+		.name = "s5k5e9",
+	},
+	.probe  = s5k5e9_probe,
+	.remove = s5k5e9_remove,
+};
+
+module_i2c_driver(s5k5e9_i2c_driver)
+
+MODULE_DESCRIPTION("Samsung S5K5E9 image sensor subdev driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/s5kgm2.c b/drivers/media/i2c/s5kgm2.c
new file mode 100644
index 00000000000000..4f0b2e0e21321b
--- /dev/null
+++ b/drivers/media/i2c/s5kgm2.c
@@ -0,0 +1,3768 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2024 Vitalii Skorkin <nikroksm@mail.ru>
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/unaligned.h>
+
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+
+#define to_s5kgm2(_sd) container_of(_sd, struct s5kgm2, sd)
+
+struct s5kgm2_reg {
+	u16 address;
+	u32 val;
+};
+
+struct s5kgm2_reg_list {
+	u32 num_of_regs;
+	const struct s5kgm2_reg *regs;
+};
+
+struct s5kgm2_mode {
+	u32 width;
+	u32 height;
+	u32 hts;
+	u32 vts;
+	s64 link_freq;
+	u32 lane_count;
+	u32 depth;
+	const struct s5kgm2_reg_list reg_list;
+	u32 mbus_code;
+};
+
+static const struct s5kgm2_reg s5kgm2_regs[] = {
+	{0x6028, 0x4000},
+	{0x0000, 0x0011},
+	{0x0000, 0x08d2},
+	{0x6214, 0xf9f3},
+	{0x0a02, 0x0074},
+	{0x6028, 0x2000},
+	{0x602a, 0x52d8},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xf6be},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x40ba},
+	{0x6f12, 0x7047},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0xc0ba},
+	{0x6f12, 0x7047},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x2de9},
+	{0x6f12, 0xfc41},
+	{0x6f12, 0x0446},
+	{0x6f12, 0x0120},
+	{0x6f12, 0x8df8},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x8df8},
+	{0x6f12, 0x0400},
+	{0x6f12, 0xf848},
+	{0x6f12, 0x1f46},
+	{0x6f12, 0x1646},
+	{0x6f12, 0x0d46},
+	{0x6f12, 0x8442},
+	{0x6f12, 0x04d1},
+	{0x6f12, 0x01a9},
+	{0x6f12, 0x6846},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x82fd},
+	{0x6f12, 0x07e0},
+	{0x6f12, 0xf348},
+	{0x6f12, 0xf830},
+	{0x6f12, 0x8442},
+	{0x6f12, 0x03d1},
+	{0x6f12, 0x01a9},
+	{0x6f12, 0x6846},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x7efd},
+	{0x6f12, 0x2368},
+	{0x6f12, 0xe068},
+	{0x6f12, 0xd4e9},
+	{0x6f12, 0x041c},
+	{0x6f12, 0x1a1a},
+	{0x6f12, 0x01fb},
+	{0x6f12, 0x1c22},
+	{0x6f12, 0x4ff0},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x97b1},
+	{0x6f12, 0x981b},
+	{0x6f12, 0x431e},
+	{0x6f12, 0x9342},
+	{0x6f12, 0x20dc},
+	{0x6f12, 0x101a},
+	{0x6f12, 0x4000},
+	{0x6f12, 0x9df8},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x9df8},
+	{0x6f12, 0x0430},
+	{0x6f12, 0x801c},
+	{0x6f12, 0x1a44},
+	{0x6f12, 0x90fb},
+	{0x6f12, 0xf2f0},
+	{0x6f12, 0x491e},
+	{0x6f12, 0xc4e9},
+	{0x6f12, 0x0d01},
+	{0x6f12, 0xbde8},
+	{0x6f12, 0xfc81},
+	{0x6f12, 0x8542},
+	{0x6f12, 0x0bdc},
+	{0x6f12, 0x9df8},
+	{0x6f12, 0x0010},
+	{0x6f12, 0x9df8},
+	{0x6f12, 0x0420},
+	{0x6f12, 0x401b},
+	{0x6f12, 0x4000},
+	{0x6f12, 0x1144},
+	{0x6f12, 0x90fb},
+	{0x6f12, 0xf1f0},
+	{0x6f12, 0xc4e9},
+	{0x6f12, 0x0d0c},
+	{0x6f12, 0xefe7},
+	{0x6f12, 0x281a},
+	{0x6f12, 0xc4f8},
+	{0x6f12, 0x34c0},
+	{0x6f12, 0x02e0},
+	{0x6f12, 0xb01a},
+	{0x6f12, 0xc4f8},
+	{0x6f12, 0x34c0},
+	{0x6f12, 0x90fb},
+	{0x6f12, 0xf1f2},
+	{0x6f12, 0x01fb},
+	{0x6f12, 0x1200},
+	{0x6f12, 0xa063},
+	{0x6f12, 0xe2e7},
+	{0x6f12, 0x2de9},
+	{0x6f12, 0xf047},
+	{0x6f12, 0x8246},
+	{0x6f12, 0xd248},
+	{0x6f12, 0x0c46},
+	{0x6f12, 0xd24d},
+	{0x6f12, 0x10f8},
+	{0x6f12, 0x5a1f},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x35f8},
+	{0x6f12, 0xa47f},
+	{0x6f12, 0x8078},
+	{0x6f12, 0x6e88},
+	{0x6f12, 0x491e},
+	{0x6f12, 0x3944},
+	{0x6f12, 0x401e},
+	{0x6f12, 0x2980},
+	{0x6f12, 0x3044},
+	{0x6f12, 0x6880},
+	{0x6f12, 0xcc48},
+	{0x6f12, 0x0068},
+	{0x6f12, 0x4fea},
+	{0x6f12, 0x1049},
+	{0x6f12, 0x80b2},
+	{0x6f12, 0x8046},
+	{0x6f12, 0x0146},
+	{0x6f12, 0x4846},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x2efd},
+	{0x6f12, 0x2146},
+	{0x6f12, 0x5046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x2ffd},
+	{0x6f12, 0x0122},
+	{0x6f12, 0x4146},
+	{0x6f12, 0x4846},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x25fd},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x2dfd},
+	{0x6f12, 0x8146},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x2ffd},
+	{0x6f12, 0x8046},
+	{0x6f12, 0xa28a},
+	{0x6f12, 0x218a},
+	{0x6f12, 0x4b46},
+	{0x6f12, 0x04f1},
+	{0x6f12, 0x1800},
+	{0x6f12, 0xfff7},
+	{0x6f12, 0x7aff},
+	{0x6f12, 0xe28a},
+	{0x6f12, 0x618a},
+	{0x6f12, 0x4346},
+	{0x6f12, 0x04f5},
+	{0x6f12, 0x8870},
+	{0x6f12, 0xfff7},
+	{0x6f12, 0x73ff},
+	{0x6f12, 0x2f80},
+	{0x6f12, 0x6e80},
+	{0x6f12, 0xbde8},
+	{0x6f12, 0xf087},
+	{0x6f12, 0x2de9},
+	{0x6f12, 0xf047},
+	{0x6f12, 0x0646},
+	{0x6f12, 0xb548},
+	{0x6f12, 0x0d46},
+	{0x6f12, 0x4268},
+	{0x6f12, 0x140c},
+	{0x6f12, 0x97b2},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3946},
+	{0x6f12, 0x2046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00fd},
+	{0x6f12, 0x2946},
+	{0x6f12, 0x3046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x10fd},
+	{0x6f12, 0x0122},
+	{0x6f12, 0x3946},
+	{0x6f12, 0x2046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xf7fc},
+	{0x6f12, 0xad48},
+	{0x6f12, 0xad49},
+	{0x6f12, 0x0089},
+	{0x6f12, 0xa1f8},
+	{0x6f12, 0x0c02},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x09fd},
+	{0x6f12, 0x0446},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xf7fc},
+	{0x6f12, 0x0546},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xf9fc},
+	{0x6f12, 0xa849},
+	{0x6f12, 0x4ef6},
+	{0x6f12, 0xb202},
+	{0x6f12, 0x64b1},
+	{0x6f12, 0x35b1},
+	{0x6f12, 0x10b1},
+	{0x6f12, 0x44f6},
+	{0x6f12, 0x1750},
+	{0x6f12, 0x05e0},
+	{0x6f12, 0x47f2},
+	{0x6f12, 0xd410},
+	{0x6f12, 0x02e0},
+	{0x6f12, 0x18b1},
+	{0x6f12, 0x42f6},
+	{0x6f12, 0x8e30},
+	{0x6f12, 0x0880},
+	{0x6f12, 0x00e0},
+	{0x6f12, 0x0a80},
+	{0x6f12, 0x0024},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xf3fc},
+	{0x6f12, 0x00b1},
+	{0x6f12, 0x0124},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xf4fc},
+	{0x6f12, 0x00b1},
+	{0x6f12, 0x641c},
+	{0x6f12, 0x9b4e},
+	{0x6f12, 0x9b4d},
+	{0x6f12, 0x5836},
+	{0x6f12, 0xb71c},
+	{0x6f12, 0x688f},
+	{0x6f12, 0x06f1},
+	{0x6f12, 0x0408},
+	{0x6f12, 0x0028},
+	{0x6f12, 0x35f8},
+	{0x6f12, 0x4a0f},
+	{0x6f12, 0x06f1},
+	{0x6f12, 0x0609},
+	{0x6f12, 0x07f1},
+	{0x6f12, 0x060a},
+	{0x6f12, 0x18d0},
+	{0x6f12, 0x40ba},
+	{0x6f12, 0x00bf},
+	{0x6f12, 0xa040},
+	{0x6f12, 0x3080},
+	{0x6f12, 0x6888},
+	{0x6f12, 0x40ba},
+	{0x6f12, 0x00bf},
+	{0x6f12, 0xa040},
+	{0x6f12, 0x3880},
+	{0x6f12, 0xa888},
+	{0x6f12, 0x40ba},
+	{0x6f12, 0x00bf},
+	{0x6f12, 0xa040},
+	{0x6f12, 0xa8f8},
+	{0x6f12, 0x0000},
+	{0x6f12, 0xe888},
+	{0x6f12, 0x40ba},
+	{0x6f12, 0x00bf},
+	{0x6f12, 0xa040},
+	{0x6f12, 0xa9f8},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x2889},
+	{0x6f12, 0x40ba},
+	{0x6f12, 0x00bf},
+	{0x6f12, 0x0de0},
+	{0x6f12, 0xa040},
+	{0x6f12, 0x3080},
+	{0x6f12, 0x6888},
+	{0x6f12, 0xa040},
+	{0x6f12, 0x3880},
+	{0x6f12, 0xa888},
+	{0x6f12, 0xa040},
+	{0x6f12, 0xa8f8},
+	{0x6f12, 0x0000},
+	{0x6f12, 0xe888},
+	{0x6f12, 0xa040},
+	{0x6f12, 0xa9f8},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x2889},
+	{0x6f12, 0xa040},
+	{0x6f12, 0xaaf8},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x85e7},
+	{0x6f12, 0x70b5},
+	{0x6f12, 0x0546},
+	{0x6f12, 0x7f48},
+	{0x6f12, 0x1e46},
+	{0x6f12, 0x437a},
+	{0x6f12, 0xa888},
+	{0x6f12, 0x23b3},
+	{0x6f12, 0x18b3},
+	{0x6f12, 0x02f1},
+	{0x6f12, 0x8044},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x6082},
+	{0x6f12, 0xa082},
+	{0x6f12, 0xa888},
+	{0x6f12, 0x401e},
+	{0x6f12, 0xe082},
+	{0x6f12, 0x8888},
+	{0x6f12, 0x2083},
+	{0x6f12, 0xc888},
+	{0x6f12, 0x6083},
+	{0x6f12, 0x46f6},
+	{0x6f12, 0x6810},
+	{0x6f12, 0x2080},
+	{0x6f12, 0x7548},
+	{0x6f12, 0x0021},
+	{0x6f12, 0x8369},
+	{0x6f12, 0x8420},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xa0fc},
+	{0x6f12, 0xe880},
+	{0x6f12, 0x0120},
+	{0x6f12, 0x2080},
+	{0x6f12, 0x0220},
+	{0x6f12, 0xaff3},
+	{0x6f12, 0x0080},
+	{0x6f12, 0xe888},
+	{0x6f12, 0x4ff0},
+	{0x6f12, 0xff31},
+	{0x6f12, 0x06eb},
+	{0x6f12, 0x8000},
+	{0x6f12, 0x00f1},
+	{0x6f12, 0x0050},
+	{0x6f12, 0x0160},
+	{0x6f12, 0x70bd},
+	{0x6f12, 0xe880},
+	{0x6f12, 0x70bd},
+	{0x6f12, 0x624a},
+	{0x6f12, 0x10b5},
+	{0x6f12, 0x12f8},
+	{0x6f12, 0x5a3f},
+	{0x6f12, 0x9278},
+	{0x6f12, 0x5b1e},
+	{0x6f12, 0x521e},
+	{0x6f12, 0x9bb2},
+	{0x6f12, 0x92b2},
+	{0x6f12, 0x0028},
+	{0x6f12, 0x10d0},
+	{0x6f12, 0x01f1},
+	{0x6f12, 0x8041},
+	{0x6f12, 0x40f2},
+	{0x6f12, 0x1344},
+	{0x6f12, 0x40f2},
+	{0x6f12, 0x0110},
+	{0x6f12, 0x8c81},
+	{0x6f12, 0xc881},
+	{0x6f12, 0x0882},
+	{0x6f12, 0x5948},
+	{0x6f12, 0x30f8},
+	{0x6f12, 0xa44f},
+	{0x6f12, 0x2344},
+	{0x6f12, 0xcb80},
+	{0x6f12, 0x4088},
+	{0x6f12, 0x1044},
+	{0x6f12, 0x4881},
+	{0x6f12, 0x10bd},
+	{0x6f12, 0x2de9},
+	{0x6f12, 0xf05f},
+	{0x6f12, 0x0646},
+	{0x6f12, 0x5448},
+	{0x6f12, 0x0d46},
+	{0x6f12, 0x8268},
+	{0x6f12, 0x140c},
+	{0x6f12, 0x97b2},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3946},
+	{0x6f12, 0x2046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x3dfc},
+	{0x6f12, 0x2946},
+	{0x6f12, 0x3046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x66fc},
+	{0x6f12, 0x0122},
+	{0x6f12, 0x3946},
+	{0x6f12, 0x2046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x34fc},
+	{0x6f12, 0x002d},
+	{0x6f12, 0x52d0},
+	{0x6f12, 0xc021},
+	{0x6f12, 0x5048},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x60fc},
+	{0x6f12, 0xdff8},
+	{0x6f12, 0x3cb1},
+	{0x6f12, 0x0026},
+	{0x6f12, 0x4ff0},
+	{0x6f12, 0x9609},
+	{0x6f12, 0x4ff0},
+	{0x6f12, 0x4b0a},
+	{0x6f12, 0xeeb1},
+	{0x6f12, 0x012e},
+	{0x6f12, 0x1ed0},
+	{0x6f12, 0x022e},
+	{0x6f12, 0x1fd0},
+	{0x6f12, 0x0025},
+	{0x6f12, 0x4848},
+	{0x6f12, 0x0024},
+	{0x6f12, 0x001f},
+	{0x6f12, 0x06eb},
+	{0x6f12, 0x4601},
+	{0x6f12, 0x00eb},
+	{0x6f12, 0x0117},
+	{0x6f12, 0xcdb1},
+	{0x6f12, 0x04eb},
+	{0x6f12, 0x4400},
+	{0x6f12, 0x07eb},
+	{0x6f12, 0x8008},
+	{0x6f12, 0x08f1},
+	{0x6f12, 0x0401},
+	{0x6f12, 0x05eb},
+	{0x6f12, 0x8400},
+	{0x6f12, 0x0422},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x45fc},
+	{0x6f12, 0xb8f8},
+	{0x6f12, 0x0400},
+	{0x6f12, 0xb8f8},
+	{0x6f12, 0x0610},
+	{0x6f12, 0xa0b1},
+	{0x6f12, 0x16e0},
+	{0x6f12, 0xbbf8},
+	{0x6f12, 0x2a50},
+	{0x6f12, 0xe3e7},
+	{0x6f12, 0xbbf8},
+	{0x6f12, 0x2c50},
+	{0x6f12, 0xe0e7},
+	{0x6f12, 0x3248},
+	{0x6f12, 0x8589},
+	{0x6f12, 0xdde7},
+	{0x6f12, 0x04eb},
+	{0x6f12, 0x4401},
+	{0x6f12, 0x07eb},
+	{0x6f12, 0x8102},
+	{0x6f12, 0x4846},
+	{0x6f12, 0xa2f8},
+	{0x6f12, 0x0490},
+	{0x6f12, 0x5146},
+	{0x6f12, 0xa2f8},
+	{0x6f12, 0x06a0},
+	{0x6f12, 0x06e0},
+	{0x6f12, 0x4846},
+	{0x6f12, 0xa8f8},
+	{0x6f12, 0x0490},
+	{0x6f12, 0x11b9},
+	{0x6f12, 0x5146},
+	{0x6f12, 0xa8f8},
+	{0x6f12, 0x06a0},
+	{0x6f12, 0x0002},
+	{0x6f12, 0xb0fb},
+	{0x6f12, 0xf1f0},
+	{0x6f12, 0x04eb},
+	{0x6f12, 0x4401},
+	{0x6f12, 0x07eb},
+	{0x6f12, 0x8101},
+	{0x6f12, 0x641c},
+	{0x6f12, 0x0881},
+	{0x6f12, 0x042c},
+	{0x6f12, 0xc7db},
+	{0x6f12, 0x761c},
+	{0x6f12, 0x042e},
+	{0x6f12, 0xb7db},
+	{0x6f12, 0xbde8},
+	{0x6f12, 0xf09f},
+	{0x6f12, 0x2de9},
+	{0x6f12, 0xf04f},
+	{0x6f12, 0x1f4b},
+	{0x6f12, 0x9d7a},
+	{0x6f12, 0x042d},
+	{0x6f12, 0x00d3},
+	{0x6f12, 0x0325},
+	{0x6f12, 0x224f},
+	{0x6f12, 0x4ff6},
+	{0x6f12, 0xff7b},
+	{0x6f12, 0x3f1f},
+	{0x6f12, 0x4ff0},
+	{0x6f12, 0x000a},
+	{0x6f12, 0x3d70},
+	{0x6f12, 0x0668},
+	{0x6f12, 0x4ff0},
+	{0x6f12, 0x0109},
+	{0x6f12, 0x0bea},
+	{0x6f12, 0xc604},
+	{0x6f12, 0x1d4e},
+	{0x6f12, 0x5480},
+	{0x6f12, 0x368d},
+	{0x6f12, 0xd680},
+	{0x6f12, 0x91f8},
+	{0x6f12, 0x00c0},
+	{0x6f12, 0x4ff4},
+	{0x6f12, 0x8056},
+	{0x6f12, 0xbcf1},
+	{0x6f12, 0x000f},
+	{0x6f12, 0x32d0},
+	{0x6f12, 0xdb89},
+	{0x6f12, 0x9c42},
+	{0x6f12, 0x49d2},
+	{0x6f12, 0x81f8},
+	{0x6f12, 0x0090},
+	{0x6f12, 0x3311},
+	{0x6f12, 0xd380},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0x10a0},
+	{0x6f12, 0x05eb},
+	{0x6f12, 0x4505},
+	{0x6f12, 0x0023},
+	{0x6f12, 0x07eb},
+	{0x6f12, 0x0515},
+	{0x6f12, 0x5661},
+	{0x6f12, 0x03eb},
+	{0x6f12, 0x430c},
+	{0x6f12, 0x05eb},
+	{0x6f12, 0x8c0c},
+	{0x6f12, 0x5769},
+	{0x6f12, 0x5b1c},
+	{0x6f12, 0xccf8},
+	{0x6f12, 0x0c70},
+	{0x6f12, 0x042b},
+	{0x6f12, 0xf5db},
+	{0x6f12, 0x53e0},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x50d4},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x4680},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x4ac0},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x6b80},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x6c00},
+	{0x6f12, 0x4000},
+	{0x6f12, 0xd000},
+	{0x6f12, 0x4000},
+	{0x6f12, 0xd516},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x3990},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x2ff0},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x4a80},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5fb0},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x1150},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0x10a0},
+	{0x6f12, 0x05eb},
+	{0x6f12, 0x4505},
+	{0x6f12, 0x0023},
+	{0x6f12, 0x07eb},
+	{0x6f12, 0x0517},
+	{0x6f12, 0x5661},
+	{0x6f12, 0x03eb},
+	{0x6f12, 0x4305},
+	{0x6f12, 0x07eb},
+	{0x6f12, 0x8505},
+	{0x6f12, 0xb2f8},
+	{0x6f12, 0x0680},
+	{0x6f12, 0xb5f8},
+	{0x6f12, 0x08c0},
+	{0x6f12, 0x4fea},
+	{0x6f12, 0x0838},
+	{0x6f12, 0xb8fb},
+	{0x6f12, 0xfcfc},
+	{0x6f12, 0x5b1c},
+	{0x6f12, 0xc5f8},
+	{0x6f12, 0x0cc0},
+	{0x6f12, 0x042b},
+	{0x6f12, 0xeedb},
+	{0x6f12, 0x20e0},
+	{0x6f12, 0x0223},
+	{0x6f12, 0x0b70},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0x1090},
+	{0x6f12, 0x5661},
+	{0x6f12, 0x5388},
+	{0x6f12, 0xd488},
+	{0x6f12, 0x1b02},
+	{0x6f12, 0xb3fb},
+	{0x6f12, 0xf4f3},
+	{0x6f12, 0x9cb2},
+	{0x6f12, 0x05eb},
+	{0x6f12, 0x4505},
+	{0x6f12, 0x0023},
+	{0x6f12, 0x07eb},
+	{0x6f12, 0x0517},
+	{0x6f12, 0x03eb},
+	{0x6f12, 0x4305},
+	{0x6f12, 0x07eb},
+	{0x6f12, 0x8505},
+	{0x6f12, 0xb2f8},
+	{0x6f12, 0x0680},
+	{0x6f12, 0xb5f8},
+	{0x6f12, 0x08c0},
+	{0x6f12, 0x4fea},
+	{0x6f12, 0x0838},
+	{0x6f12, 0xb8fb},
+	{0x6f12, 0xfcfc},
+	{0x6f12, 0x5b1c},
+	{0x6f12, 0xc5f8},
+	{0x6f12, 0x0cc0},
+	{0x6f12, 0x042b},
+	{0x6f12, 0xeedb},
+	{0x6f12, 0xb442},
+	{0x6f12, 0x04d9},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0x0890},
+	{0x6f12, 0xd460},
+	{0x6f12, 0x3446},
+	{0x6f12, 0x02e0},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0x08a0},
+	{0x6f12, 0xd660},
+	{0x6f12, 0xe308},
+	{0x6f12, 0x0360},
+	{0x6f12, 0x0978},
+	{0x6f12, 0x1170},
+	{0x6f12, 0x0168},
+	{0x6f12, 0x0bea},
+	{0x6f12, 0xc100},
+	{0x6f12, 0x9080},
+	{0x6f12, 0x2103},
+	{0x6f12, 0xb1fb},
+	{0x6f12, 0xf0f0},
+	{0x6f12, 0xb042},
+	{0x6f12, 0x05d0},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0x0890},
+	{0x6f12, 0xd168},
+	{0x6f12, 0x4143},
+	{0x6f12, 0x080b},
+	{0x6f12, 0xd060},
+	{0x6f12, 0xbde8},
+	{0x6f12, 0xf08f},
+	{0x6f12, 0x2de9},
+	{0x6f12, 0xf04f},
+	{0x6f12, 0x0bac},
+	{0x6f12, 0xdde9},
+	{0x6f12, 0x1065},
+	{0x6f12, 0x94e8},
+	{0x6f12, 0x000e},
+	{0x6f12, 0xdde9},
+	{0x6f12, 0x0ec7},
+	{0x6f12, 0xfb4c},
+	{0x6f12, 0xddf8},
+	{0x6f12, 0x54e0},
+	{0x6f12, 0xddf8},
+	{0x6f12, 0x2480},
+	{0x6f12, 0xa4f8},
+	{0x6f12, 0x8401},
+	{0x6f12, 0xa4f8},
+	{0x6f12, 0x8611},
+	{0x6f12, 0xc4f8},
+	{0x6f12, 0x7ca1},
+	{0x6f12, 0xc4f8},
+	{0x6f12, 0x7891},
+	{0x6f12, 0xa4f8},
+	{0x6f12, 0x80b1},
+	{0x6f12, 0xa4f8},
+	{0x6f12, 0x82c1},
+	{0x6f12, 0xc4f8},
+	{0x6f12, 0x6881},
+	{0x6f12, 0xc4e9},
+	{0x6f12, 0x5c23},
+	{0x6f12, 0x0a98},
+	{0x6f12, 0xc4f8},
+	{0x6f12, 0x6c01},
+	{0x6f12, 0xe4e9},
+	{0x6f12, 0x5776},
+	{0x6f12, 0xef4b},
+	{0x6f12, 0x84f8},
+	{0x6f12, 0x3450},
+	{0x6f12, 0x1298},
+	{0x6f12, 0x84f8},
+	{0x6f12, 0x3500},
+	{0x6f12, 0xc4f8},
+	{0x6f12, 0x08e0},
+	{0x6f12, 0x1398},
+	{0x6f12, 0x6087},
+	{0x6f12, 0x1498},
+	{0x6f12, 0xa087},
+	{0x6f12, 0x0021},
+	{0x6f12, 0x01eb},
+	{0x6f12, 0x4100},
+	{0x6f12, 0x03eb},
+	{0x6f12, 0x8000},
+	{0x6f12, 0x00f1},
+	{0x6f12, 0xc402},
+	{0x6f12, 0xf430},
+	{0x6f12, 0x34ca},
+	{0x6f12, 0x80e8},
+	{0x6f12, 0x3400},
+	{0x6f12, 0x491c},
+	{0x6f12, 0x0429},
+	{0x6f12, 0xf2db},
+	{0x6f12, 0xbfe7},
+	{0x6f12, 0x2de9},
+	{0x6f12, 0xff4f},
+	{0x6f12, 0x95b0},
+	{0x6f12, 0x1646},
+	{0x6f12, 0x27aa},
+	{0x6f12, 0xe04c},
+	{0x6f12, 0x92e8},
+	{0x6f12, 0x8101},
+	{0x6f12, 0x24aa},
+	{0x6f12, 0x229d},
+	{0x6f12, 0x92e8},
+	{0x6f12, 0x000e},
+	{0x6f12, 0x84f8},
+	{0x6f12, 0x7901},
+	{0x6f12, 0x04f5},
+	{0x6f12, 0x9272},
+	{0x6f12, 0x02f1},
+	{0x6f12, 0x5501},
+	{0x6f12, 0x18a8},
+	{0x6f12, 0xfff7},
+	{0x6f12, 0x02ff},
+	{0x6f12, 0x1898},
+	{0x6f12, 0xadb2},
+	{0x6f12, 0x80b2},
+	{0x6f12, 0xcde9},
+	{0x6f12, 0x0005},
+	{0x6f12, 0xb2b2},
+	{0x6f12, 0x04f5},
+	{0x6f12, 0x8471},
+	{0x6f12, 0xfbb2},
+	{0x6f12, 0x0e46},
+	{0x6f12, 0x0da8},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x0efb},
+	{0x6f12, 0x1898},
+	{0x6f12, 0xa4f8},
+	{0x6f12, 0x7602},
+	{0x6f12, 0xa4f8},
+	{0x6f12, 0x7852},
+	{0x6f12, 0x1ffa},
+	{0x6f12, 0x8bf1},
+	{0x6f12, 0xcdf8},
+	{0x6f12, 0x00a0},
+	{0x6f12, 0xcde9},
+	{0x6f12, 0x0118},
+	{0x6f12, 0x1ffa},
+	{0x6f12, 0x89f3},
+	{0x6f12, 0x3146},
+	{0x6f12, 0x0da8},
+	{0x6f12, 0x239a},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x01fb},
+	{0x6f12, 0xc948},
+	{0x6f12, 0x0078},
+	{0x6f12, 0x38b1},
+	{0x6f12, 0xdde9},
+	{0x6f12, 0x1512},
+	{0x6f12, 0x0da8},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xfefa},
+	{0x6f12, 0x08b1},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00fb},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0xe000},
+	{0x6f12, 0x09ad},
+	{0x6f12, 0xb4f8},
+	{0x6f12, 0x7422},
+	{0x6f12, 0xb4f8},
+	{0x6f12, 0x7212},
+	{0x6f12, 0xd4f8},
+	{0x6f12, 0x0031},
+	{0x6f12, 0x85e8},
+	{0x6f12, 0x0f00},
+	{0x6f12, 0xb4f8},
+	{0x6f12, 0xcc00},
+	{0x6f12, 0x05ad},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0xac30},
+	{0x6f12, 0xd4f8},
+	{0x6f12, 0xd020},
+	{0x6f12, 0xd4f8},
+	{0x6f12, 0x9c10},
+	{0x6f12, 0x85e8},
+	{0x6f12, 0x0f00},
+	{0x6f12, 0xb4f8},
+	{0x6f12, 0x9830},
+	{0x6f12, 0xd4f8},
+	{0x6f12, 0xc820},
+	{0x6f12, 0x54f8},
+	{0x6f12, 0x941f},
+	{0x6f12, 0x01ad},
+	{0x6f12, 0x206c},
+	{0x6f12, 0x85e8},
+	{0x6f12, 0x0f00},
+	{0x6f12, 0xe068},
+	{0x6f12, 0x0090},
+	{0x6f12, 0xb4f8},
+	{0x6f12, 0x4410},
+	{0x6f12, 0x208a},
+	{0x6f12, 0xa36c},
+	{0x6f12, 0x6269},
+	{0x6f12, 0xfff7},
+	{0x6f12, 0x5aff},
+	{0x6f12, 0x19b0},
+	{0x6f12, 0x55e7},
+	{0x6f12, 0x2de9},
+	{0x6f12, 0xf047},
+	{0x6f12, 0x8146},
+	{0x6f12, 0xae48},
+	{0x6f12, 0x8846},
+	{0x6f12, 0x1646},
+	{0x6f12, 0x0169},
+	{0x6f12, 0x1c46},
+	{0x6f12, 0x0d0c},
+	{0x6f12, 0x8fb2},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3946},
+	{0x6f12, 0x2846},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x7bfa},
+	{0x6f12, 0x2346},
+	{0x6f12, 0x3246},
+	{0x6f12, 0x4146},
+	{0x6f12, 0x4846},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xc5fa},
+	{0x6f12, 0x0122},
+	{0x6f12, 0x3946},
+	{0x6f12, 0x2846},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x70fa},
+	{0x6f12, 0x9f4b},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x00eb},
+	{0x6f12, 0x4001},
+	{0x6f12, 0x03eb},
+	{0x6f12, 0x8101},
+	{0x6f12, 0x54f8},
+	{0x6f12, 0x2020},
+	{0x6f12, 0x51f8},
+	{0x6f12, 0xfc5f},
+	{0x6f12, 0x6a43},
+	{0x6f12, 0x120b},
+	{0x6f12, 0x44f8},
+	{0x6f12, 0x2020},
+	{0x6f12, 0x04eb},
+	{0x6f12, 0x8002},
+	{0x6f12, 0x0968},
+	{0x6f12, 0x1569},
+	{0x6f12, 0x401c},
+	{0x6f12, 0x4d43},
+	{0x6f12, 0x290b},
+	{0x6f12, 0x1161},
+	{0x6f12, 0x0428},
+	{0x6f12, 0xe9db},
+	{0x6f12, 0x47e5},
+	{0x6f12, 0x8008},
+	{0x6f12, 0x4843},
+	{0x6f12, 0x00eb},
+	{0x6f12, 0x4010},
+	{0x6f12, 0x400b},
+	{0x6f12, 0x0a21},
+	{0x6f12, 0xb0fb},
+	{0x6f12, 0xf1f0},
+	{0x6f12, 0x10b5},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xa1fa},
+	{0x6f12, 0x9148},
+	{0x6f12, 0x4bf6},
+	{0x6f12, 0xff71},
+	{0x6f12, 0x8288},
+	{0x6f12, 0xbde8},
+	{0x6f12, 0x1040},
+	{0x6f12, 0x46f2},
+	{0x6f12, 0x0e20},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x9cba},
+	{0x6f12, 0x38b5},
+	{0x6f12, 0x0446},
+	{0x6f12, 0x0120},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x9cfa},
+	{0x6f12, 0x0120},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x9efa},
+	{0x6f12, 0x2046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xa0fa},
+	{0x6f12, 0x217a},
+	{0x6f12, 0x8748},
+	{0x6f12, 0x491e},
+	{0x6f12, 0x20f8},
+	{0x6f12, 0x901f},
+	{0x6f12, 0x0121},
+	{0x6f12, 0x4182},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x0090},
+	{0x6f12, 0x401c},
+	{0x6f12, 0x0090},
+	{0x6f12, 0xc828},
+	{0x6f12, 0xfbd3},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x8bfa},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x83fa},
+	{0x6f12, 0x7848},
+	{0x6f12, 0xb0f8},
+	{0x6f12, 0xae00},
+	{0x6f12, 0x00b1},
+	{0x6f12, 0x0120},
+	{0x6f12, 0x7749},
+	{0x6f12, 0x1c39},
+	{0x6f12, 0x0870},
+	{0x6f12, 0x38bd},
+	{0x6f12, 0x70b5},
+	{0x6f12, 0x0646},
+	{0x6f12, 0x7748},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x8169},
+	{0x6f12, 0x0c0c},
+	{0x6f12, 0x8db2},
+	{0x6f12, 0x2946},
+	{0x6f12, 0x2046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x10fa},
+	{0x6f12, 0x3046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x7bfa},
+	{0x6f12, 0x0122},
+	{0x6f12, 0x2946},
+	{0x6f12, 0x2046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x08fa},
+	{0x6f12, 0x6a48},
+	{0x6f12, 0xb0f8},
+	{0x6f12, 0xae00},
+	{0x6f12, 0x0028},
+	{0x6f12, 0x0cd0},
+	{0x6f12, 0x6948},
+	{0x6f12, 0x1c38},
+	{0x6f12, 0x0078},
+	{0x6f12, 0x0028},
+	{0x6f12, 0x07d0},
+	{0x6f12, 0xbde8},
+	{0x6f12, 0x7040},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x1021},
+	{0x6f12, 0x4bf2},
+	{0x6f12, 0xa200},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xf6b9},
+	{0x6f12, 0x70bd},
+	{0x6f12, 0x70b5},
+	{0x6f12, 0x674e},
+	{0x6f12, 0x0025},
+	{0x6f12, 0xf08a},
+	{0x6f12, 0x58b1},
+	{0x6f12, 0x664c},
+	{0x6f12, 0xa08e},
+	{0x6f12, 0x0005},
+	{0x6f12, 0x03d4},
+	{0x6f12, 0x0021},
+	{0x6f12, 0x1f20},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x5bfa},
+	{0x6f12, 0x4ff4},
+	{0x6f12, 0x0060},
+	{0x6f12, 0xa086},
+	{0x6f12, 0xf582},
+	{0x6f12, 0x5848},
+	{0x6f12, 0xb0f8},
+	{0x6f12, 0xae00},
+	{0x6f12, 0x0028},
+	{0x6f12, 0x0bd0},
+	{0x6f12, 0x574c},
+	{0x6f12, 0x1c3c},
+	{0x6f12, 0x2078},
+	{0x6f12, 0x0028},
+	{0x6f12, 0x06d0},
+	{0x6f12, 0x0122},
+	{0x6f12, 0x1021},
+	{0x6f12, 0x4bf2},
+	{0x6f12, 0xa200},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xd4f9},
+	{0x6f12, 0x2570},
+	{0x6f12, 0x70bd},
+	{0x6f12, 0x70b5},
+	{0x6f12, 0x5348},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x016b},
+	{0x6f12, 0x0d0c},
+	{0x6f12, 0x8eb2},
+	{0x6f12, 0x3146},
+	{0x6f12, 0x2846},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xc8f9},
+	{0x6f12, 0x4c4c},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x84f8},
+	{0x6f12, 0x7700},
+	{0x6f12, 0x84f8},
+	{0x6f12, 0x7800},
+	{0x6f12, 0x7334},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x37fa},
+	{0x6f12, 0x14f8},
+	{0x6f12, 0x7309},
+	{0x6f12, 0x58b1},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0x7100},
+	{0x6f12, 0x0428},
+	{0x6f12, 0x07d1},
+	{0x6f12, 0x4248},
+	{0x6f12, 0xb0f8},
+	{0x6f12, 0xe622},
+	{0x6f12, 0xd107},
+	{0x6f12, 0x02d0},
+	{0x6f12, 0x521c},
+	{0x6f12, 0xa0f8},
+	{0x6f12, 0xe622},
+	{0x6f12, 0x3146},
+	{0x6f12, 0x2846},
+	{0x6f12, 0xbde8},
+	{0x6f12, 0x7040},
+	{0x6f12, 0x0122},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xa9b9},
+	{0x6f12, 0x70b5},
+	{0x6f12, 0x0646},
+	{0x6f12, 0x3e48},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x816b},
+	{0x6f12, 0x0c0c},
+	{0x6f12, 0x8db2},
+	{0x6f12, 0x2946},
+	{0x6f12, 0x2046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x9ef9},
+	{0x6f12, 0x3046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x18fa},
+	{0x6f12, 0x0122},
+	{0x6f12, 0x2946},
+	{0x6f12, 0x2046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x96f9},
+	{0x6f12, 0x002e},
+	{0x6f12, 0x02d1},
+	{0x6f12, 0x3949},
+	{0x6f12, 0x0120},
+	{0x6f12, 0x0880},
+	{0x6f12, 0x70bd},
+	{0x6f12, 0x10b5},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x0ffa},
+	{0x6f12, 0x3749},
+	{0x6f12, 0x4989},
+	{0x6f12, 0x8142},
+	{0x6f12, 0x0ed2},
+	{0x6f12, 0x2b49},
+	{0x6f12, 0xb1f8},
+	{0x6f12, 0xfa22},
+	{0x6f12, 0x8242},
+	{0x6f12, 0x07d8},
+	{0x6f12, 0xb1f8},
+	{0x6f12, 0xf422},
+	{0x6f12, 0x8242},
+	{0x6f12, 0x05d2},
+	{0x6f12, 0xd1f8},
+	{0x6f12, 0x1817},
+	{0x6f12, 0x8142},
+	{0x6f12, 0x01d9},
+	{0x6f12, 0x0120},
+	{0x6f12, 0x10bd},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x10bd},
+	{0x6f12, 0x70b5},
+	{0x6f12, 0x2648},
+	{0x6f12, 0x0022},
+	{0x6f12, 0xc169},
+	{0x6f12, 0x0c0c},
+	{0x6f12, 0x8db2},
+	{0x6f12, 0x2946},
+	{0x6f12, 0x2046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x6ef9},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xf3f9},
+	{0x6f12, 0x0122},
+	{0x6f12, 0x2946},
+	{0x6f12, 0x2046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x67f9},
+	{0x6f12, 0x1c4c},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0x7300},
+	{0x6f12, 0x20b1},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0x7100},
+	{0x6f12, 0x0428},
+	{0x6f12, 0x11d0},
+	{0x6f12, 0x0120},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0x7410},
+	{0x6f12, 0x21b1},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0x7210},
+	{0x6f12, 0x0429},
+	{0x6f12, 0x0bd0},
+	{0x6f12, 0x0121},
+	{0x6f12, 0x0844},
+	{0x6f12, 0x1c4e},
+	{0x6f12, 0x4ff6},
+	{0x6f12, 0xff75},
+	{0x6f12, 0x0228},
+	{0x6f12, 0x06d0},
+	{0x6f12, 0x0328},
+	{0x6f12, 0x09d0},
+	{0x6f12, 0x13e0},
+	{0x6f12, 0x0220},
+	{0x6f12, 0xece7},
+	{0x6f12, 0x0221},
+	{0x6f12, 0xf2e7},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x56f9},
+	{0x6f12, 0x60b1},
+	{0x6f12, 0x1548},
+	{0x6f12, 0x04e0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x51f9},
+	{0x6f12, 0x38b1},
+	{0x6f12, 0x1348},
+	{0x6f12, 0x801c},
+	{0x6f12, 0x00f5},
+	{0x6f12, 0x0050},
+	{0x6f12, 0xb0f8},
+	{0x6f12, 0xa204},
+	{0x6f12, 0x281a},
+	{0x6f12, 0x3080},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x46f9},
+	{0x6f12, 0x41f6},
+	{0x6f12, 0xf875},
+	{0x6f12, 0xd8b1},
+	{0x6f12, 0x2846},
+	{0x6f12, 0x1ae0},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x3cc0},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5fac},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x4680},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x1150},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x6b80},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x0dc0},
+	{0x6f12, 0x4000},
+	{0x6f12, 0xb000},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x3c60},
+	{0x6f12, 0x4000},
+	{0x6f12, 0x7000},
+	{0x6f12, 0x4000},
+	{0x6f12, 0xac00},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x0e00},
+	{0x6f12, 0x4000},
+	{0x6f12, 0xf4ec},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x0154},
+	{0x6f12, 0x0820},
+	{0x6f12, 0x7d49},
+	{0x6f12, 0x0880},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x22f9},
+	{0x6f12, 0x00b9},
+	{0x6f12, 0x0825},
+	{0x6f12, 0x7a48},
+	{0x6f12, 0x801c},
+	{0x6f12, 0x0580},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x1bf9},
+	{0x6f12, 0x41f6},
+	{0x6f12, 0xfa75},
+	{0x6f12, 0x08b1},
+	{0x6f12, 0x2846},
+	{0x6f12, 0x00e0},
+	{0x6f12, 0x0620},
+	{0x6f12, 0x7449},
+	{0x6f12, 0x091d},
+	{0x6f12, 0x0880},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x10f9},
+	{0x6f12, 0x00b9},
+	{0x6f12, 0x0625},
+	{0x6f12, 0x7148},
+	{0x6f12, 0x801d},
+	{0x6f12, 0x0580},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x86f9},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0x7310},
+	{0x6f12, 0x0029},
+	{0x6f12, 0x12d0},
+	{0x6f12, 0x4ff0},
+	{0x6f12, 0x0001},
+	{0x6f12, 0x00fa},
+	{0x6f12, 0x01f0},
+	{0x6f12, 0x03d0},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0x7110},
+	{0x6f12, 0x0429},
+	{0x6f12, 0x0cd0},
+	{0x6f12, 0x0021},
+	{0x6f12, 0xc840},
+	{0x6f12, 0x4ff4},
+	{0x6f12, 0x8041},
+	{0x6f12, 0x41ea},
+	{0x6f12, 0x4000},
+	{0x6f12, 0x6649},
+	{0x6f12, 0xa1f8},
+	{0x6f12, 0xa201},
+	{0x6f12, 0x70bd},
+	{0x6f12, 0x4ff0},
+	{0x6f12, 0x0101},
+	{0x6f12, 0xebe7},
+	{0x6f12, 0x0121},
+	{0x6f12, 0xf1e7},
+	{0x6f12, 0x2de9},
+	{0x6f12, 0xf041},
+	{0x6f12, 0x8046},
+	{0x6f12, 0x6148},
+	{0x6f12, 0x1646},
+	{0x6f12, 0x0f46},
+	{0x6f12, 0x006a},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x84b2},
+	{0x6f12, 0x050c},
+	{0x6f12, 0x2146},
+	{0x6f12, 0x2846},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xd0f8},
+	{0x6f12, 0x5c48},
+	{0x6f12, 0x5d49},
+	{0x6f12, 0xb0f8},
+	{0x6f12, 0xb824},
+	{0x6f12, 0xa1f8},
+	{0x6f12, 0x7622},
+	{0x6f12, 0xb0f8},
+	{0x6f12, 0xc424},
+	{0x6f12, 0xa1f8},
+	{0x6f12, 0x7822},
+	{0x6f12, 0x5949},
+	{0x6f12, 0xb0f8},
+	{0x6f12, 0xb624},
+	{0x6f12, 0x0a80},
+	{0x6f12, 0xb0f8},
+	{0x6f12, 0xc224},
+	{0x6f12, 0x4a80},
+	{0x6f12, 0xb0f8},
+	{0x6f12, 0xb224},
+	{0x6f12, 0x8a80},
+	{0x6f12, 0xb0f8},
+	{0x6f12, 0xbe04},
+	{0x6f12, 0xc880},
+	{0x6f12, 0x3246},
+	{0x6f12, 0x3946},
+	{0x6f12, 0x4046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xfaf8},
+	{0x6f12, 0x0600},
+	{0x6f12, 0x5048},
+	{0x6f12, 0xa0f1},
+	{0x6f12, 0x1200},
+	{0x6f12, 0x07d0},
+	{0x6f12, 0xd0f8},
+	{0x6f12, 0x1210},
+	{0x6f12, 0xc0f8},
+	{0x6f12, 0x0a10},
+	{0x6f12, 0xd0f8},
+	{0x6f12, 0x1610},
+	{0x6f12, 0xc0f8},
+	{0x6f12, 0x0e10},
+	{0x6f12, 0x4a49},
+	{0x6f12, 0x0839},
+	{0x6f12, 0x0a88},
+	{0x6f12, 0x4280},
+	{0x6f12, 0x4a88},
+	{0x6f12, 0x8280},
+	{0x6f12, 0x8a88},
+	{0x6f12, 0xc280},
+	{0x6f12, 0xc988},
+	{0x6f12, 0x0181},
+	{0x6f12, 0x0122},
+	{0x6f12, 0x2146},
+	{0x6f12, 0x2846},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x98f8},
+	{0x6f12, 0x3046},
+	{0x6f12, 0xbde8},
+	{0x6f12, 0xf081},
+	{0x6f12, 0x70b5},
+	{0x6f12, 0x4149},
+	{0x6f12, 0x1422},
+	{0x6f12, 0xa1f1},
+	{0x6f12, 0x1400},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x1ff9},
+	{0x6f12, 0x3f49},
+	{0x6f12, 0x7422},
+	{0x6f12, 0xa1f1},
+	{0x6f12, 0x7400},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x19f9},
+	{0x6f12, 0x3948},
+	{0x6f12, 0xd0f8},
+	{0x6f12, 0x7612},
+	{0x6f12, 0xc0f8},
+	{0x6f12, 0x7212},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x9af8},
+	{0x6f12, 0x00b1},
+	{0x6f12, 0x0120},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x13f9},
+	{0x6f12, 0x3548},
+	{0x6f12, 0x344b},
+	{0x6f12, 0x1238},
+	{0x6f12, 0xd0f8},
+	{0x6f12, 0x1210},
+	{0x6f12, 0x40f8},
+	{0x6f12, 0x0a1f},
+	{0x6f12, 0xc168},
+	{0x6f12, 0x4160},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x0a33},
+	{0x6f12, 0x00eb},
+	{0x6f12, 0x4002},
+	{0x6f12, 0x1978},
+	{0x6f12, 0x401c},
+	{0x6f12, 0x01eb},
+	{0x6f12, 0x4101},
+	{0x6f12, 0x03eb},
+	{0x6f12, 0x0111},
+	{0x6f12, 0x01eb},
+	{0x6f12, 0x8201},
+	{0x6f12, 0x091d},
+	{0x6f12, 0x03eb},
+	{0x6f12, 0x8202},
+	{0x6f12, 0x32c9},
+	{0x6f12, 0xc432},
+	{0x6f12, 0x0428},
+	{0x6f12, 0x82e8},
+	{0x6f12, 0x3200},
+	{0x6f12, 0xecdb},
+	{0x6f12, 0x70bd},
+	{0x6f12, 0x70b5},
+	{0x6f12, 0x0646},
+	{0x6f12, 0x2148},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x806a},
+	{0x6f12, 0x84b2},
+	{0x6f12, 0x050c},
+	{0x6f12, 0x2146},
+	{0x6f12, 0x2846},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x53f8},
+	{0x6f12, 0x3046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xebf8},
+	{0x6f12, 0x1e49},
+	{0x6f12, 0x214b},
+	{0x6f12, 0x1239},
+	{0x6f12, 0x4888},
+	{0x6f12, 0x1a68},
+	{0x6f12, 0x060a},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0xce60},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0xd000},
+	{0x6f12, 0xc888},
+	{0x6f12, 0x060a},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0xd260},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0xd400},
+	{0x6f12, 0x8888},
+	{0x6f12, 0x5b68},
+	{0x6f12, 0x060a},
+	{0x6f12, 0x9e74},
+	{0x6f12, 0x1875},
+	{0x6f12, 0x0889},
+	{0x6f12, 0x010a},
+	{0x6f12, 0x9975},
+	{0x6f12, 0x1876},
+	{0x6f12, 0x0720},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0xd900},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0xda00},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0xdb00},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0xdc00},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0xdd00},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0xde00},
+	{0x6f12, 0x2020},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0xc600},
+	{0x6f12, 0x0120},
+	{0x6f12, 0x82f8},
+	{0x6f12, 0xaa00},
+	{0x6f12, 0x0246},
+	{0x6f12, 0x2146},
+	{0x6f12, 0x2846},
+	{0x6f12, 0xbde8},
+	{0x6f12, 0x7040},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x1db8},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x4000},
+	{0x6f12, 0xf5f2},
+	{0x6f12, 0x4000},
+	{0x6f12, 0xf000},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x6b80},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x3cc0},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x4680},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5fa2},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x48ac},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x4788},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x3bf0},
+	{0x6f12, 0x40f6},
+	{0x6f12, 0xc76c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x010c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x40f6},
+	{0x6f12, 0xb16c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x010c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x46f6},
+	{0x6f12, 0xd90c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x4ef6},
+	{0x6f12, 0x3d0c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x46f6},
+	{0x6f12, 0x5f7c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x46f6},
+	{0x6f12, 0x677c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x4ef6},
+	{0x6f12, 0xf55c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x46f6},
+	{0x6f12, 0x877c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x40f6},
+	{0x6f12, 0xaf2c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x010c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x40f6},
+	{0x6f12, 0xb72c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x010c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x4df6},
+	{0x6f12, 0xb30c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x43f2},
+	{0x6f12, 0x2d3c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x010c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x45f6},
+	{0x6f12, 0xdd2c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x010c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x44f6},
+	{0x6f12, 0xbd0c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x4ff2},
+	{0x6f12, 0xf74c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x4ff2},
+	{0x6f12, 0x335c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x4ff2},
+	{0x6f12, 0x356c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x4ff6},
+	{0x6f12, 0x890c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x48f2},
+	{0x6f12, 0xb57c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x46f6},
+	{0x6f12, 0x790c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x46f6},
+	{0x6f12, 0xf50c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x45f6},
+	{0x6f12, 0x235c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x45f6},
+	{0x6f12, 0x375c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x44f6},
+	{0x6f12, 0xe77c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x45f2},
+	{0x6f12, 0xbd2c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x40f2},
+	{0x6f12, 0xb90c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x44f2},
+	{0x6f12, 0xd51c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x010c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x4ff6},
+	{0x6f12, 0x7f6c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x40f2},
+	{0x6f12, 0x797c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x010c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x40f2},
+	{0x6f12, 0xc13c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x010c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x46f6},
+	{0x6f12, 0x6f7c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x45f6},
+	{0x6f12, 0x252c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x010c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x4af6},
+	{0x6f12, 0x871c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x42f2},
+	{0x6f12, 0x2d1c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6028, 0x2000},
+	{0x602a, 0x60d0},
+	{0x6f12, 0x10b5},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x4249},
+	{0x6f12, 0x4348},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x18f9},
+	{0x6f12, 0x424c},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x4249},
+	{0x6f12, 0x6060},
+	{0x6f12, 0x4248},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x11f9},
+	{0x6f12, 0x2060},
+	{0x6f12, 0x0122},
+	{0x6f12, 0x4149},
+	{0x6f12, 0x4148},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x9bfa},
+	{0x6f12, 0x0122},
+	{0x6f12, 0x4049},
+	{0x6f12, 0x4148},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x96fa},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x4049},
+	{0x6f12, 0x4048},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x91fa},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3f49},
+	{0x6f12, 0x4048},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xfcf8},
+	{0x6f12, 0xe060},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3e49},
+	{0x6f12, 0x3f48},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xf6f8},
+	{0x6f12, 0xa060},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3d49},
+	{0x6f12, 0x3e48},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xf0f8},
+	{0x6f12, 0x2061},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3c49},
+	{0x6f12, 0x3d48},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xeaf8},
+	{0x6f12, 0x6061},
+	{0x6f12, 0x3c49},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x0246},
+	{0x6f12, 0x0870},
+	{0x6f12, 0x3b49},
+	{0x6f12, 0x3b48},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x71fa},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3a49},
+	{0x6f12, 0x3b48},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x6cfa},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3a49},
+	{0x6f12, 0x3a48},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xd7f8},
+	{0x6f12, 0xa061},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3949},
+	{0x6f12, 0x3948},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xd1f8},
+	{0x6f12, 0xe061},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3849},
+	{0x6f12, 0x3848},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xcbf8},
+	{0x6f12, 0x2062},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3749},
+	{0x6f12, 0x3748},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xc5f8},
+	{0x6f12, 0xa062},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3649},
+	{0x6f12, 0x3648},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xbff8},
+	{0x6f12, 0x6062},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3549},
+	{0x6f12, 0x3548},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xb9f8},
+	{0x6f12, 0xe062},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3449},
+	{0x6f12, 0x3448},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xb3f8},
+	{0x6f12, 0x2063},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3349},
+	{0x6f12, 0x3348},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xadf8},
+	{0x6f12, 0x6063},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3249},
+	{0x6f12, 0x3248},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xa7f8},
+	{0x6f12, 0xa063},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3149},
+	{0x6f12, 0x3148},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xa1f8},
+	{0x6f12, 0xe063},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3049},
+	{0x6f12, 0x3048},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x2bfa},
+	{0x6f12, 0xbde8},
+	{0x6f12, 0x1040},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x61b8},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5433},
+	{0x6f12, 0x0000},
+	{0x6f12, 0xedf5},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x6b80},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x53b7},
+	{0x6f12, 0x0000},
+	{0x6f12, 0xe83d},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5523},
+	{0x6f12, 0x0000},
+	{0x6f12, 0xe19f},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x557f},
+	{0x6f12, 0x0000},
+	{0x6f12, 0xda7f},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x6509},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x9cc3},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5865},
+	{0x6f12, 0x0000},
+	{0x6f12, 0xf9f1},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x55b9},
+	{0x6f12, 0x0001},
+	{0x6f12, 0x332d},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5939},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x87b5},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x599f},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x689b},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5f90},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x59c9},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x5017},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5a63},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x4f91},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5a17},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x52bd},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5b5d},
+	{0x6f12, 0x0001},
+	{0x6f12, 0x03c1},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5c91},
+	{0x6f12, 0x0000},
+	{0x6f12, 0xf635},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5d91},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x212d},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5d23},
+	{0x6f12, 0x0000},
+	{0x6f12, 0xf889},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x6445},
+	{0x6f12, 0x0001},
+	{0x6f12, 0x3ac7},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5aa9},
+	{0x6f12, 0x0001},
+	{0x6f12, 0x41d5},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x6311},
+	{0x6f12, 0x0000},
+	{0x6f12, 0xd15f},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5afb},
+	{0x6f12, 0x0000},
+	{0x6f12, 0xfe7f},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x5b2d},
+	{0x6f12, 0x0001},
+	{0x6f12, 0x4927},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x62b3},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x5d7f},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0xcf49},
+	{0x6f12, 0xce48},
+	{0x6f12, 0xcf4a},
+	{0x6f12, 0xc1f8},
+	{0x6f12, 0xdc06},
+	{0x6f12, 0x101a},
+	{0x6f12, 0xa1f8},
+	{0x6f12, 0xe006},
+	{0x6f12, 0x7047},
+	{0x6f12, 0x2de9},
+	{0x6f12, 0xf041},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xbef9},
+	{0x6f12, 0xc94d},
+	{0x6f12, 0x10f0},
+	{0x6f12, 0x180f},
+	{0x6f12, 0x04d1},
+	{0x6f12, 0x95f8},
+	{0x6f12, 0x9510},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xbaf9},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xbdf9},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xc0f9},
+	{0x6f12, 0xc44e},
+	{0x6f12, 0x0124},
+	{0x6f12, 0xc44f},
+	{0x6f12, 0x05e0},
+	{0x6f12, 0x308b},
+	{0x6f12, 0x00b1},
+	{0x6f12, 0x3c80},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xbbf9},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xbef9},
+	{0x6f12, 0x0028},
+	{0x6f12, 0xf5d0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xbff9},
+	{0x6f12, 0xe864},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xc1f9},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xc4f9},
+	{0x6f12, 0xbc48},
+	{0x6f12, 0xbc49},
+	{0x6f12, 0x8089},
+	{0x6f12, 0xa1f8},
+	{0x6f12, 0x1802},
+	{0x6f12, 0xbde8},
+	{0x6f12, 0xf081},
+	{0x6f12, 0xba4b},
+	{0x6f12, 0x1847},
+	{0x6f12, 0x2de9},
+	{0x6f12, 0xfc5f},
+	{0x6f12, 0x8346},
+	{0x6f12, 0xb948},
+	{0x6f12, 0x8a46},
+	{0x6f12, 0xdde9},
+	{0x6f12, 0x0c56},
+	{0x6f12, 0x416b},
+	{0x6f12, 0x9146},
+	{0x6f12, 0x0c0c},
+	{0x6f12, 0x8fb2},
+	{0x6f12, 0x9846},
+	{0x6f12, 0x0022},
+	{0x6f12, 0x3946},
+	{0x6f12, 0x2046},
+	{0x6f12, 0xfff7},
+	{0x6f12, 0x8dfd},
+	{0x6f12, 0xcde9},
+	{0x6f12, 0x0056},
+	{0x6f12, 0x4346},
+	{0x6f12, 0x4a46},
+	{0x6f12, 0x5146},
+	{0x6f12, 0x5846},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xa7f9},
+	{0x6f12, 0x8046},
+	{0x6f12, 0x0122},
+	{0x6f12, 0x3946},
+	{0x6f12, 0x2046},
+	{0x6f12, 0xfff7},
+	{0x6f12, 0x7ffd},
+	{0x6f12, 0xac4e},
+	{0x6f12, 0x96f8},
+	{0x6f12, 0xe802},
+	{0x6f12, 0x18b9},
+	{0x6f12, 0x96f8},
+	{0x6f12, 0xc002},
+	{0x6f12, 0x0028},
+	{0x6f12, 0x6fd0},
+	{0x6f12, 0x96f8},
+	{0x6f12, 0x0e01},
+	{0x6f12, 0x0028},
+	{0x6f12, 0x6bd1},
+	{0x6f12, 0x0025},
+	{0x6f12, 0x4ff4},
+	{0x6f12, 0x1a47},
+	{0x6f12, 0x2c46},
+	{0x6f12, 0x3a46},
+	{0x6f12, 0x1821},
+	{0x6f12, 0xa448},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x91f9},
+	{0x6f12, 0xa248},
+	{0x6f12, 0x3a46},
+	{0x6f12, 0x7821},
+	{0x6f12, 0x4030},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x90f9},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x06eb},
+	{0x6f12, 0x8001},
+	{0x6f12, 0x401c},
+	{0x6f12, 0xd1f8},
+	{0x6f12, 0x6c12},
+	{0x6f12, 0x1028},
+	{0x6f12, 0x0d44},
+	{0x6f12, 0xf7db},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x06eb},
+	{0x6f12, 0x4001},
+	{0x6f12, 0x401c},
+	{0x6f12, 0xb1f8},
+	{0x6f12, 0xac12},
+	{0x6f12, 0x0428},
+	{0x6f12, 0x0c44},
+	{0x6f12, 0xf7db},
+	{0x6f12, 0x04b9},
+	{0x6f12, 0x0124},
+	{0x6f12, 0xa000},
+	{0x6f12, 0x95fb},
+	{0x6f12, 0xf0f3},
+	{0x6f12, 0x9548},
+	{0x6f12, 0x954c},
+	{0x6f12, 0x018b},
+	{0x6f12, 0x4a05},
+	{0x6f12, 0x00d5},
+	{0x6f12, 0x2143},
+	{0x6f12, 0x428b},
+	{0x6f12, 0x5505},
+	{0x6f12, 0x00d5},
+	{0x6f12, 0x2243},
+	{0x6f12, 0x1944},
+	{0x6f12, 0x1a44},
+	{0x6f12, 0x96f8},
+	{0x6f12, 0x4631},
+	{0x6f12, 0xc1f3},
+	{0x6f12, 0x0a01},
+	{0x6f12, 0xc2f3},
+	{0x6f12, 0x0a02},
+	{0x6f12, 0xc3b9},
+	{0x6f12, 0x8d4b},
+	{0x6f12, 0x1980},
+	{0x6f12, 0x9b1c},
+	{0x6f12, 0x1a80},
+	{0x6f12, 0x8b4c},
+	{0x6f12, 0x838b},
+	{0x6f12, 0x241d},
+	{0x6f12, 0x2380},
+	{0x6f12, 0xa41c},
+	{0x6f12, 0xc38b},
+	{0x6f12, 0x2380},
+	{0x6f12, 0xa41c},
+	{0x6f12, 0x038c},
+	{0x6f12, 0x2380},
+	{0x6f12, 0xa41c},
+	{0x6f12, 0x438c},
+	{0x6f12, 0x2380},
+	{0x6f12, 0xa41c},
+	{0x6f12, 0x90f8},
+	{0x6f12, 0x2430},
+	{0x6f12, 0x2380},
+	{0x6f12, 0xa41c},
+	{0x6f12, 0x90f8},
+	{0x6f12, 0x2530},
+	{0x6f12, 0x2380},
+	{0x6f12, 0x96f8},
+	{0x6f12, 0x5031},
+	{0x6f12, 0xb3b9},
+	{0x6f12, 0x804b},
+	{0x6f12, 0x1980},
+	{0x6f12, 0x991c},
+	{0x6f12, 0x0a80},
+	{0x6f12, 0x1a1d},
+	{0x6f12, 0x30f8},
+	{0x6f12, 0x1c1f},
+	{0x6f12, 0x1180},
+	{0x6f12, 0x921c},
+	{0x6f12, 0x4188},
+	{0x6f12, 0x1180},
+	{0x6f12, 0x921c},
+	{0x6f12, 0x8188},
+	{0x6f12, 0x1180},
+	{0x6f12, 0x921c},
+	{0x6f12, 0xc188},
+	{0x6f12, 0x1180},
+	{0x6f12, 0x921c},
+	{0x6f12, 0x017a},
+	{0x6f12, 0x1180},
+	{0x6f12, 0x911c},
+	{0x6f12, 0x407a},
+	{0x6f12, 0x0880},
+	{0x6f12, 0x4046},
+	{0x6f12, 0xbde8},
+	{0x6f12, 0xfc9f},
+	{0x6f12, 0x38b5},
+	{0x6f12, 0x664c},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x0090},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0xd822},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0xd912},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0xdb02},
+	{0x6f12, 0x6b46},
+	{0x6f12, 0x04f5},
+	{0x6f12, 0x3674},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x26f9},
+	{0x6f12, 0xe178},
+	{0x6f12, 0x0844},
+	{0x6f12, 0xa178},
+	{0x6f12, 0xa4f5},
+	{0x6f12, 0x3674},
+	{0x6f12, 0x0d18},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x23f9},
+	{0x6f12, 0x10b1},
+	{0x6f12, 0x6848},
+	{0x6f12, 0x0078},
+	{0x6f12, 0x00b1},
+	{0x6f12, 0x0120},
+	{0x6f12, 0x6049},
+	{0x6f12, 0x81f8},
+	{0x6f12, 0xdc00},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0x7725},
+	{0x6f12, 0x02b1},
+	{0x6f12, 0x00b1},
+	{0x6f12, 0x0120},
+	{0x6f12, 0x81f8},
+	{0x6f12, 0x0e01},
+	{0x6f12, 0x6249},
+	{0x6f12, 0x0978},
+	{0x6f12, 0x0229},
+	{0x6f12, 0x11d1},
+	{0x6f12, 0x80b9},
+	{0x6f12, 0xb4f8},
+	{0x6f12, 0x0203},
+	{0x6f12, 0xb4f8},
+	{0x6f12, 0xca20},
+	{0x6f12, 0x411e},
+	{0x6f12, 0x0a44},
+	{0x6f12, 0xb2fb},
+	{0x6f12, 0xf0f2},
+	{0x6f12, 0x84f8},
+	{0x6f12, 0x2727},
+	{0x6f12, 0xb4f8},
+	{0x6f12, 0xcc20},
+	{0x6f12, 0x1144},
+	{0x6f12, 0xb1fb},
+	{0x6f12, 0xf0f0},
+	{0x6f12, 0x84f8},
+	{0x6f12, 0x2807},
+	{0x6f12, 0xb4f8},
+	{0x6f12, 0xbe00},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0xda12},
+	{0x6f12, 0x401a},
+	{0x6f12, 0x0028},
+	{0x6f12, 0x00dc},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x84f8},
+	{0x6f12, 0xdc02},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xf7f8},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0xdc12},
+	{0x6f12, 0x0844},
+	{0x6f12, 0x5149},
+	{0x6f12, 0x91f8},
+	{0x6f12, 0x9612},
+	{0x6f12, 0x0844},
+	{0x6f12, 0x5049},
+	{0x6f12, 0xc0b2},
+	{0x6f12, 0x84f8},
+	{0x6f12, 0xdc02},
+	{0x6f12, 0x91f8},
+	{0x6f12, 0x7320},
+	{0x6f12, 0x42b1},
+	{0x6f12, 0x91f8},
+	{0x6f12, 0x7110},
+	{0x6f12, 0x0429},
+	{0x6f12, 0x04d1},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x0101},
+	{0x6f12, 0x0844},
+	{0x6f12, 0x84f8},
+	{0x6f12, 0xdc02},
+	{0x6f12, 0xc0b2},
+	{0x6f12, 0x2844},
+	{0x6f12, 0x38bd},
+	{0x6f12, 0x10b5},
+	{0x6f12, 0x3d4c},
+	{0x6f12, 0x404a},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0x0e01},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0x4611},
+	{0x6f12, 0x0143},
+	{0x6f12, 0x4e3a},
+	{0x6f12, 0x1180},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0x5011},
+	{0x6f12, 0x3c4a},
+	{0x6f12, 0x0143},
+	{0x6f12, 0x4e3a},
+	{0x6f12, 0x1180},
+	{0x6f12, 0x04f5},
+	{0x6f12, 0x8774},
+	{0x6f12, 0x0028},
+	{0x6f12, 0x53d1},
+	{0x6f12, 0x2046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xcbf8},
+	{0x6f12, 0x2046},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0xcdf8},
+	{0x6f12, 0x3a4a},
+	{0x6f12, 0x608a},
+	{0x6f12, 0x314b},
+	{0x6f12, 0x9188},
+	{0x6f12, 0x401a},
+	{0x6f12, 0x80b2},
+	{0x6f12, 0x6082},
+	{0x6f12, 0x998d},
+	{0x6f12, 0x09b1},
+	{0x6f12, 0x0846},
+	{0x6f12, 0x04e0},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0x3610},
+	{0x6f12, 0x0229},
+	{0x6f12, 0x00d1},
+	{0x6f12, 0x4008},
+	{0x6f12, 0xe085},
+	{0x6f12, 0x188e},
+	{0x6f12, 0x58b9},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0x3600},
+	{0x6f12, 0x0228},
+	{0x6f12, 0x03d0},
+	{0x6f12, 0x0128},
+	{0x6f12, 0x608a},
+	{0x6f12, 0x03d0},
+	{0x6f12, 0x03e0},
+	{0x6f12, 0x608a},
+	{0x6f12, 0x8008},
+	{0x6f12, 0x00e0},
+	{0x6f12, 0x4008},
+	{0x6f12, 0x2086},
+	{0x6f12, 0x6088},
+	{0x6f12, 0x1188},
+	{0x6f12, 0x0844},
+	{0x6f12, 0x6080},
+	{0x6f12, 0xe088},
+	{0x6f12, 0x1188},
+	{0x6f12, 0x401a},
+	{0x6f12, 0xe080},
+	{0x6f12, 0xa08a},
+	{0x6f12, 0xd188},
+	{0x6f12, 0x401a},
+	{0x6f12, 0x80b2},
+	{0x6f12, 0xa082},
+	{0x6f12, 0x598d},
+	{0x6f12, 0x09b1},
+	{0x6f12, 0x0846},
+	{0x6f12, 0x04e0},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0x3610},
+	{0x6f12, 0x0229},
+	{0x6f12, 0x00d1},
+	{0x6f12, 0x4000},
+	{0x6f12, 0x6086},
+	{0x6f12, 0xd88d},
+	{0x6f12, 0x58b9},
+	{0x6f12, 0x94f8},
+	{0x6f12, 0x3600},
+	{0x6f12, 0x0228},
+	{0x6f12, 0x03d0},
+	{0x6f12, 0x0128},
+	{0x6f12, 0xa08a},
+	{0x6f12, 0x03d0},
+	{0x6f12, 0x03e0},
+	{0x6f12, 0xa08a},
+	{0x6f12, 0x8000},
+	{0x6f12, 0x00e0},
+	{0x6f12, 0x4000},
+	{0x6f12, 0xa086},
+	{0x6f12, 0xa088},
+	{0x6f12, 0x5188},
+	{0x6f12, 0x0844},
+	{0x6f12, 0xa080},
+	{0x6f12, 0x2089},
+	{0x6f12, 0x5188},
+	{0x6f12, 0x401a},
+	{0x6f12, 0x2081},
+	{0x6f12, 0x10bd},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x66f4},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x3cc0},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x6c00},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x6a80},
+	{0x6f12, 0x4000},
+	{0x6f12, 0x6c02},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x0dc0},
+	{0x6f12, 0x4000},
+	{0x6f12, 0x6000},
+	{0x6f12, 0x0001},
+	{0x6f12, 0x3051},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x6b80},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x4ac0},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x4d2c},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x34c0},
+	{0x6f12, 0xffff},
+	{0x6f12, 0xf800},
+	{0x6f12, 0x4000},
+	{0x6f12, 0xae4e},
+	{0x6f12, 0x4000},
+	{0x6f12, 0xaf4e},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x33b0},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x2a80},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x0e00},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x4680},
+	{0x6f12, 0x2000},
+	{0x6f12, 0x6c00},
+	{0x6f12, 0x43f2},
+	{0x6f12, 0x510c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x010c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x46f2},
+	{0x6f12, 0xdd7c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x45f2},
+	{0x6f12, 0xf57c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x45f6},
+	{0x6f12, 0x735c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x43f6},
+	{0x6f12, 0x2d0c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x44f6},
+	{0x6f12, 0x934c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x010c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x47f2},
+	{0x6f12, 0x8d4c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x47f6},
+	{0x6f12, 0xd10c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x43f6},
+	{0x6f12, 0x390c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x45f6},
+	{0x6f12, 0x555c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x4df2},
+	{0x6f12, 0x5f1c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x4bf6},
+	{0x6f12, 0x1d2c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x4bf6},
+	{0x6f12, 0x572c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x4ff6},
+	{0x6f12, 0x335c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x47f2},
+	{0x6f12, 0x0b0c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x43f6},
+	{0x6f12, 0x8f2c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x010c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x49f6},
+	{0x6f12, 0x911c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x49f6},
+	{0x6f12, 0x613c},
+	{0x6f12, 0xc0f2},
+	{0x6f12, 0x000c},
+	{0x6f12, 0x6047},
+	{0x6f12, 0x08d2},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0009},
+	{0x6f12, 0xffff},
+	{0x602a, 0x6c00},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0155},
+	{0x602a, 0x1ea6},
+	{0x6f12, 0x4c09},
+	{0xf44c, 0x0a0c},
+	{0x6028, 0x2000},
+	{0x602a, 0x11e6},
+	{0x6f12, 0x000d},
+	{0x6f12, 0x0009},
+	{0x6f12, 0x0008},
+	{0x602a, 0x11ee},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x000f},
+	{0x602a, 0x122e},
+	{0x6f12, 0x001e},
+	{0x6f12, 0x0014},
+	{0x6f12, 0x0012},
+	{0x602a, 0x12d6},
+	{0x6f12, 0xfff9},
+	{0x602a, 0x12e6},
+	{0x6f12, 0x000f},
+	{0x602a, 0x146e},
+	{0x6f12, 0x002f},
+	{0x6f12, 0x0034},
+	{0x6f12, 0x0036},
+	{0x602a, 0x1ea4},
+	{0x6f12, 0x0018},
+	{0x602a, 0x0e38},
+	{0x6f12, 0x0040},
+	{0x602a, 0x1e92},
+	{0x6f12, 0x0907},
+	{0x6f12, 0x070b},
+	{0x602a, 0x1e9e},
+	{0x6f12, 0x0303},
+	{0x6f12, 0x0305},
+	{0x602a, 0x1e9a},
+	{0x6f12, 0x0b0b},
+	{0x6f12, 0x0715},
+	{0x602a, 0x1e96},
+	{0x6f12, 0x0f0c},
+	{0x6f12, 0x0c04},
+	{0x602a, 0x1eae},
+	{0x6f12, 0x3d68},
+	{0x602a, 0x2440},
+	{0x6f12, 0x0080},
+	{0x602a, 0x243e},
+	{0x6f12, 0x006f},
+	{0x602a, 0x243c},
+	{0x6f12, 0x44c2},
+	{0xf412, 0x0000},
+	{0xf45a, 0x0ffe},
+	{0x6028, 0x2000},
+	{0x602a, 0x10b0},
+	{0x6f12, 0x0100},
+	{0x602a, 0x10b4},
+	{0x6f12, 0x003f},
+	{0x602a, 0x10ba},
+	{0x6f12, 0x0040},
+	{0x602a, 0x10c4},
+	{0x6f12, 0xf480},
+	{0x602a, 0x3b20},
+	{0x6f12, 0x0100},
+	{0x602a, 0x3b26},
+	{0x6f12, 0x0008},
+	{0x602a, 0x3b22},
+	{0x6f12, 0x0080},
+	{0x9c14, 0x0000},
+	{0x9c1a, 0x0000},
+	{0x9c06, 0x0303},
+	{0x9c1c, 0x0020},
+	{0x9c1e, 0x0400},
+	{0x6028, 0x2000},
+	{0x602a, 0x239a},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x2398},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x2396},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x2394},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x2392},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x2386},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x2384},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x2382},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x2380},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x237e},
+	{0x6f12, 0x00f0},
+	{0x9c24, 0x0100},
+	{0x6028, 0x2000},
+	{0x602a, 0x3630},
+	{0x6f12, 0x0000},
+	{0x602a, 0x1eb2},
+	{0x6f12, 0x6a2d},
+	{0x602a, 0x117a},
+	{0x6f12, 0x0088},
+	{0x6f12, 0x0098},
+	{0x602a, 0x29f0},
+	{0x6f12, 0x0000},
+	{0x602a, 0x1076},
+	{0x6f12, 0x0200},
+	{0x0136, 0x1800},
+	{0x0304, 0x0006},
+	{0x030c, 0x0000},
+	{0x0302, 0x0001},
+	{0x030e, 0x0003},
+	{0x0312, 0x0000},
+	{0x030a, 0x0001},
+	{0x0308, 0x0008},
+	{0x0202, 0x0020},
+	{0x6028, 0x2000},
+	{0x602a, 0x1170},
+	{0x6f12, 0x0005},
+	{0x602a, 0x33fa},
+	{0x6f12, 0x0100},
+	{0x602a, 0x33f8},
+	{0x6f12, 0x0000},
+	{0x0b06, 0x0101},
+	{0x6028, 0x2000},
+	{0x602a, 0x1094},
+	{0x6f12, 0x0002},
+	{0x602a, 0x3020},
+	{0x6f12, 0x0040},
+	{0x0fea, 0x0500},
+	{0x6028, 0x2000},
+	{0x602a, 0x1e80},
+	{0x6f12, 0x0100},
+	{0x602a, 0x2516},
+	{0x6f12, 0x01c0},
+	{0x6f12, 0x01c2},
+	{0x6f12, 0x02c8},
+	{0x6f12, 0x02ca},
+	{0x6f12, 0x02d0},
+	{0x6f12, 0x02d2},
+	{0x6f12, 0x01d8},
+	{0x6f12, 0x01da},
+	{0x6f12, 0x01e0},
+	{0x6f12, 0x01e2},
+	{0x6f12, 0x02e8},
+	{0x6f12, 0x02ea},
+	{0x6f12, 0x02f0},
+	{0x6f12, 0x02f2},
+	{0x6f12, 0x01f8},
+	{0x6f12, 0x01fa},
+	{0x6f12, 0x01c0},
+	{0x6f12, 0x01c2},
+	{0x6f12, 0x02c8},
+	{0x6f12, 0x02ca},
+	{0x6f12, 0x02d0},
+	{0x6f12, 0x02d2},
+	{0x6f12, 0x01d8},
+	{0x6f12, 0x01da},
+	{0x6f12, 0x01e0},
+	{0x6f12, 0x01e2},
+	{0x6f12, 0x02e8},
+	{0x6f12, 0x02ea},
+	{0x6f12, 0x02f0},
+	{0x6f12, 0x02f2},
+	{0x6f12, 0x01f8},
+	{0x6f12, 0x01fa},
+	{0x602a, 0x2596},
+	{0x6f12, 0x01c0},
+	{0x6f12, 0x01c2},
+	{0x6f12, 0x01c8},
+	{0x6f12, 0x01ca},
+	{0x6f12, 0x01d0},
+	{0x6f12, 0x01d2},
+	{0x6f12, 0x01d8},
+	{0x6f12, 0x01da},
+	{0x6f12, 0x01e0},
+	{0x6f12, 0x01e2},
+	{0x6f12, 0x01e8},
+	{0x6f12, 0x01ea},
+	{0x6f12, 0x01f0},
+	{0x6f12, 0x01f2},
+	{0x6f12, 0x01f8},
+	{0x6f12, 0x01fa},
+	{0x6f12, 0x01c0},
+	{0x6f12, 0x01c2},
+	{0x6f12, 0x01c8},
+	{0x6f12, 0x01ca},
+	{0x6f12, 0x01d0},
+	{0x6f12, 0x01d2},
+	{0x6f12, 0x01d8},
+	{0x6f12, 0x01da},
+	{0x6f12, 0x01e0},
+	{0x6f12, 0x01e2},
+	{0x6f12, 0x01e8},
+	{0x6f12, 0x01ea},
+	{0x6f12, 0x01f0},
+	{0x6f12, 0x01f2},
+	{0x6f12, 0x01f8},
+	{0x6f12, 0x01fa},
+	{0x602a, 0x0e7c},
+	{0x6f12, 0x0400},
+	{0x0118, 0x0004},
+	{0x010c, 0x0000},
+	{0x011a, 0x0001},
+	{0x6028, 0x2000},
+	{0x602a, 0x1070},
+	{0x6f12, 0x0004},
+	{0x602a, 0x0efc},
+	{0x6f12, 0x0100},
+	{0x602a, 0x0ed4},
+	{0x6f12, 0x0003},
+	{0x602a, 0x0f00},
+	{0x6f12, 0x0100},
+	{0x6f12, 0x0800},
+	{0x602a, 0x2634},
+	{0x6f12, 0x0500},
+	{0x602a, 0x34d8},
+	{0x6f12, 0x0040},
+	{0x6f12, 0x0040},
+	{0x6f12, 0x07c0},
+	{0x6f12, 0x07c0},
+	{0x602a, 0x34d0},
+	{0x6f12, 0x0100},
+	{0x602a, 0x39a8},
+	{0x6f12, 0x0001},
+	{0x602a, 0x39b0},
+	{0x6f12, 0x0014},
+	{0x6f12, 0x001e},
+	{0x6f12, 0x0014},
+	{0x6f12, 0x001e},
+	{0x6f12, 0x0005},
+	{0x602a, 0x39c2},
+	{0x6f12, 0x0001},
+	{0x602a, 0x3992},
+	{0x6f12, 0x0002},
+	{0x602a, 0x39cc},
+	{0x6f12, 0x0001},
+	{0x602a, 0x37ec},
+	{0x6f12, 0x0023},
+	{0x6f12, 0x0023},
+	{0x602a, 0x37fa},
+	{0x6f12, 0x0000},
+	{0x602a, 0x3806},
+	{0x6f12, 0x0023},
+	{0x6f12, 0x0023},
+	{0x602a, 0x3814},
+	{0x6f12, 0x0000},
+	{0x602a, 0x39da},
+	{0x6f12, 0x104d},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0b00},
+	{0x6f12, 0x0b80},
+	{0x6f12, 0x2274},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0812},
+	{0x6f12, 0x1f2d},
+	{0x6f12, 0x3944},
+	{0x6f12, 0x4e56},
+	{0x6f12, 0x010a},
+	{0x6f12, 0x1521},
+	{0x6f12, 0x2e3e},
+	{0x6f12, 0x4c57},
+	{0x6f12, 0x626b},
+	{0x6f12, 0x0e18},
+	{0x6f12, 0x2330},
+	{0x6f12, 0x4050},
+	{0x6f12, 0x606d},
+	{0x6f12, 0x7882},
+	{0x6f12, 0x1e2a},
+	{0x6f12, 0x3645},
+	{0x6f12, 0x5669},
+	{0x6f12, 0x7a89},
+	{0x6f12, 0x96a1},
+	{0x6f12, 0x313e},
+	{0x6f12, 0x4c5d},
+	{0x6f12, 0x7085},
+	{0x6f12, 0x98a8},
+	{0x6f12, 0xb7c4},
+	{0x6f12, 0x4250},
+	{0x6f12, 0x5f71},
+	{0x6f12, 0x869d},
+	{0x6f12, 0xb2c4},
+	{0x6f12, 0xd4e2},
+	{0x6f12, 0x4f5e},
+	{0x6f12, 0x6f82},
+	{0x6f12, 0x98b1},
+	{0x6f12, 0xc7da},
+	{0x6f12, 0xebfa},
+	{0x6f12, 0x5a6a},
+	{0x6f12, 0x7b90},
+	{0x6f12, 0xa7c1},
+	{0x6f12, 0xd9ed},
+	{0x6f12, 0xffff},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x6028, 0x2000},
+	{0x602a, 0x1f1e},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x1f32},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x2036},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x204a},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x214e},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x2162},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x2266},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x227a},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x237e},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x2392},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x6f12, 0x00f0},
+	{0x602a, 0x3640},
+	{0x6f12, 0x0001},
+	{0x6f12, 0x0001},
+	{0x602a, 0x364c},
+	{0x6f12, 0x2ff0},
+	{0x6f12, 0xf44a},
+	{0x6f12, 0x0005},
+	{0x6f12, 0xf44c},
+	{0x6f12, 0x0a0c},
+	{0x6f12, 0xf412},
+	{0x6f12, 0x0000},
+	{0x6f12, 0xf454},
+	{0x6f12, 0x0011},
+	{0x6f12, 0xf45a},
+	{0x6f12, 0x0ffe},
+	{0x6f12, 0x9c14},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x9c1a},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x9c06},
+	{0x6f12, 0x0303},
+	{0x6f12, 0x9c1c},
+	{0x6f12, 0x0020},
+	{0x6f12, 0x9c1e},
+	{0x6f12, 0x0400},
+	{0x6f12, 0x9c02},
+	{0x6f12, 0x1fc0},
+	{0x6f12, 0x9c04},
+	{0x6f12, 0x1fc7},
+	{0x6f12, 0x9c24},
+	{0x6f12, 0x0100},
+};
+
+static const struct s5kgm2_reg s5kgm2_2000x1500_4lane_regs[] = {
+	{0x6214, 0xf9f3},
+	{0x0344, 0x0000},
+	{0x0346, 0x0000},
+	{0x0348, 0x1f3f},
+	{0x034a, 0x176f},
+	{0x034c, 0x07d0},
+	{0x034e, 0x05dc},
+	{0x0340, 0x0690},
+	{0x0342, 0x18e0},
+	{0x0900, 0x0124},
+	{0x0380, 0x0002},
+	{0x0382, 0x0002},
+	{0x0384, 0x0002},
+	{0x0386, 0x0006},
+	{0x0400, 0x1010},
+	{0x0402, 0x1010},
+	{0x0404, 0x2000},
+	{0x0350, 0x0000},
+	{0x0352, 0x0000},
+	{0x0136, 0x1333},
+	{0x013e, 0x0001},
+	{0x0300, 0x0005},
+	{0x0302, 0x0001},
+	{0x0304, 0x0006},
+	{0x0306, 0x00fc},
+	{0x0308, 0x0008},
+	{0x030a, 0x0001},
+	{0x030c, 0x0000},
+	{0x030e, 0x0003},
+	{0x0310, 0x005e},
+	{0x0312, 0x0000},
+	{0x6028, 0x2000},
+	{0x602a, 0x0e36},
+	{0x6f12, 0x000a},
+	{0x602a, 0x1250},
+	{0x6f12, 0x0002},
+	{0xf44a, 0x0007},
+	{0xf454, 0x0011},
+	{0x6028, 0x2000},
+	{0x602a, 0x10c0},
+	{0x6f12, 0xbfc2},
+	{0x6f12, 0xbfc3},
+	{0x602a, 0x3b24},
+	{0x6f12, 0x0008},
+	{0x9c02, 0x0fe0},
+	{0x9c04, 0x0fe7},
+	{0x6028, 0x2000},
+	{0x602a, 0x0e6e},
+	{0x6f12, 0xffff},
+	{0x602a, 0x3632},
+	{0x6f12, 0x0240},
+	{0x602a, 0x11b4},
+	{0x6f12, 0x0040},
+	{0x6028, 0x2000},
+	{0x602a, 0x0dd6},
+	{0x6f12, 0x000a},
+	{0x602a, 0x0ddc},
+	{0x6f12, 0x0001},
+	{0x602a, 0x1eac},
+	{0x6f12, 0x0096},
+	{0x6028, 0x2000},
+	{0x602a, 0x33b0},
+	{0x6f12, 0x0008},
+	{0x602a, 0x33b6},
+	{0x6f12, 0x0004},
+	{0x602a, 0x33fc},
+	{0x6f12, 0x0604},
+	{0x602a, 0x33fe},
+	{0x6f12, 0x0704},
+	{0x602a, 0x3462},
+	{0x6f12, 0x7701},
+	{0x602a, 0x347c},
+	{0x6f12, 0x0000},
+	{0x602a, 0x34a6},
+	{0x6f12, 0x5555},
+	{0x602a, 0x34e4},
+	{0x6f12, 0x0000},
+	{0x602a, 0x34f2},
+	{0x6f12, 0x0001},
+	{0x0d00, 0x0000},
+	{0x0d02, 0x0001},
+	{0x0114, 0x0300},
+	{0x6028, 0x2000},
+	{0x602a, 0x116e},
+	{0x6f12, 0x0000},
+	{0x602a, 0x1172},
+	{0x6f12, 0x0100},
+	{0x602a, 0x6c0e},
+	{0x6f12, 0x0210},
+	{0x602a, 0x2a10},
+	{0x6f12, 0x0100},
+	{0x602a, 0x2a80},
+	{0x6f12, 0x0200},
+	{0x602a, 0x6c0a},
+	{0x6f12, 0x0167},
+	{0x6f12, 0x00a8},
+	{0xb134, 0x0100},
+	{0x0bc8, 0x0001},
+	{0x6028, 0x2000},
+	{0x602a, 0x39aa},
+	{0x6f12, 0x0002},
+	{0x6f12, 0x0001},
+	{0x6f12, 0x0001},
+	{0x602a, 0x39ba},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0001},
+	{0x6f12, 0x0000},
+	{0x6f12, 0x0000},
+	{0x602a, 0x39c4},
+	{0x6f12, 0x0000},
+	{0x6028, 0x2000},
+	{0x602a, 0x0e26},
+	{0x6f12, 0x0440},
+	{0x6f12, 0x0440},
+	{0x602a, 0x1e7e},
+	{0x6f12, 0x0401},
+	{0x602a, 0x2a02},
+	{0x6f12, 0x0100},
+	{0x602a, 0x2450},
+	{0x6f12, 0x0005},
+	{0x602a, 0x25f8},
+	{0x6f12, 0xaaaa},
+	{0x602a, 0x34d8},
+	{0x6f12, 0x07c0},
+	{0x6f12, 0x07c0},
+	{0x6028, 0x2000},
+	{0x602a, 0x6a98},
+	{0x6f12, 0x0000},
+	{0x602a, 0x364e},
+	{0x6f12, 0xf44a},
+	{0x6f12, 0x0007},
+	{0x602a, 0x3676},
+	{0x6f12, 0x9c02},
+	{0x6f12, 0x0fe0},
+	{0x602a, 0x367a},
+	{0x6f12, 0x9c04},
+	{0x6f12, 0x0fe7},
+};
+
+static struct s5kgm2_mode s5kgm2_modes[] = {
+	{
+		.width = 2000,
+		.height = 1500,
+		.hts = 6368,
+		.vts = 1680,
+		.link_freq = 360000000,
+		.lane_count = 4,
+		.depth = 10,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(s5kgm2_2000x1500_4lane_regs),
+			.regs = s5kgm2_2000x1500_4lane_regs,
+		},
+		.mbus_code = MEDIA_BUS_FMT_SGRBG10_1X10,
+	},
+};
+
+static const char * const s5kgm2_supply_names[] = {
+	"vana",
+	"vdig",
+	"vio",
+};
+
+struct s5kgm2 {
+	struct clk *xvclk;
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *hblank;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *exposure;
+	struct s5kgm2_mode *cur_mode;
+	struct regulator_bulk_data supplies[ARRAY_SIZE(s5kgm2_supply_names)];
+	struct gpio_desc *reset_gpio;
+};
+
+static int s5kgm2_write(struct s5kgm2 *s5kgm2, u16 reg, u16 len, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&s5kgm2->sd);
+	u8 buf[6];
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << 8 * (4 - len), buf + 2);
+	if (i2c_master_send(client, buf, len + 2) != len + 2) {
+		dev_err(&client->dev,
+				"Cannot write register %u!\n", reg);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int s5kgm2_write_reg_list(struct s5kgm2 *s5kgm2, const struct s5kgm2_reg_list *reg_list)
+{
+	int ret = 0;
+
+	for (unsigned int i = 0; i < reg_list->num_of_regs; i++)
+		ret = s5kgm2_write(s5kgm2, reg_list->regs[i].address, 2, reg_list->regs[i].val);
+
+	return ret;
+}
+
+static int s5kgm2_read(struct s5kgm2 *s5kgm2, u16 reg, u16 len, u32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&s5kgm2->sd);
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2];
+	u8 data_buf[4] = {0};
+	int ret;
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, addr_buf);
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = sizeof(addr_buf);
+	msgs[0].buf = addr_buf;
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[4 - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs)) {
+		dev_err(&client->dev,
+				"Cannot read register %u!\n", reg);
+		return -EIO;
+	}
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+static int s5kgm2_start_stream(struct s5kgm2 *s5kgm2,
+				   struct v4l2_subdev_state *state)
+{
+	int ret;
+	const struct s5kgm2_reg_list regs = {
+		.num_of_regs = ARRAY_SIZE(s5kgm2_regs),
+		.regs = s5kgm2_regs,
+	};
+
+	ret = s5kgm2_write_reg_list(s5kgm2, &regs);
+	if (ret)
+		return ret;
+
+	ret = s5kgm2_write_reg_list(s5kgm2, &s5kgm2->cur_mode->reg_list);
+	if (ret)
+		return ret;
+
+	ret = __v4l2_ctrl_handler_setup(&s5kgm2->ctrl_handler);
+	if (ret)
+		return ret;
+
+	ret = s5kgm2_write(s5kgm2, 0x0100, 2, 0x100);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int s5kgm2_stop_stream(struct s5kgm2 *s5kgm2)
+{
+	int ret;
+
+	ret = s5kgm2_write(s5kgm2, 0x0100, 1, 0x00);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int s5kgm2_s_stream(struct v4l2_subdev *sd, int on)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct s5kgm2 *s5kgm2 = to_s5kgm2(sd);
+	struct v4l2_subdev_state *state;
+	int ret = 0;
+
+	state = v4l2_subdev_lock_and_get_active_state(sd);
+
+	if (on) {
+		ret = pm_runtime_resume_and_get(&client->dev);
+		if (ret < 0)
+			goto unlock_and_return;
+
+		ret = s5kgm2_start_stream(s5kgm2, state);
+		if (ret) {
+			dev_err(&client->dev, "Failed to start streaming\n");
+			pm_runtime_put_sync(&client->dev);
+			goto unlock_and_return;
+		}
+	} else {
+		s5kgm2_stop_stream(s5kgm2);
+		pm_runtime_mark_last_busy(&client->dev);
+		pm_runtime_put_autosuspend(&client->dev);
+	}
+
+unlock_and_return:
+	v4l2_subdev_unlock_state(state);
+
+	return ret;
+}
+
+static int s5kgm2_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *state,
+			  struct v4l2_subdev_format *fmt)
+{
+	struct s5kgm2 *s5kgm2 = to_s5kgm2(sd);
+	struct s5kgm2_mode *mode;
+	u64 pixel_rate;
+	u32 v_blank;
+	u32 h_blank;
+
+	mode = v4l2_find_nearest_size(s5kgm2_modes, ARRAY_SIZE(s5kgm2_modes),
+					  width, height, fmt->format.width,
+					  fmt->format.height);
+
+	fmt->format.code = mode->mbus_code;
+	fmt->format.width = mode->width;
+	fmt->format.height = mode->height;
+	fmt->format.field = V4L2_FIELD_NONE;
+
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		*v4l2_subdev_state_get_format(state, 0) =  fmt->format;
+	} else {
+		s5kgm2->cur_mode = mode;
+		pixel_rate = mode->link_freq * 2 * mode->lane_count / mode->depth;
+		__v4l2_ctrl_s_ctrl_int64(s5kgm2->pixel_rate, pixel_rate);
+		/* Update limits and set FPS to default */
+		v_blank = mode->vts - mode->height;
+		__v4l2_ctrl_modify_range(s5kgm2->vblank, v_blank,
+					 0xffff - mode->height,
+					 1, v_blank);
+		__v4l2_ctrl_s_ctrl(s5kgm2->vblank, v_blank);
+		h_blank = mode->hts - mode->width;
+		__v4l2_ctrl_modify_range(s5kgm2->hblank, h_blank,
+					 h_blank, 1, h_blank);
+	}
+
+	return 0;
+}
+
+static int s5kgm2_get_selection(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_state *sd_state,
+			  struct v4l2_subdev_selection *sel)
+{
+	struct s5kgm2 *s5kgm2 = to_s5kgm2(sd);
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP:
+		sel->r = *v4l2_subdev_state_get_crop(sd_state, sel->pad);
+		return 0;
+
+	case V4L2_SEL_TGT_NATIVE_SIZE:
+		sel->r.top = 0;
+		sel->r.left = 0;
+		sel->r.width = s5kgm2->cur_mode->width;
+		sel->r.height = s5kgm2->cur_mode->height;
+		return 0;
+
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.top = 0;
+		sel->r.left = 0;
+		sel->r.width = s5kgm2->cur_mode->width;
+		sel->r.height = s5kgm2->cur_mode->height;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int s5kgm2_enum_frame_sizes(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_state *state,
+				   struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index >= ARRAY_SIZE(s5kgm2_modes))
+		return -EINVAL;
+
+	if (fse->code != s5kgm2_modes[fse->index].mbus_code)
+		return -EINVAL;
+
+	fse->min_width  = s5kgm2_modes[fse->index].width;
+	fse->max_width  = s5kgm2_modes[fse->index].width;
+	fse->max_height = s5kgm2_modes[fse->index].height;
+	fse->min_height = s5kgm2_modes[fse->index].height;
+
+	return 0;
+}
+
+static int s5kgm2_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *state,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct s5kgm2 *s5kgm2 = to_s5kgm2(sd);
+
+	if (code->index != 0)
+		return -EINVAL;
+
+	code->code = s5kgm2->cur_mode->mbus_code;
+
+	return 0;
+}
+
+static int s5kgm2_init_state(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_state *sd_state)
+{
+	struct s5kgm2 *s5kgm2 = to_s5kgm2(sd);
+	struct v4l2_subdev_format fmt = {
+		.which = V4L2_SUBDEV_FORMAT_TRY,
+		.format = {
+			.width = s5kgm2->cur_mode->width,
+			.height = s5kgm2->cur_mode->height,
+		},
+	};
+
+	s5kgm2_set_fmt(sd, sd_state, &fmt);
+
+	return 0;
+}
+
+static int s5kgm2_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct s5kgm2 *s5kgm2 = container_of(ctrl->handler,
+						 struct s5kgm2, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&s5kgm2->sd);
+	struct v4l2_mbus_framefmt *format;
+	struct v4l2_subdev_state *state;
+	u32 exposure_max;
+	int ret;
+
+	state = v4l2_subdev_get_locked_active_state(&s5kgm2->sd);
+	format = v4l2_subdev_state_get_format(state, 0);
+
+	/* Propagate change of current control to all related controls */
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = s5kgm2->cur_mode->height + ctrl->val - 2;
+		__v4l2_ctrl_modify_range(s5kgm2->exposure,
+					 s5kgm2->exposure->minimum,
+					 exposure_max, s5kgm2->exposure->step,
+					 exposure_max);
+	}
+
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_EXPOSURE:
+		ret = s5kgm2_write(s5kgm2, 0x0202, 2, ctrl->val);
+		break;
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = s5kgm2_write(s5kgm2, 0x0204, 2, ctrl->val);
+		break;
+	case V4L2_CID_VBLANK:
+		ret = s5kgm2_write(s5kgm2, 0x0340, 2, s5kgm2->cur_mode->height + ctrl->val);
+		break;
+	default:
+		ret = -EINVAL;
+		dev_warn(&client->dev, "%s Unhandled id: 0x%x\n",
+			 __func__, ctrl->id);
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_subdev_core_ops s5kgm2_core_ops = { };
+
+static const struct v4l2_subdev_video_ops s5kgm2_video_ops = {
+	.s_stream = s5kgm2_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops s5kgm2_pad_ops = {
+	.enum_mbus_code = s5kgm2_enum_mbus_code,
+	.enum_frame_size = s5kgm2_enum_frame_sizes,
+	.get_fmt = v4l2_subdev_get_fmt,
+	.set_fmt = s5kgm2_set_fmt,
+	.get_selection = s5kgm2_get_selection,
+};
+
+static const struct v4l2_subdev_ops s5kgm2_subdev_ops = {
+	.core	= &s5kgm2_core_ops,
+	.video	= &s5kgm2_video_ops,
+	.pad	= &s5kgm2_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops s5kgm2_internal_ops = {
+	.init_state = s5kgm2_init_state,
+};
+
+static const struct v4l2_ctrl_ops s5kgm2_ctrl_ops = {
+	.s_ctrl = s5kgm2_set_ctrl,
+};
+
+static int s5kgm2_power_on(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct s5kgm2 *s5kgm2 = to_s5kgm2(sd);
+	int ret;
+
+	gpiod_set_value_cansleep(s5kgm2->reset_gpio, 0);
+	usleep_range(1000, 2000);
+
+	ret = clk_prepare_enable(s5kgm2->xvclk);
+	if (ret) {
+		dev_err(dev, "Failed to enable xvclk\n");
+		return ret;
+	}
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(s5kgm2_supply_names),
+					s5kgm2->supplies);
+	if (ret) {
+		dev_err(dev, "failed to enable regulators\n");
+		goto disable_clk;
+	}
+
+	gpiod_set_value_cansleep(s5kgm2->reset_gpio, 1);
+	usleep_range(10000, 11000);
+
+	return 0;
+
+disable_clk:
+	clk_disable_unprepare(s5kgm2->xvclk);
+	return ret;
+};
+
+static int s5kgm2_power_off(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct s5kgm2 *s5kgm2 = to_s5kgm2(sd);
+
+	clk_disable_unprepare(s5kgm2->xvclk);
+	usleep_range(1000, 2000);
+
+	gpiod_set_value_cansleep(s5kgm2->reset_gpio, 0);
+	usleep_range(1000, 2000);
+
+	regulator_bulk_disable(ARRAY_SIZE(s5kgm2_supply_names),
+					   s5kgm2->supplies);
+	return 0;
+};
+
+static int s5kgm2_init_ctrls(struct s5kgm2 *s5kgm2)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&s5kgm2->sd);
+	struct v4l2_ctrl_handler *handler = &s5kgm2->ctrl_handler;
+	struct v4l2_fwnode_device_properties props;
+	struct v4l2_ctrl *ctrl;
+	struct s5kgm2_mode *mode = s5kgm2->cur_mode;
+	u64 pixel_rate;
+	u32 h_blank;
+	u32 v_blank;
+	u32 exposure_max;
+	int ret;
+	static s64 link_freq[] = {
+		0
+	};
+	link_freq[0] = mode->link_freq;
+
+	ret = v4l2_ctrl_handler_init(handler, 5);
+	if (ret)
+		return ret;
+
+	ctrl = v4l2_ctrl_new_int_menu(handler, NULL, V4L2_CID_LINK_FREQ,
+					  ARRAY_SIZE(link_freq) - 1, 0, link_freq);
+	if (ctrl)
+		ctrl->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	pixel_rate = mode->link_freq * 2 * mode->lane_count / mode->depth;
+	s5kgm2->pixel_rate = v4l2_ctrl_new_std(handler, NULL, V4L2_CID_PIXEL_RATE,
+			  0, pixel_rate, 1, pixel_rate);
+
+	h_blank = mode->hts - mode->width;
+	s5kgm2->hblank = v4l2_ctrl_new_std(handler, NULL, V4L2_CID_HBLANK,
+					   h_blank, h_blank, 1, h_blank);
+	if (s5kgm2->hblank)
+		s5kgm2->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	v_blank = mode->vts - mode->height;
+	s5kgm2->vblank = v4l2_ctrl_new_std(handler, &s5kgm2_ctrl_ops,
+					   V4L2_CID_VBLANK, v_blank,
+					   0xffff - mode->height,
+					   1, v_blank);
+
+	exposure_max = mode->vts - 3;
+	s5kgm2->exposure = v4l2_ctrl_new_std(handler, &s5kgm2_ctrl_ops,
+						 V4L2_CID_EXPOSURE,
+						 0,
+						 exposure_max, 1,
+						 exposure_max);
+
+	v4l2_ctrl_new_std(handler, &s5kgm2_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			  32, 512, 1, 512);
+
+	if (handler->error) {
+		ret = handler->error;
+		goto err_free_handler;
+	}
+
+	ret = v4l2_fwnode_device_parse(&client->dev, &props);
+	if (ret)
+		goto err_free_handler;
+
+	ret = v4l2_ctrl_new_fwnode_properties(handler, &s5kgm2_ctrl_ops,
+						  &props);
+	if (ret)
+		goto err_free_handler;
+
+	s5kgm2->sd.ctrl_handler = handler;
+
+	return 0;
+
+err_free_handler:
+	dev_err(&client->dev, "Failed to init controls: %d\n", ret);
+	v4l2_ctrl_handler_free(handler);
+
+	return ret;
+}
+
+static int s5kgm2_check_sensor_id(struct s5kgm2 *s5kgm2)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&s5kgm2->sd);
+	u32 id = 0;
+	int ret;
+
+	ret = s5kgm2_read(s5kgm2, 0x0000, 2, &id);
+	if (ret)
+		return ret;
+
+	if (id != 0x08d2) {
+		dev_err(&client->dev, "Chip ID mismatch: expected 0x%x, got 0x%x\n", 0x08d2, id);
+		return -ENODEV;
+	}
+
+	dev_info(&client->dev, "Detected s5kgm2 sensor\n");
+	return 0;
+}
+
+static int s5kgm2_parse_of(struct s5kgm2 *s5kgm2)
+{
+	struct v4l2_fwnode_endpoint vep = { .bus_type = V4L2_MBUS_CSI2_DPHY };
+	struct i2c_client *client = v4l2_get_subdevdata(&s5kgm2->sd);
+	struct device *dev = &client->dev;
+	struct fwnode_handle *endpoint;
+	int ret;
+
+	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);
+	if (!endpoint) {
+		dev_err(dev, "Failed to get endpoint\n");
+		return -EINVAL;
+	}
+
+	ret = v4l2_fwnode_endpoint_parse(endpoint, &vep);
+	fwnode_handle_put(endpoint);
+	if (ret) {
+		dev_err(dev, "Failed to parse endpoint: %d\n", ret);
+		return ret;
+	}
+
+	for (unsigned int i = 0; i < ARRAY_SIZE(s5kgm2_modes); i++) {
+		struct s5kgm2_mode *mode = &s5kgm2_modes[i];
+
+		if (mode->lane_count != vep.bus.mipi_csi2.num_data_lanes)
+			continue;
+
+		s5kgm2->cur_mode = mode;
+		break;
+	}
+
+	if (!s5kgm2->cur_mode) {
+		dev_err(dev, "Unsupported number of data lanes %u\n",
+			vep.bus.mipi_csi2.num_data_lanes);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int s5kgm2_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct s5kgm2 *s5kgm2;
+	struct v4l2_subdev *sd;
+	int ret;
+
+	s5kgm2 = devm_kzalloc(dev, sizeof(*s5kgm2), GFP_KERNEL);
+	if (!s5kgm2)
+		return -ENOMEM;
+
+	s5kgm2->xvclk = devm_clk_get(dev, "xvclk");
+	if (IS_ERR(s5kgm2->xvclk))
+		return dev_err_probe(dev, PTR_ERR(s5kgm2->xvclk),
+					 "Failed to get xvclk\n");
+
+	s5kgm2->reset_gpio = devm_gpiod_get(dev, "reset",
+							 GPIOD_OUT_LOW);
+	if (IS_ERR(s5kgm2->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(s5kgm2->reset_gpio),
+					 "Failed to get reset gpio\n");
+
+	v4l2_i2c_subdev_init(&s5kgm2->sd, client, &s5kgm2_subdev_ops);
+	s5kgm2->sd.internal_ops = &s5kgm2_internal_ops;
+
+	for (unsigned int i = 0; i < ARRAY_SIZE(s5kgm2_supply_names); i++)
+		s5kgm2->supplies[i].supply = s5kgm2_supply_names[i];
+
+	ret = devm_regulator_bulk_get(&client->dev,
+					   ARRAY_SIZE(s5kgm2_supply_names),
+					   s5kgm2->supplies);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ret = s5kgm2_parse_of(s5kgm2);
+	if (ret)
+		return ret;
+
+	ret = s5kgm2_init_ctrls(s5kgm2);
+	if (ret)
+		return ret;
+
+	sd = &s5kgm2->sd;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	s5kgm2->pad.flags = MEDIA_PAD_FL_SOURCE;
+	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&sd->entity, 1, &s5kgm2->pad);
+	if (ret < 0)
+		goto err_free_handler;
+
+	sd->state_lock = s5kgm2->ctrl_handler.lock;
+	ret = v4l2_subdev_init_finalize(sd);
+	if (ret < 0) {
+		dev_err(&client->dev, "Subdev initialization error %d\n", ret);
+		goto err_clean_entity;
+	}
+
+	ret = s5kgm2_power_on(dev);
+	if (ret)
+		goto err_clean_entity;
+
+	pm_runtime_set_active(dev);
+	pm_runtime_get_noresume(dev);
+	pm_runtime_enable(dev);
+
+	ret = s5kgm2_check_sensor_id(s5kgm2);
+	if (ret)
+		goto err_power_off;
+
+	pm_runtime_set_autosuspend_delay(dev, 1000);
+	pm_runtime_use_autosuspend(dev);
+
+	ret = v4l2_async_register_subdev_sensor(sd);
+	if (ret) {
+		dev_err(dev, "v4l2 async register subdev failed\n");
+		goto err_power_off;
+	}
+
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+	return 0;
+
+err_power_off:
+	pm_runtime_disable(dev);
+	pm_runtime_put_noidle(dev);
+	s5kgm2_power_off(dev);
+err_clean_entity:
+	media_entity_cleanup(&sd->entity);
+err_free_handler:
+	v4l2_ctrl_handler_free(&s5kgm2->ctrl_handler);
+
+	return ret;
+};
+
+static void s5kgm2_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct s5kgm2 *s5kgm2 = to_s5kgm2(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	v4l2_ctrl_handler_free(&s5kgm2->ctrl_handler);
+
+	pm_runtime_disable(&client->dev);
+	if (!pm_runtime_status_suspended(&client->dev))
+		s5kgm2_power_off(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+}
+
+static const struct dev_pm_ops s5kgm2_pm_ops = {
+	SET_RUNTIME_PM_OPS(s5kgm2_power_off, s5kgm2_power_on, NULL)
+};
+
+static const struct of_device_id s5kgm2_of_match[] = {
+	{ .compatible = "samsung,s5kgm2" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, s5kgm2_of_match);
+
+static struct i2c_driver s5kgm2_i2c_driver = {
+	.driver = {
+		.of_match_table = s5kgm2_of_match,
+		.pm = &s5kgm2_pm_ops,
+		.name = "s5kgm2",
+	},
+	.probe  = s5kgm2_probe,
+	.remove = s5kgm2_remove,
+};
+
+module_i2c_driver(s5kgm2_i2c_driver)
+
+MODULE_DESCRIPTION("Samsung S5KGM2 image sensor subdev driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/qcom/camss/camss-csiphy-3ph-1-0.c b/drivers/media/platform/qcom/camss/camss-csiphy-3ph-1-0.c
index df7e93a5a4f6e2..6782f57565ebe9 100644
--- a/drivers/media/platform/qcom/camss/camss-csiphy-3ph-1-0.c
+++ b/drivers/media/platform/qcom/camss/camss-csiphy-3ph-1-0.c
@@ -348,6 +348,136 @@ csiphy_reg_t lane_regs_sm8250[5][20] = {
 	},
 };
 
+/* GEN2 1.2.2 2PH */
+static const struct
+csiphy_reg_t lane_regs_sc7180[5][23] = {
+	{
+		{0x0030, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0904, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0910, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0900, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0908, 0x06, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0904, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x002c, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0034, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0010, 0x50, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x001c, 0x0a, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0014, 0x60, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0028, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x003c, 0xb8, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0000, 0x91, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0004, 0x0c, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0020, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0008, 0x10, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
+		{0x0010, 0x52, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0038, 0xfe, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x005c, 0xc0, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0060, 0x0d, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0800, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
+	},
+	{
+		{0x0730, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c84, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c90, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c80, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c88, 0x06, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c84, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x072c, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0734, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0710, 0x50, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x071c, 0x0a, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0714, 0x60, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0728, 0x04, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x073c, 0xb8, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0700, 0x80, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0704, 0x0c, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0720, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0708, 0x04, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
+		{0x070c, 0xff, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0710, 0x52, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0738, 0x1f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0800, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
+		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
+	},
+	{
+		{0x0230, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0a04, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0a10, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0a00, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0a08, 0x06, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0a04, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x022c, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0234, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0210, 0x50, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x021c, 0x0a, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0214, 0x60, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0228, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x023c, 0xb8, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0200, 0x91, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0204, 0x0c, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0220, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0208, 0x04, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
+		{0x0210, 0x52, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0238, 0xfe, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x025c, 0xc0, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0260, 0x0d, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0800, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
+	},
+	{
+		{0x0430, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0b04, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0b10, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0b00, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0b08, 0x06, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0b04, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x042c, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0434, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0410, 0x50, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x041c, 0x0a, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0414, 0x60, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0428, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x043c, 0xb8, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0400, 0x91, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0404, 0x0c, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0420, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0408, 0x04, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
+		{0x0410, 0x52, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0438, 0xfe, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x045c, 0xc0, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0460, 0x0d, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0800, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
+	},
+	{
+		{0x0630, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c04, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c10, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c00, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c08, 0x06, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0c04, 0x07, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x062c, 0x01, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0634, 0x0f, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0610, 0x50, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x061c, 0x0a, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0614, 0x60, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0628, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x063c, 0xb8, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0600, 0x91, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0604, 0x0c, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0620, 0x00, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0608, 0x04, 0x00, CSIPHY_SETTLE_CNT_LOWER_BYTE},
+		{0x0610, 0x52, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0638, 0xfe, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x065c, 0xc0, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0660, 0x0d, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0800, 0x02, 0x00, CSIPHY_DEFAULT_PARAMS},
+		{0x0000, 0x00, 0x00, CSIPHY_DNP_PARAMS},
+	},
+};
+
 static void csiphy_hw_version_read(struct csiphy_device *csiphy,
 				   struct device *dev)
 {
@@ -509,6 +639,10 @@ static void csiphy_gen2_config_lanes(struct csiphy_device *csiphy,
 		r = &lane_regs_sdm845[0][0];
 		array_size = ARRAY_SIZE(lane_regs_sdm845[0]);
 		break;
+	case CAMSS_7180:
+		r = &lane_regs_sc7180[0][0];
+		array_size = ARRAY_SIZE(lane_regs_sc7180[0]);
+		break;
 	case CAMSS_8250:
 		r = &lane_regs_sm8250[0][0];
 		array_size = ARRAY_SIZE(lane_regs_sm8250[0]);
@@ -558,6 +692,7 @@ static bool csiphy_is_gen2(u32 version)
 
 	switch (version) {
 	case CAMSS_845:
+	case CAMSS_7180:
 	case CAMSS_8250:
 	case CAMSS_8280XP:
 		ret = true;
diff --git a/drivers/media/platform/qcom/camss/camss-vfe.c b/drivers/media/platform/qcom/camss/camss-vfe.c
index 83c5a36d071fcc..05191cc2c2f936 100644
--- a/drivers/media/platform/qcom/camss/camss-vfe.c
+++ b/drivers/media/platform/qcom/camss/camss-vfe.c
@@ -336,6 +336,7 @@ static u32 vfe_src_pad_code(struct vfe_line *line, u32 sink_code,
 	case CAMSS_8x96:
 	case CAMSS_660:
 	case CAMSS_845:
+	case CAMSS_7180:
 	case CAMSS_8250:
 	case CAMSS_8280XP:
 		switch (sink_code) {
@@ -1693,6 +1694,7 @@ static int vfe_bpl_align(struct vfe_device *vfe)
 
 	switch (vfe->camss->res->version) {
 	case CAMSS_845:
+	case CAMSS_7180:
 	case CAMSS_8250:
 	case CAMSS_8280XP:
 		ret = 16;
diff --git a/drivers/media/platform/qcom/camss/camss.c b/drivers/media/platform/qcom/camss/camss.c
index d64985ca6e884f..6d758dd0b9fcba 100644
--- a/drivers/media/platform/qcom/camss/camss.c
+++ b/drivers/media/platform/qcom/camss/camss.c
@@ -1112,6 +1112,267 @@ static const struct resources_icc icc_res_sm8250[] = {
 	},
 };
 
+static const struct camss_subdev_resources csiphy_res_7180[] = {
+	/* CSIPHY0 */
+	{
+		.regulators = {},
+		.clock = {
+			"csiphy0",
+			"csiphy0_timer"
+		},
+		.clock_rate = {
+			{ 150000000, 270000000, 360000000 },
+			{ 300000000 },
+		},
+		.reg = { "csiphy0" },
+		.interrupt = { "csiphy0" },
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
+	},
+	/* CSIPHY1 */
+	{
+		.regulators = {},
+		.clock = {
+			"csiphy1",
+			"csiphy1_timer"
+		},
+		.clock_rate = {
+			{ 150000000, 270000000, 360000000 },
+			{ 300000000 },
+		},
+		.reg = { "csiphy1" },
+		.interrupt = { "csiphy1" },
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
+	},
+	/* CSIPHY2 */
+	{
+		.regulators = {},
+		.clock = {
+			"csiphy2",
+			"csiphy2_timer"
+		},
+		.clock_rate = {
+			{ 150000000, 270000000, 360000000 },
+			{ 300000000 },
+		},
+		.reg = { "csiphy2" },
+		.interrupt = { "csiphy2" },
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
+	},
+	/* CSIPHY3 */
+	{
+		.regulators = {},
+		.clock = {
+			"csiphy3",
+			"csiphy3_timer"
+		},
+		.clock_rate = {
+			{ 150000000, 270000000, 360000000 },
+			{ 300000000 },
+		},
+		.reg = { "csiphy3" },
+		.interrupt = { "csiphy3" },
+		.csiphy = {
+			.hw_ops = &csiphy_ops_3ph_1_0,
+			.formats = &csiphy_formats_sdm845
+		}
+	}
+};
+
+static const struct camss_subdev_resources csid_res_7180[] = {
+	/* CSID0 */
+	{
+		.regulators = { "vdda-phy", "vdda-pll" },
+		.clock = {
+			"soc_ahb",
+			"vfe0",
+			"vfe0_cphy_rx",
+			"csi0"
+		},
+		.clock_rate = {
+			{ 0 },
+			{ 240000000, 360000000, 432000000, 600000000 },
+			{ 150000000, 270000000, 360000000 },
+			{ 150000000, 270000000, 360000000, 480000000 },
+		},
+		.reg = { "csid0" },
+		.interrupt = { "csid0" },
+		.csid = {
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
+	},
+	/* CSID1 */
+	{
+		.regulators = { "vdda-phy", "vdda-pll" },
+		.clock = {
+			"soc_ahb",
+			"vfe1",
+			"vfe1_cphy_rx",
+			"csi1",
+		},
+		.clock_rate = {
+			{ 0 },
+			{ 240000000, 360000000, 432000000, 600000000 },
+			{ 150000000, 270000000, 360000000 },
+			{ 150000000, 270000000, 360000000, 480000000 },
+		},
+		.reg = { "csid1" },
+		.interrupt = { "csid1" },
+		.csid = {
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
+	},
+	/* CSID2 */
+	{
+		.regulators = { "vdda-phy", "vdda-pll" },
+		.clock = {
+			"soc_ahb",
+			"vfe_lite",
+			"vfe_lite_cphy_rx",
+			"csi2",
+		},
+		.clock_rate = {
+			{ 0 },
+			{ 240000000, 360000000, 432000000, 600000000 },
+			{ 150000000, 270000000, 360000000 },
+			{ 150000000, 270000000, 360000000, 480000000 },
+		},
+		.reg = { "csid2" },
+		.interrupt = { "csid2" },
+		.csid = {
+			.is_lite = true,
+			.hw_ops = &csid_ops_gen2,
+			.parent_dev_ops = &vfe_parent_dev_ops,
+			.formats = &csid_formats_gen2
+		}
+	}
+};
+
+static const struct camss_subdev_resources vfe_res_7180[] = {
+	/* VFE0 */
+	{
+		.regulators = {},
+		.clock = {
+			"camnoc_axi",
+			"cpas_ahb",
+			"soc_ahb",
+			"vfe0",
+			"vfe0_axi",
+			"csi0",
+		},
+		.clock_rate = {
+			{ 0 },
+			{ 0 },
+			{ 0 },
+			{ 19200000, 240000000, 360000000, 432000000, 600000000 },
+			{ 0 },
+			{ 150000000, 270000000, 360000000, 480000000 },
+		},
+		.reg = { "vfe0" },
+		.interrupt = { "vfe0" },
+		.vfe = {
+			.line_num = 4,
+			.has_pd = true,
+			.pd_name = "ife0",
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
+	},
+	/* VFE1 */
+	{
+		.regulators = {},
+		.clock = {
+			"camnoc_axi",
+			"cpas_ahb",
+			"soc_ahb",
+			"vfe1",
+			"vfe1_axi",
+			"csi1",
+		},
+		.clock_rate = {
+			{ 0 },
+			{ 0 },
+			{ 0 },
+			{ 19200000, 240000000, 360000000, 432000000, 600000000 },
+			{ 0 },
+			{ 150000000, 270000000, 360000000, 480000000 },
+		},
+		.reg = { "vfe1" },
+		.interrupt = { "vfe1" },
+		.vfe = {
+			.line_num = 4,
+			.has_pd = true,
+			.pd_name = "ife1",
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
+	},
+	/* VFE-lite */
+	{
+		.regulators = {},
+		.clock = {
+			"camnoc_axi",
+			"cpas_ahb",
+			"soc_ahb",
+			"vfe_lite",
+			"csi2",
+		},
+		.clock_rate = {
+			{ 0 },
+			{ 0 },
+			{ 0 },
+			{ 19200000, 240000000, 360000000, 432000000, 600000000 },
+			{ 150000000, 270000000, 360000000, 480000000 },
+		},
+		.reg = { "vfe_lite" },
+		.interrupt = { "vfe_lite" },
+		.vfe = {
+			.is_lite = true,
+			.line_num = 4,
+			.hw_ops = &vfe_ops_170,
+			.formats_rdi = &vfe_formats_rdi_845,
+			.formats_pix = &vfe_formats_pix_845
+		}
+	}
+};
+
+static const struct resources_icc icc_res_7180[] = {
+	{
+		.name = "cam_ahb",
+		.icc_bw_tbl.avg = 125000,
+		.icc_bw_tbl.peak = 250000,
+	},
+	{
+		.name = "cam_hf_0_camnoc",
+		.icc_bw_tbl.avg = 2097152,
+		.icc_bw_tbl.peak = 2097152,
+	},
+	{
+		.name = "cam_hf_1_camnoc",
+		.icc_bw_tbl.avg = 2097152,
+		.icc_bw_tbl.peak = 2097152,
+	},
+	{
+		.name = "cam_sf_camnoc",
+		.icc_bw_tbl.avg = 2097152,
+		.icc_bw_tbl.peak = 2097152,
+	},
+};
+
 static const struct camss_subdev_resources csiphy_res_sc8280xp[] = {
 	/* CSIPHY0 */
 	{
@@ -2429,6 +2690,20 @@ static const struct camss_resources sm8250_resources = {
 	.link_entities = camss_link_entities
 };
 
+static const struct camss_resources sc7180_resources = {
+	.version = CAMSS_7180,
+	.pd_name = "top",
+	.csiphy_res = csiphy_res_7180,
+	.csid_res = csid_res_7180,
+	.vfe_res = vfe_res_7180,
+	.icc_res = icc_res_7180,
+	.icc_path_num = ARRAY_SIZE(icc_res_7180),
+	.csiphy_num = ARRAY_SIZE(csiphy_res_7180),
+	.csid_num = ARRAY_SIZE(csid_res_7180),
+	.vfe_num = ARRAY_SIZE(vfe_res_7180),
+	.link_entities = camss_link_entities
+};
+
 static const struct camss_resources sc8280xp_resources = {
 	.version = CAMSS_8280XP,
 	.pd_name = "top",
@@ -2450,6 +2725,7 @@ static const struct of_device_id camss_dt_match[] = {
 	{ .compatible = "qcom,sdm660-camss", .data = &sdm660_resources },
 	{ .compatible = "qcom,sdm845-camss", .data = &sdm845_resources },
 	{ .compatible = "qcom,sm8250-camss", .data = &sm8250_resources },
+	{ .compatible = "qcom,sc7180-camss", .data = &sc7180_resources },
 	{ .compatible = "qcom,sc8280xp-camss", .data = &sc8280xp_resources },
 	{ }
 };
diff --git a/drivers/media/platform/qcom/camss/camss.h b/drivers/media/platform/qcom/camss/camss.h
index 73c47c07fc30c5..867e275db4bec8 100644
--- a/drivers/media/platform/qcom/camss/camss.h
+++ b/drivers/media/platform/qcom/camss/camss.h
@@ -77,6 +77,7 @@ enum camss_version {
 	CAMSS_8x96,
 	CAMSS_660,
 	CAMSS_845,
+	CAMSS_7180,
 	CAMSS_8250,
 	CAMSS_8280XP,
 };
diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index bcfa63fb9f1e20..ab00b43eae4318 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -192,6 +192,16 @@ config BATTERY_QCOM_BATTMGR
 	  which is used on modern Qualcomm platforms to provide battery and
 	  power supply information.
 
+config BATTERY_QCOM_QG
+	tristate "Qualcomm PMIC QGauge driver"
+	depends on MFD_SPMI_PMIC
+	depends on IIO
+	help
+	  Say Y here to enable the Qualcomm Technologies, Inc. QGauge driver
+	  which uses the periodic sampling of the battery voltage and current
+	  to determine the battery state-of-charge (SOC) and supports other
+	  battery management features.
+
 config BATTERY_OLPC
 	tristate "One Laptop Per Child battery"
 	depends on OLPC_EC
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index 8dcb4154531718..3a06c77d46127f 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -35,6 +35,7 @@ obj-$(CONFIG_BATTERY_LEGO_EV3)	+= lego_ev3_battery.o
 obj-$(CONFIG_BATTERY_LENOVO_YOGA_C630) += lenovo_yoga_c630_battery.o
 obj-$(CONFIG_BATTERY_PMU)	+= pmu_battery.o
 obj-$(CONFIG_BATTERY_QCOM_BATTMGR)	+= qcom_battmgr.o
+obj-$(CONFIG_BATTERY_QCOM_QG)	+= qcom_qg.o
 obj-$(CONFIG_BATTERY_OLPC)	+= olpc_battery.o
 obj-$(CONFIG_BATTERY_SAMSUNG_SDI)	+= samsung-sdi-battery.o
 obj-$(CONFIG_BATTERY_COLLIE)	+= collie_battery.o
diff --git a/drivers/power/supply/qcom_qg.c b/drivers/power/supply/qcom_qg.c
new file mode 100644
index 00000000000000..d6bda9ad94f675
--- /dev/null
+++ b/drivers/power/supply/qcom_qg.c
@@ -0,0 +1,264 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2024, Danila Tikhonov <danila@jiaxyga.com>
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/power_supply.h>
+#include <linux/iio/consumer.h>
+#include <linux/regmap.h>
+
+/* SRAM */
+#define QG_SRAM_BASE	0xb600
+
+/* BATT offsets */
+#define QG_S2_NORMAL_AVG_V_DATA0_REG	0x80 /* 2-byte 0x80-0x81 */
+#define QG_S2_NORMAL_AVG_I_DATA0_REG	0x82 /* 2-byte 0x82-0x83 */
+#define QG_LAST_ADC_V_DATA0_REG		0xc0 /* 2-byte 0xc0-0xc1 */
+#define QG_LAST_ADC_I_DATA0_REG		0xc2 /* 2-byte 0xc2-0xc3 */
+
+/* SRAM offsets */
+#define QG_SDAM_OCV_OFFSET		0x4c /* 4-byte 0x4c-0x4f */
+#define QG_SDAM_LEARNED_CAPACITY_OFFSET	0x68 /* 2-byte 0x68-0x69 */
+
+struct qcom_qg_chip {
+	struct device *dev;
+	struct regmap *regmap;
+	unsigned int base;
+
+	struct iio_channel *batt_therm_chan;
+	struct iio_channel *batt_id_chan;
+
+	struct power_supply *batt_psy;
+	struct power_supply_battery_info *batt_info;
+};
+
+static int qcom_qg_get_current(struct qcom_qg_chip *chip, u8 offset, int *val)
+{
+	s16 temp;
+	u8 readval[2];
+	int ret;
+
+	ret = regmap_bulk_read(chip->regmap, chip->base + offset, readval, 2);
+	if (ret) {
+		dev_err(chip->dev, "Failed to read current: %d\n", ret);
+		return ret;
+	}
+
+	temp = (s16)(readval[1] << 8 | readval[0]);
+	*val = div_s64((s64)temp * 152588, 1000);
+
+	return 0;
+}
+
+static int qcom_qg_get_voltage(struct qcom_qg_chip *chip, u8 offset, int *val)
+{
+	int ret, temp;
+	u8 readval[2];
+
+	ret = regmap_bulk_read(chip->regmap, chip->base + offset, readval, 2);
+	if (ret) {
+		dev_err(chip->dev, "Failed to read voltage: %d\n", ret);
+		return ret;
+	}
+
+	temp = readval[1] << 8 | readval[0];
+	*val = div_u64((u64)temp * 194637, 1000);
+
+	return 0;
+}
+
+/*
+ * Yes, this function simply calculates the capacity based on
+ * the current voltage. This will be rewritten in the future.
+ */
+static int qcom_qg_get_capacity(struct qcom_qg_chip *chip, int *val)
+{
+	int ret, voltage_now;
+	int voltage_min = chip->batt_info->voltage_min_design_uv;
+	int voltage_max = chip->batt_info->voltage_max_design_uv;
+
+	ret = qcom_qg_get_voltage(chip,
+				QG_S2_NORMAL_AVG_V_DATA0_REG, &voltage_now);
+	if (ret) {
+		dev_err(chip->dev, "Failed to get current voltage: %d\n", ret);
+		return ret;
+	}
+
+	if (voltage_now <= voltage_min)
+		*val = 0;
+	else if (voltage_now >= voltage_max)
+		*val = 100;
+	else
+		*val = (((voltage_now - voltage_min) * 100) /
+						(voltage_max - voltage_min));
+
+	return 0;
+}
+
+static enum power_supply_property qcom_qg_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_VOLTAGE_OCV,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+};
+
+static int qcom_qg_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct qcom_qg_chip *chip = power_supply_get_drvdata(psy);
+	int ret;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LIPO;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:
+		val->intval = chip->batt_info->voltage_max_design_uv;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:
+		val->intval = chip->batt_info->voltage_min_design_uv;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		ret = qcom_qg_get_voltage(chip,
+				QG_LAST_ADC_V_DATA0_REG, &val->intval);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+		ret = qcom_qg_get_voltage(chip,
+				QG_S2_NORMAL_AVG_V_DATA0_REG, &val->intval);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_OCV:
+		ret = regmap_raw_read(chip->regmap,
+			QG_SRAM_BASE + QG_SDAM_OCV_OFFSET, &val->intval, 4);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		ret = qcom_qg_get_current(chip,
+				QG_LAST_ADC_I_DATA0_REG, &val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_AVG:
+		ret = qcom_qg_get_current(chip,
+				QG_S2_NORMAL_AVG_I_DATA0_REG, &val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		val->intval = chip->batt_info->charge_full_design_uah;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		ret = regmap_raw_read(chip->regmap, QG_SRAM_BASE +
+				QG_SDAM_LEARNED_CAPACITY_OFFSET, &val->intval, 2);
+		if (!ret) val->intval *= 1000; /* mah to uah */
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		ret = qcom_qg_get_capacity(chip, &val->intval);
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		ret = iio_read_channel_processed
+					(chip->batt_therm_chan, &val->intval);
+		break;
+	default:
+		dev_err(chip->dev, "invalid property: %d\n", psp);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct power_supply_desc batt_psy_desc = {
+	.name = "qcom_qg",
+	.type = POWER_SUPPLY_TYPE_BATTERY,
+	.properties = qcom_qg_props,
+	.num_properties = ARRAY_SIZE(qcom_qg_props),
+	.get_property = qcom_qg_get_property,
+};
+
+static int qcom_qg_probe(struct platform_device *pdev)
+{
+	struct qcom_qg_chip *chip;
+	struct power_supply_config psy_cfg = {};
+	int ret;
+
+	chip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	chip->dev = &pdev->dev;
+
+	/* Regmap */
+	chip->regmap = dev_get_regmap(pdev->dev.parent, NULL);
+	if (!chip->regmap)
+		return dev_err_probe(chip->dev, -ENODEV,
+				     "Failed to locate the regmap\n");
+
+	/* Get base address */
+	ret = device_property_read_u32(chip->dev, "reg", &chip->base);
+	if (ret < 0)
+		return dev_err_probe(chip->dev, ret,
+				     "Couldn't read base address\n");
+
+	/* ADC for Battery ID & THERM */
+	chip->batt_id_chan = devm_iio_channel_get(&pdev->dev, "batt-id");
+	if (IS_ERR(chip->batt_id_chan))
+		return dev_err_probe(chip->dev, PTR_ERR(chip->batt_id_chan),
+				     "Couldn't get batt-id IIO channel\n");
+
+	chip->batt_therm_chan = devm_iio_channel_get(&pdev->dev, "batt-therm");
+	if (IS_ERR(chip->batt_therm_chan))
+		return dev_err_probe(chip->dev, PTR_ERR(chip->batt_therm_chan),
+				     "Couldn't get batt-therm IIO channel\n");
+
+	psy_cfg.drv_data = chip;
+	psy_cfg.of_node = pdev->dev.of_node;
+
+	/* Power supply */
+	chip->batt_psy =
+		devm_power_supply_register(chip->dev, &batt_psy_desc, &psy_cfg);
+	if (IS_ERR(chip->batt_psy))
+		return dev_err_probe(chip->dev, PTR_ERR(chip->batt_psy),
+				     "Failed to register power supply\n");
+
+	/* Battery info */
+	ret = power_supply_get_battery_info(chip->batt_psy, &chip->batt_info);
+	if (ret)
+		return dev_err_probe(chip->dev, ret,
+				     "Failed to get battery info\n");
+
+	platform_set_drvdata(pdev, chip);
+
+	return 0;
+}
+
+static const struct of_device_id qcom_qg_of_match[] = {
+	{ .compatible = "qcom,pm6150-qg", },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, qcom_qg_of_match);
+
+static struct platform_driver qcom_qg_driver = {
+	.driver = {
+		.name = "qcom,qcom_qg",
+		.of_match_table = qcom_qg_of_match,
+	},
+	.probe = qcom_qg_probe,
+};
+
+module_platform_driver(qcom_qg_driver);
+
+MODULE_AUTHOR("Danila Tikhonov <danila@jiaxyga.com>");
+MODULE_DESCRIPTION("Qualcomm PMIC QGauge (QG) driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/soc/qcom/qcom_pd_mapper.c b/drivers/soc/qcom/qcom_pd_mapper.c
index c940f4da28ed5c..c909f837c45bca 100644
--- a/drivers/soc/qcom/qcom_pd_mapper.c
+++ b/drivers/soc/qcom/qcom_pd_mapper.c
@@ -552,6 +552,7 @@ static const struct of_device_id qcom_pdm_domains[] __maybe_unused = {
 	{ .compatible = "qcom,sm4250", .data = sm6115_domains, },
 	{ .compatible = "qcom,sm6115", .data = sm6115_domains, },
 	{ .compatible = "qcom,sm6350", .data = sm6350_domains, },
+	{ .compatible = "qcom,sm7125", .data = sc7180_domains, },
 	{ .compatible = "qcom,sm7325", .data = sc7280_domains, },
 	{ .compatible = "qcom,sm8150", .data = sm8150_domains, },
 	{ .compatible = "qcom,sm8250", .data = sm8250_domains, },
diff --git a/drivers/video/backlight/qcom-wled.c b/drivers/video/backlight/qcom-wled.c
index 10129095a4c178..6d3016e008e5be 100644
--- a/drivers/video/backlight/qcom-wled.c
+++ b/drivers/video/backlight/qcom-wled.c
@@ -197,6 +197,7 @@ struct wled {
 	bool disabled_by_short;
 	bool has_short_detect;
 	bool cabc_disabled;
+	bool ovp_irq_disabled;
 	int short_irq;
 	int ovp_irq;
 
@@ -294,7 +295,10 @@ static void wled_ovp_work(struct work_struct *work)
 {
 	struct wled *wled = container_of(work,
 					 struct wled, ovp_work.work);
-	enable_irq(wled->ovp_irq);
+	if (wled->ovp_irq_disabled) {
+		enable_irq(wled->ovp_irq);
+		wled->ovp_irq_disabled = false;
+	}
 }
 
 static int wled_module_enable(struct wled *wled, int val)
@@ -321,8 +325,11 @@ static int wled_module_enable(struct wled *wled, int val)
 			 */
 			schedule_delayed_work(&wled->ovp_work, HZ / 100);
 		} else {
-			if (!cancel_delayed_work_sync(&wled->ovp_work))
+			if (!cancel_delayed_work_sync(&wled->ovp_work) && 
+					!wled->ovp_irq_disabled) {
 				disable_irq(wled->ovp_irq);
+				wled->ovp_irq_disabled = true;
+			}
 		}
 	}
 
@@ -1725,6 +1732,8 @@ static void wled_remove(struct platform_device *pdev)
 	cancel_delayed_work_sync(&wled->ovp_work);
 	disable_irq(wled->short_irq);
 	disable_irq(wled->ovp_irq);
+
+	wled->ovp_irq_disabled = true;
 }
 
 static const struct of_device_id wled_match_table[] = {
diff --git a/sound/soc/codecs/tas2562.c b/sound/soc/codecs/tas2562.c
index 54561ae598b87a..159c6a77634116 100644
--- a/sound/soc/codecs/tas2562.c
+++ b/sound/soc/codecs/tas2562.c
@@ -471,6 +471,9 @@ static int tas2562_volume_control_put(struct snd_kcontrol *kcontrol,
 {
 	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
 	struct tas2562_data *tas2562 = snd_soc_component_get_drvdata(component);
+	
+//Sometimes doesn't work with "amixer -c0 cset" command. Maybe it has to do something with 'page' switching
+#if 0
 	int ret;
 	u32 reg_val;
 
@@ -491,6 +494,7 @@ static int tas2562_volume_control_put(struct snd_kcontrol *kcontrol,
 				      ((reg_val >> 24) & 0xff));
 	if (ret)
 		return ret;
+#endif
 
 	tas2562->volume_lvl = ucontrol->value.integer.value[0];
 
