created via: git diff d390303b28dabbb91b2d32016a4f72da478733b9 1728ab7f6075ea66a7ad1400791c826b9f01f8c3 of https://github.com/msm8916-mainline/linux (master branch as of 1728ab7f6075ea66a7ad1400791c826b9f01f8c3)

diff --git a/.ci-check.sh b/.ci-check.sh
new file mode 100755
index 000000000000..520cebecc74d
--- /dev/null
+++ b/.ci-check.sh
@@ -0,0 +1,8 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-only
+set -eux
+
+git format-patch "$1"
+scripts/checkpatch.pl --strict --color=always *.patch || :
+! scripts/checkpatch.pl --strict --color=always --terse --show-types *.patch \
+	| grep -Ff .ci-checkpatch.txt
diff --git a/.ci-checkpatch.txt b/.ci-checkpatch.txt
new file mode 100644
index 000000000000..78bc7f230019
--- /dev/null
+++ b/.ci-checkpatch.txt
@@ -0,0 +1,7 @@
+ERROR:
+BAD_SIGN_OFF:
+FROM_SIGN_OFF_MISMATCH:
+LEADING_SPACE:
+MISSING_EOF_NEWLINE:
+SPACE_BEFORE_TAB:
+SPDX_LICENSE_TAG:
diff --git a/.ci-prepare.sh b/.ci-prepare.sh
new file mode 100755
index 000000000000..7bbe756ae534
--- /dev/null
+++ b/.ci-prepare.sh
@@ -0,0 +1,46 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-only
+set -eux
+
+# Show information about CI runner environment
+nproc && grep Mem /proc/meminfo && df -hT .
+
+# Install Linux build dependencies
+apk add build-base bison findutils flex gmp-dev mpc1-dev mpfr-dev openssl-dev perl python3 linux-headers
+
+if [ -n "${DRONE-}" ]; then
+	# Workaround problem with faccessat2() on Drone CI
+	wget https://gist.githubusercontent.com/TravMurav/36c83efbc188115aa9b0fc7f4afba63e/raw/faccessat.c -P /opt
+	gcc -O2 -shared -o /opt/faccessat.so /opt/faccessat.c
+	export LD_PRELOAD=/opt/faccessat.so
+fi
+
+# Setup compiler
+case "$1" in
+gcc)
+	case "$ARCH" in
+		arm64)	gcc_toolchain=aarch64-none-elf ;;
+		arm)	gcc_toolchain=arm-none-eabi ;;
+	esac
+	apk add "gcc-$gcc_toolchain"
+	MAKE_OPTS="CROSS_COMPILE=$gcc_toolchain-"
+	;;
+clang)
+	apk add clang lld llvm
+	MAKE_OPTS="LLVM=1"
+	;;
+esac
+MAKE_OPTS="-j$(nproc) $MAKE_OPTS"
+
+# Write build script
+cat > .ci-build.sh <<EOF
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0-only
+set -eux
+
+cat arch/arm64/configs/msm8916_defconfig arch/arm/configs/msm8916_defconfig.part > arch/arm/configs/msm8916_defconfig
+make $MAKE_OPTS msm8916_defconfig
+echo CONFIG_WERROR=y >> .config
+make $MAKE_OPTS
+EOF
+chmod +x .ci-build.sh
diff --git a/.drone.yml b/.drone.yml
new file mode 100644
index 000000000000..db48beb62491
--- /dev/null
+++ b/.drone.yml
@@ -0,0 +1,73 @@
+---
+kind: pipeline
+type: docker
+name: arm64
+
+platform:
+  os: linux
+  arch: amd64
+
+clone:
+  depth: 1
+
+environment:
+  ARCH: arm64
+
+steps:
+  - name: build (gcc)
+    image: alpine:latest
+    commands:
+      - . .ci-prepare.sh gcc
+      - ./.ci-build.sh
+      - apk add git && git clean -dxfq
+
+  - name: build (clang)
+    image: alpine:latest
+    commands:
+      - . .ci-prepare.sh clang
+      - ./.ci-build.sh
+
+  - name: check
+    image: alpine:latest
+    commands:
+      - apk add git perl
+      - ./.ci-check.sh origin/$DRONE_TARGET_BRANCH
+    when:
+      event: pull_request
+
+---
+kind: pipeline
+type: docker
+name: arm
+
+platform:
+  os: linux
+  arch: amd64
+
+clone:
+  depth: 1
+
+environment:
+  ARCH: arm
+
+steps:
+  - name: build (gcc)
+    image: alpine:latest
+    commands:
+      - . .ci-prepare.sh gcc
+      - ./.ci-build.sh
+      - apk add git && git clean -dxfq
+
+  - name: build (clang)
+    image: alpine:latest
+    commands:
+      - . .ci-prepare.sh clang
+      - ./.ci-build.sh
+
+  - name: check
+    image: alpine:latest
+    commands:
+      - apk add git perl
+      - ./.ci-check.sh origin/$DRONE_TARGET_BRANCH
+    when:
+      event: pull_request
diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
new file mode 100644
index 000000000000..e57a30176f7a
--- /dev/null
+++ b/.github/workflows/build.yml
@@ -0,0 +1,21 @@
+name: Build
+on: [push, pull_request]
+jobs:
+  build:
+    runs-on: ubuntu-latest
+    strategy:
+      fail-fast: false
+      matrix:
+        arch: [arm64, arm]
+        compiler: [gcc, clang]
+    env:
+      ARCH: ${{ matrix.arch }}
+    steps:
+    - uses: actions/checkout@v3
+    - uses: jirutka/setup-alpine@v1
+    - name: Prepare build environment
+      run: ./.ci-prepare.sh ${{ matrix.compiler }}
+      shell: alpine.sh --root {0}
+    - name: Build
+      run: ./.ci-build.sh
+      shell: alpine.sh {0}
diff --git a/.github/workflows/check.yml b/.github/workflows/check.yml
new file mode 100644
index 000000000000..a5c27ecde488
--- /dev/null
+++ b/.github/workflows/check.yml
@@ -0,0 +1,11 @@
+name: Check
+on: [pull_request]
+jobs:
+  check:
+    runs-on: ubuntu-latest
+    steps:
+    - uses: actions/checkout@v3
+      with:
+        fetch-depth: 64
+    - name: Run checkpatch.pl
+      run: ./.ci-check.sh HEAD~1
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 000000000000..56a35cf58d20
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,101 @@
+# Contributing to msm8916-mainline/linux
+Thanks for your interest in contributing to msm8916-mainline/linux! :tada:
+
+## About
+[msm8916-mainline/linux] is a fork of the [mainline Linux kernel](https://kernel.org)
+(released by Linus Torvalds). Goal of the repository is to **temporarily** host
+**work-in-progress** changes for various devices based on the
+Qualcomm Snapdragon 410/412 (MSM8916) SoC.
+
+Once ready, changes should be [submitted upstream](https://www.kernel.org/doc/html/latest/process/submitting-patches.html)
+through the appropriate mailing lists.  
+**Changes submitted in this repository will not automatically land upstream!**
+
+**Note:** This fork is **unofficial** and not (directly) affiliated to the mainline
+Linux project. As such, it is entirely **optional** to submit your changes as
+pull request to this repository. You can also immediately send your changes
+upstream to the appropriate mailing lists. Submitting your changes here (before
+sending them upstream) has the following advantages:
+
+  - **Preliminary review:** You get early feedback on your patches which may
+    speed up submission of your patch upstream later.
+    **Note:** Acceptance of your patch in this repository does not mean that
+    the upstream maintainers will accept it!
+
+  - **Kept up-to-date:** All patches in this repository will be rebased to newer
+    upstream Linux releases, so your device will be always up-to-date even with
+    some work-in-progress changes.
+
+  - **Packaged in [postmarketOS]:** This fork is the source of the
+    `linux-postmarketos-qcom-msm8916` package in postmarketOS, which is used by
+    all MSM8916 devices based on the mainline kernel. Your changes will be
+    included in the next release and therefore show up in postmarketOS.
+
+## Patch Requirements
+Goal for all patches in this repository is to upstream them eventually. Therefore,
+the formal requirements are similar to upstream, e.g.:
+
+  - No compile warnings/errors
+  - Clean code style
+  - Changes separated into clean commits (one per logical change/subsystem)
+  - Appropriate commit message that explains the motivation for the change
+
+If you want to contribute to this repository, you should be willing to bring your
+patches into suitable shape for upstreaming. Most of this is documented upstream
+in [Submitting patches]. Don't worry if you don't get it exactly right the first time. :)
+
+### Sign off your patches - the Developer's Certificate of Origin
+Upstream contributions to the Linux kernel are required to have the following
+tag in the commit message:
+
+```
+Signed-off-by: FirstName LastName <your-email@example.com>
+```
+
+These tags are also required when contributing to this repository. Reason for
+this is that you might become busy at some point, or your interests change. Then
+it is important that someone else can pick up your work and finish it up.
+
+Please read [Sign your work - the Developerâ€™s Certificate of Origin](https://www.kernel.org/doc/html/latest/process/submitting-patches.html#sign-your-work-the-developer-s-certificate-of-origin)
+**carefully** to understand the meaning of the `Signed-off-by:`.
+It also explains how to add it easily when creating new commits.
+
+## Upstreaming
+Upstreaming changes takes time. And sometimes, changes cannot be submitted
+upstream yet because they are work-in-progress or because there are fundamental
+open problems that cannot be solved immediately, e.g.:
+
+  - Weird issues where the actual cause cannot be determined at the moment ("hacks").
+  - New drivers with problems in some edge cases.
+  - Panel drivers that are mostly auto-generated and that are hard to document
+    properly because of lack of documentation.
+  - Battery/charging drivers that are hard to validate without expert knowledge.
+
+If you have something (mostly) working and the [formal patch requirements](#patch-requirements)
+are met, then it's good to share it with others in this repository.
+
+However, keep in mind that maintaining a large amount of patches in this
+repository consumes a significant amount of time, especially when breaking
+changes are made upstream. This means less time to review new patches
+or to work on improvements everyone can benefit from.
+
+**Please help to keep maintenance time at an acceptable level by submitting your
+patches upstream when they are ready.** If you are not sure if your patches are
+ready, just ask and we can discuss it.
+
+### Patches that touch upstream files
+Patches that touch upstream files which are frequently updated
+(e.g. existing, shared drivers instead of files specific to your device)
+should be submitted upstream before they are merged into this repository.
+This is because those tend to cause conflicts much more frequently when updating
+to newer kernel versions.
+
+This is just a guideline to reduce maintenance, exceptions can be made if necessary.
+
+## Questions
+If you have any questions, feel free to ask in the [postmarketOS mainline channel
+on Matrix or IRC](https://wiki.postmarketos.org/wiki/Matrix_and_IRC).
+
+[msm8916-mainline/linux]: https://github.com/msm8916-mainline/linux
+[postmarketOS]: https://postmarketos.org
+[Submitting patches]: https://www.kernel.org/doc/html/latest/process/submitting-patches.html
diff --git a/Documentation/devicetree/bindings/input/touchscreen/himax,hx852es.yaml b/Documentation/devicetree/bindings/input/touchscreen/himax,hx852es.yaml
new file mode 100644
index 000000000000..40a60880111d
--- /dev/null
+++ b/Documentation/devicetree/bindings/input/touchscreen/himax,hx852es.yaml
@@ -0,0 +1,81 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/input/touchscreen/himax,hx852es.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Himax HX852x(ES) touch panel controller
+
+maintainers:
+  - Stephan Gerhold <stephan@gerhold.net>
+
+allOf:
+  - $ref: touchscreen.yaml#
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - himax,hx8525e
+          - himax,hx8526e
+          - himax,hx8527e
+      - const: himax,hx852es
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+    description: Touch Screen Interrupt (TSIX), active low
+
+  reset-gpios:
+    maxItems: 1
+    description: External Reset (XRES), active low
+
+  vcca-supply:
+    description: Analog power supply (VCCA)
+
+  vccd-supply:
+    description: Digital power supply (VCCD)
+
+  touchscreen-inverted-x: true
+  touchscreen-inverted-y: true
+  touchscreen-size-x: true
+  touchscreen-size-y: true
+  touchscreen-swapped-x-y: true
+
+  linux,keycodes:
+    minItems: 1
+    maxItems: 4
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - reset-gpios
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+    #include <dt-bindings/input/input.h>
+    #include <dt-bindings/interrupt-controller/irq.h>
+
+    i2c {
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      touchscreen@48 {
+        compatible = "himax,hx8527e", "himax,hx852es";
+        reg = <0x48>;
+        interrupt-parent = <&tlmm>;
+        interrupts = <13 IRQ_TYPE_LEVEL_LOW>;
+        reset-gpios = <&tlmm 12 GPIO_ACTIVE_LOW>;
+        vcca-supply = <&reg_ts_vcca>;
+        vccd-supply = <&pm8916_l6>;
+        linux,keycodes = <KEY_BACK KEY_HOMEPAGE KEY_APPSELECT>;
+      };
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/power/supply/smb1360.yaml b/Documentation/devicetree/bindings/power/supply/smb1360.yaml
new file mode 100644
index 000000000000..ac10fe51eb3d
--- /dev/null
+++ b/Documentation/devicetree/bindings/power/supply/smb1360.yaml
@@ -0,0 +1,271 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/power/supply/smb1360.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: Qualcomm SMB1360 charger and fuel gauge
+
+maintainers:
+  - Jonathan Albrieux <jonathan.albrieux@gmail.com>
+
+description: |
+  Port for Qualcomm SMB1360 charger and fuel gauge downstream driver.
+
+  A brief overview of the chip can be found at:
+    https://www.qualcomm.com/products/quick-charge-10
+
+  Original code can be found at:
+    https://github.com/msm8916-mainline/android_kernel_qcom_msm8916/blob/master/drivers/power/smb1360-charger-fg.c
+
+properties:
+  compatible:
+    enum:
+      - qcom,smb1360
+
+  reg:
+    description: I2C address of the charger.
+
+  interrupts:
+    description:
+      IRQ number of the GPIO connected to the STAT pin.
+
+  qcom,rsense-10mohm:
+    type: boolean
+    description:
+      Indicates the Rsense resistor configuration.
+      If set, the Rsense is 10mOhm else it's 20mOhm.
+
+  qcom,float-voltage-mv:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      The maximum voltage up to which the battery is charged.
+      This value is in mV.
+
+  qcom,iterm-ma:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Specifies the termination current to indicate end-of-charge.
+      Possible values in 25, 50, 75, 100, 125, 150, 175 and 200mA
+
+  qcom,charging-timeout:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Maximum duration in minutes that a single charge cycle may last.
+      Supported values are 0, 192, 384, 768, and 1536. A value of 0 means that
+      no charge cycle timeout is used and charging can continue indefinitely.
+
+  qcom,recharge-thresh-mv:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Specifies the minimum voltage drop in millivolts below the float voltage
+      that is required in order to initiate a new charging cycle.
+      Supported values are 50, 100, 200 and 300mV.
+
+  qcom,chg-inhibit-disabled:
+    type: boolean
+    description:
+      Disables the charger-inhibit function.
+
+  qcom,battery-profile:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Specifies the battery profile to use.
+      0 is for profile A, 1 is for profile B.
+    enum: [0, 1]
+
+  qcom,fg-batt-capacity-mah:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      The new battery capacity to be supported.
+      This updates the ACTUAL and NOMINAL CAPACITY of the profile.
+
+  qcom,fg-cc-soc-coeff:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      The CC_TO_SOC_COEFF of the new battery capacity.
+      This value is calculated from the batt-capacity and then encoded
+      as floating number. cc_soc_coeff = HALF_ENCODING(8192 / batt-capacity)
+
+  qcom,fg-cutoff-voltage-mv:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      This is the minimum allowed system voltage. The FG will report
+      SOC = 0 at this voltage. This value is in mV.
+
+  qcom,fg-iterm-ma:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      This is termination current at which the Monotonic SOC reports 100.
+      The value passed here is negated in the driver (assuming that the iterm
+      is always -ve). This value is in mA.
+
+  qcom,fg-ibatt-standby-ma:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      This is the minimum current value for the SOC to be above 0% at
+      the cutoff voltage. This value is in mA.
+
+  qcom,fg-cc-to-cv-mv:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      This is the voltage at which the FG transitions from CC to CV.
+      This value should never be higher than the float voltage. This
+      value is in mV.
+
+  qcom,thermistor-c1-coeff:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      This is the NTC thermistor C1 coeff for the thermistor inside
+      the battery. This value is 16-bit float encoded value determined from the
+      NTC-c1_coeff mapping.
+
+  qcom,fg-auto-recharge-soc:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Defines the auto recharging SOC threshold.
+
+  qcom,otp-hard-jeita-config:
+    type: boolean
+    description:
+      Indicates if cold and hot thresholds need be modified.
+      If it's not defined, default temp thresholds [0, 55] will be used.
+
+  qcom,otp-hot-bat-decidegc:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Hot battery temperature in decidegC.
+
+  qcom,otp-cold-bat-decidegc:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Cold battery temperature in decidegC.
+
+  qcom,soft-jeita-config:
+    type: boolean
+    description:
+      Indicates if soft JEITA compensation should be enabled. When the soft
+      temperature limits are reached, the maximum voltage up to which battery
+      is charged is reduced and charging current is limited.
+
+  qcom,warm-bat-decidegc:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Warm battery temperature in decidegC.
+
+  qcom,cool-bat-decidegc:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Cool battery temperature in decidegC.
+
+  qcom,soft-jeita-comp-voltage-mv:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      The battery target voltage that is used when the soft temperature
+      thresholds are reached.
+
+  qcom,soft-jeita-comp-current-ma:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      The maximum charging current used when the soft temperature thresholds
+      are reached.
+
+  qcom,shdn-after-pwroff:
+    type: boolean
+    description:
+      Configure smb1360 for shutdown at power-off.
+
+  qcom,fg-reset-at-pon:
+    type: boolean
+    description:
+      Indicates if the FG reset at power-on is enabled.
+
+  qcom,fg-reset-threshold-mv:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    description:
+      Indicates the voltage threshold to reset the FG. It is compared against
+      the difference between in predicted voltage and current voltage.
+      If this value is not specified a default value of 50mV is used.
+      Unit is in milli-volts.
+
+  qcom,otp-rslow-config:
+    $ref: /schemas/types.yaml#/definitions/uint8-array
+    description:
+      Undocumented feature found on some devices as "qcom,otp-rslow-cfg".
+      Each item is a value keyed respectively to 0x54, 0x55, 0x56 and 0x57
+      and written to OTP.
+    minItems: 4
+    maxItems: 4
+
+  usb_otg_vbus:
+    description: Regulator controlling USB OTG VBUS.
+    # TODO: Reference regulator-max-microamps here somehow?
+
+dependencies:
+  qcom,otp-hard-jeita-config: [ 'qcom,otp-hot-bat-decidegc', 'qcom,otp-cold-bat-decidegc' ]
+  qcom,otp-hot-bat-decidegc: [ 'qcom,otp-hard-jeita-config' ]
+  qcom,otp-cold-bat-decidegc: [ 'qcom,otp-hard-jeita-config' ]
+  qcom,fg-cc-soc-coeff: [ 'qcom,fg-batt-capacity-mah' ]
+
+required:
+  - compatible
+  - reg
+
+additionalProperties: true
+
+examples:
+  - |
+    #include <dt-bindings/interrupt-controller/irq.h>
+
+    i2c {
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      charger: battery@14 {
+        compatible = "qcom,smb1360";
+        reg = <0x14>;
+
+        interrupt-parent = <&msmgpio>;
+        interrupts = <62 IRQ_TYPE_LEVEL_LOW>;
+
+        pinctrl-names = "default";
+        pinctrl-0 = <&smb_int_default>;
+
+        qcom,rsense-10mohm;
+
+        qcom,float-voltage-mv = <4400>;
+        qcom,iterm-ma = <100>;
+        qcom,charging-timeout = <192>;
+        qcom,recharge-thresh-mv = <50>;
+        qcom,chg-inhibit-disabled;
+
+        qcom,battery-profile = <0>;
+
+        qcom,fg-batt-capacity-mah = <2810>;
+        qcom,fg-cc-soc-coeff = <0x81D5>;
+        qcom,fg-cutoff-voltage-mv = <3400>;
+        qcom,fg-iterm-ma = <100>;
+        qcom,fg-ibatt-standby-ma = <200>;
+        qcom,fg-cc-to-cv-mv = <4397>;
+        qcom,thermistor-c1-coeff = <0x86C2>;
+        qcom,fg-auto-recharge-soc = <97>;
+
+        qcom,otp-hard-jeita-config;
+        qcom,otp-hot-bat-decidegc = <500>;
+        qcom,otp-cold-bat-decidegc = <(-50)>;
+
+        qcom,soft-jeita-config;
+        qcom,warm-bat-decidegc = <450>;
+        qcom,cool-bat-decidegc = <100>;
+        qcom,soft-jeita-comp-voltage-mv = <4000>;
+        qcom,soft-jeita-comp-current-ma = <600>;
+
+        qcom,shdn-after-pwroff;
+        qcom,fg-reset-at-pon;
+        qcom,fg-reset-threshold-mv = <200>;
+
+        usb_otg_vbus: usb-otg-vbus {
+          regulator-max-microamp = <1500000>;
+        };
+      };
+    };
diff --git a/Documentation/devicetree/bindings/soc/qcom/qcom,memshare.yaml b/Documentation/devicetree/bindings/soc/qcom/qcom,memshare.yaml
new file mode 100644
index 000000000000..ebdf128b066c
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/qcom/qcom,memshare.yaml
@@ -0,0 +1,109 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/soc/qcom/qcom,memshare.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: Qualcomm QMI Shared Memory Service
+
+description: |
+  This driver provides a QMI service that allows remote processors (like modem)
+  to request additional memory. It is used for applications like GPS in modem.
+
+maintainers:
+  - Nikita Travkin <nikitos.tr@gmail.com>
+
+properties:
+  compatible:
+    const: qcom,memshare
+
+  qcom,legacy-client:
+    $ref: /schemas/types.yaml#/definitions/phandle
+    description: Phandle to a memshare client node used for legacy requests.
+
+  "#address-cells":
+    const: 1
+
+  "#size-cells":
+    const: 0
+
+patternProperties:
+  "^.*@[0-9]+$":
+    type: object
+
+    properties:
+      reg:
+        description: Proc-ID for clients in this node.
+
+      qcom,qrtr-node:
+        $ref: /schemas/types.yaml#/definitions/uint32
+        description: Node from which the requests are expected.
+
+      "#address-cells":
+        const: 1
+
+      "#size-cells":
+        const: 0
+
+    patternProperties:
+      "^.*@[0-9]+$":
+        type: object
+
+        properties:
+          reg:
+            description: ID of this client.
+
+          memory-region:
+            $ref: /schemas/types.yaml#/definitions/phandle
+            description: |
+              Reserved memory region that should be used for allocation.
+
+        required:
+          - reg
+
+    required:
+      - reg
+      - qcom,qrtr-node
+
+required:
+  - compatible
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/soc/qcom,memshare.h>
+
+    reserved-memory {
+
+      #address-cells = <2>;
+      #size-cells = <2>;
+
+      gps_mem: gps@93c00000 {
+        reg = <0x0 0x93c00000 0x0 0x200000>;
+        no-map;
+      };
+    };
+
+    memshare {
+      compatible = "qcom,memshare";
+      qcom,legacy-client = <&memshare_gps>;
+
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      mpss@0 {
+        reg = <MEMSHARE_PROC_MPSS_V01>;
+        qcom,qrtr-node = <0>;
+
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        memshare_gps: gps@0 {
+          reg = <0>;
+          memory-region = <&gps_mem>;
+        };
+      };
+    };
+
+...
diff --git a/MAINTAINERS b/MAINTAINERS
index b878ddc99f94..c039f02971a4 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -10172,6 +10172,13 @@ S:	Maintained
 F:	Documentation/devicetree/bindings/input/touchscreen/himax,hx83112b.yaml
 F:	drivers/input/touchscreen/himax_hx83112b.c
 
+HIMAX HX852X TOUCHSCREEN DRIVER
+M:	Stephan Gerhold <stephan@gerhold.net>
+L:	linux-input@vger.kernel.org
+S:	Maintained
+F:	Documentation/devicetree/bindings/input/touchscreen/himax,hx852es.yaml
+F:	drivers/input/touchscreen/himax_hx852x.c
+
 HIPPI
 M:	Jes Sorensen <jes@trained-monkey.org>
 L:	linux-hippi@sunsite.dk
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 202397be76d8..f41ce8bdda16 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -11,6 +11,7 @@ config ARM
 	select ARCH_HAS_DEBUG_VIRTUAL if MMU
 	select ARCH_HAS_DMA_ALLOC if MMU
 	select ARCH_HAS_DMA_OPS
+	select ARCH_HAS_DMA_PREP_COHERENT if IOMMU_DMA
 	select ARCH_HAS_DMA_WRITE_COMBINE if !ARM_DMA_MEM_BUFFERABLE
 	select ARCH_HAS_ELF_RANDOMIZE
 	select ARCH_HAS_FORTIFY_SOURCE
diff --git a/arch/arm/boot/dts/qcom/Makefile b/arch/arm/boot/dts/qcom/Makefile
index f06c6d425e91..eac9a0dc36bd 100644
--- a/arch/arm/boot/dts/qcom/Makefile
+++ b/arch/arm/boot/dts/qcom/Makefile
@@ -31,9 +31,18 @@ dtb-$(CONFIG_ARCH_QCOM) += \
 	qcom-msm8226-samsung-ms013g.dtb \
 	qcom-msm8226-samsung-s3ve3g.dtb \
 	qcom-msm8660-surf.dtb \
+	qcom-msm8905-nokia-argon.dtb \
+	qcom-msm8909-acer-t01.dtb \
+	qcom-msm8909-fareastone-smart506.dtb \
+	qcom-msm8909-lenovo-lxf-p5100.dtb \
+	qcom-msm8909-nokia-leo.dtb \
+	qcom-msm8909-nokia-sparkler.dtb \
+	qcom-msm8909-zte-sapphire.dtb \
 	qcom-msm8916-samsung-e5.dtb \
 	qcom-msm8916-samsung-e7.dtb \
+	qcom-msm8916-samsung-fortunaltezt.dtb \
 	qcom-msm8916-samsung-grandmax.dtb \
+	qcom-msm8916-samsung-heatqlte.dtb \
 	qcom-msm8916-samsung-serranove.dtb \
 	qcom-msm8926-htc-memul.dtb \
 	qcom-msm8926-microsoft-superman-lte.dtb \
diff --git a/arch/arm/boot/dts/qcom/qcom-msm8905-nokia-argon.dts b/arch/arm/boot/dts/qcom/qcom-msm8905-nokia-argon.dts
new file mode 100644
index 000000000000..724c5be8c5b0
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/qcom-msm8905-nokia-argon.dts
@@ -0,0 +1,396 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/dts-v1/;
+#include "qcom-msm8909-pm8909.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/qcom,pmic-gpio.h>
+#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>
+
+/ {
+	model = "Nokia 8110 4G";
+	compatible = "nokia,argon", "qcom,msm8905", "qcom,msm8909";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp_uart1;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		/delete-node/ rmtfs@87c00000;
+		/* On downstream, this address is set by the bootloader */
+		rmtfs@9f700000 {
+			compatible = "qcom,rmtfs-mem";
+			reg = <0x9f700000 0x300000>;
+			no-map;
+
+			qcom,client-id = <1>;
+		};
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pm8909_pwm 0 100000>;
+
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		num-interpolated-steps = <2>;
+		default-brightness-level = <10>;
+	};
+
+	bat: battery {
+		compatible = "simple-battery";
+		voltage-min-design-microvolt = <3400000>;
+		voltage-max-design-microvolt = <4400000>;
+		energy-full-design-microwatt-hours = <5850000>;
+		charge-full-design-microamp-hours = <1500000>;
+
+		ocv-capacity-celsius = <25>;
+		ocv-capacity-table-0 = <4380000 100>, <4292000 95>,
+			<4234000 90>, <4190000 85>, <4158000 80>, <4125000 75>,
+			<4090000 70>, <4040000 65>, <3988000 60>, <3950000 55>,
+			<3925000 50>, <3880000 45>, <3840000 40>, <3800000 35>,
+			<3784000 30>, <3761000 25>, <3743000 20>, <3722000 16>,
+			<3702000 13>, <3690000 11>, <3688000 10>, <3687000 9>,
+			<3685000 8>, <3683000 7>, <3677000 6>, <3656000 5>,
+			<3612000 4>, <3554000 3>, <3462000 2>, <3322000 1>,
+			<3000000 0>;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		pinctrl-0 = <&gpio_key_active &lid_switch_active>;
+		pinctrl-names = "default";
+
+		key-up {
+			wakeup-source;
+			gpios = <&tlmm 90 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_UP>;
+			debounce-interval = <15>;
+			linux,can-disable;
+		};
+
+		key-back {
+			wakeup-source;
+			gpios = <&tlmm 98 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_BACKSPACE>;
+			debounce-interval = <15>;
+			linux,can-disable;
+		};
+
+		switch-lid-close {
+			wakeup-source;
+			gpios = <&tlmm 92 GPIO_ACTIVE_LOW>;
+			linux,input-type = <EV_SW>;
+			linux,code = <SW_LID>;
+		};
+
+		switch-lid-open {
+			gpios = <&tlmm 36 GPIO_ACTIVE_LOW>;
+			linux,input-type = <EV_SW>;
+			linux,code = <SW_KEYPAD_SLIDE>;
+		};
+	};
+
+	matrix_keypad: keypad {
+		compatible = "gpio-matrix-keypad";
+
+		col-scan-delay-ms = <7>;
+		debounce-delay-ms = <10>;
+		gpio-activelow;
+		pinctrl-0 = <&matrix_keypad_row_default &matrix_keypad_col_default>;
+		pinctrl-names = "default";
+
+		row-gpios = <&tlmm 97 GPIO_ACTIVE_LOW
+			&tlmm 96 GPIO_ACTIVE_LOW
+			&tlmm 95 GPIO_ACTIVE_LOW
+			&tlmm 94 GPIO_ACTIVE_LOW>;
+
+		col-gpios = <&tlmm 52 GPIO_ACTIVE_LOW
+			&tlmm 56 GPIO_ACTIVE_LOW
+			&tlmm 7 GPIO_ACTIVE_LOW
+			&tlmm 99 GPIO_ACTIVE_LOW
+			&tlmm 6 GPIO_ACTIVE_LOW>;
+
+		linux,keymap = <
+			MATRIX_KEY(0, 0, KEY_PICKUP_PHONE)
+			MATRIX_KEY(0, 1, KEY_1)
+			MATRIX_KEY(0, 2, KEY_4)
+			MATRIX_KEY(0, 3, KEY_7)
+			MATRIX_KEY(0, 4, KEY_NUMERIC_STAR)
+
+			MATRIX_KEY(1, 0, KEY_LEFT)
+			MATRIX_KEY(1, 1, KEY_2)
+			MATRIX_KEY(1, 2, KEY_5)
+			MATRIX_KEY(1, 3, KEY_8)
+			MATRIX_KEY(1, 4, KEY_0)
+
+			MATRIX_KEY(2, 0, KEY_KBD_LCD_MENU1)
+			MATRIX_KEY(2, 1, KEY_3)
+			MATRIX_KEY(2, 2, KEY_6)
+			MATRIX_KEY(2, 3, KEY_9)
+			MATRIX_KEY(2, 4, KEY_NUMERIC_POUND)
+
+			MATRIX_KEY(3, 0, KEY_ENTER)
+			MATRIX_KEY(3, 1, KEY_RIGHT)
+			MATRIX_KEY(3, 2, KEY_KBD_LCD_MENU2)
+		>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		pinctrl-0 = <&keypad_backlight_default>;
+		pinctrl-names = "default";
+
+		led-0 {
+			function = LED_FUNCTION_KBD_BACKLIGHT;
+			color = <LED_COLOR_ID_WHITE>;
+			gpios = <&pm8909_gpios 1 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&blsp_spi5 {
+	status = "okay";
+
+	display@0 {
+		compatible = "nokia,argon-gc9305-v2-panel", "panel-mipi-dbi-spi";
+		reg = <0>;
+		backlight = <&backlight>;
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_HIGH>;
+		dc-gpios = <&tlmm 110 GPIO_ACTIVE_HIGH>;
+		spi-max-frequency = <50000000>;
+		power-supply = <&pm8909_l17>;
+		io-supply = <&pm8909_l6>;
+		width-mm = <36>;
+		height-mm = <48>;
+
+		pinctrl-0 = <&panel_gpios_default>;
+		pinctrl-names = "default";
+
+		panel-timing {
+			hactive = <240>;
+			vactive = <320>;
+			hback-porch = <0>;
+			vback-porch = <0>;
+			hfront-porch = <0>;
+			vfront-porch = <0>;
+			hsync-len = <0>;
+			vsync-len = <0>;
+			clock-frequency = <(240 * 320 * 30)>; /* 30 fps */
+		};
+	};
+};
+
+&blsp_uart1 {
+	status = "okay";
+};
+
+&mpss {
+	status = "okay";
+};
+
+&pm8909_bms {
+	monitored-battery = <&bat>;
+	power-supplies = <&pm8909_charger>;
+	status = "okay";
+};
+
+&pm8909_charger {
+	qcom,fast-charge-safe-current = <360000>;
+	qcom,fast-charge-safe-voltage = <4350000>;
+
+	monitored-battery = <&bat>;
+
+	status = "okay";
+};
+
+&pm8909_pwm {
+	pinctrl-0 = <&pwm_out>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&pm8909_resin {
+	linux,code = <KEY_DOWN>;
+	status = "okay";
+};
+
+&pm8909_vib {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+};
+
+&sdhc_2 {
+	non-removable;
+	status = "okay";
+};
+
+&usb {
+	extcon = <&pm8909_charger>;
+	status = "okay";
+};
+
+&usb_hs_phy {
+	extcon = <&pm8909_charger>;
+};
+
+&wcnss {
+	status = "okay";
+};
+
+&wcnss_iris {
+	compatible = "qcom,wcn3620";
+};
+
+&smd_rpm_regulators {
+	s2 {
+		regulator-min-microvolt = <1850000>;
+		regulator-max-microvolt = <1850000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1000000>;
+		regulator-max-microvolt = <1000000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-system-load = <200000>;
+		regulator-allow-set-load;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3000000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3000000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&pm8909_gpios {
+	keypad_backlight_default: keypad-backlight-default-state {
+		pins = "gpio1";
+		function = PMIC_GPIO_FUNC_NORMAL;
+		output-low;
+		power-source = <PM8916_GPIO_L5>;
+	};
+};
+
+&pm8909_mpps {
+	pwm_out: mpp2-state {
+		pins = "mpp2";
+		function = "digital";
+		power-source = <PM8916_MPP_VPH>;
+		output-low;
+		qcom,dtest = <1>;
+	};
+};
+
+&tlmm {
+	gpio_key_active: gpio-key-active-state {
+		pins = "gpio90", "gpio98";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	lid_switch_active: lid-switch-active-state {
+		pins = "gpio36", "gpio92";
+		function = "gpio";
+		drive-strength = <6>;
+		bias-pull-up;
+	};
+
+	matrix_keypad_row_default: matrix-keypad-row-gpio-state {
+		pins = "gpio94", "gpio95", "gpio96", "gpio97";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	matrix_keypad_col_default: matrix-keypad-col-default-state {
+		pins = "gpio52", "gpio56", "gpio7", "gpio99", "gpio6";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	panel_gpios_default: panel-gpios-default-state {
+		pins = "gpio24", "gpio25", "gpio110";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+};
diff --git a/arch/arm/boot/dts/qcom/qcom-msm8909-acer-t01.dts b/arch/arm/boot/dts/qcom/qcom-msm8909-acer-t01.dts
new file mode 100644
index 000000000000..4ceadaf37d1c
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/qcom-msm8909-acer-t01.dts
@@ -0,0 +1,378 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "qcom-msm8909-pm8909.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>
+
+/ {
+	model = "Acer Liquid Z330";
+	compatible = "acer,t01", "qcom,msm8909";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp_uart1;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+
+		framebuffer@83200000 {
+			compatible = "simple-framebuffer";
+			reg = <0x83200000 (480 * 854 * 3)>;
+
+			width = <480>;
+			height = <854>;
+			stride = <(480 * 3)>;
+			format = "r8g8b8";
+
+			power-domains = <&gcc MDSS_GDSC>;
+
+			clocks = <&gcc GCC_MDSS_AHB_CLK>,
+				 <&gcc GCC_MDSS_AXI_CLK>,
+				 <&gcc GCC_MDSS_VSYNC_CLK>,
+				 <&gcc GCC_MDSS_MDP_CLK>,
+				 <&gcc GCC_MDSS_BYTE0_CLK>,
+				 <&gcc GCC_MDSS_PCLK0_CLK>,
+				 <&gcc GCC_MDSS_ESC0_CLK>;
+		};
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pm8909_pwm 0 100000>;
+
+		brightness-levels = <0 255>;
+		num-interpolated-steps = <255>;
+		default-brightness-level = <255>;
+	};
+
+	bat: battery {
+		compatible = "simple-battery";
+		voltage-min-design-microvolt = <3400000>;
+		voltage-max-design-microvolt = <4350000>;
+		energy-full-design-microwatt-hours = <7600000>;
+		charge-full-design-microamp-hours = <2000000>;
+
+		ocv-capacity-celsius = <25>;
+		ocv-capacity-table-0 = <4335000 100>, <4265000 95>,
+			<4207000 90>, <4152000 85>, <4101000 80>, <4051000 75>,
+			<3995000 70>, <3958000 65>, <3921000 60>, <3874000 55>,
+			<3838000 50>, <3815000 45>, <3797000 40>, <3783000 35>,
+			<3772000 30>, <3763000 25>, <3744000 20>, <3718000 16>,
+			<3692000 13>, <3689000 11>, <3688000 10>, <3687000 9>,
+			<3685000 8>, <3683000 7>, <3679000 6>, <3663000 5>,
+			<3620000 4>, <3555000 3>, <3461000 2>, <3312000 1>,
+			<3000000 0>;
+	};
+
+	flash-led-controller {
+		compatible = "sgmicro,sgm3140";
+		enable-gpios = <&tlmm 17 GPIO_ACTIVE_HIGH>;
+		flash-gpios = <&tlmm 16 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-0 = <&camera_flash_default>;
+		pinctrl-names = "default";
+
+		flash_led: led {
+			function = LED_FUNCTION_FLASH;
+			color = <LED_COLOR_ID_WHITE>;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-0 = <&gpio_keys_default>;
+		pinctrl-names = "default";
+
+		label = "GPIO Buttons";
+
+		button-volume-up {
+			label = "Volume Up";
+			gpios = <&tlmm 90 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+	};
+};
+
+&blsp_i2c1 {
+	status = "okay";
+
+	accelerometer@18 {
+		compatible = "bosch,bma222";
+		reg = <0x18>;
+
+		vddio-supply = <&pm8909_l6>;
+		vdd-supply = <&pm8909_l17>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <96 IRQ_TYPE_EDGE_RISING>,
+			     <65 IRQ_TYPE_EDGE_RISING>;
+		interrupt-names = "INT1", "INT2";
+
+		pinctrl-0 = <&accel_int_default>;
+		pinctrl-names = "default";
+
+		mount-matrix = "0", "1", "0",
+			       "-1", "0", "0",
+			       "0", "0", "-1";
+	};
+
+	led-controller@45 {
+		compatible = "awinic,aw2013";
+		reg = <0x45>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		vcc-supply = <&pm8909_l17>;
+		vio-supply = <&pm8909_l6>;
+
+		led@0 {
+			reg = <0>;
+			led-max-microamp = <15000>;
+			function = LED_FUNCTION_INDICATOR;
+			color = <LED_COLOR_ID_GREEN>;
+		};
+
+		led@1 {
+			reg = <1>;
+			led-max-microamp = <15000>;
+			function = LED_FUNCTION_INDICATOR;
+			color = <LED_COLOR_ID_RED>;
+		};
+
+		led@2 {
+			reg = <2>;
+			led-max-microamp = <15000>;
+			function = LED_FUNCTION_INDICATOR;
+			color = <LED_COLOR_ID_BLUE>;
+		};
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@26 {
+		compatible = "mstar,msg2138";
+		reg = <0x26>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+
+		reset-gpios = <&tlmm 12 GPIO_ACTIVE_LOW>;
+
+		vdd-supply = <&pm8909_l17>;
+		vddio-supply = <&pm8909_l6>;
+
+		touchscreen-size-x = <480>;
+		touchscreen-size-y = <854>;
+
+		pinctrl-0 = <&touchscreen_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_uart1 {
+	status = "okay";
+};
+
+&pm8909_bms {
+	monitored-battery = <&bat>;
+	power-supplies = <&pm8909_charger>;
+	status = "okay";
+};
+
+&pm8909_charger {
+	qcom,fast-charge-safe-current = <630000>;
+	qcom,fast-charge-safe-voltage = <4300000>;
+
+	monitored-battery = <&bat>;
+
+	status = "okay";
+};
+
+&pm8909_pwm {
+	pinctrl-0 = <&pwm_out>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&pm8909_resin {
+	linux,code = <KEY_VOLUMEDOWN>;
+	status = "okay";
+};
+
+&pm8909_vib {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+};
+
+&sdhc_2 {
+	non-removable;
+	status = "okay";
+};
+
+&usb {
+	extcon = <&pm8909_charger>;
+	status = "okay";
+};
+
+&usb_hs_phy {
+	extcon = <&pm8909_charger>;
+};
+
+&wcnss {
+	status = "okay";
+};
+
+&wcnss_iris {
+	compatible = "qcom,wcn3620";
+};
+
+&smd_rpm_regulators {
+	s2 {
+		regulator-min-microvolt = <1850000>;
+		regulator-max-microvolt = <1850000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1000000>;
+		regulator-max-microvolt = <1000000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-system-load = <200000>;
+		regulator-allow-set-load;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3000000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3000000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&pm8909_mpps {
+	pwm_out: mpp2-state {
+		pins = "mpp2";
+		function = "digital";
+		power-source = <PM8916_MPP_VPH>;
+		output-low;
+		qcom,dtest = <1>;
+	};
+};
+
+&tlmm {
+	accel_int_default: accel-int-default-state {
+		pins = "gpio65", "gpio96";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	camera_flash_default: camera-flash-default-state {
+		pins = "gpio16", "gpio17";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_keys_default: gpio-keys-default-state {
+		pins = "gpio90";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	touchscreen_default: touchscreen-default-state {
+		reset-pins {
+			pins = "gpio12";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-disable;
+		};
+
+		touchscreen-pins {
+			pins = "gpio13";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-pull-up;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/qcom/qcom-msm8909-fareastone-smart506.dts b/arch/arm/boot/dts/qcom/qcom-msm8909-fareastone-smart506.dts
new file mode 100644
index 000000000000..994b891126b4
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/qcom-msm8909-fareastone-smart506.dts
@@ -0,0 +1,342 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "qcom-msm8909-pm8909.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>
+
+/ {
+	model = "Fareastone Smart 506";
+	compatible = "fareastone,smart506", "qcom,msm8909";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp_uart1;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pm8909_pwm 0 100000>;
+
+		brightness-levels = <0 255>;
+		num-interpolated-steps = <255>;
+		default-brightness-level = <255>;
+	};
+
+	battery: battery {
+		compatible = "simple-battery";
+		voltage-min-design-microvolt = <3400000>;
+		voltage-max-design-microvolt = <4350000>;
+		energy-full-design-microwatt-hours = <7600000>;
+		charge-full-design-microamp-hours = <2000000>;
+
+		ocv-capacity-celsius = <25>;
+		ocv-capacity-table-0 = <4368000 100>, <4301000 95>,
+			<4242000 90>, <4184000 85>, <4128000 80>, <4075000 75>,
+			<4026000 70>, <3978000 65>, <3932000 60>, <3882000 55>,
+			<3848000 50>, <3823000 45>, <3803000 40>, <3786000 35>,
+			<3772000 30>, <3758000 25>, <3739000 20>, <3716000 16>,
+			<3692000 13>, <3688000 11>, <3686000 10>, <3686000 9>,
+			<3684000 8>, <3682000 7>, <3676000 6>, <3656000 5>,
+			<3612000 4>, <3552000 3>, <3469000 2>, <3331000 1>,
+			<3000000 0>;
+	};
+
+	flash-led-controller {
+		/* Actually leedcon,sl610w1d */
+		compatible = "sgmicro,sgm3140";
+		enable-gpios = <&tlmm 31 GPIO_ACTIVE_HIGH>;
+		flash-gpios = <&tlmm 32 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-0 = <&camera_flash_default>;
+		pinctrl-names = "default";
+
+		flash_led: led {
+			function = LED_FUNCTION_FLASH;
+			color = <LED_COLOR_ID_WHITE>;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-0 = <&gpio_keys_default>;
+		pinctrl-names = "default";
+
+		label = "GPIO Buttons";
+
+		button-volume-up {
+			label = "Volume Up";
+			gpios = <&tlmm 90 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		led-keypad-backlight {
+			function = LED_FUNCTION_KBD_BACKLIGHT;
+			color = <LED_COLOR_ID_WHITE>;
+			gpios = <&tlmm 98 GPIO_ACTIVE_HIGH>;
+
+			pinctrl-0 = <&gpio_leds_default>;
+			pinctrl-names = "default";
+		};
+	};
+};
+
+&blsp_i2c1 {
+	status = "okay";
+
+	accelerometer@18 {
+		compatible = "bosch,bma222";
+		reg = <0x18>;
+
+		vddio-supply = <&pm8909_l6>;
+		vdd-supply = <&pm8909_l17>;
+
+		interrupts-extended = <&tlmm 96 IRQ_TYPE_EDGE_RISING>,
+				      <&tlmm 65 IRQ_TYPE_EDGE_RISING>;
+		interrupt-names = "INT1", "INT2";
+
+		pinctrl-0 = <&accel_int_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@5d {
+		compatible = "goodix,gt911";
+		reg = <0x5d>;
+
+		interrupts-extended = <&tlmm 13 IRQ_TYPE_EDGE_RISING>;
+
+		reset-gpios = <&tlmm 12 GPIO_ACTIVE_LOW>;
+
+		AVDD28-supply = <&pm8909_l17>;
+		VDDIO-supply = <&pm8909_l6>;
+
+		touchscreen-size-x = <720>;
+		touchscreen-size-y = <1280>;
+
+		pinctrl-0 = <&touchscreen_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_uart1 {
+	status = "okay";
+};
+
+&pm8909_bms {
+	monitored-battery = <&battery>;
+	power-supplies = <&pm8909_charger>;
+	status = "okay";
+};
+
+&pm8909_charger {
+	qcom,vdd-safe = <4400000>;
+	qcom,ibat-safe = <360000>;
+
+	monitored-battery = <&battery>;
+
+	status = "okay";
+};
+
+&pm8909_pwm {
+	pinctrl-0 = <&pwm_out>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&pm8909_resin {
+	linux,code = <KEY_VOLUMEDOWN>;
+	status = "okay";
+};
+
+&pm8909_vib {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+};
+
+&sdhc_2 {
+	non-removable;
+	status = "okay";
+};
+
+&usb {
+	extcon = <&pm8909_charger>;
+	status = "okay";
+};
+
+&usb_hs_phy {
+	extcon = <&pm8909_charger>;
+};
+
+&wcnss {
+	status = "okay";
+};
+
+&wcnss_iris {
+	compatible = "qcom,wcn3620";
+};
+
+&smd_rpm_regulators {
+	s2 {
+		regulator-min-microvolt = <1850000>;
+		regulator-max-microvolt = <1850000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1000000>;
+		regulator-max-microvolt = <1000000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3000000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3000000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&pm8909_mpps {
+	pwm_out: mpp2-state {
+		pins = "mpp2";
+		function = "digital";
+		power-source = <PM8916_MPP_VPH>;
+		output-low;
+		qcom,dtest = <1>;
+	};
+};
+
+&tlmm {
+	accel_int_default: accel-int-default-state {
+		pins = "gpio65", "gpio96";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	camera_flash_default: camera-flash-default-state {
+		pins = "gpio31", "gpio32";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_keys_default: gpio-keys-default-state {
+		pins = "gpio90";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	gpio_leds_default: gpio-leds-default-state {
+		pins = "gpio98";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	touchscreen_default: touchscreen-default-state {
+		reset-pins {
+			pins = "gpio12";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-disable;
+		};
+
+		touchscreen-pins {
+			pins = "gpio13";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-pull-up;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/qcom/qcom-msm8909-lenovo-lxf-p5100.dts b/arch/arm/boot/dts/qcom/qcom-msm8909-lenovo-lxf-p5100.dts
new file mode 100644
index 000000000000..328ec2772629
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/qcom-msm8909-lenovo-lxf-p5100.dts
@@ -0,0 +1,380 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "qcom-msm8909-pm8909.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>
+
+/ {
+	model = "Lenovo Yoga Tab 3 10 LTE";
+	compatible = "lenovo,lxf-p5100", "qcom,msm8909";
+	chassis-type = "tablet";
+
+	aliases {
+		serial0 = &blsp_uart1;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		stdout-path = "serial0";
+
+		framebuffer@83200000 {
+			compatible = "simple-framebuffer";
+			reg = <0x83200000 (800 * 1280 * 3)>;
+
+			width = <800>;
+			height = <1280>;
+			stride = <(1280 * 3)>;
+			format = "r8g8b8";
+
+			power-domains = <&gcc MDSS_GDSC>;
+
+			clocks = <&gcc GCC_MDSS_AHB_CLK>,
+				 <&gcc GCC_MDSS_AXI_CLK>,
+				 <&gcc GCC_MDSS_VSYNC_CLK>,
+				 <&gcc GCC_MDSS_MDP_CLK>,
+				 <&gcc GCC_MDSS_BYTE0_CLK>,
+				 <&gcc GCC_MDSS_PCLK0_CLK>,
+				 <&gcc GCC_MDSS_ESC0_CLK>;
+		};
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pm8909_pwm 0 100000>;
+
+		brightness-levels = <0 255>;
+		num-interpolated-steps = <255>;
+		default-brightness-level = <255>;
+	};
+
+	battery: battery {
+		compatible = "simple-battery";
+		voltage-min-design-microvolt = <3400000>;
+		voltage-max-design-microvolt = <4350000>;
+		energy-full-design-microwatt-hours = <7600000>;
+		charge-full-design-microamp-hours = <2000000>;
+
+		ocv-capacity-celsius = <25>;
+		ocv-capacity-table-0 = <4335000 100>, <4265000 95>,
+			<4207000 90>, <4152000 85>, <4101000 80>, <4051000 75>,
+			<3995000 70>, <3958000 65>, <3921000 60>, <3874000 55>,
+			<3838000 50>, <3815000 45>, <3797000 40>, <3783000 35>,
+			<3772000 30>, <3763000 25>, <3744000 20>, <3718000 16>,
+			<3692000 13>, <3689000 11>, <3688000 10>, <3687000 9>,
+			<3685000 8>, <3683000 7>, <3679000 6>, <3663000 5>,
+			<3620000 4>, <3555000 3>, <3461000 2>, <3312000 1>,
+			<3000000 0>;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-0 = <&gpio_keys_default>;
+		pinctrl-names = "default";
+
+		label = "GPIO Buttons";
+
+		button-volume-up {
+			label = "Volume Up";
+			gpios = <&tlmm 90 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+	};
+
+	gpio-hall-sensor {
+		compatible = "gpio-keys";
+
+		pinctrl-0 = <&gpio_hall_sensor_default>;
+		pinctrl-names = "default";
+
+		label = "GPIO Hall Effect Sensor";
+
+		event-hall-sensor {
+			label = "Hall Effect Sensor";
+			gpios = <&tlmm 36 GPIO_ACTIVE_LOW>;
+			linux,input-type = <EV_SW>;
+			linux,code = <SW_LID>;
+			linux,can-disable;
+		};
+	};
+
+	reg_ts_vdd: regulator-ts {
+		compatible = "regulator-fixed";
+		regulator-name = "reg_ts_vdd";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+
+		gpios = <&tlmm 92 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&ts_vdd_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_i2c1 {
+	status = "okay";
+	/* TODO: add Bochs BMA223 accelerometer/ELAN EPL2102 light sensor here */
+	magnetometer@c {
+		compatible = "asahi-kasei,ak09911";
+		reg = <0x0c>;
+
+		vdd-supply = <&pm8909_l17>;
+		vid-supply = <&pm8909_l6>;
+
+		reset-gpios = <&tlmm 94 GPIO_ACTIVE_LOW>;
+
+		pinctrl-0 = <&magnetometer_default>;
+		pinctrl-names = "default";
+	};
+
+	led-controller@68 {
+		compatible = "si-en,sn3191";
+		reg = <0x68>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		shutdown-gpios = <&tlmm 27 GPIO_ACTIVE_HIGH>;
+
+		led@1 {
+			reg = <1>;
+			function = LED_FUNCTION_INDICATOR;
+			color = <LED_COLOR_ID_WHITE>;
+			led-max-microamp = <5000>;
+		};
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@6c {
+		compatible = "hideep,hideep-ts";
+		reg = <0x6c>;
+
+		interrupts-extended = <&tlmm 13 IRQ_TYPE_EDGE_FALLING>;
+
+		reset-gpios = <&tlmm 12 GPIO_ACTIVE_LOW>;
+
+		vdd-supply = <&reg_ts_vdd>;
+		vid-supply = <&pm8909_l6>;
+
+		touchscreen-size-x = <800>;
+		touchscreen-size-y = <1280>;
+
+		pinctrl-0 = <&touchscreen_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_uart1 {
+	status = "okay";
+};
+
+/* FIXME: Missing the real fuel gauge's node */
+&pm8909_bms {
+	monitored-battery = <&battery>;
+	status = "okay";
+};
+
+&pm8909_mpps {
+	pwm_out: mpp2-state {
+		pins = "mpp2";
+		function = "digital";
+		power-source = <PM8916_MPP_VPH>;
+		output-low;
+		qcom,dtest = <1>;
+	};
+};
+
+&pm8909_pwm {
+	pinctrl-0 = <&pwm_out>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&pm8909_resin {
+	linux,code = <KEY_VOLUMEDOWN>;
+	status = "okay";
+};
+
+/* FIXME: Set up smb358 properly for the usb */
+&pm8909_usbin {
+	status = "okay";
+};
+
+&pm8909_vib {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+};
+
+&sdhc_2 {
+	status = "okay";
+};
+
+&smd_rpm_regulators {
+	s2 {
+		regulator-min-microvolt = <1850000>;
+		regulator-max-microvolt = <1850000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1000000>;
+		regulator-max-microvolt = <1000000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-system-load = <200000>;
+		regulator-allow-set-load;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3000000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3000000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&usb {
+	dr_mode = "peripheral";
+	extcon = <&pm8909_usbin>;
+	status = "okay";
+};
+
+&usb_hs_phy {
+	extcon = <&pm8909_usbin>;
+	status = "okay";
+};
+
+&wcnss {
+	status = "okay";
+};
+
+&wcnss_iris {
+	compatible = "qcom,wcn3620";
+};
+
+&tlmm {
+	gpio_keys_default: gpio-keys-default-state {
+		pins = "gpio90";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	gpio_hall_sensor_default: gpio-hall-sensor-default-state {
+		pins = "gpio36";
+		function = "gpio";
+		drive-strength = <10>;
+		bias-disable;
+	};
+
+	magnetometer_default: magnetometer-default-state {
+		pins = "gpio94";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	touchscreen_default: touchscreen-default-state {
+		reset-pins {
+			pins = "gpio12";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-disable;
+		};
+
+		touchscreen-pins {
+			pins = "gpio13";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-pull-up;
+		};
+	};
+
+	ts_vdd_default: ts_vdd_default-state {
+		vdd-pins {
+			pins = "gpio92";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-disable;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/qcom/qcom-msm8909-nokia-leo-common.dtsi b/arch/arm/boot/dts/qcom/qcom-msm8909-nokia-leo-common.dtsi
new file mode 100644
index 000000000000..709f4813d413
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/qcom-msm8909-nokia-leo-common.dtsi
@@ -0,0 +1,354 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#include "qcom-msm8909-pm8909.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/qcom,pmic-gpio.h>
+#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>
+
+/ {
+	aliases {
+		serial0 = &blsp_uart1;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		/delete-node/ rmtfs@87c00000;
+		/delete-node/ mpss@88000000;
+		/delete-node/ wcnss@8d500000;
+		reserved@84a00000 {
+			reg = <0x84a00000 0x400000>;
+			no-map;
+		};
+		mpss_mem: mpss@88000000 {
+			reg = <0x88000000 0x05000000>;
+			no-map;
+		};
+		wcnss_mem: wcnss@8d000000 {
+			reg = <0x8d000000 0x700000>;
+			no-map;
+		};
+		/* On downstream, this address is set by the bootloader */
+		rmtfs@9e900000 {
+			compatible = "qcom,rmtfs-mem";
+			reg = <0x9e900000 0x300000>;
+			no-map;
+
+			qcom,client-id = <1>;
+		};
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pm8909_pwm 0 100000>;
+
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		num-interpolated-steps = <2>;
+		default-brightness-level = <10>;
+	};
+
+	bat: battery {
+		compatible = "simple-battery";
+		voltage-min-design-microvolt = <3400000>;
+		voltage-max-design-microvolt = <4200000>;
+		energy-full-design-microwatt-hours = <5700000>;
+		charge-full-design-microamp-hours = <1500000>;
+
+		ocv-capacity-celsius = <25>;
+		ocv-capacity-table-0 = <4186000 100>, <4122000 95>,
+			<4078000 90>, <4033000 85>, <3982000 80>, <3958000 75>,
+			<3928000 70>, <3899000 65>, <3866000 60>, <3831000 55>,
+			<3808000 50>, <3793000 45>, <3782000 40>, <3775000 35>,
+			<3769000 30>, <3758000 25>, <3740000 20>, <3718000 16>,
+			<3696000 13>, <3689000 11>, <3688000 10>, <3687000 9>,
+			<3685000 8>, <3682000 7>, <3672000 6>, <3643000 5>,
+			<3596000 4>, <3532000 3>, <3448000 2>, <3315000 1>,
+			<3000000 0>;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		pinctrl-0 = <&gpio_key_active>;
+		pinctrl-names = "default";
+
+		key-star {
+			wakeup-source;
+			gpios = <&tlmm 90 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_NUMERIC_STAR>;
+			debounce-interval = <15>;
+			linux,can-disable;
+		};
+	};
+
+	matrix_keypad: keypad {
+		status = "disabled";
+		compatible = "gpio-matrix-keypad";
+
+		col-scan-delay-us = <7>;
+		debounce-delay-ms = <10>;
+		gpio-activelow;
+		pinctrl-0 = <&matrix_keypad_row_default &matrix_keypad_col_default>;
+		pinctrl-names = "default";
+
+		row-gpios = <&tlmm 97 GPIO_ACTIVE_LOW
+			&tlmm 96 GPIO_ACTIVE_LOW
+			&tlmm 95 GPIO_ACTIVE_LOW
+			&tlmm 94 GPIO_ACTIVE_LOW>;
+
+		col-gpios = <&tlmm 0 GPIO_ACTIVE_LOW
+			&tlmm 3 GPIO_ACTIVE_LOW
+			&tlmm 7 GPIO_ACTIVE_LOW
+			&tlmm 99 GPIO_ACTIVE_LOW
+			&tlmm 6 GPIO_ACTIVE_LOW
+			&tlmm 1 GPIO_ACTIVE_LOW>;
+
+		/* Specify linux,keypad in device dts */
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		pinctrl-0 = <&keypad_backlight_default>;
+		pinctrl-names = "default";
+
+		led-0 {
+			function = LED_FUNCTION_KBD_BACKLIGHT;
+			color = <LED_COLOR_ID_WHITE>;
+			gpios = <&pm8909_gpios 1 GPIO_ACTIVE_HIGH>;
+		};
+	};
+};
+
+&blsp_spi5 {
+	status = "okay";
+
+	panel: display@0 {
+		/* Specify panel compatible and physical size in device dts */
+		compatible = "panel-mipi-dbi-spi";
+		reg = <0>;
+		backlight = <&backlight>;
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_HIGH>;
+		dc-gpios = <&tlmm 110 GPIO_ACTIVE_HIGH>;
+		spi-max-frequency = <50000000>;
+		power-supply = <&pm8909_l17>;
+		io-supply = <&pm8909_l6>;
+
+		pinctrl-0 = <&panel_gpios_default>;
+		pinctrl-names = "default";
+
+		status = "disabled";
+
+		panel-timing {
+			hactive = <240>;
+			vactive = <320>;
+			hback-porch = <0>;
+			vback-porch = <0>;
+			hfront-porch = <0>;
+			vfront-porch = <0>;
+			hsync-len = <0>;
+			vsync-len = <0>;
+			clock-frequency = <(240 * 320 * 30)>; /* 30 fps */
+		};
+	};
+};
+
+&blsp_uart1 {
+	status = "okay";
+};
+
+&mpss {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+};
+
+&sdhc_2 {
+	non-removable;
+	status = "okay";
+};
+
+&pm8909_bms {
+	monitored-battery = <&bat>;
+	power-supplies = <&pm8909_charger>;
+	status = "okay";
+};
+
+&pm8909_charger {
+	qcom,fast-charge-safe-current = <270000>;
+	qcom,fast-charge-safe-voltage = <4150000>;
+
+	monitored-battery = <&bat>;
+
+	status = "okay";
+};
+
+&pm8909_pwm {
+	pinctrl-0 = <&pwm_out>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&pm8909_resin {
+	linux,code = <KEY_NUMERIC_POUND>;
+	status = "okay";
+};
+
+&usb {
+	extcon = <&pm8909_charger>;
+	status = "okay";
+};
+
+&usb_hs_phy {
+	extcon = <&pm8909_charger>;
+};
+
+&wcnss {
+	status = "okay";
+};
+
+&wcnss_iris {
+	compatible = "qcom,wcn3620";
+};
+
+&smd_rpm_regulators {
+	s2 {
+		regulator-min-microvolt = <1850000>;
+		regulator-max-microvolt = <1850000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1000000>;
+		regulator-max-microvolt = <1000000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-allow-set-load;
+		regulator-system-load = <200000>;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3000000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3000000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&pm8909_gpios {
+	keypad_backlight_default: keypad-backlight-default-state {
+		pins = "gpio1";
+		function = PMIC_GPIO_FUNC_NORMAL;
+		power-source = <PM8916_GPIO_L2>;
+		output-low;
+	};
+};
+
+&pm8909_mpps {
+	pwm_out: mpp2-state {
+		pins = "mpp2";
+		function = "digital";
+		power-source = <PM8916_MPP_VPH>;
+		output-low;
+		qcom,dtest = <1>;
+	};
+};
+
+&tlmm {
+	gpio_key_active: gpio-key-active-state {
+		pins = "gpio90";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	matrix_keypad_row_default: matrix-keypad-row-default-state {
+		pins = "gpio94", "gpio95", "gpio96", "gpio97";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	matrix_keypad_col_default: matrix-keypad-col-default-state {
+		pins = "gpio0", "gpio3", "gpio7", "gpio99", "gpio6", "gpio1";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	panel_gpios_default: panel-gpios-default-state {
+		pins = "gpio24", "gpio25", "gpio110";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+};
diff --git a/arch/arm/boot/dts/qcom/qcom-msm8909-nokia-leo.dts b/arch/arm/boot/dts/qcom/qcom-msm8909-nokia-leo.dts
new file mode 100644
index 000000000000..e8fa1bccb694
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/qcom-msm8909-nokia-leo.dts
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/dts-v1/;
+#include "qcom-msm8909-nokia-leo-common.dtsi"
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "Nokia 6300 4G";
+	compatible = "nokia,leo", "qcom,msm8909";
+	chassis-type = "handset";
+};
+
+&matrix_keypad {
+	linux,keymap = <
+		MATRIX_KEY(0, 0, KEY_KBD_LCD_MENU1)
+		MATRIX_KEY(0, 1, KEY_1)
+		MATRIX_KEY(0, 2, KEY_4)
+		MATRIX_KEY(0, 3, KEY_7)
+		MATRIX_KEY(0, 4, KEY_NUMERIC_STAR)
+		MATRIX_KEY(0, 5, KEY_PICKUP_PHONE)
+
+		MATRIX_KEY(1, 0, KEY_MENU)
+		MATRIX_KEY(1, 1, KEY_2)
+		MATRIX_KEY(1, 2, KEY_5)
+		MATRIX_KEY(1, 3, KEY_8)
+		MATRIX_KEY(1, 4, KEY_0)
+		MATRIX_KEY(1, 5, KEY_HANGUP_PHONE)
+
+		MATRIX_KEY(2, 0, KEY_LEFT)
+		MATRIX_KEY(2, 1, KEY_3)
+		MATRIX_KEY(2, 2, KEY_6)
+		MATRIX_KEY(2, 3, KEY_9)
+		MATRIX_KEY(2, 4, KEY_NUMERIC_POUND)
+		MATRIX_KEY(2, 5, KEY_KBD_LCD_MENU2)
+
+		MATRIX_KEY(3, 0, KEY_DOWN)
+		MATRIX_KEY(3, 1, KEY_BACKSPACE)
+		MATRIX_KEY(3, 2, KEY_RIGHT)
+		MATRIX_KEY(3, 3, KEY_ENTER)
+		MATRIX_KEY(3, 4, KEY_UP)
+	>;
+	status = "okay";
+};
+
+&panel {
+	compatible = "nokia,leo-gc9305-hlt-24-panel", "panel-mipi-dbi-spi";
+	width-mm = <36>;
+	height-mm = <48>;
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/qcom/qcom-msm8909-nokia-sparkler.dts b/arch/arm/boot/dts/qcom/qcom-msm8909-nokia-sparkler.dts
new file mode 100644
index 000000000000..21e052a4ed22
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/qcom-msm8909-nokia-sparkler.dts
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/dts-v1/;
+#include "qcom-msm8909-nokia-leo-common.dtsi"
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "Nokia 8000 4G";
+	compatible = "nokia,sparkler", "qcom,msm8909";
+	chassis-type = "handset";
+};
+
+&matrix_keypad {
+	linux,keymap = <
+		MATRIX_KEY(0, 0, KEY_PICKUP_PHONE)
+		MATRIX_KEY(0, 1, KEY_1)
+		MATRIX_KEY(0, 2, KEY_4)
+		MATRIX_KEY(0, 3, KEY_7)
+		MATRIX_KEY(0, 4, KEY_NUMERIC_STAR)
+		MATRIX_KEY(0, 5, KEY_MENU)
+
+		MATRIX_KEY(1, 0, KEY_KBD_LCD_MENU1)
+		MATRIX_KEY(1, 1, KEY_2)
+		MATRIX_KEY(1, 2, KEY_5)
+		MATRIX_KEY(1, 3, KEY_8)
+		MATRIX_KEY(1, 4, KEY_0)
+		MATRIX_KEY(1, 5, KEY_BACKSPACE)
+
+		MATRIX_KEY(2, 0, KEY_LEFT)
+		MATRIX_KEY(2, 1, KEY_3)
+		MATRIX_KEY(2, 2, KEY_6)
+		MATRIX_KEY(2, 3, KEY_9)
+		MATRIX_KEY(2, 4, KEY_NUMERIC_POUND)
+		MATRIX_KEY(2, 5, KEY_HANGUP_PHONE)
+
+		MATRIX_KEY(3, 0, KEY_ENTER)
+		MATRIX_KEY(3, 1, KEY_KBD_LCD_MENU2)
+		MATRIX_KEY(3, 2, KEY_RIGHT)
+		MATRIX_KEY(3, 3, KEY_UP)
+		MATRIX_KEY(3, 4, KEY_DOWN)
+	>;
+	status = "okay";
+};
+
+&panel {
+	compatible = "nokia,sparkler-gc9307-hlt-28-panel", "panel-mipi-dbi-spi";
+	width-mm = <42>;
+	height-mm = <56>;
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/qcom/qcom-msm8909-pm8909.dtsi b/arch/arm/boot/dts/qcom/qcom-msm8909-pm8909.dtsi
new file mode 100644
index 000000000000..a1829c36be6c
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/qcom-msm8909-pm8909.dtsi
@@ -0,0 +1,62 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include "qcom-msm8909.dtsi"
+#include "qcom-pm8909.dtsi"
+
+&mpss {
+	pll-supply = <&pm8909_l7>;
+};
+
+&sdhc_1 {
+	vmmc-supply = <&pm8909_l8>;
+	vqmmc-supply = <&pm8909_l5>;
+};
+
+&sdhc_2 {
+	vmmc-supply = <&pm8909_l11>;
+	vqmmc-supply = <&pm8909_l12>;
+};
+
+&usb_hs_phy {
+	v1p8-supply = <&pm8909_l7>;
+	v3p3-supply = <&pm8909_l13>;
+};
+
+&wcnss {
+	vddpx-supply = <&pm8909_l7>;
+};
+
+&wcnss_iris {
+	vddxo-supply = <&pm8909_l7>;
+	vddrfa-supply = <&pm8909_l10>;
+	vddpa-supply = <&pm8909_l9>;
+	vdddig-supply = <&pm8909_l5>;
+};
+
+&rpm_requests {
+	smd_rpm_regulators: pm8909-regulators {
+		compatible = "qcom,rpm-pm8909-regulators";
+
+		/* pm8909_s1 is managed by rpmpd (MSM8909_VDDCX) */
+		pm8909_s2: s2 {};
+
+		pm8909_l1: l1 {};
+		pm8909_l2: l2 {};
+		/* pm8909_l3 is managed by rpmpd (MSM8909_VDDMX) */
+		pm8909_l4: l4 {};
+		pm8909_l5: l5 {};
+		pm8909_l6: l6 {};
+		pm8909_l7: l7 {};
+		pm8909_l8: l8 {};
+		pm8909_l9: l9 {};
+		pm8909_l10: l10 {};
+		pm8909_l11: l11 {};
+		pm8909_l12: l12 {};
+		pm8909_l13: l13 {};
+		pm8909_l14: l14 {};
+		pm8909_l15: l15 {};
+		/* pm8909_l16 is missing in PM8909 */
+		pm8909_l17: l17 {};
+		pm8909_l18: l18 {};
+	};
+};
diff --git a/arch/arm/boot/dts/qcom/qcom-msm8909-zte-sapphire.dts b/arch/arm/boot/dts/qcom/qcom-msm8909-zte-sapphire.dts
new file mode 100644
index 000000000000..d0b525730873
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/qcom-msm8909-zte-sapphire.dts
@@ -0,0 +1,223 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "qcom-msm8909-pm8909.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	model = "ZTE N818S";
+	compatible = "zte,sapphire", "qcom,msm8909";
+	chassis-type = "handset";
+
+	aliases {
+		serial0 = &blsp_uart1;
+	};
+
+	chosen {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+		stdout-path = "serial0";
+
+		framebuffer@83200036 {
+			compatible = "simple-framebuffer";
+
+			/*
+			 * The downstream bootloader gives us this unaligned framebuffer.
+			 * We should also have a memory-region here, however memory-regions
+			 * must be page-aligned, and with 0x83200000 the image is distorted
+			 */
+
+			reg = <0x83200036 (480 * 800 * 3)>;
+			width = <480>;
+			height = <800>;
+			stride = <(480 * 3)>;
+			format = "r8g8b8";
+
+			power-domains = <&gcc MDSS_GDSC>;
+
+			clocks = <&gcc GCC_MDSS_AHB_CLK>,
+				 <&gcc GCC_MDSS_AXI_CLK>,
+				 <&gcc GCC_MDSS_VSYNC_CLK>,
+				 <&gcc GCC_MDSS_MDP_CLK>,
+				 <&gcc GCC_MDSS_BYTE0_CLK>,
+				 <&gcc GCC_MDSS_PCLK0_CLK>,
+				 <&gcc GCC_MDSS_ESC0_CLK>;
+		};
+	};
+
+	reserved-memory {
+		/*
+		 * The reserved memory for the framebuffer should start at 0x83200036
+		 * However this causes a crash, as memory reserves must align to page boundaries.
+		 * Therefore we must align it and add the extra 0x36 to the size.
+		 */
+
+		cont_splash_mem: memory@83200000 {
+			reg = <0x83200000 (0x36 + (480 * 800 * 3))>;
+			no-map;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-0 = <&gpio_keys_default>;
+		pinctrl-names = "default";
+
+		label = "GPIO Buttons";
+
+		button-volume-up {
+			label = "Volume Up";
+			gpios = <&tlmm 90 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+
+		button-volume-down {
+			label = "Volume Down";
+			gpios = <&tlmm 91 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEDOWN>;
+		};
+	};
+};
+
+&blsp_uart1 {
+	status = "okay";
+};
+
+&pm8909_usbin {
+	status = "okay";
+};
+
+&pm8909_vib {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+};
+
+&sdhc_2 {
+	non-removable;
+	status = "okay";
+};
+
+&usb {
+	extcon = <&pm8909_usbin>;
+	dr_mode = "peripheral";
+	status = "okay";
+};
+
+&usb_hs_phy {
+	extcon = <&pm8909_usbin>;
+};
+
+&wcnss {
+	status = "okay";
+};
+
+&wcnss_iris {
+	compatible = "qcom,wcn3620";
+};
+
+&smd_rpm_regulators {
+	s2 {
+		regulator-min-microvolt = <1850000>;
+		regulator-max-microvolt = <1850000>;
+	};
+
+	l1 {
+		regulator-min-microvolt = <1000000>;
+		regulator-max-microvolt = <1000000>;
+	};
+
+	l2 {
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+	};
+
+	l4 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l5 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l6 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l7 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	l8 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2900000>;
+	};
+
+	l9 {
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	l10 {
+		regulator-min-microvolt = <1225000>;
+		regulator-max-microvolt = <1300000>;
+	};
+
+	l11 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+		regulator-system-load = <200000>;
+		regulator-allow-set-load;
+	};
+
+	l12 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <2950000>;
+	};
+
+	l13 {
+		regulator-min-microvolt = <3075000>;
+		regulator-max-microvolt = <3075000>;
+	};
+
+	l14 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3000000>;
+	};
+
+	l15 {
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3000000>;
+	};
+
+	l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	l18 {
+		regulator-min-microvolt = <2700000>;
+		regulator-max-microvolt = <2700000>;
+	};
+};
+
+&tlmm {
+	gpio_keys_default: gpio-keys-default-state {
+		pins = "gpio90", "gpio91";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+};
diff --git a/arch/arm/boot/dts/qcom/qcom-msm8909.dtsi b/arch/arm/boot/dts/qcom/qcom-msm8909.dtsi
new file mode 100644
index 000000000000..afaff1782a49
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/qcom-msm8909.dtsi
@@ -0,0 +1,1575 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2014-2019, The Linux Foundation. All rights reserved.
+ */
+
+#include <dt-bindings/clock/qcom,gcc-msm8909.h>
+#include <dt-bindings/clock/qcom,rpmcc.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/power/qcom-rpmpd.h>
+#include <dt-bindings/thermal/thermal.h>
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	interrupt-parent = <&intc>;
+
+	aliases {
+		mmc0 = &sdhc_1; /* SDC1 eMMC slot */
+		mmc1 = &sdhc_2; /* SDC2 SD card slot */
+	};
+
+	chosen { };
+
+	clocks {
+		xo_board: xo-board {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <19200000>;
+		};
+
+		sleep_clk: sleep-clk {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <32768>;
+		};
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			reg = <0x0>;
+			next-level-cache = <&L2_0>;
+			enable-method = "qcom,msm8909-smp";
+			clocks = <&apcs>;
+			#cooling-cells = <2>;
+			power-domains = <&rpmpd MSM8909_VDDCX_AO>;
+			power-domain-names = "perf";
+			operating-points-v2 = <&cpu_opp_table>;
+			cpu-idle-states = <&CPU_SLEEP_0>;
+			qcom,acc = <&cpu0_acc>;
+			qcom,saw = <&cpu0_saw>;
+		};
+
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			reg = <0x1>;
+			next-level-cache = <&L2_0>;
+			enable-method = "qcom,msm8909-smp";
+			clocks = <&apcs>;
+			#cooling-cells = <2>;
+			power-domains = <&rpmpd MSM8909_VDDCX_AO>;
+			power-domain-names = "perf";
+			operating-points-v2 = <&cpu_opp_table>;
+			cpu-idle-states = <&CPU_SLEEP_0>;
+			qcom,acc = <&cpu1_acc>;
+			qcom,saw = <&cpu1_saw>;
+		};
+
+		cpu2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			reg = <0x2>;
+			next-level-cache = <&L2_0>;
+			enable-method = "qcom,msm8909-smp";
+			clocks = <&apcs>;
+			#cooling-cells = <2>;
+			power-domains = <&rpmpd MSM8909_VDDCX_AO>;
+			power-domain-names = "perf";
+			operating-points-v2 = <&cpu_opp_table>;
+			cpu-idle-states = <&CPU_SLEEP_0>;
+			qcom,acc = <&cpu2_acc>;
+			qcom,saw = <&cpu2_saw>;
+		};
+
+		cpu3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			reg = <0x3>;
+			next-level-cache = <&L2_0>;
+			enable-method = "qcom,msm8909-smp";
+			clocks = <&apcs>;
+			#cooling-cells = <2>;
+			power-domains = <&rpmpd MSM8909_VDDCX_AO>;
+			power-domain-names = "perf";
+			operating-points-v2 = <&cpu_opp_table>;
+			cpu-idle-states = <&CPU_SLEEP_0>;
+			qcom,acc = <&cpu3_acc>;
+			qcom,saw = <&cpu3_saw>;
+		};
+
+		L2_0: l2-cache {
+			compatible = "cache";
+			cache-level = <2>;
+		};
+
+		idle-states {
+			CPU_SLEEP_0: cpu-sleep-0 {
+				compatible = "qcom,idle-state-spc";
+				idle-state-name = "standalone-power-collapse";
+				entry-latency-us = <180>;
+				exit-latency-us = <240>;
+				min-residency-us = <1260>;
+				local-timer-stop;
+			};
+		};
+	};
+
+	cpu_opp_table: cpu-opp-table {
+		compatible = "operating-points-v2-kryo-cpu", "operating-points-v2";
+		nvmem-cells = <&cpu_speedbin>;
+		opp-shared;
+
+		/*
+		 * The lower CPU frequencies are meant to be 200, 400, 533 and
+		 * 800 MHz. However, they are generated from GPLL0 which does
+		 * not run at exactly 800 MHz but rather 799999804 Hz.
+		 */
+		opp-199999951 {
+			opp-hz = /bits/ 64 <199999951>;
+			required-opps = <&rpmpd_opp_ret>;
+			opp-supported-hw = <0xff>;
+		};
+		opp-399999902 {
+			opp-hz = /bits/ 64 <399999902>;
+			required-opps = <&rpmpd_opp_svs_soc>;
+			opp-supported-hw = <0xff>;
+		};
+		opp-533333202 {
+			opp-hz = /bits/ 64 <533333202>;
+			required-opps = <&rpmpd_opp_svs_soc>;
+			opp-supported-hw = <0xff>;
+		};
+		opp-799999804 {
+			opp-hz = /bits/ 64 <799999804>;
+			required-opps = <&rpmpd_opp_nom>;
+			opp-supported-hw = <0xff>;
+		};
+		/* Higher CPU frequencies are generated with the A7PLL */
+		opp-998400000 {
+			opp-hz = /bits/ 64 <998400000>;
+			required-opps = <&rpmpd_opp_nom>;
+			opp-supported-hw = <0x5>;
+		};
+		opp-1094400000 {
+			opp-hz = /bits/ 64 <1094400000>;
+			required-opps = <&rpmpd_opp_super_turbo>;
+			opp-supported-hw = <0x5>;
+		};
+		opp-1248000000 {
+			opp-hz = /bits/ 64 <1248000000>;
+			required-opps = <&rpmpd_opp_super_turbo>;
+			opp-supported-hw = <0x1>;
+		};
+		opp-1267200000 {
+			opp-hz = /bits/ 64 <1267200000>;
+			required-opps = <&rpmpd_opp_super_turbo>;
+			opp-supported-hw = <0x1>;
+		};
+	};
+
+	firmware {
+		scm: scm {
+			compatible = "qcom,scm-msm8916", "qcom,scm";
+			clocks = <&gcc GCC_CRYPTO_CLK>,
+				 <&gcc GCC_CRYPTO_AXI_CLK>,
+				 <&gcc GCC_CRYPTO_AHB_CLK>;
+			clock-names = "core", "bus", "iface";
+			qcom,dload-mode = <&tcsr 0x6100>;
+		};
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		/* We expect the bootloader to fill in the reg */
+		reg = <0x80000000 0x0>;
+	};
+
+	pmu {
+		compatible = "arm,cortex-a7-pmu";
+		interrupts = <GIC_PPI 7 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>;
+	};
+
+	reserved-memory {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		tz-apps@87a00000 {
+			reg = <0x87a00000 0x200000>;
+			no-map;
+		};
+		rmtfs@87c00000 {
+			compatible = "qcom,rmtfs-mem";
+			reg = <0x87c00000 0xe0000>;
+			no-map;
+
+			qcom,client-id = <1>;
+		};
+		rfsa@87ce0000 {
+			reg = <0x87ce0000 0x20000>;
+			no-map;
+		};
+		smem@87d00000 {
+			compatible = "qcom,smem";
+			reg = <0x87d00000 0x100000>;
+			no-map;
+
+			hwlocks = <&tcsr_mutex 3>;
+			qcom,rpm-msg-ram = <&rpm_msg_ram>;
+		};
+		tz@87e00000 {
+			reg = <0x87e00000 0x200000>;
+			no-map;
+		};
+
+		mpss_mem: mpss@88000000 {
+			reg = <0x88000000 0x05500000>;
+			no-map;
+		};
+		wcnss_mem: wcnss@8d500000 {
+			reg = <0x8d500000 0x700000>;
+			no-map;
+		};
+		mba_mem: mba@8dc00000 {
+			reg = <0x8dc00000 0x100000>;
+			no-map;
+		};
+	};
+
+	smd {
+		compatible = "qcom,smd";
+
+		rpm {
+			interrupts = <GIC_SPI 168 IRQ_TYPE_EDGE_RISING>;
+			qcom,ipc = <&apcs 8 0>;
+			qcom,smd-edge = <15>;
+
+			rpm_requests: rpm-requests {
+				compatible = "qcom,rpm-msm8909";
+				qcom,smd-channels = "rpm_requests";
+
+				rpmcc: clock-controller {
+					compatible = "qcom,rpmcc-msm8909", "qcom,rpmcc";
+					#clock-cells = <1>;
+					clocks = <&xo_board>;
+					clock-names = "xo";
+				};
+
+				rpmpd: power-controller {
+					compatible = "qcom,msm8909-rpmpd";
+					#power-domain-cells = <1>;
+					operating-points-v2 = <&rpmpd_opp_table>;
+
+					rpmpd_opp_table: opp-table {
+						compatible = "operating-points-v2";
+
+						rpmpd_opp_ret: opp1 {
+							opp-level = <1>;
+						};
+						rpmpd_opp_svs_krait: opp2 {
+							opp-level = <2>;
+						};
+						rpmpd_opp_svs_soc: opp3 {
+							opp-level = <3>;
+						};
+						rpmpd_opp_nom: opp4 {
+							opp-level = <4>;
+						};
+						rpmpd_opp_turbo: opp5 {
+							opp-level = <5>;
+						};
+						rpmpd_opp_super_turbo: opp6 {
+							opp-level = <6>;
+						};
+					};
+				};
+			};
+		};
+	};
+
+	smp2p-hexagon {
+		compatible = "qcom,smp2p";
+		qcom,smem = <435>, <428>;
+
+		interrupts = <GIC_SPI 27 IRQ_TYPE_EDGE_RISING>;
+
+		qcom,ipc = <&apcs 8 14>;
+
+		qcom,local-pid = <0>;
+		qcom,remote-pid = <1>;
+
+		hexagon_smp2p_out: master-kernel {
+			qcom,entry-name = "master-kernel";
+
+			#qcom,smem-state-cells = <1>;
+		};
+
+		hexagon_smp2p_in: slave-kernel {
+			qcom,entry-name = "slave-kernel";
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+	};
+
+	smp2p-wcnss {
+		compatible = "qcom,smp2p";
+		qcom,smem = <451>, <431>;
+
+		interrupts = <GIC_SPI 143 IRQ_TYPE_EDGE_RISING>;
+
+		qcom,ipc = <&apcs 8 18>;
+
+		qcom,local-pid = <0>;
+		qcom,remote-pid = <4>;
+
+		wcnss_smp2p_out: master-kernel {
+			qcom,entry-name = "master-kernel";
+
+			#qcom,smem-state-cells = <1>;
+		};
+
+		wcnss_smp2p_in: slave-kernel {
+			qcom,entry-name = "slave-kernel";
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+	};
+
+	smsm {
+		compatible = "qcom,smsm";
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		qcom,ipc-1 = <&apcs 8 13>;
+		qcom,ipc-3 = <&apcs 8 19>;
+
+		apps_smsm: apps@0 {
+			reg = <0>;
+
+			#qcom,smem-state-cells = <1>;
+		};
+
+		hexagon_smsm: hexagon@1 {
+			reg = <1>;
+			interrupts = <GIC_SPI 26 IRQ_TYPE_EDGE_RISING>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		wcnss_smsm: wcnss@6 {
+			reg = <6>;
+			interrupts = <GIC_SPI 144 IRQ_TYPE_EDGE_RISING>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+	};
+
+	soc: soc@0 {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		rng@22000 {
+			compatible = "qcom,prng";
+			reg = <0x00022000 0x200>;
+			clocks = <&gcc GCC_PRNG_AHB_CLK>;
+			clock-names = "core";
+		};
+
+		qfprom: qfprom@5c000 {
+			compatible = "qcom,qfprom";
+			reg = <0x0005c000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			cpu_speedbin: speedbin@c {
+				reg = <0x0c 0x1>;
+				bits = <2 3>;
+			};
+
+			tsens_s0_p1: s0-p1@a0 {
+				reg = <0xa0 0x1>;
+				bits = <0 6>;
+			};
+			tsens_s0_p2: s0-p2@a0 {
+				reg = <0xa0 0x2>;
+				bits = <6 6>;
+			};
+			tsens_s1_p1: s1-p1@a1 {
+				reg = <0xa1 0x2>;
+				bits = <4 6>;
+			};
+			tsens_s1_p2: s1-p2@a2 {
+				reg = <0xa2 0x1>;
+				bits = <2 6>;
+			};
+			tsens_s2_p1: s2-p1@a3 {
+				reg = <0xa3 0x1>;
+				bits = <0 6>;
+			};
+			tsens_s2_p2: s2-p2@a3 {
+				reg = <0xa3 0x2>;
+				bits = <6 6>;
+			};
+			tsens_s3_p1: s3-p1@a4 {
+				reg = <0xa4 0x2>;
+				bits = <4 6>;
+			};
+			tsens_s3_p2: s3-p2@a5 {
+				reg = <0xa5 0x1>;
+				bits = <2 6>;
+			};
+			tsens_s4_p1: s4-p1@a6 {
+				reg = <0xa6 0x1>;
+				bits = <0 6>;
+			};
+			tsens_s4_p2: s4-p2@a6 {
+				reg = <0xa6 0x2>;
+				bits = <6 6>;
+			};
+			tsens_base1: base1@dc {
+				reg = <0xdc 0x1>;
+				bits = <0 8>;
+			};
+			tsens_base2: base2@dd {
+				reg = <0xdd 0x1>;
+				bits = <0 8>;
+			};
+			tsens_mode: mode@de {
+				reg = <0xde 0x1>;
+				bits = <0 3>;
+			};
+		};
+
+		rpm_msg_ram: sram@60000 {
+			compatible = "qcom,rpm-msg-ram";
+			reg = <0x00060000 0x8000>;
+		};
+
+		sram@290000 {
+			compatible = "qcom,rpm-stats";
+			reg = <0x00290000 0x10000>;
+		};
+
+		tsens: thermal-sensor@4a9000 {
+			compatible = "qcom,msm8909-tsens", "qcom,tsens-v0_1";
+			reg = <0x004a9000 0x1000>, /* TM */
+			      <0x004a8000 0x1000>; /* SROT */
+			nvmem-cells = <&tsens_mode>,
+				      <&tsens_base1>, <&tsens_base2>,
+				      <&tsens_s0_p1>, <&tsens_s0_p2>,
+				      <&tsens_s1_p1>, <&tsens_s1_p2>,
+				      <&tsens_s2_p1>, <&tsens_s2_p2>,
+				      <&tsens_s3_p1>, <&tsens_s3_p2>,
+				      <&tsens_s4_p1>, <&tsens_s4_p2>;
+			nvmem-cell-names = "mode",
+					   "base1", "base2",
+					   "s0_p1", "s0_p2",
+					   "s1_p1", "s1_p2",
+					   "s2_p1", "s2_p2",
+					   "s3_p1", "s3_p2",
+					   "s4_p1", "s4_p2";
+			interrupts = <GIC_SPI 184 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "uplow";
+			#thermal-sensor-cells = <1>;
+			#qcom,sensors = <5>;
+		};
+
+		restart@4ab000 {
+			compatible = "qcom,pshold";
+			reg = <0x004ab000 0x4>;
+		};
+
+		tlmm: pinctrl@1000000 {
+			compatible = "qcom,msm8909-tlmm";
+			reg = <0x01000000 0x300000>;
+			interrupts = <GIC_SPI 208 IRQ_TYPE_LEVEL_HIGH>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio-ranges = <&tlmm 0 0 117>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+
+			blsp_i2c1_default: blsp-i2c1-default-state {
+				pins = "gpio6", "gpio7";
+				function = "blsp_i2c1";
+
+				drive-strength = <2>;
+				bias-disable;
+			};
+
+			blsp_i2c1_sleep: blsp-i2c1-sleep-state {
+				pins = "gpio6", "gpio7";
+				function = "gpio";
+
+				drive-strength = <2>;
+				bias-disable;
+			};
+
+			blsp_i2c2_default: blsp-i2c2-default-state {
+				pins = "gpio111", "gpio112";
+				function = "blsp_i2c2";
+
+				drive-strength = <2>;
+				bias-disable;
+			};
+
+			blsp_i2c2_sleep: blsp-i2c2-sleep-state {
+				pins = "gpio111", "gpio112";
+				function = "gpio";
+
+				drive-strength = <2>;
+				bias-disable;
+			};
+
+			blsp_i2c3_default: blsp-i2c3-default-state {
+				pins = "gpio29", "gpio30";
+				function = "blsp_i2c3";
+
+				drive-strength = <2>;
+				bias-disable;
+			};
+
+			blsp_i2c3_sleep: blsp-i2c3-sleep-state {
+				pins = "gpio29", "gpio30";
+				function = "gpio";
+
+				drive-strength = <2>;
+				bias-disable;
+			};
+
+			blsp_i2c4_default: blsp-i2c4-default-state {
+				pins = "gpio14", "gpio15";
+				function = "blsp_i2c4";
+
+				drive-strength = <2>;
+				bias-disable;
+			};
+
+			blsp_i2c4_sleep: blsp-i2c4-sleep-state {
+				pins = "gpio14", "gpio15";
+				function = "gpio";
+
+				drive-strength = <2>;
+				bias-disable;
+			};
+
+			blsp_i2c5_default: blsp-i2c5-default-state {
+				pins = "gpio18", "gpio19";
+				function = "blsp_i2c5";
+
+				drive-strength = <2>;
+				bias-disable;
+			};
+
+			blsp_i2c5_sleep: blsp-i2c5-sleep-state {
+				pins = "gpio18", "gpio19";
+				function = "gpio";
+
+				drive-strength = <2>;
+				bias-disable;
+			};
+
+			blsp_i2c6_default: blsp-i2c6-default-state {
+				pins = "gpio10", "gpio11";
+				function = "blsp_i2c6";
+
+				drive-strength = <2>;
+				bias-disable;
+			};
+
+			blsp_i2c6_sleep: blsp-i2c6-sleep-state {
+				pins = "gpio10", "gpio11";
+				function = "gpio";
+
+				drive-strength = <2>;
+				bias-disable;
+			};
+
+			blsp_spi1_default: blsp-spi1-default-state {
+				pins = "gpio4", "gpio5", "gpio6", "gpio7";
+				function = "blsp_spi1";
+
+				drive-strength = <12>;
+				bias-disable;
+			};
+
+			blsp_spi1_sleep: blsp-spi1-sleep-state {
+				pins = "gpio4", "gpio5", "gpio6", "gpio7";
+				function = "gpio";
+
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+
+			blsp_spi2_default: blsp-spi2-default-state {
+				pins = "gpio20", "gpio21", "gpio111", "gpio112";
+				function = "blsp_spi2";
+
+				drive-strength = <12>;
+				bias-disable;
+			};
+
+			blsp_spi2_sleep: blsp-spi2-sleep-state {
+				pins = "gpio20", "gpio21", "gpio111", "gpio112";
+				function = "gpio";
+
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+
+			blsp_spi3_default: blsp-spi3-default-state {
+				pins = "gpio0", "gpio1", "gpio2", "gpio3";
+				function = "blsp_spi3";
+
+				drive-strength = <12>;
+				bias-disable;
+			};
+
+			blsp_spi3_sleep: blsp-spi3-sleep-state {
+				pins = "gpio0", "gpio1", "gpio2", "gpio3";
+				function = "gpio";
+
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+
+			blsp_spi4_default: blsp-spi4-default-state {
+				pins = "gpio12", "gpio13", "gpio14", "gpio15";
+				function = "blsp_spi4";
+
+				drive-strength = <12>;
+				bias-disable;
+			};
+
+			blsp_spi4_sleep: blsp-spi4-sleep-state {
+				pins = "gpio12", "gpio13", "gpio14", "gpio15";
+				function = "gpio";
+
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+
+			blsp_spi5_default: blsp-spi5-default-state {
+				pins = "gpio16", "gpio17", "gpio18", "gpio19";
+				function = "blsp_spi5";
+
+				drive-strength = <12>;
+				bias-disable;
+			};
+
+			blsp_spi5_sleep: blsp-spi5-sleep-state {
+				pins = "gpio16", "gpio17", "gpio18", "gpio19";
+				function = "gpio";
+
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+
+			blsp_spi6_default: blsp-spi6-default-state {
+				pins = "gpio8", "gpio9", "gpio10", "gpio11";
+				function = "blsp_spi6";
+
+				drive-strength = <12>;
+				bias-disable;
+			};
+
+			blsp_spi6_sleep: blsp-spi6-sleep-state {
+				pins = "gpio8", "gpio9", "gpio10", "gpio11";
+				function = "gpio";
+
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+
+			blsp_uart1_default: blsp-uart1-default-state {
+				pins = "gpio4", "gpio5";
+				function = "blsp_uart1";
+
+				drive-strength = <2>;
+				bias-disable;
+			};
+
+			blsp_uart1_sleep: blsp-uart1-sleep-state {
+				pins = "gpio4", "gpio5";
+				function = "gpio";
+
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+
+			blsp_uart2_default: blsp-uart2-default-state {
+				pins = "gpio20", "gpio21";
+				function = "blsp_uart2";
+
+				drive-strength = <2>;
+				bias-disable;
+			};
+
+			blsp_uart2_sleep: blsp-uart2-sleep-state {
+				pins = "gpio20", "gpio21";
+				function = "gpio";
+
+				drive-strength = <2>;
+				bias-pull-down;
+			};
+
+			sdc1_clk_on: sdc1-clk-on-state {
+				pins = "sdc1_clk";
+				bias-disable;
+				drive-strength = <16>;
+			};
+
+			sdc1_clk_off: sdc1-clk-off-state {
+				pins = "sdc1_clk";
+				bias-disable;
+				drive-strength = <2>;
+			};
+
+			sdc1_cmd_on: sdc1-cmd-on-state {
+				pins = "sdc1_cmd";
+				bias-disable;
+				drive-strength = <10>;
+			};
+
+			sdc1_cmd_off: sdc1-cmd-off-state {
+				pins = "sdc1_cmd";
+				bias-disable;
+				drive-strength = <2>;
+			};
+
+			sdc1_data_on: sdc1-data-on-state {
+				pins = "sdc1_data";
+				bias-pull-up;
+				drive-strength = <10>;
+			};
+
+			sdc1_data_off: sdc1-data-off-state {
+				pins = "sdc1_data";
+				bias-pull-up;
+				drive-strength = <2>;
+			};
+
+			sdc2_clk_on: sdc2-clk-on-state {
+				pins = "sdc2_clk";
+				drive-strength = <16>;
+				bias-disable;
+			};
+
+			sdc2_clk_off: sdc2-clk-off-state {
+				pins = "sdc2_clk";
+				bias-disable;
+				drive-strength = <2>;
+			};
+
+			sdc2_cmd_on: sdc2-cmd-on-state {
+				pins = "sdc2_cmd";
+				bias-pull-up;
+				drive-strength = <10>;
+			};
+
+			sdc2_cmd_off: sdc2-cmd-off-state {
+				pins = "sdc2_cmd";
+				bias-pull-up;
+				drive-strength = <2>;
+			};
+
+			sdc2_data_on: sdc2-data-on-state {
+				pins = "sdc2_data";
+				bias-pull-up;
+				drive-strength = <10>;
+			};
+
+			sdc2_data_off: sdc2-data-off-state {
+				pins = "sdc2_data";
+				bias-pull-up;
+				drive-strength = <2>;
+			};
+
+			wcnss_pin_a: wcnss-active-state {
+				pins = "gpio40", "gpio41", "gpio42",
+				       "gpio43", "gpio44";
+				function = "wcss_wlan";
+
+				drive-strength = <6>;
+				bias-pull-up;
+			};
+		};
+
+		gcc: clock-controller@1800000 {
+			compatible = "qcom,gcc-msm8909";
+			reg = <0x01800000 0x80000>;
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+			#power-domain-cells = <1>;
+			clocks = <&xo_board>, <&sleep_clk>, <0>, <0>;
+			clock-names = "xo", "sleep_clk", "dsi0pll", "dsi0pllbyte";
+		};
+
+		tcsr_mutex: hwlock@1905000 {
+			compatible = "qcom,tcsr-mutex";
+			reg = <0x01905000 0x20000>;
+			#hwlock-cells = <1>;
+		};
+
+		tcsr: syscon@1937000 {
+			compatible = "qcom,tcsr-msm8909", "syscon";
+			reg = <0x01937000 0x30000>;
+		};
+
+		spmi_bus: spmi@200f000 {
+			compatible = "qcom,spmi-pmic-arb";
+			reg = <0x0200f000 0x001000>,
+			      <0x02400000 0x400000>,
+			      <0x02c00000 0x400000>,
+			      <0x03800000 0x200000>,
+			      <0x0200a000 0x002100>;
+			reg-names = "core", "chnls", "obsrvr", "intr", "cnfg";
+			interrupt-names = "periph_irq";
+			interrupts = <GIC_SPI 190 IRQ_TYPE_LEVEL_HIGH>;
+			qcom,ee = <0>;
+			qcom,channel = <0>;
+			#address-cells = <2>;
+			#size-cells = <0>;
+			interrupt-controller;
+			#interrupt-cells = <4>;
+		};
+
+		bam_dmux_dma: dma-controller@4044000 {
+			compatible = "qcom,bam-v1.7.0";
+			reg = <0x04044000 0x19000>;
+			interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+			#dma-cells = <1>;
+			qcom,ee = <0>;
+
+			num-channels = <6>;
+			qcom,num-ees = <1>;
+			qcom,powered-remotely;
+		};
+
+		mpss: remoteproc@4080000 {
+			compatible = "qcom,msm8909-mss-pil";
+			reg = <0x04080000 0x100>,
+			      <0x04020000 0x040>;
+			reg-names = "qdsp6", "rmb";
+
+			interrupts-extended = <&intc GIC_SPI 24 IRQ_TYPE_EDGE_RISING>,
+					      <&hexagon_smp2p_in 0 IRQ_TYPE_EDGE_RISING>,
+					      <&hexagon_smp2p_in 1 IRQ_TYPE_EDGE_RISING>,
+					      <&hexagon_smp2p_in 2 IRQ_TYPE_EDGE_RISING>,
+					      <&hexagon_smp2p_in 3 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names = "wdog", "fatal", "ready",
+					  "handover", "stop-ack";
+
+			power-domains = <&rpmpd MSM8909_VDDCX>,
+					<&rpmpd MSM8909_VDDMX_AO>;
+			power-domain-names = "cx", "mx";
+
+			clocks = <&gcc GCC_MSS_CFG_AHB_CLK>,
+				 <&gcc GCC_MSS_Q6_BIMC_AXI_CLK>,
+				 <&gcc GCC_BOOT_ROM_AHB_CLK>,
+				 <&xo_board>;
+			clock-names = "iface", "bus", "mem", "xo";
+
+			qcom,smem-states = <&hexagon_smp2p_out 0>;
+			qcom,smem-state-names = "stop";
+
+			resets = <&gcc GCC_MSS_RESTART>;
+			reset-names = "mss_restart";
+
+			qcom,halt-regs = <&tcsr 0x18000 0x19000 0x1a000>;
+
+			status = "disabled";
+
+			mba {
+				memory-region = <&mba_mem>;
+			};
+
+			mpss {
+				memory-region = <&mpss_mem>;
+			};
+
+			bam_dmux: bam-dmux {
+				compatible = "qcom,bam-dmux";
+
+				interrupt-parent = <&hexagon_smsm>;
+				interrupts = <1 IRQ_TYPE_EDGE_BOTH>, <11 IRQ_TYPE_EDGE_BOTH>;
+				interrupt-names = "pc", "pc-ack";
+
+				qcom,smem-states = <&apps_smsm 1>, <&apps_smsm 11>;
+				qcom,smem-state-names = "pc", "pc-ack";
+
+				dmas = <&bam_dmux_dma 4>, <&bam_dmux_dma 5>;
+				dma-names = "tx", "rx";
+			};
+
+			smd-edge {
+				interrupts = <GIC_SPI 25 IRQ_TYPE_EDGE_RISING>;
+
+				qcom,smd-edge = <0>;
+				qcom,ipc = <&apcs 8 12>;
+				qcom,remote-pid = <1>;
+
+				label = "hexagon";
+			};
+		};
+
+		sdhc_1: sdhci@7824000 {
+			compatible = "qcom,msm8916-sdhci", "qcom,sdhci-msm-v4";
+			reg = <0x07824900 0x11c>, <0x07824000 0x800>;
+			reg-names = "hc_mem", "core_mem";
+
+			interrupts = <GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 138 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "hc_irq", "pwr_irq";
+			clocks = <&gcc GCC_SDCC1_APPS_CLK>,
+				 <&gcc GCC_SDCC1_AHB_CLK>,
+				 <&xo_board>;
+			clock-names = "core", "iface", "xo";
+
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&sdc1_clk_on &sdc1_cmd_on &sdc1_data_on>;
+			pinctrl-1 = <&sdc1_clk_off &sdc1_cmd_off &sdc1_data_off>;
+
+			mmc-hs200-1_8v;
+			mmc-ddr-1_8v;
+			bus-width = <8>;
+			non-removable;
+			status = "disabled";
+		};
+
+		sdhc_2: sdhci@7864000 {
+			compatible = "qcom,msm8916-sdhci", "qcom,sdhci-msm-v4";
+			reg = <0x07864900 0x11c>, <0x07864000 0x800>;
+			reg-names = "hc_mem", "core_mem";
+
+			interrupts = <GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 221 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "hc_irq", "pwr_irq";
+			clocks = <&gcc GCC_SDCC2_APPS_CLK>,
+				 <&gcc GCC_SDCC2_AHB_CLK>,
+				 <&xo_board>;
+			clock-names = "core", "iface", "xo";
+
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&sdc2_clk_on &sdc2_cmd_on &sdc2_data_on>;
+			pinctrl-1 = <&sdc2_clk_off &sdc2_cmd_off &sdc2_data_off>;
+
+			bus-width = <4>;
+			status = "disabled";
+		};
+
+		blsp_dma: dma-controller@7884000 {
+			compatible = "qcom,bam-v1.7.0";
+			reg = <0x07884000 0x23000>;
+			interrupts = <GIC_SPI 238 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc GCC_BLSP1_AHB_CLK>;
+			clock-names = "bam_clk";
+			#dma-cells = <1>;
+			qcom,ee = <0>;
+			qcom,controlled-remotely;
+		};
+
+		blsp_uart1: serial@78af000 {
+			compatible = "qcom,msm-uartdm-v1.4", "qcom,msm-uartdm";
+			reg = <0x078af000 0x200>;
+			interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc GCC_BLSP1_UART1_APPS_CLK>,
+				 <&gcc GCC_BLSP1_AHB_CLK>;
+			clock-names = "core", "iface";
+			dmas = <&blsp_dma 0>, <&blsp_dma 1>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&blsp_uart1_default>;
+			pinctrl-1 = <&blsp_uart1_sleep>;
+			status = "disabled";
+		};
+
+		blsp_uart2: serial@78b0000 {
+			compatible = "qcom,msm-uartdm-v1.4", "qcom,msm-uartdm";
+			reg = <0x078b0000 0x200>;
+			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc GCC_BLSP1_UART2_APPS_CLK>,
+				 <&gcc GCC_BLSP1_AHB_CLK>;
+			clock-names = "core", "iface";
+			dmas = <&blsp_dma 2>, <&blsp_dma 3>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&blsp_uart2_default>;
+			pinctrl-1 = <&blsp_uart2_sleep>;
+			status = "disabled";
+		};
+
+		blsp_i2c1: i2c@78b5000 {
+			compatible = "qcom,i2c-qup-v2.2.1";
+			reg = <0x078b5000 0x500>;
+			interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc GCC_BLSP1_QUP1_I2C_APPS_CLK>,
+				 <&gcc GCC_BLSP1_AHB_CLK>;
+			clock-names = "core", "iface";
+			dmas = <&blsp_dma 4>, <&blsp_dma 5>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&blsp_i2c1_default>;
+			pinctrl-1 = <&blsp_i2c1_sleep>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		blsp_spi1: spi@78b5000 {
+			compatible = "qcom,spi-qup-v2.2.1";
+			reg = <0x078b5000 0x500>;
+			interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc GCC_BLSP1_QUP1_SPI_APPS_CLK>,
+				 <&gcc GCC_BLSP1_AHB_CLK>;
+			clock-names = "core", "iface";
+			dmas = <&blsp_dma 4>, <&blsp_dma 5>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&blsp_spi1_default>;
+			pinctrl-1 = <&blsp_spi1_sleep>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		blsp_i2c2: i2c@78b6000 {
+			compatible = "qcom,i2c-qup-v2.2.1";
+			reg = <0x078b6000 0x500>;
+			interrupts = <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc GCC_BLSP1_QUP2_I2C_APPS_CLK>,
+				 <&gcc GCC_BLSP1_AHB_CLK>;
+			clock-names = "core", "iface";
+			dmas = <&blsp_dma 6>, <&blsp_dma 7>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&blsp_i2c2_default>;
+			pinctrl-1 = <&blsp_i2c2_sleep>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		blsp_spi2: spi@78b6000 {
+			compatible = "qcom,spi-qup-v2.2.1";
+			reg = <0x078b6000 0x500>;
+			interrupts = <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc GCC_BLSP1_QUP2_SPI_APPS_CLK>,
+				 <&gcc GCC_BLSP1_AHB_CLK>;
+			clock-names = "core", "iface";
+			dmas = <&blsp_dma 6>, <&blsp_dma 7>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&blsp_spi2_default>;
+			pinctrl-1 = <&blsp_spi2_sleep>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		blsp_i2c3: i2c@78b7000 {
+			compatible = "qcom,i2c-qup-v2.2.1";
+			reg = <0x078b7000 0x500>;
+			interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc GCC_BLSP1_QUP3_I2C_APPS_CLK>,
+				 <&gcc GCC_BLSP1_AHB_CLK>;
+			clock-names = "core", "iface";
+			dmas = <&blsp_dma 8>, <&blsp_dma 9>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&blsp_i2c3_default>;
+			pinctrl-1 = <&blsp_i2c3_sleep>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		blsp_spi3: spi@78b7000 {
+			compatible = "qcom,spi-qup-v2.2.1";
+			reg = <0x078b7000 0x500>;
+			interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc GCC_BLSP1_QUP3_SPI_APPS_CLK>,
+				 <&gcc GCC_BLSP1_AHB_CLK>;
+			clock-names = "core", "iface";
+			dmas = <&blsp_dma 8>, <&blsp_dma 9>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&blsp_spi3_default>;
+			pinctrl-1 = <&blsp_spi3_sleep>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		blsp_i2c4: i2c@78b8000 {
+			compatible = "qcom,i2c-qup-v2.2.1";
+			reg = <0x078b8000 0x500>;
+			interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc GCC_BLSP1_QUP4_I2C_APPS_CLK>,
+				 <&gcc GCC_BLSP1_AHB_CLK>;
+			clock-names = "core", "iface";
+			dmas = <&blsp_dma 10>, <&blsp_dma 11>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&blsp_i2c4_default>;
+			pinctrl-1 = <&blsp_i2c4_sleep>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		blsp_spi4: spi@78b8000 {
+			compatible = "qcom,spi-qup-v2.2.1";
+			reg = <0x078b8000 0x500>;
+			interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc GCC_BLSP1_QUP4_SPI_APPS_CLK>,
+				 <&gcc GCC_BLSP1_AHB_CLK>;
+			clock-names = "core", "iface";
+			dmas = <&blsp_dma 10>, <&blsp_dma 11>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&blsp_spi4_default>;
+			pinctrl-1 = <&blsp_spi4_sleep>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		blsp_i2c5: i2c@78b9000 {
+			compatible = "qcom,i2c-qup-v2.2.1";
+			reg = <0x078b9000 0x500>;
+			interrupts = <GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc GCC_BLSP1_QUP5_I2C_APPS_CLK>,
+				 <&gcc GCC_BLSP1_AHB_CLK>;
+			clock-names = "core", "iface";
+			dmas = <&blsp_dma 12>, <&blsp_dma 13>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&blsp_i2c5_default>;
+			pinctrl-1 = <&blsp_i2c5_sleep>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		blsp_spi5: spi@78b9000 {
+			compatible = "qcom,spi-qup-v2.2.1";
+			reg = <0x078b9000 0x500>;
+			interrupts = <GIC_SPI 99 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc GCC_BLSP1_QUP5_SPI_APPS_CLK>,
+				 <&gcc GCC_BLSP1_AHB_CLK>;
+			clock-names = "core", "iface";
+			dmas = <&blsp_dma 12>, <&blsp_dma 13>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&blsp_spi5_default>;
+			pinctrl-1 = <&blsp_spi5_sleep>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		blsp_i2c6: i2c@78ba000 {
+			compatible = "qcom,i2c-qup-v2.2.1";
+			reg = <0x078ba000 0x500>;
+			interrupts = <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc GCC_BLSP1_QUP6_I2C_APPS_CLK>,
+				 <&gcc GCC_BLSP1_AHB_CLK>;
+			clock-names = "core", "iface";
+			dmas = <&blsp_dma 14>, <&blsp_dma 15>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&blsp_i2c6_default>;
+			pinctrl-1 = <&blsp_i2c6_sleep>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		blsp_spi6: spi@78ba000 {
+			compatible = "qcom,spi-qup-v2.2.1";
+			reg = <0x078ba000 0x500>;
+			interrupts = <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc GCC_BLSP1_QUP6_SPI_APPS_CLK>,
+				 <&gcc GCC_BLSP1_AHB_CLK>;
+			clock-names = "core", "iface";
+			dmas = <&blsp_dma 14>, <&blsp_dma 15>;
+			dma-names = "tx", "rx";
+			pinctrl-names = "default", "sleep";
+			pinctrl-0 = <&blsp_spi6_default>;
+			pinctrl-1 = <&blsp_spi6_sleep>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		usb: usb@78d9000 {
+			compatible = "qcom,ci-hdrc";
+			reg = <0x078d9000 0x200>, <0x078d9200 0x200>;
+			interrupts = <GIC_SPI 134 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&gcc GCC_USB_HS_AHB_CLK>,
+				 <&gcc GCC_USB_HS_SYSTEM_CLK>;
+			clock-names = "iface", "core";
+			assigned-clocks = <&gcc GCC_USB_HS_SYSTEM_CLK>;
+			assigned-clock-rates = <80000000>;
+			resets = <&gcc GCC_USB_HS_BCR>;
+			reset-names = "core";
+			phy_type = "ulpi";
+			dr_mode = "otg";
+			hnp-disable;
+			srp-disable;
+			adp-disable;
+			ahb-burst-config = <0>;
+			phy-names = "usb-phy";
+			phys = <&usb_hs_phy>;
+			status = "disabled";
+			#reset-cells = <1>;
+
+			ulpi {
+				usb_hs_phy: phy {
+					compatible = "qcom,usb-hs-phy-msm8909",
+						     "qcom,usb-hs-phy";
+					#phy-cells = <0>;
+					clocks = <&xo_board>, <&gcc GCC_USB2A_PHY_SLEEP_CLK>;
+					clock-names = "ref", "sleep";
+					resets = <&gcc GCC_QUSB2_PHY_BCR>,
+						 <&gcc GCC_USB2_HS_PHY_ONLY_BCR>;
+					reset-names = "phy", "por";
+					qcom,init-seq = /bits/ 8 <0x0 0x73>;
+				};
+			};
+		};
+
+		wcnss: remoteproc@a21b000 {
+			compatible = "qcom,pronto-v3-pil", "qcom,pronto";
+			reg = <0x0a204000 0x2000>, <0x0a202000 0x1000>, <0x0a21b000 0x3000>;
+			reg-names = "ccu", "dxe", "pmu";
+
+			memory-region = <&wcnss_mem>;
+
+			interrupts-extended = <&intc GIC_SPI 149 IRQ_TYPE_EDGE_RISING>,
+					      <&wcnss_smp2p_in 0 IRQ_TYPE_EDGE_RISING>,
+					      <&wcnss_smp2p_in 1 IRQ_TYPE_EDGE_RISING>,
+					      <&wcnss_smp2p_in 2 IRQ_TYPE_EDGE_RISING>,
+					      <&wcnss_smp2p_in 3 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names = "wdog", "fatal", "ready", "handover", "stop-ack";
+
+			power-domains = <&rpmpd MSM8909_VDDCX>,
+					<&rpmpd MSM8909_VDDMX>;
+			power-domain-names = "cx", "mx";
+
+			qcom,smem-states = <&wcnss_smp2p_out 0>;
+			qcom,smem-state-names = "stop";
+
+			pinctrl-names = "default";
+			pinctrl-0 = <&wcnss_pin_a>;
+
+			status = "disabled";
+
+			wcnss_iris: iris {
+				/* Separate chip, compatible is board-specific */
+				clocks = <&rpmcc RPM_SMD_RF_CLK2>;
+				clock-names = "xo";
+			};
+
+			smd-edge {
+				interrupts = <GIC_SPI 142 IRQ_TYPE_EDGE_RISING>;
+
+				qcom,ipc = <&apcs 8 17>;
+				qcom,smd-edge = <6>;
+				qcom,remote-pid = <4>;
+
+				label = "pronto";
+
+				wcnss_ctrl: wcnss {
+					compatible = "qcom,wcnss";
+					qcom,smd-channels = "WCNSS_CTRL";
+
+					qcom,mmio = <&wcnss>;
+
+					wcnss_bt: bluetooth {
+						compatible = "qcom,wcnss-bt";
+					};
+
+					wcnss_wifi: wifi {
+						compatible = "qcom,wcnss-wlan";
+
+						interrupts = <GIC_SPI 145 IRQ_TYPE_LEVEL_HIGH>,
+							     <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>;
+						interrupt-names = "tx", "rx";
+
+						qcom,smem-states = <&apps_smsm 10>, <&apps_smsm 9>;
+						qcom,smem-state-names = "tx-enable", "tx-rings-empty";
+					};
+				};
+			};
+		};
+
+		intc: interrupt-controller@b000000 {
+			compatible = "qcom,msm-qgic2";
+			reg = <0x0b000000 0x1000>,
+			      <0x0b002000 0x1000>;
+			interrupt-controller;
+			#interrupt-cells = <3>;
+		};
+
+		apcs: mailbox@b011000 {
+			compatible = "qcom,msm8916-apcs-kpss-global", "syscon";
+			reg = <0x0b011000 0x1000>;
+			#mbox-cells = <1>;
+			clocks = <&a7pll>, <&gcc GPLL0>;
+			clock-names = "pll", "aux";
+			#clock-cells = <0>;
+		};
+
+		a7pll: clock@b016000 {
+			compatible = "qcom,msm8916-a53pll";
+			reg = <0x0b016000 0x40>;
+			#clock-cells = <0>;
+			clocks = <&xo_board>;
+			clock-names = "xo";
+			operating-points-v2 = <&a7pll_opp_table>;
+
+			a7pll_opp_table: opp-table {
+				compatible = "operating-points-v2";
+
+				opp-998400000 {
+					opp-hz = /bits/ 64 <998400000>;
+				};
+				opp-1094400000 {
+					opp-hz = /bits/ 64 <1094400000>;
+				};
+				opp-1190400000 {
+					opp-hz = /bits/ 64 <1190400000>;
+				};
+				opp-1248000000 {
+					opp-hz = /bits/ 64 <1248000000>;
+				};
+				opp-1267200000 {
+					opp-hz = /bits/ 64 <1267200000>;
+				};
+			};
+		};
+
+		timer@b020000 {
+			compatible = "arm,armv7-timer-mem";
+			reg = <0x0b020000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+
+			frame@b021000 {
+				reg = <0x0b021000 0x1000>, <0x0b022000 0x1000>;
+				interrupts = <GIC_SPI 8 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
+				frame-number = <0>;
+			};
+
+			frame@b023000 {
+				reg = <0x0b023000 0x1000>;
+				interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
+				frame-number = <1>;
+				status = "disabled";
+			};
+
+			frame@b024000 {
+				reg = <0x0b024000 0x1000>;
+				interrupts = <GIC_SPI 10 IRQ_TYPE_LEVEL_HIGH>;
+				frame-number = <2>;
+				status = "disabled";
+			};
+
+			frame@b025000 {
+				reg = <0x0b025000 0x1000>;
+				interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
+				frame-number = <3>;
+				status = "disabled";
+			};
+
+			frame@b026000 {
+				reg = <0x0b026000 0x1000>;
+				interrupts = <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>;
+				frame-number = <4>;
+				status = "disabled";
+			};
+
+			frame@b027000 {
+				reg = <0x0b027000 0x1000>;
+				interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
+				frame-number = <5>;
+				status = "disabled";
+			};
+
+			frame@b028000 {
+				reg = <0x0b028000 0x1000>;
+				interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
+				frame-number = <6>;
+				status = "disabled";
+			};
+		};
+
+		cpu0_acc: power-manager@b088000 {
+			compatible = "qcom,msm8909-acc";
+			reg = <0x0b088000 0x1000>;
+		};
+		cpu0_saw: power-manager@b089000 {
+			compatible = "qcom,msm8909-saw2-v3.0-cpu", "qcom,saw2";
+			reg = <0x0b089000 0x1000>;
+		};
+		cpu1_acc: power-manager@b098000 {
+			compatible = "qcom,msm8909-acc";
+			reg = <0x0b098000 0x1000>;
+		};
+		cpu1_saw: power-manager@b099000 {
+			compatible = "qcom,msm8909-saw2-v3.0-cpu", "qcom,saw2";
+			reg = <0x0b099000 0x1000>;
+		};
+		cpu2_acc: power-manager@b0a8000 {
+			compatible = "qcom,msm8909-acc";
+			reg = <0x0b0a8000 0x1000>;
+		};
+		cpu2_saw: power-manager@b0a9000 {
+			compatible = "qcom,msm8909-saw2-v3.0-cpu", "qcom,saw2";
+			reg = <0x0b0a9000 0x1000>;
+		};
+		cpu3_acc: power-manager@b0b8000 {
+			compatible = "qcom,msm8909-acc";
+			reg = <0x0b0b8000 0x1000>;
+		};
+		cpu3_saw: power-manager@b0b9000 {
+			compatible = "qcom,msm8909-saw2-v3.0-cpu", "qcom,saw2";
+			reg = <0x0b0b9000 0x1000>;
+		};
+	};
+
+	thermal-zones {
+		cpu0-2-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <0>;
+
+			thermal-sensors = <&tsens 3>;
+
+			trips {
+				cpu0_2_alert0: trip-point0 {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+				cpu0_2_crit: cpu_crit {
+					temperature = <100000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&cpu0_2_alert0>;
+					cooling-device = <&cpu0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+							 <&cpu1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+							 <&cpu2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+							 <&cpu3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+				};
+			};
+		};
+
+		cpu1-3-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <0>;
+
+			thermal-sensors = <&tsens 4>;
+
+			trips {
+				cpu1_3_alert0: trip-point0 {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+				cpu1_3_crit: cpu_crit {
+					temperature = <100000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&cpu1_3_alert0>;
+					cooling-device = <&cpu0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+							 <&cpu1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+							 <&cpu2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+							 <&cpu3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+				};
+			};
+		};
+
+		gpu-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <0>;
+
+			thermal-sensors = <&tsens 2>;
+
+			trips {
+				gpu_alert0: trip-point0 {
+					temperature = <90000>;
+					hysteresis = <2000>;
+					type = "hot";
+				};
+			};
+		};
+
+		camera-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <0>;
+
+			thermal-sensors = <&tsens 1>;
+
+			trips {
+				cam_alert0: trip-point0 {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "hot";
+				};
+			};
+		};
+
+		modem-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <0>;
+
+			thermal-sensors = <&tsens 0>;
+
+			trips {
+				modem_alert0: trip-point0 {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "hot";
+				};
+			};
+		};
+
+	};
+
+	timer {
+		compatible = "arm,armv7-timer";
+		interrupts = <GIC_PPI 2 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 3 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 4 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 1 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>;
+	};
+};
diff --git a/arch/arm/boot/dts/qcom/qcom-msm8916-samsung-fortunaltezt.dts b/arch/arm/boot/dts/qcom/qcom-msm8916-samsung-fortunaltezt.dts
new file mode 100644
index 000000000000..a1fd9588d476
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/qcom-msm8916-samsung-fortunaltezt.dts
@@ -0,0 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#include "arm64/qcom/msm8916-samsung-fortunaltezt.dts"
+#include "qcom-msm8916-smp.dtsi"
+
+&tsens {
+	/* FIXME: The device crashes when accessing the SROT region for some reason */
+	qcom,srot-locked;
+};
diff --git a/arch/arm/boot/dts/qcom/qcom-msm8916-samsung-heatqlte.dts b/arch/arm/boot/dts/qcom/qcom-msm8916-samsung-heatqlte.dts
new file mode 100644
index 000000000000..c900d0af919e
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/qcom-msm8916-samsung-heatqlte.dts
@@ -0,0 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#include "arm64/qcom/msm8916-samsung-heatqlte.dts"
+#include "qcom-msm8916-smp.dtsi"
+
+&tsens {
+	/* FIXME: The device crashes when accessing the SROT region for some reason */
+	qcom,srot-locked;
+};
diff --git a/arch/arm/boot/dts/qcom/qcom-pm8909.dtsi b/arch/arm/boot/dts/qcom/qcom-pm8909.dtsi
new file mode 100644
index 000000000000..b632a1883d77
--- /dev/null
+++ b/arch/arm/boot/dts/qcom/qcom-pm8909.dtsi
@@ -0,0 +1,146 @@
+// SPDX-License-Identifier: GPL-2.0-only
+#include <dt-bindings/input/linux-event-codes.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/spmi/spmi.h>
+
+&spmi_bus {
+	pm8909_0: pmic@0 {
+		compatible = "qcom,pm8909", "qcom,spmi-pmic";
+		reg = <0x0 SPMI_USID>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		pon@800 {
+			compatible = "qcom,pm8916-pon";
+			reg = <0x800>;
+			mode-bootloader = <0x2>;
+			mode-recovery = <0x1>;
+
+			pwrkey {
+				compatible = "qcom,pm8941-pwrkey";
+				interrupts = <0x0 0x8 0 IRQ_TYPE_EDGE_BOTH>;
+				debounce = <15625>;
+				bias-pull-up;
+				linux,code = <KEY_POWER>;
+			};
+
+			pm8909_resin: resin {
+				compatible = "qcom,pm8941-resin";
+				interrupts = <0x0 0x8 1 IRQ_TYPE_EDGE_BOTH>;
+				debounce = <15625>;
+				bias-pull-up;
+				status = "disabled";
+			};
+
+			watchdog {
+				compatible = "qcom,pm8916-wdt";
+				interrupts = <0x0 0x8 6 IRQ_TYPE_EDGE_RISING>;
+				timeout-sec = <60>;
+			};
+		};
+
+		pm8909_charger: charger@1000 {
+			compatible = "qcom,pm8916-lbc";
+			reg = <0x1000>, <0x1200>, <0x1300>, <0x1600>;
+			reg-names = "chgr", "bat_if", "usb", "misc";
+
+			interrupts = <0x0 0x10 0 IRQ_TYPE_EDGE_BOTH>,
+				     <0x0 0x10 5 IRQ_TYPE_EDGE_BOTH>,
+				     <0x0 0x10 6 IRQ_TYPE_EDGE_BOTH>,
+				     <0x0 0x10 7 IRQ_TYPE_EDGE_BOTH>,
+				     <0x0 0x12 0 IRQ_TYPE_EDGE_BOTH>,
+				     <0x0 0x12 1 IRQ_TYPE_EDGE_BOTH>,
+				     <0x0 0x13 0 IRQ_TYPE_EDGE_BOTH>,
+				     <0x0 0x13 1 IRQ_TYPE_EDGE_BOTH>,
+				     <0x0 0x13 2 IRQ_TYPE_EDGE_BOTH>,
+				     <0x0 0x13 4 IRQ_TYPE_EDGE_BOTH>;
+			interrupt-names = "vbat_det",
+					  "fast_chg",
+					  "chg_fail",
+					  "chg_done",
+					  "bat_pres",
+					  "temp_ok",
+					  "coarse_det",
+					  "usb_vbus",
+					  "chg_gone",
+					  "overtemp";
+
+			status = "disabled";
+		};
+
+		pm8909_usbin: extcon@1300 {
+			compatible = "qcom,pm8941-misc";
+			reg = <0x1300>;
+			interrupts = <0x0 0x13 1 IRQ_TYPE_EDGE_BOTH>;
+			interrupt-names = "usb_vbus";
+			status = "disabled";
+		};
+
+		pm8909_bms: vm-bms@4000 {
+			compatible = "qcom,pm8916-bms-vm";
+			reg = <0x4000>;
+
+			interrupts = <0x0 0x40 0 IRQ_TYPE_EDGE_RISING>,
+				     <0x0 0x40 1 IRQ_TYPE_EDGE_RISING>,
+				     <0x0 0x40 2 IRQ_TYPE_EDGE_RISING>,
+				     <0x0 0x40 3 IRQ_TYPE_EDGE_RISING>,
+				     <0x0 0x40 4 IRQ_TYPE_EDGE_RISING>,
+				     <0x0 0x40 5 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names = "cv_leave",
+					  "cv_enter",
+					  "ocv_good",
+					  "ocv_thr",
+					  "fifo",
+					  "state_chg";
+
+			status = "disabled";
+		};
+
+		rtc@6000 {
+			compatible = "qcom,pm8941-rtc";
+			reg = <0x6000>;
+			interrupts = <0x0 0x61 0x1 IRQ_TYPE_EDGE_RISING>;
+		};
+
+		pm8909_mpps: mpps@a000 {
+			compatible = "qcom,pm8916-mpp", "qcom,spmi-mpp";
+			reg = <0xa000>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			gpio-ranges = <&pm8909_mpps 0 0 4>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		pm8909_gpios: gpios@c000 {
+			compatible = "qcom,pm8916-gpio", "qcom,spmi-gpio";
+			reg = <0xc000>;
+			gpio-controller;
+			gpio-ranges = <&pm8909_gpios 0 0 4>;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+	};
+
+	pm8909_1: pmic@1 {
+		compatible = "qcom,pm8909", "qcom,spmi-pmic";
+		reg = <0x1 SPMI_USID>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		pm8909_pwm: pwm {
+			compatible = "qcom,pm8916-pwm";
+
+			#pwm-cells = <2>;
+
+			status = "disabled";
+		};
+
+		pm8909_vib: vibrator@c000 {
+			compatible = "qcom,pm8916-vib";
+			reg = <0xc000>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm/configs/.gitignore b/arch/arm/configs/.gitignore
new file mode 100644
index 000000000000..1cd39ba800c9
--- /dev/null
+++ b/arch/arm/configs/.gitignore
@@ -0,0 +1,2 @@
+# This is dynamically built from the arm64 one (see msm8916_defconfig.part)
+msm8916_defconfig
diff --git a/arch/arm/configs/msm8916_defconfig.part b/arch/arm/configs/msm8916_defconfig.part
new file mode 100644
index 000000000000..dc9c6e2577be
--- /dev/null
+++ b/arch/arm/configs/msm8916_defconfig.part
@@ -0,0 +1,35 @@
+# Build the full configuration by running
+# cat arch/arm64/configs/msm8916_defconfig arch/arm/configs/msm8916_defconfig.part > arch/arm/configs/msm8916_defconfig
+
+CONFIG_PERF_EVENTS=y
+# CONFIG_CACHE_L2X0 is not set
+# CONFIG_ARM_ERRATA_643719 is not set
+CONFIG_SMP=y
+CONFIG_ARM_PSCI=y
+CONFIG_HZ_300=y
+CONFIG_HIGHMEM=y
+# CONFIG_ATAGS is not set
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+CONFIG_ARM_CRYPTO=y
+CONFIG_CRYPTO_SHA1_ARM_NEON=y
+CONFIG_CRYPTO_SHA1_ARM_CE=y
+CONFIG_CRYPTO_SHA2_ARM_CE=y
+CONFIG_CRYPTO_SHA512_ARM=y
+CONFIG_CRYPTO_BLAKE2S_ARM=y
+CONFIG_CRYPTO_BLAKE2B_NEON=m
+CONFIG_CRYPTO_AES_ARM=y
+CONFIG_CRYPTO_AES_ARM_BS=y
+CONFIG_CRYPTO_AES_ARM_CE=y
+CONFIG_CRYPTO_GHASH_ARM_CE=y
+CONFIG_CRYPTO_CRC32_ARM_CE=y
+CONFIG_CRYPTO_POLY1305_ARM=m
+CONFIG_CRYPTO_CURVE25519_NEON=m
+CONFIG_POWER_RESET=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_STRICT_DEVMEM=y
+
+# msm8909
+CONFIG_PINCTRL_MSM8909=y
+CONFIG_MSM_GCC_8909=y
diff --git a/arch/arm/mach-qcom/Kconfig b/arch/arm/mach-qcom/Kconfig
index f4765be1b2a0..85b06e4910d9 100644
--- a/arch/arm/mach-qcom/Kconfig
+++ b/arch/arm/mach-qcom/Kconfig
@@ -4,6 +4,7 @@ menuconfig ARCH_QCOM
 	depends on ARCH_MULTI_V7
 	select ARM_GIC
 	select ARM_AMBA
+	select IOMMU_DMA
 	select CLKSRC_QCOM
 	select HAVE_ARM_ARCH_TIMER
 	select PINCTRL
diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c
index 88c2d68a69c9..43b0cdced95b 100644
--- a/arch/arm/mm/dma-mapping.c
+++ b/arch/arm/mm/dma-mapping.c
@@ -1794,6 +1794,13 @@ void arch_teardown_dma_ops(struct device *dev)
 	set_dma_ops(dev, NULL);
 }
 
+#ifdef CONFIG_IOMMU_DMA
+void arch_dma_prep_coherent(struct page *page, size_t size)
+{
+	__dma_clear_buffer(page, size, NORMAL);
+}
+#endif
+
 void arch_sync_dma_for_device(phys_addr_t paddr, size_t size,
 		enum dma_data_direction dir)
 {
diff --git a/arch/arm64/boot/dts/qcom/Makefile b/arch/arm64/boot/dts/qcom/Makefile
index ae002c7cf126..6d951fbdd44f 100644
--- a/arch/arm64/boot/dts/qcom/Makefile
+++ b/arch/arm64/boot/dts/qcom/Makefile
@@ -1,4 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
+dtb-$(CONFIG_ARCH_QCOM)	+= apq8016-samsung-gtelwifiue.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= apq8016-samsung-matissevewifi.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= apq8016-sbc.dtb
 
 apq8016-sbc-usb-host-dtbs	:= apq8016-sbc.dtb apq8016-sbc-usb-host.dtbo
@@ -27,10 +29,14 @@ dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp453.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= ipq9574-rdp454.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8216-samsung-fortuna3g.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-acer-a1-724.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-alcatel-alto5-vdf.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-alcatel-idol347.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-ark-peach.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-asus-z00l.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-asus-z010d.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-gplus-fl8005a.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-huawei-g7.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-huawei-y635.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-lg-c50.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-lg-m216.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-longcheer-l8150.dtb
@@ -40,26 +46,32 @@ dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-motorola-osprey.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-motorola-surnia.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-mtp.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-a3u-eur.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-a5-zt.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-a5u-eur.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-e5.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-e7.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-fortunaltezt.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-gprimeltecan.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-grandmax.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-grandprimelte.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-gt510.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-gt58.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-heatqlte.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-j3ltetw.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-j5.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-j5x.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-rossa.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-on7.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-samsung-serranove.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-thwc-uf896.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-thwc-ufi001c.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-vivo-y21l.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-wingtech-wt86518.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-wingtech-wt86528.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-wingtech-wt88047.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8916-yiming-uz801v3.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8929-wingtech-wt82918hd.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= msm8939-alcatel-idol3.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8939-huawei-kiwi.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8939-longcheer-l9100.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= msm8939-samsung-a7.dtb
diff --git a/arch/arm64/boot/dts/qcom/apq8016-samsung-gtelwifiue.dts b/arch/arm64/boot/dts/qcom/apq8016-samsung-gtelwifiue.dts
new file mode 100644
index 000000000000..81993f8fa21d
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/apq8016-samsung-gtelwifiue.dts
@@ -0,0 +1,348 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/sound/apq8016-lpass.h>
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "Samsung Galaxy Tab E 9.6 (SM-T560NU)";
+	compatible = "samsung,gtelwifiue", "qcom,apq8016";
+	chassis-type = "tablet";
+
+	aliases {
+		mmc0 = &sdhc_1; /* eMMC */
+		mmc1 = &sdhc_2; /* SD card */
+		serial0 = &blsp_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		/* Additional memory used by Samsung firmware modifications */
+		tz-apps@85500000 {
+			reg = <0x0 0x85500000 0x0 0xb00000>;
+			no-map;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-0 = <&gpio_keys_default>;
+		pinctrl-names = "default";
+
+		label = "GPIO Buttons";
+
+		volume-up-button {
+			label = "Volume Up";
+			gpios = <&tlmm 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+
+		home-button {
+			label = "Home";
+			gpios = <&tlmm 109 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_HOMEPAGE>;
+		};
+	};
+
+	reg_vdd_tsp: regulator-vdd-tsp {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd_tsp";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&tlmm 73 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&reg_tsp_en_default>;
+		pinctrl-names = "default";
+
+		startup-delay-us = <150>;
+	};
+
+	reg_lcd: regulator-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "lcd";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&tlmm 8 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&reg_lcd_en_default>;
+		pinctrl-names = "default";
+
+		// FIXME: This breaks turning panel back on
+		regulator-always-on;
+		regulator-boot-on;
+		startup-delay-us = <150>;
+	};
+};
+
+&blsp_i2c1 {
+	status = "okay";
+
+	muic: extcon@25 {
+		compatible = "siliconmitus,sm5703-muic";
+		reg = <0x25>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <12 IRQ_TYPE_EDGE_FALLING>;
+
+		pinctrl-0 = <&muic_int_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	accelerometer@1d {
+		compatible = "st,lis2hh12";
+		reg = <0x1d>;
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l5>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <115 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "INT1";
+
+		st,drdy-int-pin = <1>;
+		mount-matrix = "0", "1", "0",
+				  "-1", "0", "0",
+				   "0", "0", "1";
+
+		pinctrl-0 = <&accel_int_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@20 {
+		compatible = "zinitix,zt7554", "zinitix,bt541";
+		reg = <0x20>;
+		interrupt-parent = <&tlmm>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+
+		touchscreen-size-x = <800>;
+		touchscreen-size-y = <1280>;
+		linux,keycodes = <KEY_APPSELECT KEY_BACK>;
+
+		vcca-supply = <&reg_vdd_tsp>;
+		vdd-supply = <&pm8916_l5>;
+
+		pinctrl-0 = <&tsp_int_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_uart2 {
+	status = "okay";
+};
+
+&gpu {
+	status = "okay";
+};
+
+&lpass {
+	status = "okay";
+};
+
+&lpass_codec {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	panel@0 {
+		compatible = "samsung,nt51017-b4p096wx5vp09";
+		reg = <0>;
+
+		lcd-supply = <&reg_lcd>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&pm8916_codec {
+	jack-gpios = <&tlmm 110 GPIO_ACTIVE_LOW>;
+	qcom,micbias-lvl = <2800>;
+
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+
+	pinctrl-0 = <&jack_default>;
+	pinctrl-names = "default";
+
+	status = "okay";
+};
+
+&pm8916_resin {
+	linux,code = <KEY_VOLUMEDOWN>;
+	status = "okay";
+};
+
+&pm8916_rpm_regulators {
+	pm8916_l17: l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+};
+
+&sdhc_1 {
+	status = "okay";
+};
+
+&sdhc_2 {
+	pinctrl-0 = <&sdc2_default &sdc2_cd_default>;
+	pinctrl-1 = <&sdc2_sleep &sdc2_cd_default>;
+	pinctrl-names = "default", "sleep";
+
+	cd-gpios = <&tlmm 38 GPIO_ACTIVE_LOW>;
+
+	status = "okay";
+};
+
+&sound {
+	pinctrl-0 = <&cdc_pdm_default>;
+	pinctrl-1 = <&cdc_pdm_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	model = "msm8916";
+	audio-routing =
+		"AMIC1", "MIC BIAS Internal1",
+		"AMIC2", "MIC BIAS Internal2";
+
+	status = "okay";
+
+	dai-link-primary {
+		link-name = "Primary MI2S";
+
+		cpu {
+			sound-dai = <&lpass MI2S_PRIMARY>;
+		};
+
+		codec {
+			sound-dai = <&lpass_codec 0>, <&pm8916_codec 0>;
+		};
+	};
+
+	dai-link-tertiary {
+		link-name = "Tertiary MI2S";
+
+		cpu {
+			sound-dai = <&lpass MI2S_TERTIARY>;
+		};
+
+		codec {
+			sound-dai = <&lpass_codec 1>, <&pm8916_codec 1>;
+		};
+	};
+};
+
+&usb {
+	extcon = <&muic>, <&muic>;
+	status = "okay";
+};
+
+&usb_hs_phy {
+	extcon = <&muic>;
+};
+
+&venus {
+	status = "okay";
+};
+
+&venus_mem {
+	status = "okay";
+};
+
+&wcnss {
+	status = "okay";
+};
+
+&wcnss_iris {
+	compatible = "qcom,wcn3660b";
+};
+
+&wcnss_mem {
+	status = "okay";
+};
+
+&tlmm {
+	accel_int_default: accel-int-default-state {
+		pins = "gpio115";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	jack_default: jack-default-state {
+		pins = "gpio110";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_keys_default: gpio-keys-default-state {
+		pins = "gpio107", "gpio109";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	muic_int_default: muic-int-default-state {
+		pins = "gpio12";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	reg_lcd_en_default: reg-lcd-en-default-state {
+		pins = "gpio8";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	reg_tsp_en_default: reg-tsp-en-default-state {
+		pins = "gpio73";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	sdc2_cd_default: sdc2-cd-default-state {
+		pins = "gpio38";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tsp_int_default: tsp-int-default-state {
+		pins = "gpio13";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/apq8016-samsung-matissevewifi.dts b/arch/arm64/boot/dts/qcom/apq8016-samsung-matissevewifi.dts
new file mode 100644
index 000000000000..be7631a969f4
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/apq8016-samsung-matissevewifi.dts
@@ -0,0 +1,465 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/sound/apq8016-lpass.h>
+
+/ {
+	model = "Samsung Galaxy Tab 4 10.1 WiFi (2015) (SM-T533)";
+	compatible = "samsung,matissevewifi", "qcom,apq8016";
+	chassis-type = "tablet";
+
+	aliases {
+		mmc0 = &sdhc_1; /* eMMC */
+		mmc1 = &sdhc_2; /* SD card */
+		serial0 = &blsp_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		/* Additional memory used by Samsung firmware modifications */
+		tz-apps@85500000 {
+			reg = <0x0 0x85500000 0x0 0xb00000>;
+			no-map;
+		};
+	};
+
+	speaker_codec: audio-codec {
+		compatible = "maxim,max98357a";
+		sdmode-gpios = <&tlmm 100 GPIO_ACTIVE_HIGH>;
+		#sound-dai-cells = <0>;
+	};
+
+	clk_pwm_backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&clk_pwm 0 100000>;
+
+		brightness-levels = <0 255>;
+		num-interpolated-steps = <255>;
+		default-brightness-level = <128>;
+	};
+
+	clk_pwm: pwm {
+		compatible = "clk-pwm";
+		#pwm-cells = <2>;
+
+		clocks = <&gcc GCC_GP3_CLK>;
+
+		pinctrl-0 = <&backlight_pwm_default>;
+		pinctrl-names = "default";
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-0 = <&gpio_keys_default>;
+		pinctrl-names = "default";
+
+		label = "GPIO Buttons";
+
+		volume-up-button {
+			label = "Volume Up";
+			gpios = <&tlmm 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+
+		home-button {
+			label = "Home";
+			gpios = <&tlmm 109 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_HOMEPAGE>;
+		};
+	};
+
+	reg_lcd: regulator-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "lcd";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+
+		gpio = <&tlmm 8 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		startup-delay-us = <500>;
+
+		pinctrl-0 = <&lcd_en_default>;
+		pinctrl-names = "default";
+	};
+
+	reg_lvds_1p2: regulator-lvds-1p2 {
+		compatible = "regulator-fixed";
+		regulator-name = "lvds_1p2";
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+
+		/* FIXME: Set up TC358764 DSI->LVDS bridge properly */
+		regulator-always-on;
+		regulator-boot-on;
+
+		gpio = <&tlmm 17 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		startup-delay-us = <200>;
+
+		pinctrl-0 = <&lvds_en_default>;
+		pinctrl-names = "default";
+	};
+
+	reg_lvds_1p8: regulator-lvds-1p8 {
+		compatible = "regulator-fixed";
+		regulator-name = "lvds_1p8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+
+		/* FIXME: Set up TC358764 DSI->LVDS bridge properly */
+		regulator-always-on;
+		regulator-boot-on;
+		startup-delay-us = <200>;
+
+		gpio = <&tlmm 17 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	reg_lvds_3p3: regulator-lvds-3p3 {
+		compatible = "regulator-fixed";
+		regulator-name = "lvds_3p3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		/* FIXME: Set up TC358764 DSI->LVDS bridge properly */
+		regulator-always-on;
+		regulator-boot-on;
+		startup-delay-us = <200>;
+
+		gpio = <&tlmm 17 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
+	reg_tsp_1p8v: regulator-tsp-1p8v {
+		compatible = "regulator-fixed";
+		regulator-name = "tsp_1p8v";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+
+		gpio = <&tlmm 73 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&tsp_en_default>;
+		pinctrl-names = "default";
+	};
+
+	reg_tsp_3p3v: regulator-tsp-3p3v {
+		compatible = "regulator-fixed";
+		regulator-name = "tsp_3p3v";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&tlmm 98 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&tsp_en1_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_i2c1 {
+	status = "okay";
+
+	muic: extcon@25 {
+		compatible = "siliconmitus,sm5502-muic";
+		reg = <0x25>;
+		interrupt-parent = <&tlmm>;
+		interrupts = <12 IRQ_TYPE_EDGE_FALLING>;
+		pinctrl-0 = <&muic_int_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	accelerometer@1d {
+		compatible = "st,lis2hh12";
+		reg = <0x1d>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <115 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "INT1";
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l5>;
+
+		st,drdy-int-pin = <1>;
+
+		pinctrl-0 = <&accel_int_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@4a {
+		compatible = "atmel,maxtouch";
+		reg = <0x4a>;
+		interrupt-parent = <&tlmm>;
+		interrupts = <13 IRQ_TYPE_LEVEL_LOW>;
+
+		vdd-supply = <&reg_tsp_1p8v>;
+		vdda-supply = <&reg_tsp_3p3v>;
+
+		reset-gpios = <&tlmm 114 GPIO_ACTIVE_LOW>;
+
+		pinctrl-0 = <&tsp_int_rst_default>;
+		pinctrl-names = "default";
+
+		/* The first 4 touch keys are never reported */
+		linux,keycodes = <0 0 0 0 KEY_APPSELECT KEY_BACK>;
+	};
+};
+
+&blsp_uart2 {
+	status = "okay";
+};
+
+&gpu {
+	status = "okay";
+};
+
+&lpass {
+	status = "okay";
+
+	dai@3 {
+		reg = <MI2S_QUATERNARY>;
+		qcom,playback-sd-lines = <1>;
+	};
+};
+
+&lpass_codec {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	panel@0 {
+		/* FIXME: Set up TC358764 DSI->LVDS bridge properly */
+		compatible = "samsung,tc358764-ltl101al06-simple";
+		reg = <0>;
+
+		power-supply = <&reg_lcd>;
+		backlight = <&clk_pwm_backlight>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&pm8916_codec {
+	jack-gpios = <&tlmm 110 GPIO_ACTIVE_LOW>;
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vtreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vtreshold-high = <75 150 237 450 500>;
+
+	pinctrl-0 = <&jack_default>;
+	pinctrl-names = "default";
+
+	status = "okay";
+};
+
+&pm8916_resin {
+	linux,code = <KEY_VOLUMEDOWN>;
+	status = "okay";
+};
+
+&pm8916_rpm_regulators {
+	pm8916_l17: l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+};
+
+&sdhc_1 {
+	status = "okay";
+};
+
+&sdhc_2 {
+	pinctrl-0 = <&sdc2_default &sdc2_cd_default>;
+	pinctrl-1 = <&sdc2_sleep &sdc2_cd_default>;
+	pinctrl-names = "default", "sleep";
+
+	cd-gpios = <&tlmm 38 GPIO_ACTIVE_LOW>;
+
+	status = "okay";
+};
+
+&sound {
+	pinctrl-0 = <&cdc_pdm_default &sec_mi2s_default>;
+	pinctrl-1 = <&cdc_pdm_sleep &sec_mi2s_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	model = "samsung-gt510";
+	audio-routing =
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS External1";
+
+	status = "okay";
+
+	dai-link-primary {
+		link-name = "Primary MI2S";
+
+		cpu {
+			sound-dai = <&lpass MI2S_PRIMARY>;
+		};
+
+		codec {
+			sound-dai = <&lpass_codec 0>, <&pm8916_codec 0>;
+		};
+	};
+
+	dai-link-tertiary {
+		link-name = "Tertiary MI2S";
+
+		cpu {
+			sound-dai = <&lpass MI2S_TERTIARY>;
+		};
+
+		codec {
+			sound-dai = <&lpass_codec 1>, <&pm8916_codec 1>;
+		};
+	};
+
+	dai-link-quaternary {
+		link-name = "Quaternary MI2S";
+
+		cpu {
+			sound-dai = <&lpass MI2S_QUATERNARY>;
+		};
+
+		codec {
+			sound-dai = <&speaker_codec>;
+		};
+	};
+};
+
+&usb {
+	extcon = <&muic>, <&muic>;
+	status = "okay";
+};
+
+&usb_hs_phy {
+	extcon = <&muic>;
+};
+
+&venus {
+	status = "okay";
+};
+
+&venus_mem {
+	status = "okay";
+};
+
+&wcnss {
+	status = "okay";
+};
+
+&wcnss_iris {
+	compatible = "qcom,wcn3660b";
+};
+
+&wcnss_mem {
+	status = "okay";
+};
+
+&tlmm {
+	accel_int_default: accel-int-default-state {
+		pins = "gpio115";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	backlight_pwm_default: backlight-pwm-default-state {
+		pins = "gpio51";
+		function = "gcc_gp3_clk_a";
+	};
+
+	gpio_keys_default: gpio-keys-default-state {
+		pins = "gpio107", "gpio109";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	jack_default: jack-default-state {
+		pins = "gpio110";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcd_en_default: lcd-en-default-state {
+		pins = "gpio8";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lvds_en_default: lvds-en-default-state {
+		pins = "gpio17";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	muic_int_default: muic-int-default-state {
+		pins = "gpio12";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	sdc2_cd_default: sdc2-cd-default-state {
+		pins = "gpio38";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tsp_en_default: tsp-en-default-state {
+		pins = "gpio73";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tsp_en1_default: tsp-en1-default-state {
+		pins = "gpio98";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tsp_int_rst_default: tsp-int-rst-default-state {
+		pins = "gpio13", "gpio114";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-acer-a1-724.dts b/arch/arm64/boot/dts/qcom/msm8916-acer-a1-724.dts
index b4ce14a79370..56ebe72c3eb1 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-acer-a1-724.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-acer-a1-724.dts
@@ -136,6 +136,39 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	panel@0 {
+		compatible = "acer,a1-724-hx8394d";
+		reg = <0>;
+
+		power-supply = <&pm8916_l17>;
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
 &mpss_mem {
 	reg = <0x0 0x86800000 0x0 0x4500000>;
 };
@@ -242,6 +275,22 @@ gpio_keys_default: gpio-keys-default-state {
 		bias-pull-up;
 	};
 
+	mdss_default: mdss-default-state {
+		pins = "gpio25";
+		function = "gpio";
+
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio25";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	sdc2_cd_default: sdc2-cd-default-state {
 		pins = "gpio38";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8916-alcatel-alto5-vdf.dts b/arch/arm64/boot/dts/qcom/msm8916-alcatel-alto5-vdf.dts
new file mode 100644
index 000000000000..c0f79a6f4b13
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-alcatel-alto5-vdf.dts
@@ -0,0 +1,106 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "Vodafone Smart prime 6 (alto5-vdf)";
+	compatible = "alcatel,alto5-vdf", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		mmc0 = &sdhc_1; /* eMMC */
+		mmc1 = &sdhc_2; /* SD card */
+		serial0 = &blsp_uart2;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-0 = <&gpio_keys_default>;
+		pinctrl-names = "default";
+
+		label = "GPIO Buttons";
+
+		volume-up-button {
+			label = "Volume Up";
+			gpios = <&tlmm 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+	};
+};
+
+&blsp_uart2 {
+	status = "okay";
+};
+
+&pm8916_resin {
+	linux,code = <KEY_VOLUMEDOWN>;
+	status = "okay";
+};
+
+&pm8916_usbin {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+};
+
+&sdhc_2 {
+	pinctrl-0 = <&sdc2_default &sdc2_cd_default>;
+	pinctrl-1 = <&sdc2_sleep &sdc2_cd_default>;
+	pinctrl-names = "default", "sleep";
+
+	cd-gpios = <&tlmm 38 GPIO_ACTIVE_HIGH>;
+
+	status = "okay";
+};
+
+&usb {
+	dr_mode = "peripheral";
+	extcon = <&pm8916_usbin>;
+	status = "okay";
+};
+
+&usb_hs_phy {
+	extcon = <&pm8916_usbin>;
+};
+
+&venus {
+	status = "okay";
+};
+
+&venus_mem {
+	status = "okay";
+};
+
+&wcnss {
+	status = "okay";
+};
+
+&wcnss_iris {
+	compatible = "qcom,wcn3620";
+};
+
+&wcnss_mem {
+	status = "okay";
+};
+
+&tlmm {
+	gpio_keys_default: gpio-keys-default-state {
+		pins = "gpio107";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	sdc2_cd_default: sdc2-cd-default-state {
+		pins = "gpio38";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-alcatel-idol347.dts b/arch/arm64/boot/dts/qcom/msm8916-alcatel-idol347.dts
index 3459145516a1..295dca8a74ae 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-alcatel-idol347.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-alcatel-idol347.dts
@@ -8,6 +8,7 @@
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>
 
 / {
 	model = "Alcatel OneTouch Idol 3 (4.7)";
@@ -37,6 +38,15 @@ rmtfs: rmtfs@86680000 {
 		};
 	};
 
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pm8916_pwm 0 100000>;
+
+		brightness-levels = <0 255>;
+		num-interpolated-steps = <255>;
+		default-brightness-level = <64>;
+	};
+
 	gpio-keys {
 		compatible = "gpio-keys";
 
@@ -84,6 +94,58 @@ usb_id: usb-id {
 	};
 };
 
+&blsp_i2c2 {
+	status = "okay";
+
+	charger: battery@14 {
+		compatible = "qcom,smb1360";
+		reg = <0x14>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <9 IRQ_TYPE_LEVEL_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&smb_int_default>;
+		qcom,otp-rslow-config = /bits/ 8 <0x0 0x0 0x0 0x0>;
+
+		qcom,float-voltage-mv = <4350>;
+		qcom,iterm-ma = <75>;
+		qcom,charging-timeout = <768>; /* 0 in downstream */
+		qcom,recharge-thresh-mv = <100>;
+		qcom,chg-inhibit-disabled;
+
+		qcom,battery-profile = <0>;
+		qcom,fg-batt-capacity-mah = <2000>;
+		qcom,fg-cc-soc-coeff = <0x8819>;
+		qcom,fg-cutoff-voltage-mv = <3400>;
+		qcom,fg-ibatt-standby-ma = <200>;
+		qcom,fg-cc-to-cv-mv = <4328>;
+		qcom,thermistor-c1-coeff = <0x86C8>;
+		qcom,fg-auto-recharge-soc = <95>; /* 99 in downstream */
+
+		qcom,otp-hard-jeita-config;
+		qcom,otp-hot-bat-decidegc = <550>;
+		qcom,otp-cold-bat-decidegc = <0>;
+
+		qcom,soft-jeita-config;
+		qcom,warm-bat-decidegc = <450>;
+		qcom,cool-bat-decidegc = <100>;
+		qcom,soft-jeita-comp-voltage-mv = <4100>;
+		qcom,soft-jeita-comp-current-ma = <550>;
+
+		qcom,shdn-after-pwroff;
+		qcom,fg-reset-at-pon;
+		qcom,fg-reset-threshold-mv = <200>;
+
+		/* Set by bootloader */
+		status = "disabled";
+
+		usb_otg_vbus: usb-otg-vbus {
+			regulator-max-microamp = <1500000>;
+		};
+	};
+};
+
 &blsp_i2c3 {
 	status = "okay";
 
@@ -169,6 +231,29 @@ accelerometer@f {
 			       "0", "0", "-1";
 	};
 
+	regulator@3e {
+		compatible = "ti,tps65132";
+		reg = <0x3e>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&tps65132_en_default>;
+
+		reg_lcd_pos: outp {
+			regulator-name = "outp";
+			regulator-min-microvolt = <5500000>;
+			regulator-max-microvolt = <5500000>;
+			enable-gpios = <&tlmm 2 GPIO_ACTIVE_HIGH>;
+			regulator-active-discharge = <1>;
+		};
+
+		reg_lcd_neg: outn {
+			regulator-name = "outn";
+			regulator-min-microvolt = <5500000>;
+			regulator-max-microvolt = <5500000>;
+			enable-gpios = <&tlmm 33 GPIO_ACTIVE_HIGH>;
+			regulator-active-discharge = <1>;
+		};
+	};
+
 	proximity@48 {
 		compatible = "sensortek,stk3310";
 		reg = <0x48>;
@@ -216,6 +301,47 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_active>;
+	pinctrl-1 = <&mdss_suspend>;
+
+	panel@0 {
+		compatible = "alcatel,idol347-panel";
+		reg = <0>;
+
+		backlight = <&backlight>;
+
+		vsp-supply = <&reg_lcd_pos>;
+		vsn-supply = <&reg_lcd_neg>;
+
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
 &mpss_mem {
 	reg = <0x0 0x86800000 0x0 0x5000000>;
 };
@@ -228,6 +354,12 @@ &pm8916_codec {
 	qcom,hphl-jack-type-normally-open;
 };
 
+&pm8916_pwm {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm_out>;
+};
+
 &pm8916_resin {
 	status = "okay";
 	linux,code = <KEY_VOLUMEDOWN>;
@@ -319,11 +451,12 @@ codec {
 
 &usb {
 	status = "okay";
-	extcon = <&usb_id>, <&usb_id>;
+	extcon = <&charger>, <&usb_id>;
+	vbus-supply = <&usb_otg_vbus>;
 };
 
 &usb_hs_phy {
-	extcon = <&usb_id>;
+	extcon = <&charger>;
 };
 
 &venus {
@@ -433,6 +566,22 @@ mag_reset_default: mag-reset-default-state {
 		bias-disable;
 	};
 
+	mdss_active: mdss-active-state {
+		pins = "gpio25";
+		function = "gpio";
+
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_suspend: mdss-suspend-state {
+		pins = "gpio25";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	proximity_int_default: proximity-int-default-state {
 		pins = "gpio12";
 		function = "gpio";
@@ -448,6 +597,14 @@ sdc2_cd_default: sdc2-cd-default-state {
 		bias-disable;
 	};
 
+	smb_int_default: smb-int-default-state {
+		pins = "gpio9";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
 	speaker_bottom_default: speaker-bottom-default-state {
 		pins = "gpio111";
 		function = "gpio";
@@ -462,6 +619,14 @@ speaker_top_default: speaker-top-default-state {
 		bias-disable;
 	};
 
+	tps65132_en_default: tps65132-en-default-state {
+		pins = "gpio2", "gpio33";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	ts_int_reset_default: ts-int-reset-default-state {
 		pins = "gpio13", "gpio100";
 		function = "gpio";
@@ -478,3 +643,13 @@ usb_id_default: usb-id-default-state {
 		bias-pull-up;
 	};
 };
+
+&pm8916_mpps {
+	pwm_out: mpp4-state {
+		pins = "mpp4";
+		function = "digital";
+		power-source = <PM8916_MPP_L5>;
+		output-low;
+		qcom,dtest = <1>;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-ark-peach.dts b/arch/arm64/boot/dts/qcom/msm8916-ark-peach.dts
new file mode 100644
index 000000000000..2f43fb5246ec
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-ark-peach.dts
@@ -0,0 +1,104 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "ARK Benefit A3";
+	compatible = "ark,peach", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		mmc0 = &sdhc_1; /* eMMC */
+		mmc1 = &sdhc_2; /* SD card */
+		serial0 = &blsp_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-0 = <&gpio_keys_default>;
+		pinctrl-names = "default";
+
+		label = "GPIO Buttons";
+
+		volume-up-button {
+			label = "Volume Up";
+			gpios = <&tlmm 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+
+		volume-down-button {
+			label = "Volume Down";
+			gpios = <&tlmm 108 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEDOWN>;
+		};
+	};
+};
+
+&blsp_uart2 {
+	status = "okay";
+};
+
+&pm8916_usbin {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+};
+
+&sdhc_2 {
+	pinctrl-0 = <&sdc2_default>;
+	pinctrl-1 = <&sdc2_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	non-removable;
+
+	status = "okay";
+};
+
+&usb {
+	extcon = <&pm8916_usbin>;
+	dr_mode = "peripheral";
+	status = "okay";
+};
+
+&usb_hs_phy {
+	extcon = <&pm8916_usbin>;
+};
+
+&venus {
+	status = "okay";
+};
+
+&venus_mem {
+	status = "okay";
+};
+
+&wcnss {
+	status = "okay";
+};
+
+&wcnss_iris {
+	compatible = "qcom,wcn3620";
+};
+
+&wcnss_mem {
+	status = "okay";
+};
+
+&tlmm {
+	gpio_keys_default: gpio-keys-default-state {
+		pins = "gpio107", "gpio108";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-asus-z00l.dts b/arch/arm64/boot/dts/qcom/msm8916-asus-z00l.dts
index 77618c7374df..05c016d701b0 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-asus-z00l.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-asus-z00l.dts
@@ -132,6 +132,43 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		compatible = "asus,z00l-panel";
+		reg = <0>;
+
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+		backlight-gpios = <&tlmm 21 GPIO_ACTIVE_HIGH>;
+		power-supply = <&pm8916_l8>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_bl_en_default>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
 &mpss_mem {
 	reg = <0x0 0x86800000 0x0 0x5500000>;
 };
@@ -218,6 +255,14 @@ imu_default: imu-default-state {
 		bias-disable;
 	};
 
+	lcd_bl_en_default: lcd-bl-en-default-state {
+		pins = "gpio21";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	mag_reset_default: mag-reset-default-state {
 		pins = "gpio112";
 		function = "gpio";
@@ -226,6 +271,22 @@ mag_reset_default: mag-reset-default-state {
 		bias-disable;
 	};
 
+	mdss_default: mdss-default-state {
+		pins = "gpio25";
+		function = "gpio";
+
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio25";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	sd_vmmc_en_default: sd-vmmc-en-default-state {
 		pins = "gpio87";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8916-asus-z010d.dts b/arch/arm64/boot/dts/qcom/msm8916-asus-z010d.dts
new file mode 100644
index 000000000000..fb0b88efdea9
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-asus-z010d.dts
@@ -0,0 +1,365 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include "msm8916-modem-qdsp6.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+
+/ {
+	model = "Asus Zenfone Max ZC550KL";
+	compatible = "asus,z010d", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		mmc0 = &sdhc_1; /* eMMC */
+		mmc1 = &sdhc_2; /* SD card */
+		serial0 = &blsp_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-0 = <&gpio_keys_default>;
+		pinctrl-names = "default";
+
+		label = "GPIO Buttons";
+
+		volume-up-button {
+			label = "Volume Up";
+			gpios = <&tlmm 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+			debounce-interval = <15>;
+		};
+	};
+
+	gpio-hall-sensor {
+		compatible = "gpio-keys";
+
+		pinctrl-0 = <&gpio_hall_sensor_default>;
+		pinctrl-names = "default";
+
+		label = "GPIO Hall Effect Sensor";
+
+		hall-sensor-switch {
+			label = "Hall Effect Sensor";
+			gpios = <&tlmm 115 GPIO_ACTIVE_LOW>;
+			linux,input-type = <EV_SW>;
+			linux,code = <SW_LID>;
+			linux,can-disable;
+		};
+	};
+
+	speaker_amp: audio-amplifier {
+		compatible = "awinic,aw8738";
+
+		pinctrl-0 = <&spk_ext_pa_default>;
+		pinctrl-names = "default";
+
+		mode-gpios = <&tlmm 112 GPIO_ACTIVE_HIGH>;
+		awinic,mode = <2>;
+		sound-name-prefix = "Speaker Amp";
+	};
+
+	usb_id: usb-id {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpios = <&tlmm 110 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&usb_id_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	accelerometer@e {
+		compatible = "kionix,kxtj21009";
+		reg = <0x0e>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <114 IRQ_TYPE_EDGE_FALLING>;
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+
+		pinctrl-0 = <&accel_int_default>;
+		pinctrl-names = "default";
+	};
+
+	magnetometer@c {
+		compatible = "asahi-kasei,ak09911";
+		reg = <0x0c>;
+
+		vdd-supply = <&pm8916_l17>;
+		vid-supply = <&pm8916_l6>;
+
+		reset-gpios = <&tlmm 36 GPIO_ACTIVE_LOW>;
+
+		pinctrl-0 = <&mag_reset_default>;
+		pinctrl-names = "default";
+	};
+
+	led-controller@45 {
+		compatible = "awinic,aw2013";
+		reg = <0x45>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		vcc-supply = <&pm8916_l17>;
+		vio-supply = <&pm8916_l6>;
+
+		led@0 {
+			reg = <0>;
+			led-max-microamp = <5000>;
+			function = LED_FUNCTION_INDICATOR;
+			color = <LED_COLOR_ID_GREEN>;
+		};
+
+		led@1 {
+			reg = <1>;
+			led-max-microamp = <5000>;
+			function = LED_FUNCTION_INDICATOR;
+			color = <LED_COLOR_ID_RED>;
+		};
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@38 {
+		/* Actually ft5x46 */
+		compatible = "edt,edt-ft5306";
+		reg = <0x38>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+
+		vcc-supply = <&pm8916_l17>;
+		iovcc-supply = <&pm8916_l6>;
+
+		reset-gpios = <&tlmm 12 GPIO_ACTIVE_LOW>;
+
+		touchscreen-size-x = <720>;
+		touchscreen-size-y = <1280>;
+
+		pinctrl-0 = <&touchscreen_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_uart2 {
+	status = "okay";
+};
+
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	panel@0 {
+		compatible = "asus,z010d-r69339";
+		reg = <0>;
+
+		power-supply = <&pm8916_l17>;
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&mpss_mem {
+	reg = <0x0 0x86800000 0x0 0x5500000>;
+};
+
+&pm8916_codec {
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+	qcom,hphl-jack-type-normally-open;
+};
+
+&pm8916_resin {
+	linux,code = <KEY_VOLUMEDOWN>;
+	status = "okay";
+};
+
+&pm8916_rpm_regulators {
+	pm8916_l17: l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+};
+
+&pm8916_vib {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+};
+
+&sdhc_2 {
+	pinctrl-0 = <&sdc2_default &sdc2_cd_default>;
+	pinctrl-1 = <&sdc2_sleep &sdc2_cd_default>;
+	pinctrl-names = "default", "sleep";
+
+	cd-gpios = <&tlmm 38 GPIO_ACTIVE_LOW>;
+
+	status = "okay";
+};
+
+&sound {
+	model = "bq-paella";
+	widgets =
+		"Speaker", "Speaker",
+		"Headphone", "Headphones";
+	pin-switches = "Speaker";
+	audio-routing =
+		"Speaker", "Speaker Amp OUT",
+		"Speaker Amp IN", "HPH_R",
+		"Headphones", "HPH_L",
+		"Headphones", "HPH_R",
+		"AMIC1", "MIC BIAS Internal1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS Internal3";
+	aux-devs = <&speaker_amp>;
+};
+
+&usb {
+	extcon = <&usb_id>, <&usb_id>;
+	status = "okay";
+};
+
+&usb_hs_phy {
+	extcon = <&usb_id>;
+};
+
+&venus {
+	status = "okay";
+};
+
+&venus_mem {
+	status = "okay";
+};
+
+&wcnss {
+	status = "okay";
+};
+
+&wcnss_iris {
+	compatible = "qcom,wcn3620";
+};
+
+&wcnss_mem {
+	status = "okay";
+};
+
+&tlmm {
+	accel_int_default: accel-int-default-state {
+		pins = "gpio114";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_hall_sensor_default: gpio-hall-sensor-default-state {
+		pins = "gpio115";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_keys_default: gpio-keys-default-state {
+		pins = "gpio107";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	mag_reset_default: mag-reset-default-state {
+		pins = "gpio36";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss_default: mdss-default-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable = <0>;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	sdc2_cd_default: sdc2-cd-default-state {
+		pins = "gpio38";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	spk_ext_pa_default: spk-ext-pa-default-state {
+		pins = "gpio112";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	touchscreen_default: touchscreen-default-state {
+		touchscreen-pins {
+			pins = "gpio13";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-pull-up;
+		};
+
+		reset-pins {
+			pins = "gpio12";
+			function = "gpio";
+			drive-strength = <2>;
+			bias-disable;
+		};
+	};
+
+	usb_id_default: usb-id-default-state {
+		pins = "gpio110";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-pull-up;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-gplus-fl8005a.dts b/arch/arm64/boot/dts/qcom/msm8916-gplus-fl8005a.dts
index f7be7e371820..d196944a809d 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-gplus-fl8005a.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-gplus-fl8005a.dts
@@ -8,6 +8,7 @@
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>
 
 / {
 	model = "GPLUS FL8005A";
@@ -24,6 +25,15 @@ chosen {
 		stdout-path = "serial0";
 	};
 
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pm8916_pwm 0 100000>;
+
+		brightness-levels = <0 255>;
+		num-interpolated-steps = <255>;
+		default-brightness-level = <255>;
+	};
+
 	battery: battery {
 		compatible = "simple-battery";
 		device-chemistry = "lithium-ion-polymer";
@@ -96,6 +106,17 @@ led-green {
 		};
 	};
 
+	reg_lcd: regulator-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "lcd";
+
+		gpio = <&tlmm 8 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&lcd_en_default>;
+		pinctrl-names = "default";
+	};
+
 	usb_id: usb-id {
 		compatible = "linux,extcon-usb-gpio";
 		id-gpios = <&tlmm 110 GPIO_ACTIVE_HIGH>;
@@ -134,6 +155,45 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	panel@0 {
+		compatible = "gplus,fl8005a-panel";
+		reg = <0>;
+
+		backlight = <&backlight>;
+		power-supply = <&reg_lcd>;
+
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&mdss {
+	status = "okay";
+};
+
 &mpss_mem {
 	reg = <0x0 0x86800000 0x0 0x5000000>;
 };
@@ -150,6 +210,12 @@ &pm8916_codec {
 	qcom,hphl-jack-type-normally-open;
 };
 
+&pm8916_pwm {
+	pinctrl-0 = <&pwm_out>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
 &pm8916_resin {
 	linux,code = <KEY_VOLUMEDOWN>;
 	status = "okay";
@@ -239,6 +305,27 @@ gpio_leds_default: gpio-led-default-state {
 		bias-disable;
 	};
 
+	lcd_en_default: lcd-en-default-state {
+		pins = "gpio8";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss_default: mdss-default-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	sdc2_cd_default: sdc2-cd-default-state {
 		pins = "gpio38";
 		function = "gpio";
@@ -269,3 +356,13 @@ usb_id_default: usb-id-default-state {
 		bias-pull-up;
 	};
 };
+
+&pm8916_mpps {
+	pwm_out: mpp4-state {
+		pins = "mpp4";
+		function = "digital";
+		power-source = <PM8916_MPP_VPH>;
+		output-low;
+		qcom,dtest = <1>;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-huawei-g7.dts b/arch/arm64/boot/dts/qcom/msm8916-huawei-g7.dts
index bf7fc89dd106..f591d741c4d8 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-huawei-g7.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-huawei-g7.dts
@@ -216,6 +216,10 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
 &lpass {
 	status = "okay";
 };
@@ -224,6 +228,40 @@ &lpass_codec {
 	status = "okay";
 };
 
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_active>;
+	pinctrl-1 = <&mdss_suspend>;
+
+	panel@0 {
+		compatible = "huawei,g7-panel";
+		reg = <0>;
+
+		vsp-supply = <&reg_lcd_pos>;
+		vsn-supply = <&reg_lcd_neg>;
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
 &pm8916_codec {
 	status = "okay";
 	qcom,micbias-lvl = <2800>;
@@ -389,6 +427,22 @@ mag_reset_default: mag-reset-default-state {
 		bias-disable;
 	};
 
+	mdss_active: mdss-active-state {
+		pins = "gpio25";
+		function = "gpio";
+
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_suspend: mdss-suspend-state {
+		pins = "gpio25";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	prox_irq_default: prox-irq-default-state {
 		pins = "gpio113";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8916-huawei-y635.dts b/arch/arm64/boot/dts/qcom/msm8916-huawei-y635.dts
new file mode 100644
index 000000000000..1fe68883a9a7
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-huawei-y635.dts
@@ -0,0 +1,348 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/sound/apq8016-lpass.h>
+
+/ {
+	model = "Huawei Y635";
+	compatible = "huawei,y635", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		mmc0 = &sdhc_1; /* eMMC */
+		mmc1 = &sdhc_2; /* SD card */
+		serial0 = &blsp_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-0 = <&gpio_keys_default>;
+		pinctrl-names = "default";
+
+		label = "GPIO Buttons";
+
+		volume-up-button {
+			label = "Volume Up";
+			gpios = <&tlmm 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+	};
+
+	bat: battery {
+		compatible = "simple-battery";
+		voltage-min-design-microvolt = <3400000>;
+		voltage-max-design-microvolt = <4350000>;
+		energy-full-design-microwatt-hours = <7600000>;
+		charge-full-design-microamp-hours = <2000000>;
+
+		ocv-capacity-celsius = <25>;
+		ocv-capacity-table-0 = <4331000 100>, <4261000 95>, <4204000 90>,
+			<4152000 85>, <4102000 80>, <4060000 75>, <3998000 70>,
+			<3964000 65>, <3924000 60>, <3874000 55>, <3842000 50>,
+			<3820000 45>, <3800000 40>, <3785000 35>, <3720000 30>,
+			<3758000 25>, <3735000 20>, <3706000 16>, <3690000 13>,
+			<3687000 11>, <3686000 10>, <3684000 9>, <3680000 8>,
+			<3668000 7>, <3640000 6>, <3596000 5>, <3542000 4>,
+			<3472000 3>, <3378000 2>, <3239000 1>, <3000000 0>;
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	accelerometer@18 {
+		compatible = "st,lis3dh-accel";
+		reg = <0x18>;
+		interrupt-parent = <&tlmm>;
+		interrupts = <115 IRQ_TYPE_EDGE_RISING>;
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+
+		pinctrl-0 = <&accel_int_default>;
+		pinctrl-names = "default";
+
+		mount-matrix =	"0", "-1", "0",
+				"-1", "0", "0",
+				"0", "0", "1";
+	};
+
+	proximity@39 {
+		compatible = "avago,apds9930";
+		reg = <0x39>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <113 IRQ_TYPE_EDGE_FALLING>;
+
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+
+		led-max-microamp = <100000>;
+		amstaos,proximity-diodes = <1>;
+
+		pinctrl-0 = <&prox_irq_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@26 {
+		compatible = "mstar,msg2138";
+		reg = <0x26>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+
+		reset-gpios = <&tlmm 12 GPIO_ACTIVE_LOW>;
+		pinctrl-0 = <&ts_int_reset_default>;
+		pinctrl-names = "default";
+
+		vdd-supply = <&pm8916_l16>;
+		vddio-supply = <&pm8916_l6>;
+
+		touchscreen-size-x = <2048>;
+		touchscreen-size-y = <2048>;
+
+		linux,keycodes = <KEY_BACK KEY_APPSELECT KEY_HOMEPAGE>;
+	};
+};
+
+&blsp_uart2 {
+	status = "okay";
+};
+
+&gpu {
+	status = "okay";
+};
+
+&lpass {
+	status = "okay";
+};
+
+&lpass_codec {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	panel@0 {
+		compatible = "huawei,y635-panel";
+		reg = <0>;
+
+		power-supply = <&pm8916_l17>;
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <1 2>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+&pm8916_bms {
+	monitored-battery = <&bat>;
+	power-supplies = <&pm8916_charger>;
+	status = "okay";
+};
+
+&pm8916_charger {
+	qcom,fast-charge-safe-current = <700000>;
+	qcom,fast-charge-safe-voltage = <4300000>;
+
+	monitored-battery = <&bat>;
+	status = "okay";
+};
+
+&pm8916_codec {
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+	qcom,hphl-jack-type-normally-open;
+	status = "okay";
+};
+
+&pm8916_l8 {
+	regulator-min-microvolt = <2950000>;
+	regulator-max-microvolt = <2950000>;
+};
+
+&pm8916_resin {
+	linux,code = <KEY_VOLUMEDOWN>;
+	status = "okay";
+};
+
+&pm8916_rpm_regulators {
+	pm8916_l16: l16 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+
+	pm8916_l17: l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+};
+
+&pm8916_vib {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+};
+
+&sdhc_2 {
+	pinctrl-0 = <&sdc2_default &sdc2_cd_default>;
+	pinctrl-1 = <&sdc2_sleep &sdc2_cd_default>;
+	pinctrl-names = "default", "sleep";
+
+	cd-gpios = <&tlmm 38 GPIO_ACTIVE_LOW>;
+
+	status = "okay";
+};
+
+&sound {
+	pinctrl-0 = <&cdc_pdm_default>;
+	pinctrl-1 = <&cdc_pdm_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	model = "msm8916";
+	audio-routing =
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS External1";
+
+	status = "okay";
+
+	dai-link-primary {
+		link-name = "Primary MI2S";
+
+		cpu {
+			sound-dai = <&lpass MI2S_PRIMARY>;
+		};
+
+		codec {
+			sound-dai = <&lpass_codec 0>, <&pm8916_codec 0>;
+		};
+	};
+
+	dai-link-tertiary {
+		link-name = "Tertiary MI2S";
+
+		cpu {
+			sound-dai = <&lpass MI2S_TERTIARY>;
+		};
+
+		codec {
+			sound-dai = <&lpass_codec 1>, <&pm8916_codec 1>;
+		};
+	};
+};
+
+&usb {
+	extcon = <&pm8916_charger>;
+	dr_mode = "peripheral";
+	status = "okay";
+};
+
+&usb_hs_phy {
+	extcon = <&pm8916_charger>;
+};
+
+&venus {
+	status = "okay";
+};
+
+&venus_mem {
+	status = "okay";
+};
+
+&wcnss {
+	status = "okay";
+};
+
+&wcnss_iris {
+	compatible = "qcom,wcn3620";
+};
+
+&wcnss_mem {
+	status = "okay";
+};
+
+&tlmm {
+	accel_int_default: accel-int-default-state {
+		pins = "gpio112";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_keys_default: gpio-keys-default-state {
+		pins = "gpio107";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	mdss_default: mdss-default-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	prox_irq_default: prox-irq-default-state {
+		pins = "gpio113";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	sdc2_cd_default: sdc2-cd-default-state {
+		pins = "gpio38";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	ts_int_reset_default: ts-int-reset-default-state {
+		pins = "gpio12", "gpio13";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-lg-c50.dts b/arch/arm64/boot/dts/qcom/msm8916-lg-c50.dts
index a823a1c40208..1fb83e164026 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-lg-c50.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-lg-c50.dts
@@ -62,6 +62,36 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	panel@0 {
+		compatible = "lg,c50-panel";
+		reg = <0>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
 &pm8916_usbin {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/qcom/msm8916-lg-m216.dts b/arch/arm64/boot/dts/qcom/msm8916-lg-m216.dts
index 07345e694f6f..5cbe5b485117 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-lg-m216.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-lg-m216.dts
@@ -115,6 +115,36 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	panel@0 {
+		compatible = "lg,m2db7400-incell-simple";
+		reg = <0>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
 &mpss_mem {
 	reg = <0x0 0x86800000 0x0 0x4a00000>;
 };
diff --git a/arch/arm64/boot/dts/qcom/msm8916-longcheer-l8150.dts b/arch/arm64/boot/dts/qcom/msm8916-longcheer-l8150.dts
index 7f0c2c1b8a94..719213a06b91 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-longcheer-l8150.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-longcheer-l8150.dts
@@ -9,6 +9,7 @@
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/interrupt-controller/irq.h>
 #include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>
 
 / {
 	model = "Longcheer L8150";
@@ -49,6 +50,15 @@ mpss_mem: mpss@8e800000 {
 		};
 	};
 
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pm8916_pwm 0 100000>;
+
+		brightness-levels = <0 255>;
+		num-interpolated-steps = <255>;
+		default-brightness-level = <255>;
+	};
+
 	battery: battery {
 		compatible = "simple-battery";
 		voltage-min-design-microvolt = <3400000>;
@@ -111,6 +121,26 @@ flash_led: led {
 			flash-max-timeout-us = <250000>;
 		};
 	};
+
+	usb_otg_hack: usb-otg-hack {
+		compatible = "linux,extcon-usb-gpio";
+
+		/*
+		 * NOTE: This allows detection of custom-made OTG adapters
+		 *
+		 * Since L8150 doesn't support OTG it's impossible to use normal OTG
+		 * adapters. However since USB_ID is in fact connected to GPIO it's
+		 * possible to detect custom-made OTG adapters that connect USB_ID
+		 * to 5v instead of GND and provie external power.
+		 *
+		 * Downside of this approach is that USB_ID pin is used to change boot
+		 * order of SoC and if device will be powered on with adapter attached
+		 * and powered, it will boot into USB BOOT mode.
+		 */
+		id-gpios = <&tlmm 37 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usb_id_default>;
+	};
 };
 
 &blsp_i2c1 {
@@ -248,6 +278,7 @@ rmi4-f01@1 {
 		rmi4-f12@12 {
 			reg = <0x12>;
 			syna,sensor-type = <1>; /* Touchscreen */
+			syna,no-pressure;
 		};
 	};
 };
@@ -256,6 +287,44 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		compatible = "longcheer,l8150-panel";
+		reg = <0>;
+
+		backlight = <&backlight>;
+		power-supply = <&pm8916_l17>;
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
 &pm8916_bms {
 	status = "okay";
 
@@ -279,6 +348,12 @@ &pm8916_codec {
 	qcom,hphl-jack-type-normally-open;
 };
 
+&pm8916_pwm {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm_out>;
+};
+
 &pm8916_resin {
 	status = "okay";
 	linux,code = <KEY_VOLUMEDOWN>;
@@ -313,8 +388,7 @@ &sound {
 
 &usb {
 	status = "okay";
-	dr_mode = "peripheral";
-	extcon = <&pm8916_charger>;
+	extcon = <&pm8916_charger>, <&usb_otg_hack>;
 };
 
 &usb_hs_phy {
@@ -398,6 +472,22 @@ magn_int_default: magn-int-default-state {
 		bias-disable;
 	};
 
+	mdss_default: mdss-default-state {
+		pins = "gpio25";
+		function = "gpio";
+
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio25";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	tp_int_default: tp-int-default-state {
 		pins = "gpio13";
 		function = "gpio";
@@ -405,4 +495,22 @@ tp_int_default: tp-int-default-state {
 		drive-strength = <2>;
 		bias-disable;
 	};
+
+	usb_id_default: usb-id-default-state {
+		pins = "gpio37";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+};
+
+&pm8916_mpps {
+	pwm_out: mpp4-state {
+		pins = "mpp4";
+		function = "digital";
+		power-source = <PM8916_MPP_VPH>;
+		output-low;
+		qcom,dtest = <1>;
+	};
 };
diff --git a/arch/arm64/boot/dts/qcom/msm8916-longcheer-l8910.dts b/arch/arm64/boot/dts/qcom/msm8916-longcheer-l8910.dts
index 2cc54eaf7202..2ed75fae68ef 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-longcheer-l8910.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-longcheer-l8910.dts
@@ -9,6 +9,7 @@
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/leds/common.h>
 #include <dt-bindings/pinctrl/qcom,pmic-gpio.h>
+#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>
 
 / {
 	model = "BQ Aquaris X5 (Longcheer L8910)";
@@ -35,6 +36,15 @@ speaker_amp: audio-amplifier {
 		pinctrl-names = "default";
 	};
 
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pm8916_pwm 0 100000>;
+
+		brightness-levels = <0 255>;
+		num-interpolated-steps = <255>;
+		default-brightness-level = <255>;
+	};
+
 	flash-led-controller {
 		compatible = "ocs,ocp8110";
 		enable-gpios = <&tlmm 49 GPIO_ACTIVE_HIGH>;
@@ -79,11 +89,24 @@ led-0 {
 		};
 	};
 
+	reg_ts_vcca: regulator-vcca-ts {
+		compatible = "regulator-fixed";
+		regulator-name = "regulator-vcca-ts";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+
+		gpio = <&tlmm 78 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&ts_vcca_default>;
+	};
+
 	usb_id: usb-id {
 		compatible = "linux,extcon-usb-gpio";
 		id-gpios = <&tlmm 110 GPIO_ACTIVE_HIGH>;
 		pinctrl-names = "default";
-		pinctrl-0 = <&usb_id_default>;
+		pinctrl-0 = <&usb_id_default &usb_id_switch_default>;
 	};
 };
 
@@ -176,10 +199,122 @@ imu@68 {
 	};
 };
 
+&blsp_i2c4 {
+	status = "okay";
+
+	charger: battery@14 {
+		compatible = "qcom,smb1360";
+		reg = <0x14>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <62 IRQ_TYPE_LEVEL_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&smb_int_default>;
+
+		qcom,rsense-10mohm;
+
+		qcom,float-voltage-mv = <4400>;
+		qcom,iterm-ma = <100>;
+		qcom,charging-timeout = <768>;
+		qcom,recharge-thresh-mv = <50>;
+		qcom,chg-inhibit-disabled;
+
+		qcom,battery-profile = <(-1)>; /* Set by bootloader */
+		qcom,fg-batt-capacity-mah = <2810>;
+		qcom,fg-cc-soc-coeff = <0x81D5>;
+		qcom,fg-cutoff-voltage-mv = <3400>;
+		qcom,fg-iterm-ma = <100>;
+		qcom,fg-ibatt-standby-ma = <200>;
+		qcom,fg-cc-to-cv-mv = <4397>;
+		qcom,thermistor-c1-coeff = <0x86C2>;
+		qcom,fg-auto-recharge-soc = <95>; /* 97 in downstream */
+
+		qcom,otp-hard-jeita-config;
+		qcom,otp-hot-bat-decidegc = <500>;
+		qcom,otp-cold-bat-decidegc = <(-50)>;
+
+		qcom,shdn-after-pwroff;
+		qcom,fg-reset-at-pon;
+		qcom,fg-reset-threshold-mv = <200>;
+
+		/*
+		 * Some properties are battery-specific. Battery detection
+		 * happens in the bootloader, so it will fill those appropriately
+		 * and set status = "okay".
+		 */
+		status = "disabled";
+
+		usb_otg_vbus: usb-otg-vbus {
+			regulator-max-microamp = <1500000>;
+		};
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@48 {
+		compatible = "himax,hx8527e", "himax,hx852es";
+		reg = <0x48>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <13 IRQ_TYPE_LEVEL_LOW>;
+
+		reset-gpios = <&tlmm 12 GPIO_ACTIVE_LOW>;
+
+		vcca-supply = <&reg_ts_vcca>;
+		vccd-supply = <&pm8916_l6>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&ts_int_reset_default>;
+
+		linux,keycodes = <KEY_BACK KEY_HOMEPAGE KEY_APPSELECT>;
+	};
+};
+
 &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_active>;
+	pinctrl-1 = <&mdss_suspend>;
+
+	panel@0 {
+		compatible = "longcheer,l8910-panel";
+		reg = <0>;
+
+		backlight = <&backlight>;
+		power-supply = <&pm8916_l17>;
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
 &mpss_mem {
 	reg = <0x0 0x86800000 0x0 0x5000000>;
 };
@@ -201,6 +336,12 @@ status_led_default: status-led-default-state {
 	};
 };
 
+&pm8916_pwm {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm_out>;
+};
+
 &pm8916_resin {
 	status = "okay";
 	linux,code = <KEY_VOLUMEDOWN>;
@@ -255,11 +396,12 @@ &sound {
 
 &usb {
 	status = "okay";
-	extcon = <&usb_id>, <&usb_id>;
+	extcon = <&charger>, <&usb_id>;
+	vbus-supply = <&usb_otg_vbus>;
 };
 
 &usb_hs_phy {
-	extcon = <&usb_id>;
+	extcon = <&charger>;
 };
 
 &venus {
@@ -321,6 +463,20 @@ mag_reset_default: mag-reset-default-state {
 		bias-disable;
 	};
 
+	mdss_active: mdss-active-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_suspend: mdss-suspend-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	sdc2_cd_default: sdc2-cd-default-state {
 		pins = "gpio38";
 		function = "gpio";
@@ -328,6 +484,13 @@ sdc2_cd_default: sdc2-cd-default-state {
 		bias-disable;
 	};
 
+	smb_int_default: smb-int-default-state {
+		pins = "gpio62";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
 	spk_ext_pa_default: spk-ext-pa-default-state {
 		pins = "gpio114";
 		function = "gpio";
@@ -335,6 +498,22 @@ spk_ext_pa_default: spk-ext-pa-default-state {
 		bias-disable;
 	};
 
+	ts_int_reset_default: ts-int-reset-default-state {
+		pins = "gpio12", "gpio13";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	ts_vcca_default: ts-vcca-default-state {
+		pins = "gpio78";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	usb_id_default: usb-id-default-state {
 		pins = "gpio110";
 		function = "gpio";
@@ -342,4 +521,21 @@ usb_id_default: usb-id-default-state {
 		drive-strength = <8>;
 		bias-pull-up;
 	};
+
+	usb_id_switch_default: usb-id-switch-default-state {
+		function = "gpio";
+		pins = "gpio121";
+		drive-strength = <2>;
+		output-high;
+	};
+};
+
+&pm8916_mpps {
+	pwm_out: mpp4-state {
+		pins = "mpp4";
+		function = "digital";
+		power-source = <PM8916_MPP_VPH>;
+		output-low;
+		qcom,dtest = <1>;
+	};
 };
diff --git a/arch/arm64/boot/dts/qcom/msm8916-modem-qdsp6.dtsi b/arch/arm64/boot/dts/qcom/msm8916-modem-qdsp6.dtsi
index 039961622633..1c6286160ee7 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-modem-qdsp6.dtsi
+++ b/arch/arm64/boot/dts/qcom/msm8916-modem-qdsp6.dtsi
@@ -8,6 +8,7 @@
 
 #include <dt-bindings/sound/qcom,q6afe.h>
 #include <dt-bindings/sound/qcom,q6asm.h>
+#include <dt-bindings/sound/qcom,q6voice.h>
 
 &apr {
 	status = "okay";
@@ -21,6 +22,10 @@ &bam_dmux_dma {
 	status = "okay";
 };
 
+&gps_mem {
+	status = "okay";
+};
+
 &lpass {
 	status = "reserved"; /* Controlled by QDSP6 */
 };
@@ -33,6 +38,10 @@ &mba_mem {
 	status = "okay";
 };
 
+&memshare {
+	status = "okay";
+};
+
 &mpss {
 	status = "okay";
 };
@@ -118,6 +127,14 @@ cpu {
 		};
 	};
 
+	frontend4-dai-link {
+		link-name = "CS-Voice";
+
+		cpu {
+			sound-dai = <&q6voicedai CS_VOICE>;
+		};
+	};
+
 	sound_link_backend0: backend0-dai-link {
 		link-name = "Primary MI2S";
 
diff --git a/arch/arm64/boot/dts/qcom/msm8916-motorola-harpia.dts b/arch/arm64/boot/dts/qcom/msm8916-motorola-harpia.dts
index 8380451ebbf6..25c9ee54f5e0 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-motorola-harpia.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-motorola-harpia.dts
@@ -8,6 +8,39 @@ / {
 	model = "Motorola Moto G4 Play";
 	compatible = "motorola,harpia", "qcom,msm8916";
 	chassis-type = "handset";
+
+	/*
+	 * harpia uses a NT50358 regulator to drive the display panel.
+	 * This regulator is apparently compatible with the TPS65132, except for
+	 * some differences with the enable lines, according to the downstream
+	 * kernel.
+	 * (https://github.com/MotorolaMobilityLLC/kernel-msm/blob/nougat-7.1.1-release-harpia/arch/arm/boot/dts/qcom/msm8916-harpia.dtsi#L202)
+	 * TODO: figure out what needs to be done to get a proper driver working
+	 * for this regulator. For now, we can just use fixed-regulator, as the
+	 * regulator reads voltages on startup from an onboard EEPROM, and we
+	 * don't need to adjust the regulator's values.
+	 */
+	nt50358_pos: nt50358-pos {
+		compatible = "regulator-fixed";
+		regulator-name = "nt50358-pos";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&tlmm 97 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-0 = <&lcd_p_en_default>;
+		pinctrl-names = "default";
+	};
+
+	nt50358_neg: nt50358-neg {
+		compatible = "regulator-fixed";
+		regulator-name = "nt50358-neg";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&tlmm 98 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-0 = <&lcd_n_en_default>;
+		pinctrl-names = "default";
+	};
 };
 
 &blsp_i2c1 {
@@ -56,6 +89,48 @@ accelerometer@19 {
 	/* proximity@49 */
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	panel@0 {
+		compatible = "motorola,harpia-panel";
+		reg = <0>;
+
+		vsp-supply = <&nt50358_pos>;
+		vsn-supply = <&nt50358_neg>;
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+		backlight-gpios = <&tlmm 37 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-0 = <&lcd_bl_en_default>;
+		pinctrl-names = "default";
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
 &pm8916_codec {
 	qcom,micbias-lvl = <2800>;
 	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
@@ -131,6 +206,41 @@ headset_switch_supply_en: headset-switch-supply-en-state {
 		output-high;
 	};
 
+	lcd_bl_en_default: lcd-bl-en-default-state {
+		pins = "gpio37";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcd_p_en_default: lcd-p-en-default-state {
+		pins = "gpio97";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcd_n_en_default: lcd-n-en-default-state {
+		pins = "gpio98";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss_default: mdss-default-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	sdc2_cd_default: sdc2-cd-default-state {
 		pins = "gpio118";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8916-motorola-osprey.dts b/arch/arm64/boot/dts/qcom/msm8916-motorola-osprey.dts
index ec5589fc69bd..7292f63486ac 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-motorola-osprey.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-motorola-osprey.dts
@@ -3,12 +3,24 @@
 /dts-v1/;
 
 #include "msm8916-motorola-common.dtsi"
+#include <dt-bindings/pinctrl/qcom,pmic-gpio.h>
 
 / {
 	model = "Motorola Moto G 2015";
 	compatible = "motorola,osprey", "qcom,msm8916";
 	chassis-type = "handset";
 
+	reg_panel_vddio: regulator-panel-vddio {
+		compatible = "regulator-fixed";
+		regulator-name = "vddio_panel";
+		gpio = <&tlmm 36 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-0 = <&panel_vddio_default>;
+		pinctrl-names = "default";
+		startup-delay-us = <300>;
+		regulator-boot-on;
+	};
+
 	reg_touch_vdda: regulator-touch-vdda {
 		compatible = "regulator-fixed";
 		regulator-name = "touch_vdda";
@@ -40,12 +52,76 @@ battery@36 {
 		maxim,over-volt = <4500>;
 
 	};
+
+	regulator@3e {
+		compatible = "ti,tps65132";
+		reg = <0x3e>;
+
+		pinctrl-0 = <&disp_en_default>;
+		pinctrl-names = "default";
+
+		reg_lcd_pos: outp {
+			regulator-name = "outp";
+			regulator-min-microvolt = <5500000>;
+			regulator-max-microvolt = <5500000>;
+			enable-gpios = <&pm8916_gpios 3 GPIO_ACTIVE_HIGH>;
+			regulator-active-discharge = <1>;
+		};
+
+		reg_lcd_neg: outn {
+			regulator-name = "outn";
+			regulator-min-microvolt = <5500000>;
+			regulator-max-microvolt = <5500000>;
+			enable-gpios = <&pm8916_gpios 4 GPIO_ACTIVE_HIGH>;
+			regulator-active-discharge = <1>;
+		};
+	};
 };
 
 &blsp_i2c6 {
 	/* magnetometer@c */
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	panel@0 {
+		compatible = "motorola,osprey-panel";
+		reg = <0>;
+
+		vsp-supply = <&reg_lcd_pos>;
+		vsn-supply = <&reg_lcd_neg>;
+		vddio-supply = <&reg_panel_vddio>;
+
+		reset-gpios = <&tlmm 78 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
 &pm8916_codec {
 	qcom,micbias1-ext-cap;
 	qcom,micbias2-ext-cap;
@@ -82,6 +158,27 @@ battery_alert_default: battery-alert-default-state {
 		bias-pull-up;
 	};
 
+	mdss_default: mdss-default-state {
+		pins = "gpio78";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio78";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	panel_vddio_default: panel-vddio-default-state {
+		pins = "gpio36";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	sdc2_cd_default: sdc2-cd-default-state {
 		pins = "gpio25";
 		function = "gpio";
@@ -103,3 +200,12 @@ touch_vdda_default: touch-vdda-default-state {
 		bias-disable;
 	};
 };
+
+&pm8916_gpios {
+	disp_en_default: disp-en-default-state {
+		pins = "gpio3", "gpio4";
+		function = PMIC_GPIO_FUNC_NORMAL;
+		power-source = <PM8916_GPIO_L2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-motorola-surnia.dts b/arch/arm64/boot/dts/qcom/msm8916-motorola-surnia.dts
index eecf78ba45bb..3041f814069f 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-motorola-surnia.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-motorola-surnia.dts
@@ -31,11 +31,55 @@ battery@36 {
 	};
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	panel@0 {
+		compatible = "motorola,surnia-panel";
+		reg = <0>;
+
+		power-supply = <&pm8916_l17>;
+		reset-gpios = <&tlmm 78 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
 &pm8916_codec {
 	qcom,micbias1-ext-cap;
 	qcom,micbias2-ext-cap;
 };
 
+&pm8916_rpm_regulators {
+	pm8916_l17: l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+};
+
 &sdhc_2 {
 	pinctrl-0 = <&sdc2_default &sdc2_cd_default>;
 	pinctrl-1 = <&sdc2_sleep &sdc2_cd_default>;
@@ -67,6 +111,20 @@ battery_alert_default: battery-alert-default-state {
 		bias-pull-up;
 	};
 
+	mdss_default: mdss-default-state {
+		pins = "gpio78";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio78";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	sdc2_cd_default: sdc2-cd-default-state {
 		pins = "gpio25";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-a2015-common.dtsi b/arch/arm64/boot/dts/qcom/msm8916-samsung-a2015-common.dtsi
index e6355e5e2177..9eac269d3665 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-a2015-common.dtsi
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-a2015-common.dtsi
@@ -341,6 +341,16 @@ &mpss_mem {
 	reg = <0x0 0x86800000 0x0 0x5400000>;
 };
 
+&pm8916_codec {
+	jack-gpios = <&tlmm 110 GPIO_ACTIVE_LOW>;
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&jack_default>;
+};
+
 &pm8916_resin {
 	status = "okay";
 	linux,code = <KEY_VOLUMEDOWN>;
@@ -450,6 +460,14 @@ gpio_hall_sensor_default: gpio-hall-sensor-default-state {
 		bias-disable;
 	};
 
+	jack_default: jack-default-state {
+		pins = "gpio110";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	mdss_default: mdss-default-state {
 		pins = "gpio25";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-a5-zt.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-a5-zt.dts
new file mode 100644
index 000000000000..017cee790f3c
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-a5-zt.dts
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-samsung-a5u-eur.dts"
+
+/ {
+	model = "Samsung Galaxy A5 (SM-A500YZ)";
+	compatible = "samsung,a5-zt", "samsung,a5u-eur", "qcom,msm8916";
+	chassis-type = "handset";
+
+	/* NOTE: a5-zt doesn't actually have an NFC chip. */
+	i2c-nfc {
+		status = "disabled";
+	};
+};
+
+&accelerometer {
+	mount-matrix = "0", "1", "0",
+			"1", "0", "0",
+			"0", "0", "1";
+};
+
+&reg_touch_key {
+	gpio = <&tlmm 60 GPIO_ACTIVE_HIGH>;
+};
+
+&tkey_en_default {
+	pins = "gpio60";
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-a5u-eur.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-a5u-eur.dts
index fe39be7a742b..48298862a91b 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-a5u-eur.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-a5u-eur.dts
@@ -9,6 +9,32 @@ / {
 	compatible = "samsung,a5u-eur", "qcom,msm8916";
 	chassis-type = "handset";
 
+	reg_vlcd_vdd3: regulator-vlcd-vdd3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vlcd_vdd3";
+		regulator-boot-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&pm8916_s4>;
+
+		gpio = <&tlmm 87 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_on_default>;
+	};
+
+	reg_vlcd_vci: regulator-vlcd-vci {
+		compatible = "regulator-fixed";
+		regulator-name = "vlcd_vci";
+		regulator-boot-on;
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3000000>;
+
+		gpio = <&tlmm 87 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+
 	reg_touch_key: regulator-touch-key {
 		compatible = "regulator-fixed";
 		regulator-name = "touch_key";
@@ -60,6 +86,28 @@ &clk_pwm {
 	status = "okay";
 };
 
+&mdss_dsi0 {
+	panel@0 {
+		compatible = "samsung,ea8061v-ams497ee01";
+		reg = <0>;
+
+		vdd3-supply = <&reg_vlcd_vdd3>;
+		vci-supply = <&reg_vlcd_vci>;
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
 &touchkey {
 	vcc-supply = <&reg_touch_key>;
 	vdd-supply = <&reg_touch_key>;
@@ -82,6 +130,14 @@ &wcnss_mem {
 };
 
 &tlmm {
+	lcd_on_default: lcd-on-default-state {
+		pins = "gpio87";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	tkey_en_default: tkey-en-default-state {
 		pins = "gpio97";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-e2015-common.dtsi b/arch/arm64/boot/dts/qcom/msm8916-samsung-e2015-common.dtsi
index c50f81a68897..cad5bda45408 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-e2015-common.dtsi
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-e2015-common.dtsi
@@ -71,6 +71,25 @@ accelerometer@1d {
 	};
 };
 
+&mdss_dsi0 {
+	panel: panel@0 {
+		reg = <0>;
+
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
 &mpss_mem {
 	reg = <0x0 0x86800000 0x0 0x5a00000>;
 };
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-e7.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-e7.dts
index ec1debd2e245..9937dcc19f8a 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-e7.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-e7.dts
@@ -21,6 +21,43 @@ / {
 	model = "Samsung Galaxy E7";
 	compatible = "samsung,e7", "qcom,msm8916";
 	chassis-type = "handset";
+
+	reg_vdd_tsp: regulator-vdd-tsp {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd_tsp";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+
+		gpio = <&tlmm 60 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&tsp_en_1p8_default>;
+		pinctrl-names = "default";
+	};
+
+	reg_vlcd_vdd3: regulator-vlcd-vdd3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vlcd_vdd3";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&pm8916_s4>;
+
+		gpio = <&tlmm 87 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_en_default>;
+	};
+
+	reg_vlcd_vci: regulator-vlcd-vci {
+		compatible = "regulator-fixed";
+		regulator-name = "vlcd_vci";
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3000000>;
+
+		gpio = <&tlmm 87 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
 };
 
 &battery {
@@ -29,8 +66,52 @@ &battery {
 	constant-charge-voltage-max-microvolt = <4350000>;
 };
 
+&blsp_i2c5 {
+	status = "okay";
+
+	touchscreen@49 {
+		compatible = "st,stmfts";
+		reg = <0x49>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <13 IRQ_TYPE_EDGE_FALLING>;
+
+		touchscreen-size-x = <720>;
+		touchscreen-size-y = <1280>;
+
+		avdd-supply = <&reg_vdd_tsp_a>;
+		vdd-supply = <&reg_vdd_tsp>;
+
+		pinctrl-0 = <&ts_int_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&panel {
+	compatible = "samsung,e7-panel";
+
+	vdd3-supply = <&reg_vlcd_vdd3>;
+	vci-supply = <&reg_vlcd_vci>;
+};
 
 &pm8916_l17 {
 	regulator-min-microvolt = <3000000>;
 	regulator-max-microvolt = <3000000>;
 };
+
+&tlmm {
+	lcd_en_default: lcd-en-default-state {
+		pins = "gpio87";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	tsp_en_1p8_default: tsp-en-1p8-default-state {
+		pins = "gpio60";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-fortuna-common.dtsi b/arch/arm64/boot/dts/qcom/msm8916-samsung-fortuna-common.dtsi
index 7a7e99b015d9..2dcb429dd853 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-fortuna-common.dtsi
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-fortuna-common.dtsi
@@ -112,6 +112,21 @@ s3fwrn5_nfc: nfc@27 {
 
 			status = "disabled";
 		};
+
+		pn547_nfc: nfc@2b {
+			compatible = "nxp,pn547", "nxp,nxp-nci-i2c";
+			reg = <0x2b>;
+
+			interrupts-extended = <&tlmm 21 IRQ_TYPE_EDGE_RISING>;
+
+			enable-gpios = <&tlmm 20 GPIO_ACTIVE_HIGH>;
+			firmware-gpios = <&tlmm 49 GPIO_ACTIVE_HIGH>;
+
+			pinctrl-0 = <&nfc_default>;
+			pinctrl-names = "default";
+
+			status = "disabled";
+		};
 	};
 
 	reg_motor_vdd: regulator-motor-vdd {
@@ -127,6 +142,19 @@ reg_motor_vdd: regulator-motor-vdd {
 		pinctrl-names = "default";
 	};
 
+	reg_vdd_lcd: regulator-vdd-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd_lcd";
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3000000>;
+
+		gpio = <&tlmm 102 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&lcd_on_default>;
+		pinctrl-names = "default";
+	};
+
 	reg_vdd_tsp_a: regulator-vdd-tsp-a {
 		compatible = "regulator-fixed";
 		regulator-name = "vdd_tsp_a";
@@ -307,10 +335,56 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	panel: panel@0 {
+		compatible = "samsung,gprime-panel";
+		reg = <0>;
+
+		vddio-supply = <&pm8916_l6>;
+		vdd-supply = <&reg_vdd_lcd>;
+
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+		backlight = <&clk_pwm_backlight>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1>;
+	remote-endpoint = <&panel_in>;
+};
+
 &mpss_mem {
 	reg = <0x0 0x86800000 0x0 0x5000000>;
 };
 
+&pm8916_codec {
+	jack-gpios = <&tlmm 110 GPIO_ACTIVE_LOW>;
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+
+	pinctrl-0 = <&jack_default>;
+	pinctrl-names = "default";
+};
+
 &pm8916_resin {
 	linux,code = <KEY_VOLUMEDOWN>;
 	status = "okay";
@@ -408,6 +482,34 @@ gpio_keys_default: gpio-keys-default-state {
 		bias-pull-up;
 	};
 
+	jack_default: jack-default-state {
+		pins = "gpio110";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcd_on_default: lcd-on-default-state {
+		pins = "gpio102";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss_default: mdss-default-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	motor_en_default: motor-en-default-state {
 		pins = "gpio72";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-fortunaltezt.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-fortunaltezt.dts
new file mode 100644
index 000000000000..b78019665e9e
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-fortunaltezt.dts
@@ -0,0 +1,57 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-samsung-fortuna-common.dtsi"
+
+/*
+ * NOTE: The original firmware from Samsung can only boot ARM32 kernels.
+ * Unfortunately, the firmware is signed and cannot be replaced easily.
+ * There seems to be no way to boot ARM64 kernels on this device at the moment,
+ * even though the hardware would support it.
+ *
+ * However, it is possible to use this device tree by compiling an ARM32 kernel
+ * instead. For clarity and build testing this device tree is maintained next
+ * to the other MSM8916 device trees. However, it is actually used through
+ * arch/arm/boot/dts/qcom-msm8916-samsung-fortunaltezt.dts
+ */
+
+/ {
+	model = "Samsung Galaxy Grand Prime (SM-G530Y)";
+	compatible = "samsung,fortunaltezt", "samsung,fortuna", "qcom,msm8916";
+	chassis-type = "handset";
+};
+
+&battery {
+	charge-term-current-microamp = <200000>;
+	constant-charge-current-max-microamp = <1000000>;
+	constant-charge-voltage-max-microvolt = <4350000>;
+};
+
+/* On fortunaltezt backlight is controlled with MIPI DCS commands */
+&clk_pwm {
+	status = "disabled";
+};
+
+&clk_pwm_backlight {
+	status = "disabled";
+};
+
+&panel {
+	/* Actually hx8389c without PWM. There is no other variant */
+	compatible = "samsung,hx8389c-gh9607501a";
+
+	/delete-property/ backlight;
+};
+
+&pn547_nfc {
+	status = "okay";
+};
+
+&st_accel {
+	compatible = "st,lis2hh12";
+	mount-matrix = "1",  "0", "0",
+		       "0", "-1", "0",
+		       "0",  "0", "1";
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-grandmax.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-grandmax.dts
index 5ddb69bf8e78..3579fb194408 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-grandmax.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-grandmax.dts
@@ -39,6 +39,45 @@ led-keyled {
 			pinctrl-0 = <&gpio_leds_default>;
 		};
 	};
+
+	reg_vlcd_vcc: regulator-vlcd-vcc {
+		compatible = "regulator-fixed";
+		regulator-name = "vlcd_vcc";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+
+		gpio = <&tlmm 16 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_on_default>;
+	};
+
+	reg_vsp: regulator-vsp {
+		compatible = "regulator-fixed";
+		regulator-name = "reg-vsp";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+
+		gpio = <&tlmm 97 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_enp_default>;
+	};
+
+	reg_vsn: regulator-vsn {
+		compatible = "regulator-fixed";
+		regulator-name = "reg-vsn";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+
+		gpio = <&tlmm 120 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&lcd_enn_default>;
+	};
 };
 
 &battery {
@@ -69,6 +108,19 @@ touchscreen@50 {
 	};
 };
 
+&panel {
+	compatible = "samsung,s6d2aa0x62-lpm053a250a";
+
+	vcc-supply = <&reg_vlcd_vcc>;
+	vsp-supply = <&reg_vsp>;
+	vsn-supply = <&reg_vsn>;
+
+	backlight-gpios = <&tlmm 98 GPIO_ACTIVE_HIGH>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&lcd_bl_en_default>;
+};
+
 &reg_motor_vdd {
 	gpio = <&tlmm 72 GPIO_ACTIVE_HIGH>;
 };
@@ -89,6 +141,38 @@ gpio_leds_default: gpio-led-default-state {
 		drive-strength = <2>;
 		bias-disable;
 	};
+
+	lcd_bl_en_default: lcd-bl-en-default-state {
+		pins = "gpio98";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcd_enp_default: lcd-enp-default-state {
+		pins = "gpio97";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcd_enn_default: lcd-enn-default-state {
+		pins = "gpio120";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcd_on_default: lcd-on-default-state {
+		pins = "gpio16";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
 };
 
 &motor_en_default {
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-gt5-common.dtsi b/arch/arm64/boot/dts/qcom/msm8916-samsung-gt5-common.dtsi
index fbd2caf405d5..3e5b03237e2c 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-gt5-common.dtsi
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-gt5-common.dtsi
@@ -142,6 +142,16 @@ &mpss_mem {
 	reg = <0x0 0x86800000 0x0 0x5400000>;
 };
 
+&pm8916_codec {
+	jack-gpios = <&tlmm 110 GPIO_ACTIVE_LOW>;
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vtreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vtreshold-high = <75 150 237 450 500>;
+
+	pinctrl-0 = <&jack_default>;
+	pinctrl-names = "default";
+};
+
 &pm8916_resin {
 	linux,code = <KEY_VOLUMEDOWN>;
 	status = "okay";
@@ -261,6 +271,13 @@ gpio_hall_sensor_default: gpio-hall-sensor-default-state {
 		bias-disable;
 	};
 
+	jack_default: jack-default-state {
+		pins = "gpio110";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	sdc2_cd_default: sdc2-cd-default-state {
 		pins = "gpio38";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-heatqlte.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-heatqlte.dts
new file mode 100644
index 000000000000..11cb12f48e6f
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-heatqlte.dts
@@ -0,0 +1,33 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-samsung-rossa-common.dtsi"
+
+/*
+ * NOTE: The original firmware from Samsung can only boot ARM32 kernels.
+ * Unfortunately, the firmware is signed and cannot be replaced easily.
+ * There seems to be no way to boot ARM64 kernels on this device at the moment,
+ * even though the hardware would support it.
+ *
+ * However, it is possible to use this device tree by compiling an ARM32 kernel
+ * instead. For clarity and build testing this device tree is maintained next
+ * to the other MSM8916 device trees. However, it is actually used through
+ * arch/arm/boot/dts/qcom-msm8916-samsung-heatqlte.dts
+ */
+
+/ {
+	model = "Samsung Galaxy Ace 4 (SM-G357FZ)";
+	compatible = "samsung,heatqlte", "qcom,msm8916";
+	chassis-type = "handset";
+};
+
+&battery {
+	charge-term-current-microamp = <150000>;
+	constant-charge-current-max-microamp = <700000>;
+	constant-charge-voltage-max-microvolt = <4350000>;
+};
+
+&panel {
+	compatible = "samsung,s6288a0";
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-j3-common.dtsi b/arch/arm64/boot/dts/qcom/msm8916-samsung-j3-common.dtsi
index 1d74cccc438a..fe4d8b32679e 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-j3-common.dtsi
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-j3-common.dtsi
@@ -13,6 +13,20 @@ tz-apps@85800000 {
 		};
 	};
 
+	reg_vdd_lcd_3p0: regulator-vdd-lcd-3p0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd_lcd_3p0";
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3000000>;
+		vin-supply = <&pm8916_l17>;
+
+		gpio = <&tlmm 102 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&lcd_3p0_ldo_en_default>;
+		pinctrl-names = "default";
+	};
+
 	reg_vdd_tsp_a: regulator-vdd-tsp-a {
 		compatible = "regulator-fixed";
 		regulator-name = "vdd_tsp_a";
@@ -36,6 +50,10 @@ &accelerometer {
 		       "0", "0", "-1";
 };
 
+&front_flash_led {
+	status = "disabled";
+};
+
 &gpio_hall_sensor {
 	status = "disabled";
 };
@@ -48,11 +66,32 @@ &i2c_sensors {
 	/* GPIO pins vary depending on model variant */
 };
 
+&panel {
+	vdd3-supply = <&pm8916_l6>;
+	vci-supply = <&reg_vdd_lcd_3p0>;
+};
+
+&reg_vdd_lcd_1p8 {
+	status = "disabled";
+};
+
+&reg_vdd_lcd_3p0 {
+	vin-supply = <&pm8916_l17>;
+	gpio = <&tlmm 102 GPIO_ACTIVE_HIGH>;
+};
+
 &touchscreen {
 	vdd-supply = <&reg_vdd_tsp_a>;
 };
 
 &tlmm {
+	lcd_3p0_ldo_en_default: lcd-3p0-ldo-en-default-state {
+		pins = "gpio102";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	tsp_ldo_en_default: tsp-ldo-en-default-state {
 		pins = "gpio16";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-j5-common.dtsi b/arch/arm64/boot/dts/qcom/msm8916-samsung-j5-common.dtsi
index 5ca2ada266f4..967ea7f16e3e 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-j5-common.dtsi
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-j5-common.dtsi
@@ -6,6 +6,7 @@
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/leds/common.h>
 
 / {
 	aliases {
@@ -26,6 +27,22 @@ tz-apps@85500000 {
 		};
 	};
 
+	front_flash_led: led-controller {
+		compatible = "kinetic,ktd2692";
+
+		led {
+			function = LED_FUNCTION_FLASH;
+			color = <LED_COLOR_ID_WHITE>;
+
+			led-max-microamp = <300000>;
+			flash-max-microamp = <1500000>;
+			flash-max-timeout-us = <1835000>;
+
+			pinctrl-0 = <&vtcam_flash_en_default>;
+			pinctrl-names = "default";
+		};
+	};
+
 	gpio_hall_sensor: gpio-hall-sensor {
 		compatible = "gpio-keys";
 
@@ -111,6 +128,19 @@ accelerometer: accelerometer@1d {
 			st,drdy-int-pin = <1>;
 		};
 	};
+
+	reg_vdd_lcd_1p8: regulator-vdd-lcd-1p8 {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd_lcd_1p8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&pm8916_s4>;
+
+		enable-active-high;
+
+		pinctrl-0 = <&lcd_1p8_ldo_en_default>;
+		pinctrl-names = "default";
+	};
 };
 
 &blsp_i2c5 {
@@ -137,15 +167,65 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	panel: panel@0 {
+		reg = <0>;
+
+		compatible = "samsung,s6e8aa5x01-ams497hy01";
+
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
 &mpss_mem {
 	reg = <0x0 0x86800000 0x0 0x5800000>;
 };
 
+&pm8916_codec {
+	jack-gpios = <&tlmm 110 GPIO_ACTIVE_LOW>;
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+
+	pinctrl-0 = <&jack_default>;
+	pinctrl-names = "default";
+};
+
 &pm8916_resin {
 	status = "okay";
 	linux,code = <KEY_VOLUMEDOWN>;
 };
 
+&pm8916_rpm_regulators {
+	pm8916_l17: l17 {
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3000000>;
+	};
+};
+
 &sdhc_1 {
 	status = "okay";
 };
@@ -221,6 +301,36 @@ gpio_keys_default: gpio-keys-default-state {
 		bias-pull-up;
 	};
 
+	jack_default: jack-default-state {
+		pins = "gpio110";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcd_1p8_ldo_en_default: lcd-1p8-ldo-en-default-state {
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss_default: mdss-default-state {
+		pins = "gpio25";
+		function = "gpio";
+
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio25";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	muic_i2c_default: muic-i2c-default-state {
 		pins = "gpio105", "gpio106";
 		function = "gpio";
@@ -259,4 +369,10 @@ tsp_int_default: tsp-int-default-state {
 		drive-strength = <2>;
 		bias-disable;
 	};
+
+	vtcam_flash_en_default: vtcam-flash-en-default-state {
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
 };
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-j5.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-j5.dts
index ba8650971d6a..549e7c03e150 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-j5.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-j5.dts
@@ -19,10 +19,23 @@ &blsp_i2c5 {
 	status = "disabled";
 };
 
+&front_flash_led {
+	ctrl-gpios = <&tlmm 50 GPIO_ACTIVE_HIGH>;
+};
+
+&panel {
+	vdd3-supply = <&reg_vdd_lcd_1p8>;
+	vci-supply = <&pm8916_l17>;
+};
+
 &pm8916_codec {
 	qcom,micbias1-ext-cap;
 };
 
+&reg_vdd_lcd_1p8 {
+	gpio = <&tlmm 16 GPIO_ACTIVE_HIGH>;
+};
+
 &touchscreen {
 	/* FIXME: Missing sm5703-mfd driver to power up vdd-supply */
 };
@@ -30,3 +43,11 @@ &touchscreen {
 &usb_hs_phy {
 	qcom,init-seq = /bits/ 8 <0x1 0x19 0x2 0x0b>;
 };
+
+&lcd_1p8_ldo_en_default {
+	pins = "gpio16";
+};
+
+&vtcam_flash_en_default {
+	pins = "gpio50";
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-j5x.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-j5x.dts
index 8b404a9cd62d..3d81c749fcad 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-j5x.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-j5x.dts
@@ -9,6 +9,19 @@ / {
 	compatible = "samsung,j5x", "qcom,msm8916";
 	chassis-type = "handset";
 
+	reg_vdd_lcd_3p0: regulator-vdd-lcd-3p0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd_lcd_3p0";
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3000000>;
+
+		gpio = <&tlmm 115 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&lcd_3p0_ldo_en_default>;
+		pinctrl-names = "default";
+	};
+
 	reg_vdd_tsp_a: regulator-vdd-tsp-a {
 		compatible = "regulator-fixed";
 		regulator-name = "vdd_tsp_a";
@@ -34,15 +47,36 @@ &accelerometer {
 		       "0", "0", "-1";
 };
 
+&front_flash_led {
+	ctrl-gpios = <&tlmm 85 GPIO_ACTIVE_HIGH>;
+};
+
 &muic {
 	interrupts = <121 IRQ_TYPE_EDGE_FALLING>;
 };
 
+&panel {
+	compatible = "samsung,s6e8aa5x01-ams520kt01";
+	vdd3-supply = <&reg_vdd_lcd_1p8>;
+	vci-supply = <&reg_vdd_lcd_3p0>;
+};
+
+&reg_vdd_lcd_1p8 {
+	gpio = <&tlmm 69 GPIO_ACTIVE_HIGH>;
+};
+
 &touchscreen {
 	vdd-supply = <&reg_vdd_tsp_a>;
 };
 
 &tlmm {
+	lcd_3p0_ldo_en_default: lcd-3p0-ldo-en-default-state {
+		pins = "gpio115";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	tsp_ldo_en_default: tsp-ldo-en-default-state {
 		pins = "gpio108";
 		function = "gpio";
@@ -55,6 +89,14 @@ &accel_int_default {
 	pins = "gpio49";
 };
 
+&lcd_1p8_ldo_en_default {
+	pins = "gpio69";
+};
+
 &muic_int_default {
 	pins = "gpio121";
 };
+
+&vtcam_flash_en_default {
+	pins = "gpio85";
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-on7.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-on7.dts
new file mode 100644
index 000000000000..6d5e48336b02
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-on7.dts
@@ -0,0 +1,157 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	model = "Samsung Galaxy On7 (2015)";
+	compatible = "samsung,on7", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		mmc0 = &sdhc_1; /* eMMC */
+		mmc1 = &sdhc_2; /* SD card */
+		serial0 = &blsp_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		/* Additional memory used by Samsung firmware modifications */
+		tz-apps@85500000 {
+			reg = <0x0 0x85500000 0x0 0xb00000>;
+			no-map;
+		};
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-0 = <&gpio_keys_default>;
+		pinctrl-names = "default";
+
+		label = "GPIO Buttons";
+
+		volume-up-button {
+			label = "Volume Up";
+			gpios = <&tlmm 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+
+		home-button {
+			label = "Home";
+			gpios = <&tlmm 109 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_HOMEPAGE>;
+		};
+	};
+
+	i2c-muic {
+		compatible = "i2c-gpio";
+		sda-gpios = <&tlmm 105 (GPIO_ACTIVE_HIGH|GPIO_OPEN_DRAIN)>;
+		scl-gpios = <&tlmm 106 (GPIO_ACTIVE_HIGH|GPIO_OPEN_DRAIN)>;
+
+		pinctrl-0 = <&muic_i2c_default>;
+		pinctrl-names = "default";
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		muic: extcon@25 {
+			compatible = "siliconmitus,sm5703-muic";
+			reg = <0x25>;
+
+			interrupt-parent = <&tlmm>;
+			interrupts = <12 IRQ_TYPE_EDGE_FALLING>;
+
+			pinctrl-0 = <&muic_int_default>;
+			pinctrl-names = "default";
+		};
+	};
+};
+
+&blsp_uart2 {
+	status = "okay";
+};
+
+&pm8916_resin {
+	linux,code = <KEY_VOLUMEDOWN>;
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+};
+
+&sdhc_2 {
+	pinctrl-0 = <&sdc2_default &sdc2_cd_default>;
+	pinctrl-1 = <&sdc2_sleep &sdc2_cd_default>;
+	pinctrl-names = "default", "sleep";
+
+	cd-gpios = <&tlmm 38 GPIO_ACTIVE_LOW>;
+
+	status = "okay";
+};
+
+&usb {
+	extcon = <&muic>, <&muic>;
+	status = "okay";
+};
+
+&usb_hs_phy {
+	extcon = <&muic>;
+};
+
+&venus {
+	status = "okay";
+};
+
+&venus_mem {
+	status = "okay";
+};
+
+&wcnss {
+	status = "okay";
+};
+
+&wcnss_iris {
+	compatible = "qcom,wcn3620";
+};
+
+&wcnss_mem {
+	status = "okay";
+};
+
+&tlmm {
+	gpio_keys_default: gpio-keys-default-state {
+		pins = "gpio107", "gpio109";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	muic_i2c_default: muic-i2c-default-state {
+		pins = "gpio105", "gpio106";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	muic_int_default: muic-int-default-state {
+		pins = "gpio12";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	sdc2_cd_default: sdc2-cd-default-state {
+		pins = "gpio38";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-rossa-common.dtsi b/arch/arm64/boot/dts/qcom/msm8916-samsung-rossa-common.dtsi
index e7f265e3c2ab..42afa68ef1b1 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-rossa-common.dtsi
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-rossa-common.dtsi
@@ -33,6 +33,10 @@ &clk_pwm_backlight {
 	status = "disabled";
 };
 
+&panel {
+	/delete-property/ backlight;
+};
+
 &s3fwrn5_nfc {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-rossa.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-rossa.dts
index 3413b0970c4a..6dae901368dc 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-rossa.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-rossa.dts
@@ -40,3 +40,7 @@ &mpss_mem {
 	/* Firmware for rossa needs more space */
 	reg = <0x0 0x86800000 0x0 0x5800000>;
 };
+
+&panel {
+	compatible = "samsung,cprime-panel";
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-samsung-serranove.dts b/arch/arm64/boot/dts/qcom/msm8916-samsung-serranove.dts
index 5ce8f1350abc..893a6edb471b 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-samsung-serranove.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-samsung-serranove.dts
@@ -321,15 +321,67 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+
+	panel@0 {
+		compatible = "samsung,s6e88a0-ams427ap24";
+		reg = <0>;
+
+		vdd3-supply = <&pm8916_l17>;
+		vci-supply = <&pm8916_l6>;
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+		flip-horizontal;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1>;
+	remote-endpoint = <&panel_in>;
+};
+
 &mpss_mem {
 	reg = <0x0 0x86800000 0x0 0x5a00000>;
 };
 
+&pm8916_codec {
+	jack-gpios = <&tlmm 110 GPIO_ACTIVE_LOW>;
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&jack_default>;
+};
+
 &pm8916_resin {
 	status = "okay";
 	linux,code = <KEY_VOLUMEDOWN>;
 };
 
+&pm8916_rpm_regulators {
+	pm8916_l17: l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+};
+
 &pm8916_vib {
 	status = "okay";
 };
@@ -425,6 +477,30 @@ imu_irq_default: imu-irq-default-state {
 		bias-disable;
 	};
 
+	jack_default: jack-default-state {
+		pins = "gpio110";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss_default: mdss-default-state {
+		pins = "gpio25";
+		function = "gpio";
+
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio25";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	muic_i2c_default: muic-i2c-default-state {
 		pins = "gpio105", "gpio106";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8916-vivo-y21l.dts b/arch/arm64/boot/dts/qcom/msm8916-vivo-y21l.dts
new file mode 100644
index 000000000000..4e8dc91fe9b1
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8916-vivo-y21l.dts
@@ -0,0 +1,154 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8916-pm8916.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	model = "Vivo Y21L";
+	compatible = "vivo,y21l", "qcom,msm8916";
+	chassis-type = "handset";
+
+	aliases {
+		mmc0 = &sdhc_1; /* eMMC */
+		mmc1 = &sdhc_2; /* SD card */
+		serial0 = &blsp_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		pinctrl-0 = <&gpio_keys_default>;
+		pinctrl-names = "default";
+		label = "GPIO Buttons";
+
+		button-volume-up {
+			label = "Volume Up";
+			gpios = <&tlmm 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+	};
+
+	usb_id: usb-id {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpios = <&tlmm 110 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&usb_id_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	accelerometer@18 {
+		compatible = "st,lis3dh-accel";
+		reg = <0x18>;
+		interrupts-extended = <&tlmm 21 IRQ_TYPE_EDGE_RISING>;
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+		pinctrl-0 = <&accel_int_default>;
+		pinctrl-names = "default";
+		mount-matrix = "-1", "0", "0",
+				"0", "1", "0",
+				"0", "0", "1";
+	};
+
+	magnetormeter@2e {
+		compatible = "yamaha,yas533";
+		reg = <0x2e>;
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+	};
+
+	light-sensor@39 {
+		compatible = "amstaos,tmd2772";
+		reg = <0x39>;
+		interrupts-extended = <&tlmm 113 IRQ_TYPE_EDGE_FALLING>;
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+		pinctrl-0 = <&light_int_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_uart2 {
+	status = "okay";
+};
+
+&pm8916_resin {
+	linux,code = <KEY_VOLUMEDOWN>;
+	status = "okay";
+};
+
+&pm8916_rpm_regulators {
+	pm8916_l17: l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+};
+
+&sdhc_1 {
+	status = "okay";
+};
+
+&sdhc_2 {
+	non-removable;
+	status = "okay";
+};
+
+&usb {
+	extcon = <&usb_id>, <&usb_id>;
+	status = "okay";
+};
+
+&usb_hs_phy {
+	extcon = <&usb_id>;
+};
+
+&wcnss {
+	status = "okay";
+};
+
+&wcnss_iris {
+	compatible = "qcom,wcn3620";
+};
+
+&wcnss_mem {
+	status = "okay";
+};
+
+&tlmm {
+	accel_int_default: accel-int-default-state {
+		pins = "gpio21";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_keys_default: gpio-keys-default-state {
+		pins = "gpio107";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	light_int_default: light-int-default-state {
+		pins = "gpio113";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	usb_id_default: usb-id-default-state {
+		pins = "gpio110";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-pull-up;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt86518.dts b/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt86518.dts
index 3cfa80e38a9e..8add98847e52 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt86518.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt86518.dts
@@ -35,10 +35,18 @@ accelerometer@e {
 	};
 };
 
+&gps_mem {
+	status = "disabled";
+};
+
 &headphones_switch {
 	VCC-supply = <&pm8916_l17>;
 };
 
+&memshare {
+	status = "disabled";
+};
+
 &pm8916_bms {
 	power-supplies = <&pm8916_charger>;
 };
@@ -52,6 +60,16 @@ &pm8916_charger {
 	status = "okay";
 };
 
+&reg_lcd_neg {
+	regulator-min-microvolt = <5400000>;
+	regulator-max-microvolt = <5400000>;
+};
+
+&reg_lcd_pos {
+	regulator-min-microvolt = <5400000>;
+	regulator-max-microvolt = <5400000>;
+};
+
 &sound {
 	model = "wt88047";
 	widgets = "Speaker", "Speaker",
diff --git a/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt86528.dts b/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt86528.dts
index ec2c4dcd3ead..eb128972030a 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt86528.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt86528.dts
@@ -93,6 +93,16 @@ &pm8916_codec {
 	qcom,micbias1-ext-cap;
 };
 
+&reg_lcd_neg {
+	regulator-min-microvolt = <5000000>;
+	regulator-max-microvolt = <5000000>;
+};
+
+&reg_lcd_pos {
+	regulator-min-microvolt = <5000000>;
+	regulator-max-microvolt = <5000000>;
+};
+
 &sound {
 	model = "wt86528";
 	widgets = "Speaker", "Speaker",
diff --git a/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt865x8.dtsi b/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt865x8.dtsi
index 1a7c347dc3f0..f255c487c370 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt865x8.dtsi
+++ b/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt865x8.dtsi
@@ -70,6 +70,30 @@ volume-up-button {
 	};
 };
 
+&blsp_i2c2 {
+	status = "okay";
+
+	regulator@3e {
+		compatible = "ti,tps65132";
+		reg = <0x3e>;
+
+		pinctrl-0 = <&tps65132_en_default>;
+		pinctrl-names = "default";
+
+		reg_lcd_pos: outp {
+			regulator-name = "outp";
+			enable-gpios = <&tlmm 118 GPIO_ACTIVE_HIGH>;
+			regulator-active-discharge = <1>;
+		};
+
+		reg_lcd_neg: outn {
+			regulator-name = "outn";
+			enable-gpios = <&tlmm 117 GPIO_ACTIVE_HIGH>;
+			regulator-active-discharge = <1>;
+		};
+	};
+};
+
 &blsp_i2c5 {
 	status = "okay";
 
@@ -96,6 +120,46 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	panel@0 {
+		compatible = "wingtech,wt865x8-panel";
+		reg = <0>;
+
+		vsp-supply = <&reg_lcd_pos>;
+		vsn-supply = <&reg_lcd_neg>;
+
+		backlight = <&backlight>;
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
 &mpss_mem {
 	reg = <0x0 0x86800000 0x0 0x5500000>;
 };
@@ -187,6 +251,20 @@ headphones_switch_default: headphones-switch-default-state {
 		bias-disable;
 	};
 
+	mdss_default: mdss-default-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	touchscreen_default: touchscreen-default-state {
 		touchscreen-pins {
 			pins = "gpio13";
@@ -202,6 +280,13 @@ reset-pins {
 			bias-disable;
 		};
 	};
+
+	tps65132_en_default: tps65132-en-default-state {
+		pins = "gpio117", "gpio118";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
 };
 
 &pm8916_mpps {
diff --git a/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt88047.dts b/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt88047.dts
index 510b3b3c4e3c..fe45132821b9 100644
--- a/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt88047.dts
+++ b/arch/arm64/boot/dts/qcom/msm8916-wingtech-wt88047.dts
@@ -11,6 +11,7 @@
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
 #include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>
 
 / {
 	model = "Xiaomi Redmi 2 (Wingtech WT88047)";
@@ -49,6 +50,15 @@ headphones_switch: audio-switch {
 		pinctrl-names = "default";
 	};
 
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pm8916_pwm 0 100000>;
+
+		brightness-levels = <0 255>;
+		num-interpolated-steps = <255>;
+		default-brightness-level = <255>;
+	};
+
 	flash-led-controller {
 		compatible = "ocs,ocp8110";
 		enable-gpios = <&tlmm 31 GPIO_ACTIVE_HIGH>;
@@ -108,6 +118,62 @@ imu@68 {
 	};
 };
 
+&blsp_i2c4 {
+	status = "okay";
+
+	charger: battery@14 {
+		compatible = "qcom,smb1360";
+		reg = <0x14>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <62 IRQ_TYPE_LEVEL_LOW>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&smb_int_default>;
+
+		qcom,rsense-10mohm;
+
+		qcom,float-voltage-mv = <4350>;
+		qcom,iterm-ma = <100>;
+		qcom,charging-timeout = <768>;
+		qcom,chg-inhibit-disabled;
+
+		qcom,fg-batt-capacity-mah = <0>; /* Set by bootloader */
+		qcom,fg-cc-soc-coeff = <0>; /* Set by bootloader */
+		qcom,fg-cutoff-voltage-mv = <3400>;
+		qcom,fg-iterm-ma = <150>;
+		qcom,fg-ibatt-standby-ma = <200>;
+		qcom,fg-cc-to-cv-mv = <4328>;
+		qcom,thermistor-c1-coeff = <0>; /* Set by bootloader */
+		qcom,fg-auto-recharge-soc = <95>; /* 99 in downstream */
+
+		qcom,otp-hard-jeita-config;
+		qcom,otp-hot-bat-decidegc = <600>;
+		qcom,otp-cold-bat-decidegc = <0>;
+
+		qcom,soft-jeita-config;
+		qcom,warm-bat-decidegc = <450>;
+		qcom,cool-bat-decidegc = <100>;
+		qcom,soft-jeita-comp-voltage-mv = <4000>;
+		qcom,soft-jeita-comp-current-ma = <600>;
+
+		qcom,shdn-after-pwroff;
+		qcom,fg-reset-at-pon;
+		qcom,fg-reset-threshold-mv = <100>;
+
+		/*
+		 * Some properties are battery-specific. Battery detection
+		 * happens in the bootloader, so it will fill those appropriately
+		 * and set status = "okay".
+		 */
+		status = "disabled";
+
+		usb_otg_vbus: usb-otg-vbus {
+			regulator-max-microamp = <950000>;
+		};
+	};
+};
+
 &blsp_i2c5 {
 	status = "okay";
 
@@ -171,6 +237,59 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gps_mem {
+	status = "disabled";
+};
+
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&mdss_active>;
+	pinctrl-1 = <&mdss_suspend>;
+
+	panel@0 {
+		compatible = "wingtech,wt88047-panel";
+		reg = <0>;
+
+		backlight = <&backlight>;
+		power-supply = <&pm8916_l17>;
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+};
+
+/*
+ * The modem firmware sends a "query_size" memshare request for client ID 1,
+ * but basically does not do anything with it. GPS works only if:
+ *   - Memshare is not present or
+ *   - Memshare replies to the request with an error
+ * Overall it seems pointless to enable memshare for this device.
+ */
+&memshare {
+	status = "disabled";
+};
+
 &mpss_mem {
 	reg = <0x0 0x86800000 0x0 0x5100000>;
 };
@@ -183,6 +302,12 @@ &pm8916_codec {
 	qcom,hphl-jack-type-normally-open;
 };
 
+&pm8916_pwm {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm_out>;
+};
+
 &pm8916_resin {
 	status = "okay";
 	linux,code = <KEY_VOLUMEDOWN>;
@@ -243,11 +368,12 @@ &sound {
 
 &usb {
 	status = "okay";
-	extcon = <&usb_id>, <&usb_id>;
+	extcon = <&charger>, <&usb_id>;
+	vbus-supply = <&usb_otg_vbus>;
 };
 
 &usb_hs_phy {
-	extcon = <&usb_id>;
+	extcon = <&charger>;
 };
 
 &venus {
@@ -302,6 +428,30 @@ imu_default: imu-default-state {
 		bias-disable;
 	};
 
+	mdss_active: mdss-active-state {
+		pins = "gpio25";
+		function = "gpio";
+
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_suspend: mdss-suspend-state {
+		pins = "gpio25";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	smb_int_default: smb-int-default-state {
+		pins = "gpio62";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
 	speaker_amp_default: speaker-amp-default-state {
 		pins = "gpio117";
 		function = "gpio";
@@ -334,3 +484,13 @@ usb_id_default: usb-id-default-state {
 		bias-pull-up;
 	};
 };
+
+&pm8916_mpps {
+	pwm_out: mpp4-state {
+		pins = "mpp4";
+		function = "digital";
+		power-source = <PM8916_MPP_VPH>;
+		output-low;
+		qcom,dtest = <1>;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8916.dtsi b/arch/arm64/boot/dts/qcom/msm8916.dtsi
index 0ee44706b70b..cb85f77cdc93 100644
--- a/arch/arm64/boot/dts/qcom/msm8916.dtsi
+++ b/arch/arm64/boot/dts/qcom/msm8916.dtsi
@@ -11,6 +11,7 @@
 #include <dt-bindings/power/qcom-rpmpd.h>
 #include <dt-bindings/reset/qcom,gcc-msm8916.h>
 #include <dt-bindings/soc/qcom,apr.h>
+#include <dt-bindings/soc/qcom,memshare.h>
 #include <dt-bindings/thermal/thermal.h>
 
 / {
@@ -113,6 +114,14 @@ mba_mem: mba {
 			no-map;
 			status = "disabled";
 		};
+
+		gps_mem: gps {
+			size = <0x0 0x200000>;
+			alignment = <0x0 0x100000>;
+			alloc-ranges = <0x0 0x86800000 0x0 0x8000000>;
+			no-map;
+			status = "disabled";
+		};
 	};
 
 	clocks {
@@ -264,6 +273,29 @@ scm: scm {
 		};
 	};
 
+	memshare: memshare {
+		compatible = "qcom,memshare";
+		qcom,legacy-client = <&memshare_gps>;
+
+		status = "disabled";
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		mpss@0 {
+			reg = <MEMSHARE_PROC_MPSS_V01>;
+			qcom,qrtr-node = <0>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			memshare_gps: gps@0 {
+				reg = <0>;
+				memory-region = <&gps_mem>;
+			};
+		};
+	};
+
 	pmu {
 		compatible = "arm,cortex-a53-pmu";
 		interrupts = <GIC_PPI 7 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>;
@@ -2028,6 +2060,26 @@ q6routing: routing {
 							#sound-dai-cells = <0>;
 						};
 					};
+
+					q6mvm: apr-service@9 {
+						compatible = "qcom,q6mvm";
+						reg = <APR_SVC_ADSP_MVM>;
+
+						q6voicedai: dais {
+							compatible = "qcom,q6voice-dais";
+							#sound-dai-cells = <0>;
+						};
+					};
+
+					q6cvs: apr-service@a {
+						compatible = "qcom,q6cvs";
+						reg = <APR_SVC_ADSP_CVS>;
+					};
+
+					q6cvp: apr-service@b {
+						compatible = "qcom,q6cvp";
+						reg = <APR_SVC_ADSP_CVP>;
+					};
 				};
 
 				fastrpc {
diff --git a/arch/arm64/boot/dts/qcom/msm8939-alcatel-idol3.dts b/arch/arm64/boot/dts/qcom/msm8939-alcatel-idol3.dts
new file mode 100644
index 000000000000..b9ed5fff8504
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/msm8939-alcatel-idol3.dts
@@ -0,0 +1,669 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+/dts-v1/;
+
+#include "msm8939-pm8916.dtsi"
+#include "msm8916-modem-qdsp6.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/iio/qcom,spmi-vadc.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>
+
+/ {
+	model = "Alcatel OneTouch Idol 3 (5.5)";
+	compatible = "alcatel,idol3", "qcom,msm8939";
+	chassis-type = "handset";
+
+	aliases {
+		mmc0 = &sdhc_1; /* eMMC */
+		mmc1 = &sdhc_2; /* SD card */
+		serial0 = &blsp_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0";
+	};
+
+	reserved-memory {
+		/delete-node/ rmtfs@86700000;
+
+		reserved@86680000 {
+			reg = <0x0 0x86680000 0x0 0x1000>;
+			no-map;
+		};
+
+		rmtfs: rmtfs@86681000 {
+			compatible = "qcom,rmtfs-mem";
+			reg = <0x0 0x86681000 0x0 0x15f000>;
+			no-map;
+
+			qcom,client-id = <1>;
+		};
+
+		ramoops: ramoops@9ff00000 {
+			compatible = "ramoops";
+			reg = <0 0x9ff00000 0 0x100000>;
+
+			record-size = <0x1000>;
+			console-size = <0x40000>;
+			ftrace-size = <0x1000>;
+			pmsg-size = <0x20000>;
+		};
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pm8916_pwm 0 255000>;
+		brightness-levels = <0 255>;
+		num-interpolated-steps = <255>;
+		default-brightness-level = <64>;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+
+		pinctrl-0 = <&gpio_keys_volume_up_default>;
+		pinctrl-names = "default";
+
+		label = "GPIO Keys";
+
+		button-volume-up {
+			label = "Volume Up";
+			gpios = <&tlmm 107 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_VOLUMEUP>;
+		};
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		pinctrl-0 = <&gpio_leds_default>;
+		pinctrl-names = "default";
+
+		led-0 {
+			gpios = <&tlmm 32 GPIO_ACTIVE_HIGH>;
+			function = LED_FUNCTION_TORCH;
+		};
+	};
+
+	reg_lcd_enn: regulator-lcd-enn {
+		compatible = "regulator-fixed";
+		regulator-name = "lcd_enn";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-boot-on;
+		gpio = <&tlmm 106 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-0 = <&lcd_enn_default>;
+		pinctrl-names = "default";
+	};
+
+	reg_lcd_enp: regulator-lcd-enp {
+		compatible = "regulator-fixed";
+		regulator-name = "lcd_enp";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-boot-on;
+		gpio = <&tlmm 105 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		pinctrl-0 = <&lcd_enp_default>;
+		pinctrl-names = "default";
+	};
+
+	usb_id: usb-id {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpios = <&tlmm 69 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&usb_id_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	magnetometer@c {
+		compatible = "asahi-kasei,ak09911";
+		reg = <0x0c>;
+		vdd-supply = <&pm8916_l17>;
+		vid-supply = <&pm8916_l6>;
+		reset-gpios = <&tlmm 100 GPIO_ACTIVE_LOW>;
+		pinctrl-0 = <&mag_reset_default>;
+		pinctrl-names = "default";
+		mount-matrix = "0", "1", "0",
+			      "-1", "0", "0",
+			       "0", "0", "1";
+	};
+
+	accelerometer@e {
+		compatible = "kionix,kxtj21009";
+		reg = <0x0e>;
+		interrupts-extended = <&tlmm 114 IRQ_TYPE_EDGE_FALLING>;
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+		pinctrl-0 = <&accel_int_default>;
+		pinctrl-names = "default";
+		mount-matrix = "-1", "0", "0",
+			       "0", "-1", "0",
+			       "0", "0", "-1";
+	};
+
+	proximity@39 {
+		compatible = "amstaos,tsl2772";
+		reg = <0x39>;
+		interrupts-extended = <&tlmm 34 IRQ_TYPE_EDGE_FALLING>;
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+		amstaos,proximity-diodes = <0>;
+		led-max-microamp = <100000>;
+		pinctrl-0 = <&proximity_default>;
+		pinctrl-names = "default";
+	};
+
+	gyroscope@68 {
+		compatible = "bosch,bmg160";
+		reg = <0x68>;
+		interrupts-extended = <&tlmm 23 IRQ_TYPE_EDGE_RISING>;
+		vdd-supply = <&pm8916_l17>;
+		vddio-supply = <&pm8916_l6>;
+		pinctrl-0 = <&gyro_int_default>;
+		pinctrl-names = "default";
+	};
+};
+
+&blsp_i2c4 {
+	status = "okay";
+
+	headphones: audio-codec@10 {
+		compatible = "asahi-kasei,ak4375";
+		reg = <0x10>;
+		tvdd-supply = <&pm8916_l6>;
+		pdn-gpios = <&tlmm 101 GPIO_ACTIVE_HIGH>;
+		pintctrl-0 = <&headphones_pdn_default>;
+		pinctrl-names = "default";
+		#sound-dai-cells = <0>;
+	};
+
+	charger: battery@14 {
+		compatible = "qcom,smb1360";
+		reg = <0x14>;
+
+		interrupts-extended = <&tlmm 62 IRQ_TYPE_LEVEL_LOW>;
+
+		pinctrl-0 = <&smb_int_default>;
+		pinctrl-names = "default";
+
+		qcom,float-voltage-mv = <4350>;
+		qcom,iterm-ma = <100>;
+		qcom,charging-timeout = <768>;
+		qcom,recharge-thresh-mv = <100>;
+		qcom,chg-inhibit-disabled;
+
+		qcom,battery-profile = <1>; /* downstream forces profile B */
+		qcom,fg-batt-capacity-mah = <2910>;
+		qcom,fg-cc-soc-coeff = <0x81a1>;
+		qcom,fg-cc-to-cv-mv = <4328>;
+		qcom,thermistor-c1-coeff = <0x86c8>;
+		qcom,fg-auto-recharge-soc = <95>; /* 99 in downstream */
+
+		qcom,otp-hard-jeita-config;
+		qcom,otp-hot-bat-decidegc = <550>;
+		qcom,otp-cold-bat-decidegc = <0>;
+
+		qcom,soft-jeita-config;
+		qcom,warm-bat-decidegc = <450>;
+		qcom,cool-bat-decidegc = <100>;
+		qcom,soft-jeita-comp-voltage-mv = <4100>;
+		qcom,soft-jeita-comp-current-ma = <750>;
+
+		qcom,shdn-after-pwroff;
+		qcom,fg-reset-at-pon;
+		qcom,fg-reset-threshold-mv = <200>;
+
+		usb_otg_vbus: usb-otg-vbus {
+			regulator-max-microamp = <1500000>;
+		};
+	};
+
+	speaker_codec_top: audio-codec@34 {
+		compatible = "nxp,tfa9897";
+		reg = <0x34>;
+		vddd-supply = <&pm8916_l6>;
+		rcv-gpios = <&tlmm 91 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&speaker_top_default>;
+		pinctrl-names = "default";
+		sound-name-prefix = "Speaker Top";
+		#sound-dai-cells = <0>;
+	};
+
+	speaker_codec_bottom: audio-codec@36 {
+		compatible = "nxp,tfa9897";
+		reg = <0x36>;
+		vddd-supply = <&pm8916_l6>;
+		rcv-gpios = <&tlmm 92 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&speaker_bottom_default>;
+		pinctrl-names = "default";
+		sound-name-prefix = "Speaker Bottom";
+		#sound-dai-cells = <0>;
+	};
+
+	led-controller@68 {
+		compatible = "si-en,sn3190";
+		reg = <0x68>;
+		shutdown-gpios = <&tlmm 9 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&led_enable_default &led_shutdown_default>;
+		pinctrl-names = "default";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		led@1 {
+			reg = <1>;
+			led-max-microamp = <5000>;
+			function = LED_FUNCTION_INDICATOR;
+			color = <LED_COLOR_ID_WHITE>;
+		};
+	};
+};
+
+&blsp_i2c5 {
+	status = "okay";
+
+	rmi4@20 {
+		status = "disabled";
+		compatible = "syna,rmi4-i2c";
+		reg = <0x20>;
+		interrupts-extended = <&tlmm 13 IRQ_TYPE_LEVEL_LOW>;
+		vdd-supply = <&pm8916_l17>;
+		vio-supply = <&pm8916_l6>;
+		pinctrl-0 = <&ts_int_active &ts_reset_active>;
+		pinctrl-names = "default";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		syna,startup-delay-ms = <100>;
+
+		rmi4-f01@1 {
+			reg = <0x1>;
+			syna,nosleep-mode = <1>;
+		};
+
+		rmi4-f11@11 {
+			reg = <0x11>;
+			syna,sensor-type = <1>;
+		};
+	};
+
+	touchscreen@38 {
+		status = "disabled";
+		compatible = "edt,edt-ft5406";
+		reg = <0x38>;
+		interrupts-extended = <&tlmm 13 IRQ_TYPE_LEVEL_LOW>;
+		vcc-supply = <&pm8916_l17>;
+		iovcc-supply = <&pm8916_l6>;
+		pinctrl-0 = <&ts_int_active &ts_reset_active>;
+		pinctrl-names = "default";
+		reset-gpios = <&tlmm 12 GPIO_ACTIVE_LOW>;
+
+		touchscreen-size-x = <1080>;
+		touchscreen-size-y = <1920>;
+	};
+};
+
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+	pinctrl-names = "default", "sleep";
+	status = "okay";
+
+	panel@0 {
+		compatible = "alcatel,idol3-panel";
+		reg = <0>;
+
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+		enp-supply = <&reg_lcd_enp>;
+		enn-supply = <&reg_lcd_enn>;
+
+		backlight = <&backlight>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				panel_in: endpoint {
+					remote-endpoint = <&mdss_dsi0_out>;
+				};
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <1 2 3 0>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+	status = "okay";
+};
+
+&mpss_mem {
+	reg = <0x0 0x86800000 0x0 0x5000000>;
+};
+
+&pm8916_codec {
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 100 120 180 500>;
+	qcom,mbhc-vthreshold-high = <75 100 120 180 500>;
+	qcom,hphl-jack-type-normally-open;
+};
+
+&pm8916_pwm {
+	pinctrl-0 = <&pwm_out>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&pm8916_resin {
+	linux,code = <KEY_VOLUMEDOWN>;
+	status = "okay";
+};
+
+&pm8916_rpm_regulators {
+	pm8916_l17: l17 {
+		regulator-min-microvolt = <2850000>;
+		regulator-max-microvolt = <2850000>;
+	};
+};
+
+&pm8916_vib {
+	status = "okay";
+};
+
+&q6afedai {
+	dai@18 {
+		reg = <SECONDARY_MI2S_RX>;
+		qcom,sd-lines = <0>;
+	};
+
+	dai@22 {
+		reg = <QUATERNARY_MI2S_RX>;
+		qcom,sd-lines = <0>;
+	};
+};
+
+&sdhc_1 {
+	status = "okay";
+};
+
+&sdhc_2 {
+	pinctrl-0 = <&sdc2_default &sdc2_cd_default>;
+	pinctrl-1 = <&sdc2_sleep &sdc2_cd_default>;
+	pinctrl-names = "default", "sleep";
+
+	cd-gpios = <&tlmm 38 GPIO_ACTIVE_LOW>;
+
+	status = "okay";
+};
+
+&sound {
+	model = "alcatel-idol3";
+	widgets = "Speaker", "Speaker Top", "Speaker", "Speaker Bottom";
+	pin-switches = "Speaker Top", "Speaker Bottom";
+	audio-routing =
+		"Speaker Top", "Speaker Top OUT",
+		"Speaker Bottom", "Speaker Bottom OUT",
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS External1";
+
+	pinctrl-0 = <&cdc_pdm_default &pri_mi2s_mclk_default>,
+		    <&pri_mi2s_default &pri_mi2s_ws_default &sec_mi2s_default>;
+	pinctrl-1 = <&cdc_pdm_sleep &pri_mi2s_mclk_sleep>,
+		    <&pri_mi2s_sleep &pri_mi2s_ws_sleep &sec_mi2s_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	sound_link_backend2: backend2-dai-link {
+		link-name = "Quaternary MI2S";
+
+		cpu {
+			sound-dai = <&q6afedai QUATERNARY_MI2S_RX>;
+		};
+		platform {
+			sound-dai = <&q6routing>;
+		};
+		codec {
+			sound-dai = <&speaker_codec_top>, <&speaker_codec_bottom>;
+		};
+	};
+};
+
+&sound_link_backend0 {
+	/* Primary MI2S is not used, replace with Secondary MI2S for headphones */
+	link-name = "Secondary MI2S";
+
+	cpu {
+		sound-dai = <&q6afedai SECONDARY_MI2S_RX>;
+	};
+	platform {
+		sound-dai = <&q6routing>;
+	};
+	codec {
+		sound-dai = <&headphones>;
+	};
+};
+
+&usb {
+	extcon = <&charger>, <&usb_id>;
+	vbus-supply = <&usb_otg_vbus>;
+	status = "okay";
+};
+
+&usb_hs_phy {
+	extcon = <&charger>;
+};
+
+&wcnss {
+	status = "okay";
+};
+
+&wcnss_iris {
+	compatible = "qcom,wcn3660b";
+};
+
+&wcnss_mem {
+	status = "okay";
+};
+
+/* Only some of the pins are used */
+&pri_mi2s_mclk_default {
+	pins = "gpio116";
+};
+&pri_mi2s_mclk_sleep {
+	pins = "gpio116";
+};
+&pri_mi2s_default {
+	pins = "gpio113", "gpio115";
+};
+&pri_mi2s_sleep {
+	pins = "gpio113", "gpio115";
+};
+
+&tlmm {
+	accel_int_default: accel-int-default-state {
+		pins = "gpio114";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gpio_keys_volume_up_default: gpio-keys-volume-up-default-state {
+		pins = "gpio107";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	gpio_leds_default: gpio-leds-default-state {
+		pins = "gpio32";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	gyro_int_default: gyro-int-default-state {
+		pins = "gpio23";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	headphones_pdn_default: headphones-pdn-default-state {
+		pins = "gpio101";
+		function = "gpio";
+
+		drive-strength = <16>;
+		bias-disable;
+		output-low;
+	};
+
+	lcd_enn_default: lcd-enn-default-state {
+		pins = "gpio106";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+		output-high;
+	};
+
+	lcd_enp_default: lcd-enp-default-state {
+		pins = "gpio105";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-pull-up;
+		output-high;
+	};
+
+	/*
+	 * The OEM wired an additional GPIO to be asserted so that
+	 * the si-en,sn3190 LED IC works. Since this GPIO is not
+	 * part of the IC datasheet nor supported by the driver,
+	 * force it asserted here.
+	 */
+	led_enable_default: led-enable-default-state {
+		pins = "gpio108";
+		function = "gpio";
+
+		drive-strength = <2>;
+		bias-disable;
+		output-high;
+	};
+
+	led_shutdown_default: led-shutdown-default-state {
+		pins = "gpio9";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mag_reset_default: mag-reset-default-state {
+		pins = "gpio100";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	proximity_default: proximity-default-state {
+		pins = "gpio34";
+		function = "gpio";
+		drive-strength = <6>;
+		bias-pull-up;
+	};
+
+	mdss_default: mdss-default-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	sdc2_cd_default: sdc2-cd-default-state {
+		pins = "gpio38";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	smb_int_default: smb-int-default-state {
+		pins = "gpio62";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	speaker_bottom_default: speaker-bottom-default-state {
+		pins = "gpio92";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	speaker_top_default: speaker-top-default-state {
+		pins = "gpio91";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	ts_int_active: pmx-ts-int-active-state {
+		pins = "gpio13";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
+	ts_reset_active: pmx-ts-reset-active-state {
+		pins = "gpio12";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	usb_id_default: usb-id-default-state {
+		pins = "gpio69";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-pull-up;
+	};
+};
+
+&pm8916_mpps {
+	pwm_out: mpp4-state {
+		pins = "mpp4";
+		function = "digital";
+		power-source = <PM8916_MPP_L5>;
+		output-low;
+		qcom,dtest = <1>;
+	};
+};
diff --git a/arch/arm64/boot/dts/qcom/msm8939-huawei-kiwi.dts b/arch/arm64/boot/dts/qcom/msm8939-huawei-kiwi.dts
index 3cec51891aed..11dea286edb3 100644
--- a/arch/arm64/boot/dts/qcom/msm8939-huawei-kiwi.dts
+++ b/arch/arm64/boot/dts/qcom/msm8939-huawei-kiwi.dts
@@ -4,6 +4,8 @@
 
 #include "msm8939-pm8916.dtsi"
 #include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/sound/apq8016-lpass.h>
 
 / {
 	model = "Huawei Honor 5X / GR5 (2016)";
@@ -59,6 +61,37 @@ button-volume-up {
 		};
 	};
 
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		pinctrl-0 = <&gpio_leds_default>;
+		pinctrl-names = "default";
+
+		led-0 {
+			gpios = <&tlmm 8 GPIO_ACTIVE_HIGH>;
+			color = <LED_COLOR_ID_RED>;
+			default-state = "off";
+			function = LED_FUNCTION_INDICATOR;
+			retain-state-suspended;
+		};
+
+		led-1 {
+			gpios = <&tlmm 9 GPIO_ACTIVE_HIGH>;
+			color = <LED_COLOR_ID_GREEN>;
+			default-state = "off";
+			function = LED_FUNCTION_INDICATOR;
+			retain-state-suspended;
+		};
+
+		led-2 {
+			gpios = <&tlmm 10 GPIO_ACTIVE_HIGH>;
+			color = <LED_COLOR_ID_BLUE>;
+			default-state = "off";
+			function = LED_FUNCTION_INDICATOR;
+			retain-state-suspended;
+		};
+	};
+
 	usb_id: usb-id {
 		compatible = "linux,extcon-usb-gpio";
 		id-gpios = <&tlmm 110 GPIO_ACTIVE_HIGH>;
@@ -67,9 +100,30 @@ usb_id: usb-id {
 	};
 };
 
+&blsp_i2c1 {
+	status = "okay";
+
+	speaker_codec: audio-codec@34 {
+		compatible = "nxp,tfa9895";
+		reg = <0x34>;
+		vddd-supply = <&pm8916_l5>;
+		#sound-dai-cells = <0>;
+	};
+};
+
 &blsp_i2c2 {
 	status = "okay";
 
+	magnetometer@c {
+		compatible = "asahi-kasei,ak09911";
+		reg = <0x0c>;
+		vdd-supply = <&pm8916_l17>;
+		vid-supply = <&pm8916_l6>;
+		reset-gpios = <&tlmm 36 GPIO_ACTIVE_LOW>;
+		pinctrl-0 = <&mag_reset_default>;
+		pinctrl-names = "default";
+	};
+
 	accelerometer@1e {
 		compatible = "kionix,kx023-1025";
 		reg = <0x1e>;
@@ -99,6 +153,30 @@ proximity@39 {
 		pinctrl-0 = <&prox_irq_default>;
 		pinctrl-names = "default";
 	};
+
+	regulator@3e {
+		compatible = "ti,tps65132";
+		reg = <0x3e>;
+
+		pinctrl-0 = <&reg_lcd_en_default>;
+		pinctrl-names = "default";
+
+		reg_lcd_pos: outp {
+			regulator-name = "outp";
+			regulator-min-microvolt = <5400000>;
+			regulator-max-microvolt = <5400000>;
+			enable-gpios = <&tlmm 97 GPIO_ACTIVE_HIGH>;
+			regulator-active-discharge = <1>;
+		};
+
+		reg_lcd_neg: outn {
+			regulator-name = "outn";
+			regulator-min-microvolt = <5400000>;
+			regulator-max-microvolt = <5400000>;
+			enable-gpios = <&tlmm 32 GPIO_ACTIVE_HIGH>;
+			regulator-active-discharge = <1>;
+		};
+	};
 };
 
 &blsp_i2c5 {
@@ -129,6 +207,63 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
+&lpass {
+	status = "okay";
+};
+
+&lpass_codec {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+	pinctrl-names = "default", "sleep";
+	status = "okay";
+
+	panel@0 {
+		compatible = "huawei,kiwi-panel";
+		reg = <0>;
+
+		vsp-supply = <&reg_lcd_pos>;
+		vsn-supply = <&reg_lcd_neg>;
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+	status = "okay";
+};
+
+&pm8916_codec {
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+	qcom,micbias1-ext-cap;
+	qcom,hphl-jack-type-normally-open;
+	status = "okay";
+};
+
 &pm8916_l8 {
 	regulator-min-microvolt = <2950000>;
 	regulator-max-microvolt = <2950000>;
@@ -169,6 +304,51 @@ &sdhc_2 {
 	status = "okay";
 };
 
+&sound {
+	model = "samsung-a2015";
+	audio-routing =
+		"AMIC1", "MIC BIAS External1",
+		"AMIC2", "MIC BIAS Internal2",
+		"AMIC3", "MIC BIAS External1";
+
+	pinctrl-0 = <&cdc_pdm_default &sec_mi2s_default>;
+	pinctrl-1 = <&cdc_pdm_sleep &sec_mi2s_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	status = "okay";
+
+	dai-link-primary {
+		link-name = "Primary MI2S";
+		cpu {
+			sound-dai = <&lpass MI2S_PRIMARY>;
+		};
+		codec {
+			sound-dai = <&lpass_codec 0>, <&pm8916_codec 0>;
+		};
+	};
+
+	dai-link-tertiary {
+		link-name = "Tertiary MI2S";
+		cpu {
+			sound-dai = <&lpass MI2S_TERTIARY>;
+		};
+		codec {
+			sound-dai = <&lpass_codec 1>, <&pm8916_codec 1>;
+		};
+	};
+
+	dai-link-quaternary {
+		link-name = "Quaternary MI2S";
+
+		cpu {
+			sound-dai = <&lpass MI2S_QUATERNARY>;
+		};
+		codec {
+			sound-dai = <&speaker_codec>;
+		};
+	};
+};
+
 &usb {
 	extcon = <&usb_id>, <&usb_id>;
 	status = "okay";
@@ -212,6 +392,34 @@ gpio_keys_default: gpio-keys-default-state {
 		bias-pull-up;
 	};
 
+	gpio_leds_default: gpio-leds-default-state {
+		pins = "gpio8", "gpio9", "gpio10";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mag_reset_default: mag-reset-default-state {
+		pins = "gpio36";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss_default: mdss-default-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	prox_irq_default: prox-irq-default-state {
 		pins = "gpio113";
 		function = "gpio";
@@ -219,6 +427,13 @@ prox_irq_default: prox-irq-default-state {
 		bias-disable;
 	};
 
+	reg_lcd_en_default: reg-lcd-en-default-state {
+		pins = "gpio32", "gpio97";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	sdc2_cd_default: sdc2-cd-default-state {
 		pins = "gpio38";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8939-longcheer-l9100.dts b/arch/arm64/boot/dts/qcom/msm8939-longcheer-l9100.dts
index b845da4fa23e..ab645c929203 100644
--- a/arch/arm64/boot/dts/qcom/msm8939-longcheer-l9100.dts
+++ b/arch/arm64/boot/dts/qcom/msm8939-longcheer-l9100.dts
@@ -3,6 +3,7 @@
 /dts-v1/;
 
 #include "msm8939-pm8916.dtsi"
+#include "msm8916-modem-qdsp6.dtsi"
 
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/input.h>
@@ -85,7 +86,7 @@ reg_ts_vdd: regulator-vdd-ts {
 		pinctrl-names = "default";
 	};
 
-	backlight {
+	backlight: backlight {
 		compatible = "pwm-backlight";
 		pwms = <&pm8916_pwm 0 100000>;
 		brightness-levels = <0 255>;
@@ -220,6 +221,58 @@ imu@68 {
 	};
 };
 
+&blsp_i2c4 {
+	status = "okay";
+
+	charger: battery@14 {
+		compatible = "qcom,smb1360";
+		reg = <0x14>;
+
+		interrupt-parent = <&tlmm>;
+		interrupts = <62 IRQ_TYPE_LEVEL_LOW>;
+
+		pinctrl-0 = <&smb_int_default>;
+		pinctrl-names = "default";
+
+		qcom,rsense-10mohm;
+
+		qcom,float-voltage-mv = <4400>;
+		qcom,iterm-ma = <100>;
+		qcom,charging-timeout = <768>;
+		qcom,recharge-thresh-mv = <50>;
+		qcom,chg-inhibit-disabled;
+
+		qcom,battery-profile = <(-1)>; /* Set by bootloader */
+		qcom,fg-batt-capacity-mah = <3030>;
+		qcom,fg-cc-soc-coeff = <0x8168>;
+		qcom,fg-iterm-ma = <100>;
+		qcom,fg-ibatt-standby-ma = <200>;
+		qcom,fg-cutoff-voltage-mv = <3400>;
+		qcom,fg-cc-to-cv-mv = <4397>;
+		qcom,thermistor-c1-coeff = <0x86C2>;
+		qcom,fg-auto-recharge-soc = <95>; /* 97 in downstream */
+
+		qcom,otp-hard-jeita-config;
+		qcom,otp-hot-bat-decidegc = <550>;
+		qcom,otp-cold-bat-decidegc = <0>;
+
+		qcom,shdn-after-pwroff;
+		qcom,fg-reset-at-pon;
+		qcom,fg-reset-threshold-mv = <50>;
+
+		/*
+		 * Some properties are battery-specific. Battery detection
+		 * happens in the bootloader, so it will fill those appropriately
+		 * and set status = "okay".
+		 */
+		status = "disabled";
+
+		usb_otg_vbus: usb-otg-vbus {
+			regulator-max-microamp = <1500000>;
+		};
+	};
+};
+
 &blsp_i2c5 {
 	status = "okay";
 
@@ -246,6 +299,50 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+	pinctrl-names = "default", "sleep";
+	status = "okay";
+
+	panel@0 {
+		compatible = "longcheer,l9100-panel";
+		reg = <0>;
+
+		backlight = <&backlight>;
+		power-supply = <&pm8916_l17>;
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+	status = "okay";
+};
+
+&mpss_mem {
+	reg = <0x0 0x86800000 0x0 0x5000000>;
+};
+
 &pm8916_gpios {
 	status_led_default: status-led-default-state {
 		pins = "gpio3";
@@ -302,13 +399,18 @@ &sdhc_2 {
 	status = "okay";
 };
 
+&sound {
+	status = "disabled"; /* TODO */
+};
+
 &usb {
-	extcon = <&usb_id>, <&usb_id>;
+	extcon = <&charger>, <&usb_id>;
+	vbus-supply = <&usb_otg_vbus>;
 	status = "okay";
 };
 
 &usb_hs_phy {
-	extcon = <&usb_id>;
+	extcon = <&charger>;
 };
 
 &wcnss {
@@ -380,6 +482,20 @@ mag_reset_default: mag-reset-default-state {
 		bias-disable;
 	};
 
+	mdss_default: mdss-default-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	sdc2_cd_default: sdc2-cd-default-state {
 		pins = "gpio38";
 		function = "gpio";
@@ -387,6 +503,13 @@ sdc2_cd_default: sdc2-cd-default-state {
 		bias-disable;
 	};
 
+	smb_int_default: smb-int-default-state {
+		pins = "gpio62";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+
 	ts_int_reset_default: ts-int-reset-default-state {
 		pins = "gpio12", "gpio13";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8939-samsung-a7.dts b/arch/arm64/boot/dts/qcom/msm8939-samsung-a7.dts
index ceba6e73b211..9b9ed21199f3 100644
--- a/arch/arm64/boot/dts/qcom/msm8939-samsung-a7.dts
+++ b/arch/arm64/boot/dts/qcom/msm8939-samsung-a7.dts
@@ -235,6 +235,47 @@ reg_touch_key: regulator-touch-key {
 		pinctrl-names = "default";
 	};
 
+	reg_lcd_vci: regulator-lcd-vci {
+		compatible = "regulator-fixed";
+		regulator-name = "lcd_vci";
+		regulator-min-microvolt = <3000000>;
+		regulator-max-microvolt = <3000000>;
+
+		gpio = <&tlmm 90 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&lcd_en_default>;
+		pinctrl-names = "default";
+	};
+
+	reg_vcc_lcd: regulator-vcc-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_lcd";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&pm8916_s4>;
+
+		gpio = <&tlmm 89 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&lcd_io_en_default>;
+		pinctrl-names = "default";
+	};
+
+	reg_vdd_lcd: regulator-vdd-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "vdd_lcd";
+		regulator-min-microvolt = <1500000>;
+		regulator-max-microvolt = <1500000>;
+		vdd-supply = <&pm8916_s4>;
+
+		gpio = <&tlmm 87 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+
+		pinctrl-0 = <&lcdr_en_default>;
+		pinctrl-names = "default";
+	};
+
 	reg_tsp_vdd: regulator-tsp-vdd {
 		compatible = "regulator-fixed";
 		regulator-name = "tsp_vdd";
@@ -376,6 +417,10 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
 /*
  * For some reason the speaker amplifier is connected to the second SD line
  * (MI2S_2_D1) instead of the first (MI2S_2_D0). This must be configured in the
@@ -395,10 +440,59 @@ dai-link@3 {
 	};
 };
 
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+	pinctrl-names = "default", "sleep";
+
+	status = "okay";
+
+	panel@0 {
+		compatible = "samsung,s6e3fa2-ams549eh01";
+		reg = <0>;
+
+		vdd3-supply = <&reg_lcd_vci>;
+		vddr-supply = <&reg_vdd_lcd>;
+		vcc-supply = <&reg_vcc_lcd>;
+
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+	status = "okay";
+};
+
 &mpss_mem {
 	reg = <0x0 0x86800000 0x0 0x5800000>;
 };
 
+&pm8916_codec {
+	jack-gpios = <&tlmm 110 GPIO_ACTIVE_LOW>;
+	qcom,micbias-lvl = <2800>;
+	qcom,mbhc-vthreshold-low = <75 150 237 450 500>;
+	qcom,mbhc-vthreshold-high = <75 150 237 450 500>;
+
+	pinctrl-0 = <&jack_default>;
+	pinctrl-names = "default";
+};
+
 &pm8916_resin {
 	linux,code = <KEY_VOLUMEDOWN>;
 	status = "okay";
@@ -515,6 +609,48 @@ gpio_keys_default: gpio-keys-default-state {
 		bias-pull-up;
 	};
 
+	jack_default: jack-default-state {
+		pins = "gpio110";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcd_en_default: lcd-en-default-state {
+		pins = "gpio90";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcd_io_en_default: lcd-io-en-default-state {
+		pins = "gpio89";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	lcdr_en_default: lcdr-en-default-state {
+		pins = "gpio87";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	mdss_default: mdss-default-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
 	motor_en_default: motor-en-default-state {
 		pins = "gpio86";
 		function = "gpio";
diff --git a/arch/arm64/boot/dts/qcom/msm8939-wingtech-wt82918.dtsi b/arch/arm64/boot/dts/qcom/msm8939-wingtech-wt82918.dtsi
index 800e0747a2f7..c550fd555e5a 100644
--- a/arch/arm64/boot/dts/qcom/msm8939-wingtech-wt82918.dtsi
+++ b/arch/arm64/boot/dts/qcom/msm8939-wingtech-wt82918.dtsi
@@ -25,6 +25,25 @@ backlight: backlight {
 		default-brightness-level = <128>;
 	};
 
+	battery: battery {
+		compatible = "simple-battery";
+		device-chemistry = "lithium-ion-polymer";
+		voltage-min-design-microvolt = <3400000>;
+		voltage-max-design-microvolt = <4400000>;
+		energy-full-design-microwatt-hours = <10450000>;
+		charge-full-design-microamp-hours = <2750000>;
+
+		ocv-capacity-celsius = <25>;
+		ocv-capacity-table-0 = <4365000 100>, <4314000 95>, <4253000 90>,
+			<4194000 85>, <4137000 80>, <4084000 75>, <4032000 70>,
+			<3983000 65>, <3936000 60>, <3888000 55>, <3852000 50>,
+			<3826000 45>, <3806000 40>, <3789000 35>, <3779000 30>,
+			<3769000 25>, <3740000 20>, <3712000 16>, <3702000 13>,
+			<3692000 11>, <3690000 10>, <3688000 9>, <3687000 8>,
+			<3685000 7>, <3680000 6>, <3663000 5>, <3618000 4>,
+			<3558000 3>, <3478000 2>, <3352000 1>, <3000000 0>;
+	};
+
 	flash-led-controller {
 		compatible = "sgmicro,sgm3140";
 		enable-gpios = <&tlmm 31 GPIO_ACTIVE_HIGH>;
@@ -88,6 +107,26 @@ usb_id: usb-id {
 &blsp_i2c2 {
 	status = "okay";
 
+	regulator@3e {
+		compatible = "ti,tps65132";
+		reg = <0x3e>;
+
+		pinctrl-0 = <&reg_lcd_en_default>;
+		pinctrl-names = "default";
+
+		reg_lcd_pos: outp {
+			regulator-name = "outp";
+			enable-gpios = <&tlmm 0 GPIO_ACTIVE_HIGH>;
+			regulator-active-discharge = <1>;
+		};
+
+		reg_lcd_neg: outn {
+			regulator-name = "outn";
+			enable-gpios = <&tlmm 1 GPIO_ACTIVE_HIGH>;
+			regulator-active-discharge = <1>;
+		};
+	};
+
 	accelerometer@68 {
 		compatible = "invensense,icm20608";
 		reg = <0x68>;
@@ -129,10 +168,56 @@ &blsp_uart2 {
 	status = "okay";
 };
 
+&gpu {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&mdss_dsi0 {
+	pinctrl-0 = <&mdss_default>;
+	pinctrl-1 = <&mdss_sleep>;
+	pinctrl-names = "default", "sleep";
+	status = "okay";
+
+	panel@0 {
+		compatible = "wingtech,wt82918-panel";
+		reg = <0>;
+
+		backlight = <&backlight>;
+		vsp-supply = <&reg_lcd_pos>;
+		vsn-supply = <&reg_lcd_neg>;
+		reset-gpios = <&tlmm 25 GPIO_ACTIVE_LOW>;
+
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&mdss_dsi0_out>;
+			};
+		};
+	};
+};
+
+&mdss_dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&mdss_dsi0_phy {
+	qcom,dsi-phy-regulator-ldo-mode;
+	status = "okay";
+};
+
 &mpss_mem {
 	reg = <0x0 0x86800000 0x0 0x5500000>;
 };
 
+&pm8916_bms {
+	monitored-battery = <&battery>;
+	status = "okay";
+};
+
 &pm8916_pwm {
 	pinctrl-0 = <&pwm_out>;
 	pinctrl-names = "default";
@@ -217,6 +302,27 @@ gpio_leds_default: gpio-leds-default-state {
 		bias-disable;
 	};
 
+	mdss_default: mdss-default-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdss_sleep: mdss-sleep-state {
+		pins = "gpio25";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	reg_lcd_en_default: reg-lcd-en-default-state {
+		pins = "gpio0", "gpio1";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
 	touchscreen_default: touchscreen-default-state {
 		reset-pins {
 			pins = "gpio12";
diff --git a/arch/arm64/boot/dts/qcom/msm8939.dtsi b/arch/arm64/boot/dts/qcom/msm8939.dtsi
index 7af210789879..0f6c1bfbfb58 100644
--- a/arch/arm64/boot/dts/qcom/msm8939.dtsi
+++ b/arch/arm64/boot/dts/qcom/msm8939.dtsi
@@ -11,6 +11,7 @@
 #include <dt-bindings/power/qcom-rpmpd.h>
 #include <dt-bindings/reset/qcom,gcc-msm8939.h>
 #include <dt-bindings/soc/qcom,apr.h>
+#include <dt-bindings/soc/qcom,memshare.h>
 #include <dt-bindings/thermal/thermal.h>
 
 / {
@@ -238,6 +239,29 @@ memory@80000000 {
 		reg = <0x0 0x80000000 0x0 0x0>;
 	};
 
+	memshare: memshare {
+		compatible = "qcom,memshare";
+		qcom,legacy-client = <&memshare_gps>;
+
+		status = "disabled";
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		mpss@0 {
+			reg = <MEMSHARE_PROC_MPSS_V01>;
+			qcom,qrtr-node = <0>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			memshare_gps: gps@0 {
+				reg = <0>;
+				memory-region = <&gps_mem>;
+			};
+		};
+	};
+
 	pmu {
 		compatible = "arm,cortex-a53-pmu";
 		interrupts = <GIC_PPI 7 (GIC_CPU_MASK_SIMPLE(8) | IRQ_TYPE_LEVEL_HIGH)>;
@@ -385,6 +409,14 @@ mba_mem: mba {
 			no-map;
 			status = "disabled";
 		};
+
+		gps_mem: gps {
+			size = <0x0 0x200000>;
+			alignment = <0x0 0x100000>;
+			alloc-ranges = <0x0 0x86800000 0x0 0x8000000>;
+			no-map;
+			status = "disabled";
+		};
 	};
 
 	smp2p-hexagon {
@@ -1244,10 +1276,6 @@ mdss_mdp: display-controller@1a01000 {
 
 				iommus = <&apps_iommu 4>;
 
-				interconnects = <&snoc_mm MASTER_MDP_PORT0 &bimc SLAVE_EBI_CH0>,
-						<&snoc_mm MASTER_MDP_PORT1 &bimc SLAVE_EBI_CH0>;
-				interconnect-names = "mdp0-mem", "mdp1-mem";
-
 				ports {
 					#address-cells = <1>;
 					#size-cells = <0>;
@@ -1652,6 +1680,26 @@ q6routing: routing {
 							#sound-dai-cells = <0>;
 						};
 					};
+
+					q6mvm: apr-service@9 {
+						compatible = "qcom,q6mvm";
+						reg = <APR_SVC_ADSP_MVM>;
+
+						q6voicedai: dais {
+							compatible = "qcom,q6voice-dais";
+							#sound-dai-cells = <0>;
+						};
+					};
+
+					q6cvs: apr-service@a {
+						compatible = "qcom,q6cvs";
+						reg = <APR_SVC_ADSP_CVS>;
+					};
+
+					q6cvp: apr-service@b {
+						compatible = "qcom,q6cvp";
+						reg = <APR_SVC_ADSP_CVP>;
+					};
 				};
 			};
 		};
diff --git a/arch/arm64/configs/msm8916_defconfig b/arch/arm64/configs/msm8916_defconfig
new file mode 100644
index 000000000000..56b16f3afde7
--- /dev/null
+++ b/arch/arm64/configs/msm8916_defconfig
@@ -0,0 +1,465 @@
+CONFIG_LOCALVERSION="-msm8916"
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_AUDIT=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_BPF_JIT=y
+CONFIG_BPF_JIT_ALWAYS_ON=y
+CONFIG_PREEMPT=y
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_MEMCG=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_BPF=y
+CONFIG_USER_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_PROFILING=y
+CONFIG_ARCH_QCOM=y
+# CONFIG_AMPERE_ERRATUM_AC03_CPU_38 is not set
+# CONFIG_ARM64_ERRATUM_832075 is not set
+# CONFIG_ARM64_ERRATUM_1742098 is not set
+# CONFIG_ARM64_ERRATUM_1024718 is not set
+# CONFIG_ARM64_ERRATUM_1418040 is not set
+# CONFIG_ARM64_ERRATUM_1165522 is not set
+# CONFIG_ARM64_ERRATUM_1319367 is not set
+# CONFIG_ARM64_ERRATUM_1530923 is not set
+# CONFIG_ARM64_ERRATUM_1463225 is not set
+# CONFIG_ARM64_ERRATUM_1508412 is not set
+# CONFIG_ARM64_ERRATUM_2051678 is not set
+# CONFIG_ARM64_ERRATUM_2077057 is not set
+# CONFIG_ARM64_ERRATUM_2658417 is not set
+# CONFIG_ARM64_ERRATUM_2054223 is not set
+# CONFIG_ARM64_ERRATUM_2067961 is not set
+# CONFIG_ARM64_ERRATUM_2645198 is not set
+# CONFIG_ARM64_ERRATUM_2966298 is not set
+# CONFIG_ARM64_ERRATUM_3117295 is not set
+# CONFIG_ARM64_ERRATUM_3194386 is not set
+# CONFIG_CAVIUM_ERRATUM_22375 is not set
+# CONFIG_CAVIUM_ERRATUM_23154 is not set
+# CONFIG_CAVIUM_ERRATUM_27456 is not set
+# CONFIG_CAVIUM_ERRATUM_30115 is not set
+# CONFIG_CAVIUM_TX2_ERRATUM_219 is not set
+# CONFIG_FUJITSU_ERRATUM_010001 is not set
+# CONFIG_HISILICON_ERRATUM_161600802 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_1003 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_1009 is not set
+# CONFIG_QCOM_QDF2400_ERRATUM_0065 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_E1041 is not set
+# CONFIG_NVIDIA_CARMEL_CNP_ERRATUM is not set
+# CONFIG_ROCKCHIP_ERRATUM_3588001 is not set
+# CONFIG_SOCIONEXT_SYNQUACER_PREITS is not set
+CONFIG_ARM64_VA_BITS_48=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_CLUSTER=y
+CONFIG_SCHED_SMT=y
+CONFIG_NR_CPUS=8
+CONFIG_HOTPLUG_CPU=y
+CONFIG_HZ_300=y
+CONFIG_COMPAT=y
+# CONFIG_ARM64_HW_AFDBM is not set
+# CONFIG_ARM64_PAN is not set
+# CONFIG_ARM64_USE_LSE_ATOMICS is not set
+# CONFIG_ARM64_RAS_EXTN is not set
+# CONFIG_ARM64_CNP is not set
+# CONFIG_ARM64_PTR_AUTH is not set
+# CONFIG_ARM64_AMU_EXTN is not set
+# CONFIG_ARM64_TLB_RANGE is not set
+# CONFIG_ARM64_BTI is not set
+# CONFIG_ARM64_E0PD is not set
+# CONFIG_ARM64_POE is not set
+# CONFIG_ARM64_SVE is not set
+CONFIG_RANDOMIZE_BASE=y
+# CONFIG_EFI is not set
+# CONFIG_SUSPEND is not set
+CONFIG_PM=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_CPU_IDLE=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_ARM_QCOM_SPM_CPUIDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=m
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
+CONFIG_CPUFREQ_DT=y
+CONFIG_ARM_QCOM_CPUFREQ_NVMEM=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_KSM=y
+CONFIG_TRANSPARENT_HUGEPAGE=y
+CONFIG_CMA=y
+CONFIG_LRU_GEN=y
+CONFIG_LRU_GEN_ENABLED=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IPV6=m
+CONFIG_NETFILTER=y
+CONFIG_BRIDGE_NETFILTER=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_IPVS=m
+CONFIG_IP_VS=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_NAT=m
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_VLAN_FILTERING=y
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_VLAN_8021Q_MVRP=y
+CONFIG_QRTR=y
+CONFIG_QRTR_SMD=y
+CONFIG_QRTR_TUN=m
+CONFIG_BT=y
+CONFIG_BT_HIDP=m
+CONFIG_BT_LEDS=y
+CONFIG_BT_HCIBTUSB=m
+CONFIG_BT_QCOMSMD=m
+CONFIG_CFG80211=y
+CONFIG_MAC80211=y
+CONFIG_MAC80211_LEDS=y
+CONFIG_RFKILL=y
+CONFIG_NFC=m
+CONFIG_NFC_NCI=m
+CONFIG_NFC_NXP_NCI=m
+CONFIG_NFC_NXP_NCI_I2C=m
+CONFIG_NFC_S3FWRN5_I2C=m
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_QCOM_EBI2 is not set
+CONFIG_OF_OVERLAY=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_QCOM_FASTRPC=m
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_MD=y
+CONFIG_NETDEVICES=y
+CONFIG_MACVLAN=m
+CONFIG_MACVTAP=m
+CONFIG_VXLAN=m
+CONFIG_TUN=m
+CONFIG_VETH=m
+CONFIG_RMNET=m
+CONFIG_USB_USBNET=m
+CONFIG_WCN36XX=m
+CONFIG_WWAN=y
+CONFIG_QCOM_BAM_DMUX=m
+CONFIG_RPMSG_WWAN_CTRL=m
+CONFIG_INPUT_EVDEV=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_MATRIX=m
+CONFIG_KEYBOARD_TM2_TOUCHKEY=m
+# CONFIG_MOUSE_PS2 is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ATMEL_MXT=m
+CONFIG_TOUCHSCREEN_CYTTSP5=m
+CONFIG_TOUCHSCREEN_GOODIX=m
+CONFIG_TOUCHSCREEN_HIDEEP=m
+CONFIG_TOUCHSCREEN_HIMAX_HX852X=m
+CONFIG_TOUCHSCREEN_MMS114=m
+CONFIG_TOUCHSCREEN_MELFAS_MIP4=m
+CONFIG_TOUCHSCREEN_MSG2638=m
+CONFIG_TOUCHSCREEN_IMAGIS=m
+CONFIG_TOUCHSCREEN_EDT_FT5X06=m
+CONFIG_TOUCHSCREEN_STMFTS=m
+CONFIG_TOUCHSCREEN_ZINITIX=m
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_PM8941_PWRKEY=y
+CONFIG_INPUT_PM8XXX_VIBRATOR=m
+CONFIG_INPUT_GPIO_VIBRA=m
+CONFIG_INPUT_REGULATOR_HAPTIC=m
+CONFIG_INPUT_PWM_VIBRA=m
+CONFIG_RMI4_CORE=m
+CONFIG_RMI4_I2C=m
+CONFIG_RMI4_F11=y
+CONFIG_RMI4_F12=y
+# CONFIG_SERIO is not set
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_SERIAL_MSM=y
+CONFIG_SERIAL_MSM_CONSOLE=y
+CONFIG_SERIAL_DEV_BUS=y
+CONFIG_HW_RANDOM=y
+CONFIG_I2C_CHARDEV=m
+CONFIG_I2C_MUX=y
+CONFIG_I2C_GPIO=y
+CONFIG_I2C_QCOM_CCI=m
+CONFIG_I2C_QUP=y
+CONFIG_SPI=y
+CONFIG_SPI_GPIO=y
+CONFIG_SPI_QUP=y
+CONFIG_SPI_SPIDEV=m
+CONFIG_SPMI=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_PINCTRL_MSM=y
+CONFIG_PINCTRL_MSM8916=y
+CONFIG_PINCTRL_QCOM_SPMI_PMIC=y
+CONFIG_POWER_RESET_MSM=y
+CONFIG_POWER_RESET_QCOM_PON=y
+CONFIG_BATTERY_MAX17042=m
+CONFIG_SMB1360=m
+CONFIG_BATTERY_PM8916_BMS_VM=m
+CONFIG_CHARGER_PM8916_LBC=m
+CONFIG_BATTERY_RT5033=m
+CONFIG_CHARGER_RT5033=m
+CONFIG_THERMAL=y
+CONFIG_CPU_THERMAL=y
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_THERMAL_EMULATION=y
+CONFIG_QCOM_TSENS=y
+CONFIG_QCOM_SPMI_TEMP_ALARM=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_SYSFS=y
+CONFIG_QCOM_WDT=y
+CONFIG_PM8916_WATCHDOG=y
+CONFIG_MFD_SPMI_PMIC=y
+CONFIG_MFD_RT5033=m
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_QCOM_SMD_RPM=y
+CONFIG_REGULATOR_QCOM_SPMI=y
+CONFIG_REGULATOR_RT5033=m
+CONFIG_REGULATOR_TPS65132=y
+CONFIG_MEDIA_SUPPORT=m
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_PLATFORM_SUPPORT=y
+CONFIG_V4L2_FLASH_LED_CLASS=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_QCOM_CAMSS=m
+CONFIG_VIDEO_QCOM_VENUS=m
+CONFIG_DRM=y
+CONFIG_DRM_MSM=m
+# CONFIG_DRM_MSM_MDP4 is not set
+# CONFIG_DRM_MSM_DPU is not set
+# CONFIG_DRM_MSM_DP is not set
+# CONFIG_DRM_MSM_DSI_20NM_PHY is not set
+# CONFIG_DRM_MSM_DSI_28NM_8960_PHY is not set
+# CONFIG_DRM_MSM_DSI_14NM_PHY is not set
+# CONFIG_DRM_MSM_DSI_10NM_PHY is not set
+# CONFIG_DRM_MSM_DSI_7NM_PHY is not set
+# CONFIG_DRM_MSM_HDMI is not set
+CONFIG_DRM_PANEL_SAMSUNG_S6E88A0_AMS452EF01=m
+CONFIG_DRM_PANEL_SAMSUNG_S6D7AA0=m
+CONFIG_DRM_PANEL_SIMPLE=m
+CONFIG_DRM_PANEL_MSM8916_GENERATED=m
+CONFIG_DRM_DISPLAY_CONNECTOR=m
+CONFIG_DRM_I2C_ADV7511=m
+CONFIG_DRM_I2C_ADV7511_AUDIO=y
+CONFIG_DRM_PANEL_MIPI_DBI=m
+CONFIG_DRM_SIMPLEDRM=y
+CONFIG_FB=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+CONFIG_LOGO=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_ALOOP=m
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_QCOM=m
+CONFIG_SND_SOC_APQ8016_SBC=m
+CONFIG_SND_SOC_QDSP6=m
+CONFIG_SND_SOC_QDSP6_Q6VOICE=m
+CONFIG_SND_SOC_AK4375=m
+CONFIG_SND_SOC_AW8738=m
+CONFIG_SND_SOC_MAX98357A=m
+CONFIG_SND_SOC_MSM8916_WCD_ANALOG=m
+CONFIG_SND_SOC_MSM8916_WCD_DIGITAL=m
+CONFIG_SND_SOC_SIMPLE_AMPLIFIER=m
+CONFIG_SND_SOC_TFA989X=m
+CONFIG_USB_LED_TRIG=y
+CONFIG_USB=y
+CONFIG_USB_OTG=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_HSIC_USB3503=y
+CONFIG_USB_GADGET=y
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_MSM=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_CLASS_FLASH=m
+CONFIG_LEDS_CLASS_MULTICOLOR=y
+CONFIG_LEDS_AW2013=m
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_IS31FL319X=m
+CONFIG_LEDS_KTD2692=m
+CONFIG_LEDS_SGM3140=m
+CONFIG_LEDS_SY7802=m
+CONFIG_LEDS_KTD202X=m
+CONFIG_LEDS_QCOM_LPG=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_LEDS_TRIGGER_PANIC=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_PM8XXX=y
+CONFIG_DMADEVICES=y
+CONFIG_QCOM_BAM_DMA=y
+CONFIG_COMMON_CLK_QCOM=y
+CONFIG_QCOM_A53PLL=y
+CONFIG_QCOM_CLK_APCS_MSM8916=y
+CONFIG_QCOM_CLK_SMD_RPM=y
+CONFIG_MSM_GCC_8916=y
+CONFIG_MSM_GCC_8939=y
+CONFIG_HWSPINLOCK=y
+CONFIG_HWSPINLOCK_QCOM=y
+# CONFIG_FSL_ERRATUM_A008585 is not set
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+# CONFIG_ARM64_ERRATUM_858921 is not set
+CONFIG_MAILBOX=y
+CONFIG_QCOM_APCS_IPC=y
+CONFIG_ARM_SMMU=y
+CONFIG_QCOM_IOMMU=y
+CONFIG_REMOTEPROC=y
+CONFIG_REMOTEPROC_CDEV=y
+CONFIG_QCOM_Q6V5_MSS=m
+CONFIG_QCOM_SYSMON=y
+CONFIG_QCOM_WCNSS_PIL=m
+CONFIG_RPMSG_CHAR=y
+CONFIG_RPMSG_CTRL=y
+CONFIG_RPMSG_QCOM_SMD=y
+CONFIG_QCOM_MEMSHARE_QMI_SERVICE=m
+CONFIG_QCOM_RMTFS_MEM=y
+CONFIG_QCOM_SMEM=y
+CONFIG_QCOM_SMD_RPM=y
+CONFIG_QCOM_SMP2P=y
+CONFIG_QCOM_SMSM=y
+CONFIG_QCOM_SOCINFO=y
+CONFIG_QCOM_STATS=y
+CONFIG_QCOM_WCNSS_CTRL=m
+CONFIG_QCOM_APR=m
+CONFIG_QCOM_CPR=y
+CONFIG_QCOM_RPMPD=y
+CONFIG_PM_DEVFREQ=y
+CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
+CONFIG_DEVFREQ_GOV_PERFORMANCE=y
+CONFIG_DEVFREQ_GOV_POWERSAVE=y
+CONFIG_DEVFREQ_GOV_USERSPACE=y
+CONFIG_DEVFREQ_GOV_PASSIVE=m
+CONFIG_EXTCON_QCOM_SPMI_MISC=y
+CONFIG_EXTCON_SM5502=y
+CONFIG_EXTCON_USB_GPIO=y
+CONFIG_IIO=y
+CONFIG_IIO_TRIGGERED_BUFFER=y
+CONFIG_BMC150_ACCEL=m
+CONFIG_IIO_ST_ACCEL_3AXIS=m
+CONFIG_KXCJK1013=m
+CONFIG_QCOM_SPMI_VADC=y
+CONFIG_BMG160=m
+CONFIG_BMI160_I2C=m
+CONFIG_INV_MPU6050_I2C=m
+CONFIG_IIO_ST_LSM6DSX=m
+CONFIG_CM3323=m
+CONFIG_LTR501=m
+CONFIG_STK3310=m
+CONFIG_TSL2772=m
+CONFIG_AK8975=m
+CONFIG_BMC150_MAGN_I2C=m
+CONFIG_IIO_ST_MAGN_3AXIS=m
+CONFIG_YAMAHA_YAS530=m
+CONFIG_PWM=y
+CONFIG_PWM_CLK=y
+CONFIG_QCOM_MPM=y
+CONFIG_PHY_QCOM_USB_HS=y
+CONFIG_ARM_CCI_PMU=m
+# CONFIG_NVMEM_SYSFS is not set
+CONFIG_NVMEM_QCOM_QFPROM=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_FANOTIFY=y
+CONFIG_QUOTA=y
+CONFIG_AUTOFS_FS=y
+CONFIG_FUSE_FS=m
+CONFIG_CUSE=m
+CONFIG_OVERLAY_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_PSTORE=y
+CONFIG_PSTORE_CONSOLE=y
+CONFIG_PSTORE_PMSG=y
+CONFIG_PSTORE_RAM=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_CRYPTO_BLAKE2B=m
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+CONFIG_CRYPTO_USER_API_RNG=m
+CONFIG_CRYPTO_USER_API_AEAD=m
+CONFIG_CRYPTO_NHPOLY1305_NEON=m
+CONFIG_CRYPTO_CHACHA20_NEON=m
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_POLY1305_NEON=m
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_SHA512_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64=y
+CONFIG_CRYPTO_AES_ARM64_BS=y
+CONFIG_CRYPTO_SM4_ARM64_CE_BLK=m
+CONFIG_CRYPTO_SM4_ARM64_NEON_BLK=m
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_DEV_QCE=y
+CONFIG_CRYPTO_DEV_QCOM_RNG=y
+CONFIG_LIBCRC32C=y
+CONFIG_DMA_CMA=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x0
+CONFIG_DEBUG_FS=y
diff --git a/drivers/cpuidle/Kconfig.arm b/drivers/cpuidle/Kconfig.arm
index a1ee475d180d..259ad4150b4e 100644
--- a/drivers/cpuidle/Kconfig.arm
+++ b/drivers/cpuidle/Kconfig.arm
@@ -118,7 +118,7 @@ config ARM_TEGRA_CPUIDLE
 
 config ARM_QCOM_SPM_CPUIDLE
 	bool "CPU Idle Driver for Qualcomm Subsystem Power Manager (SPM)"
-	depends on (ARCH_QCOM || COMPILE_TEST) && !ARM64 && MMU
+	depends on (ARCH_QCOM || COMPILE_TEST) && MMU
 	depends on ARCH_SUSPEND_POSSIBLE
 	select ARM_CPU_SUSPEND
 	select CPU_IDLE_MULTIPLE_DRIVERS
diff --git a/drivers/cpuidle/cpuidle-qcom-spm.c b/drivers/cpuidle/cpuidle-qcom-spm.c
index 1fc9968eae19..69aaa2186d62 100644
--- a/drivers/cpuidle/cpuidle-qcom-spm.c
+++ b/drivers/cpuidle/cpuidle-qcom-spm.c
@@ -45,7 +45,11 @@ static int qcom_cpu_spc(struct spm_driver_data *drv)
 	int ret;
 
 	spm_set_low_power_mode(drv, PM_SLEEP_MODE_SPC);
+	if (!IS_ENABLED(CONFIG_ARM64))
+		ct_cpuidle_enter();
 	ret = cpu_suspend(0, qcom_pm_collapse);
+	if (!IS_ENABLED(CONFIG_ARM64))
+		ct_cpuidle_exit();
 	/*
 	 * ARM common code executes WFI without calling into our driver and
 	 * if the SPM mode is not reset, then we may accidently power down the
@@ -63,7 +67,7 @@ static __cpuidle int spm_enter_idle_state(struct cpuidle_device *dev,
 	struct cpuidle_qcom_spm_data *data = container_of(drv, struct cpuidle_qcom_spm_data,
 							  cpuidle_driver);
 
-	return CPU_PM_CPU_IDLE_ENTER_PARAM(qcom_cpu_spc, idx, data->spm);
+	return CPU_PM_CPU_IDLE_ENTER_PARAM_RCU(qcom_cpu_spc, idx, data->spm);
 }
 
 static struct cpuidle_driver qcom_spm_idle_driver = {
@@ -127,11 +131,17 @@ static int spm_cpuidle_register(struct device *cpuidle_dev, int cpu)
 static int spm_cpuidle_drv_probe(struct platform_device *pdev)
 {
 	int cpu, ret;
+	void *entry;
 
 	if (!qcom_scm_is_available())
 		return -EPROBE_DEFER;
 
-	ret = qcom_scm_set_warm_boot_addr(cpu_resume_arm);
+#ifdef CONFIG_ARM64
+	entry = cpu_resume;
+#else
+	entry = cpu_resume_arm;
+#endif
+	ret = qcom_scm_set_warm_boot_addr(entry);
 	if (ret)
 		return dev_err_probe(&pdev->dev, ret, "set warm boot addr failed");
 
diff --git a/drivers/gpu/drm/drm_atomic_helper.c b/drivers/gpu/drm/drm_atomic_helper.c
index 43cdf39019a4..f629325ffaeb 100644
--- a/drivers/gpu/drm/drm_atomic_helper.c
+++ b/drivers/gpu/drm/drm_atomic_helper.c
@@ -1177,6 +1177,9 @@ disable_outputs(struct drm_device *dev, struct drm_atomic_state *old_state)
 
 		/* Right function depends upon target state. */
 		if (funcs) {
+			if (funcs->late_enable)
+				drm_atomic_bridge_chain_post_disable(bridge, old_state);
+
 			if (funcs->atomic_disable)
 				funcs->atomic_disable(encoder, old_state);
 			else if (new_conn_state->crtc && funcs->prepare)
@@ -1187,7 +1190,8 @@ disable_outputs(struct drm_device *dev, struct drm_atomic_state *old_state)
 				funcs->dpms(encoder, DRM_MODE_DPMS_OFF);
 		}
 
-		drm_atomic_bridge_chain_post_disable(bridge, old_state);
+		if (!funcs || !funcs->late_enable)
+			drm_atomic_bridge_chain_post_disable(bridge, old_state);
 	}
 
 	for_each_oldnew_crtc_in_state(old_state, crtc, old_crtc_state, new_crtc_state, i) {
@@ -1517,6 +1521,9 @@ void drm_atomic_helper_commit_modeset_enables(struct drm_device *dev,
 		drm_atomic_bridge_chain_pre_enable(bridge, old_state);
 
 		if (funcs) {
+			if (funcs->late_enable)
+				drm_atomic_bridge_chain_enable(bridge, old_state);
+
 			if (funcs->atomic_enable)
 				funcs->atomic_enable(encoder, old_state);
 			else if (funcs->enable)
@@ -1525,7 +1532,8 @@ void drm_atomic_helper_commit_modeset_enables(struct drm_device *dev,
 				funcs->commit(encoder);
 		}
 
-		drm_atomic_bridge_chain_enable(bridge, old_state);
+		if (!funcs || !funcs->late_enable)
+			drm_atomic_bridge_chain_enable(bridge, old_state);
 	}
 
 	drm_atomic_helper_commit_writebacks(dev, old_state);
diff --git a/drivers/gpu/drm/msm/disp/mdp5/mdp5_encoder.c b/drivers/gpu/drm/msm/disp/mdp5/mdp5_encoder.c
index eaba3b2d73b5..166b5b7bfcce 100644
--- a/drivers/gpu/drm/msm/disp/mdp5/mdp5_encoder.c
+++ b/drivers/gpu/drm/msm/disp/mdp5/mdp5_encoder.c
@@ -243,6 +243,7 @@ static const struct drm_encoder_helper_funcs mdp5_encoder_helper_funcs = {
 	.disable = mdp5_encoder_disable,
 	.enable = mdp5_encoder_enable,
 	.atomic_check = mdp5_encoder_atomic_check,
+	.late_enable = true,
 };
 
 int mdp5_encoder_get_linecount(struct drm_encoder *encoder)
diff --git a/drivers/gpu/drm/msm/dsi/dsi_manager.c b/drivers/gpu/drm/msm/dsi/dsi_manager.c
index a210b7c9e5ca..241e06e5b311 100644
--- a/drivers/gpu/drm/msm/dsi/dsi_manager.c
+++ b/drivers/gpu/drm/msm/dsi/dsi_manager.c
@@ -248,24 +248,27 @@ static int dsi_mgr_bridge_power_on(struct drm_bridge *bridge)
 	return ret;
 }
 
-static void dsi_mgr_bridge_power_off(struct drm_bridge *bridge)
+static void dsi_mgr_bridge_pre_enable(struct drm_bridge *bridge)
 {
 	int id = dsi_mgr_bridge_get_id(bridge);
 	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
-	struct msm_dsi *msm_dsi1 = dsi_mgr_get_dsi(DSI_1);
-	struct mipi_dsi_host *host = msm_dsi->host;
 	bool is_bonded_dsi = IS_BONDED_DSI();
+	int ret;
 
-	msm_dsi_host_disable_irq(host);
-	if (is_bonded_dsi && msm_dsi1) {
-		msm_dsi_host_disable_irq(msm_dsi1->host);
-		msm_dsi_host_power_off(msm_dsi1->host);
+	DBG("id=%d", id);
+
+	/* Do nothing with the host if it is slave-DSI in case of bonded DSI */
+	if (is_bonded_dsi && !IS_MASTER_DSI_LINK(id))
+		return;
+
+	ret = dsi_mgr_bridge_power_on(bridge);
+	if (ret) {
+		dev_err(&msm_dsi->pdev->dev, "Power on failed: %d\n", ret);
+		return;
 	}
-	msm_dsi_host_power_off(host);
-	dsi_mgr_phy_disable(id);
 }
 
-static void dsi_mgr_bridge_pre_enable(struct drm_bridge *bridge)
+static void dsi_mgr_bridge_enable(struct drm_bridge *bridge)
 {
 	int id = dsi_mgr_bridge_get_id(bridge);
 	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
@@ -280,16 +283,10 @@ static void dsi_mgr_bridge_pre_enable(struct drm_bridge *bridge)
 	if (is_bonded_dsi && !IS_MASTER_DSI_LINK(id))
 		return;
 
-	ret = dsi_mgr_bridge_power_on(bridge);
-	if (ret) {
-		dev_err(&msm_dsi->pdev->dev, "Power on failed: %d\n", ret);
-		return;
-	}
-
 	ret = msm_dsi_host_enable(host);
 	if (ret) {
 		pr_err("%s: enable host %d failed, %d\n", __func__, id, ret);
-		goto host_en_fail;
+		return;
 	}
 
 	if (is_bonded_dsi && msm_dsi1) {
@@ -304,8 +301,6 @@ static void dsi_mgr_bridge_pre_enable(struct drm_bridge *bridge)
 
 host1_en_fail:
 	msm_dsi_host_disable(host);
-host_en_fail:
-	dsi_mgr_bridge_power_off(bridge);
 }
 
 void msm_dsi_manager_tpg_enable(void)
@@ -321,7 +316,7 @@ void msm_dsi_manager_tpg_enable(void)
 	}
 }
 
-static void dsi_mgr_bridge_post_disable(struct drm_bridge *bridge)
+static void dsi_mgr_bridge_disable(struct drm_bridge *bridge)
 {
 	int id = dsi_mgr_bridge_get_id(bridge);
 	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
@@ -338,7 +333,7 @@ static void dsi_mgr_bridge_post_disable(struct drm_bridge *bridge)
 	 * won't be diabled until both PHYs request disable.
 	 */
 	if (is_bonded_dsi && !IS_MASTER_DSI_LINK(id))
-		goto disable_phy;
+		return;
 
 	ret = msm_dsi_host_disable(host);
 	if (ret)
@@ -349,6 +344,26 @@ static void dsi_mgr_bridge_post_disable(struct drm_bridge *bridge)
 		if (ret)
 			pr_err("%s: host1 disable failed, %d\n", __func__, ret);
 	}
+}
+
+static void dsi_mgr_bridge_post_disable(struct drm_bridge *bridge)
+{
+	int id = dsi_mgr_bridge_get_id(bridge);
+	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
+	struct msm_dsi *msm_dsi1 = dsi_mgr_get_dsi(DSI_1);
+	struct mipi_dsi_host *host = msm_dsi->host;
+	bool is_bonded_dsi = IS_BONDED_DSI();
+	int ret;
+
+	DBG("id=%d", id);
+
+	/*
+	 * Do nothing with the host if it is slave-DSI in case of bonded DSI.
+	 * It is safe to call dsi_mgr_phy_disable() here because a single PHY
+	 * won't be diabled until both PHYs request disable.
+	 */
+	if (is_bonded_dsi && !IS_MASTER_DSI_LINK(id))
+		goto disable_phy;
 
 	msm_dsi_host_disable_irq(host);
 	if (is_bonded_dsi && msm_dsi1)
@@ -436,6 +451,8 @@ static int dsi_mgr_bridge_attach(struct drm_bridge *bridge,
 static const struct drm_bridge_funcs dsi_mgr_bridge_funcs = {
 	.attach = dsi_mgr_bridge_attach,
 	.pre_enable = dsi_mgr_bridge_pre_enable,
+	.enable = dsi_mgr_bridge_enable,
+	.disable = dsi_mgr_bridge_disable,
 	.post_disable = dsi_mgr_bridge_post_disable,
 	.mode_set = dsi_mgr_bridge_mode_set,
 	.mode_valid = dsi_mgr_bridge_mode_valid,
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index d3a9a9fafe4e..d092d112892e 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -988,4 +988,5 @@ config DRM_PANEL_XINPENG_XPP055C272
 	  Say Y here if you want to enable support for the Xinpeng
 	  XPP055C272 controller for 720x1280 LCD panels with MIPI/RGB/SPI
 	  system interfaces.
+source "drivers/gpu/drm/panel/msm8916-generated/Kconfig"
 endmenu
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 987a08702410..9b304bea15bf 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -100,3 +100,4 @@ obj-$(CONFIG_DRM_PANEL_VISIONOX_VTDR6130) += panel-visionox-vtdr6130.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_R66451) += panel-visionox-r66451.o
 obj-$(CONFIG_DRM_PANEL_WIDECHIPS_WS2401) += panel-widechips-ws2401.o
 obj-$(CONFIG_DRM_PANEL_XINPENG_XPP055C272) += panel-xinpeng-xpp055c272.o
+obj-y += msm8916-generated/
diff --git a/drivers/gpu/drm/panel/msm8916-generated/Kconfig b/drivers/gpu/drm/panel/msm8916-generated/Kconfig
new file mode 100644
index 000000000000..199380ae19a6
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/Kconfig
@@ -0,0 +1,188 @@
+menu "MSM8916 panel drivers generated with linux-mdss-dsi-panel-driver-generator"
+	depends on GPIOLIB && OF && REGULATOR
+	depends on DRM_MIPI_DSI
+
+config DRM_PANEL_MSM8916_GENERATED
+	tristate "Select all generated MSM8916 panel drivers by default"
+
+config DRM_PANEL_ACER_A1_724_HX8394D
+	tristate "Acer A1 724 HX8394D"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_ALCATEL_AUO_HX8394D
+	tristate "Alcatel AUO HX8394D"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_ALCATEL_IDOL3_NT35596
+	tristate "Alcatel IDOL3 NT35596"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_ALCATEL_IDOL3_R63315
+	tristate "Alcatel IDOL3 R63315"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_ASUS_Z00L_OTM1284A
+	tristate "Asus Z00L OTM1284A"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_ASUS_Z010D_R69339
+	tristate "Asus Z010D R69339"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_GPLUS_FL8005A_HX8394D
+	tristate "Gplus FL8005A HX8394D"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_HUAWEI_BOE_OTM8019A
+	tristate "Huawei BOE OTM8019A"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_HUAWEI_KIWI_CMI_NT35532
+	tristate "Huawei KIWI CMI NT35532"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_HUAWEI_KIWI_TIANMA_NT35596
+	tristate "Huawei KIWI TIANMA NT35596"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_HUAWEI_TIANMA_NT35521
+	tristate "Huawei TIANMA NT35521"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_LONGCHEER_BOOYI_OTM1287
+	tristate "Longcheer BOOYI OTM1287"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_LONGCHEER_DIJING_ILI9881C
+	tristate "Longcheer DIJING ILI9881C"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_LONGCHEER_TRULY_NT35695
+	tristate "Longcheer TRULY NT35695"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_LONGCHEER_TRULY_OTM1288A
+	tristate "Longcheer TRULY OTM1288A"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_LONGCHEER_YUSHUN_NT35520
+	tristate "Longcheer YUSHUN NT35520"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_LONGCHEER_YUSHUN_NT35521S
+	tristate "Longcheer YUSHUN NT35521S"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_MOTOROLA_HARPIA_BOE
+	tristate "Motorola HARPIA BOE"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_MOTOROLA_HARPIA_TIANMA
+	tristate "Motorola HARPIA TIANMA"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_MOTOROLA_OSPREY_INX
+	tristate "Motorola OSPREY INX"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_MOTOROLA_SURNIA_BOE
+	tristate "Motorola SURNIA BOE"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_MOTOROLA_SURNIA_INX
+	tristate "Motorola SURNIA INX"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_SAMSUNG_EA8061_AMS549BU19_ID400418
+	tristate "Samsung EA8061 AMS549BU19 ID400418"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_SAMSUNG_EA8061V_AMS497EE01
+	tristate "Samsung EA8061V AMS497EE01"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_SAMSUNG_HX8389C_GH9607501A
+	tristate "Samsung HX8389C GH9607501A"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_SAMSUNG_NT51017_B4P096WX5VP09
+	tristate "Samsung NT51017 B4P096WX5VP09"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_SAMSUNG_S6288A0
+	tristate "Samsung S6288A0"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_SAMSUNG_S6D2AA0X62_LPM053A250A
+	tristate "Samsung S6D2AA0X62 LPM053A250A"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_SAMSUNG_S6D78A0_GH9607501A
+	tristate "Samsung S6D78A0 GH9607501A"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_SAMSUNG_S6E3FA2_AMS549EH01
+	tristate "Samsung S6E3FA2 AMS549EH01"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_SAMSUNG_S6E88A0_AMS427AP24
+	tristate "Samsung S6E88A0 AMS427AP24"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_SAMSUNG_S6E8AA5X01_AMS497HY01
+	tristate "Samsung S6E8AA5X01 AMS497HY01"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_SAMSUNG_S6E8AA5X01_AMS520KT01
+	tristate "Samsung S6E8AA5X01 AMS520KT01"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_SAMSUNG_SC7798A_BV045WVM
+	tristate "Samsung SC7798A BV045WVM"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_WINGTECH_AUO_NT35521
+	tristate "Wingtech AUO NT35521"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_WINGTECH_AUO_R61308
+	tristate "Wingtech AUO R61308"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_WINGTECH_BOE_HX8394F
+	tristate "Wingtech BOE HX8394F"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_WINGTECH_BOE_NT35521S
+	tristate "Wingtech BOE NT35521S"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_WINGTECH_EBBG_OTM1285A
+	tristate "Wingtech EBBG OTM1285A"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_WINGTECH_OTM_ILI9881C
+	tristate "Wingtech OTM ILI9881C"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_WINGTECH_QIMEI_ILI9881
+	tristate "Wingtech QIMEI ILI9881"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_WINGTECH_SHARP_R69431
+	tristate "Wingtech SHARP R69431"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_WINGTECH_TIANMA_HX8394D
+	tristate "Wingtech TIANMA HX8394D"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_WINGTECH_TM_OTM1901A
+	tristate "Wingtech TM OTM1901A"
+	default DRM_PANEL_MSM8916_GENERATED
+
+config DRM_PANEL_WINGTECH_YASSY_ILI9881
+	tristate "Wingtech YASSY ILI9881"
+	default DRM_PANEL_MSM8916_GENERATED
+
+endmenu
diff --git a/drivers/gpu/drm/panel/msm8916-generated/Makefile b/drivers/gpu/drm/panel/msm8916-generated/Makefile
new file mode 100644
index 000000000000..d626c33070b3
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/Makefile
@@ -0,0 +1,45 @@
+obj-$(CONFIG_DRM_PANEL_ACER_A1_724_HX8394D) += panel-acer-a1-724-hx8394d.o
+obj-$(CONFIG_DRM_PANEL_ALCATEL_AUO_HX8394D) += panel-alcatel-auo-hx8394d.o
+obj-$(CONFIG_DRM_PANEL_ALCATEL_IDOL3_NT35596) += panel-alcatel-idol3-nt35596.o
+obj-$(CONFIG_DRM_PANEL_ALCATEL_IDOL3_R63315) += panel-alcatel-idol3-r63315.o
+obj-$(CONFIG_DRM_PANEL_ASUS_Z00L_OTM1284A) += panel-asus-z00l-otm1284a.o
+obj-$(CONFIG_DRM_PANEL_ASUS_Z010D_R69339) += panel-asus-z010d-r69339.o
+obj-$(CONFIG_DRM_PANEL_GPLUS_FL8005A_HX8394D) += panel-gplus-fl8005a-hx8394d.o
+obj-$(CONFIG_DRM_PANEL_HUAWEI_BOE_OTM8019A) += panel-huawei-boe-otm8019a.o
+obj-$(CONFIG_DRM_PANEL_HUAWEI_KIWI_CMI_NT35532) += panel-huawei-kiwi-cmi-nt35532.o
+obj-$(CONFIG_DRM_PANEL_HUAWEI_KIWI_TIANMA_NT35596) += panel-huawei-kiwi-tianma-nt35596.o
+obj-$(CONFIG_DRM_PANEL_HUAWEI_TIANMA_NT35521) += panel-huawei-tianma-nt35521.o
+obj-$(CONFIG_DRM_PANEL_LONGCHEER_BOOYI_OTM1287) += panel-longcheer-booyi-otm1287.o
+obj-$(CONFIG_DRM_PANEL_LONGCHEER_DIJING_ILI9881C) += panel-longcheer-dijing-ili9881c.o
+obj-$(CONFIG_DRM_PANEL_LONGCHEER_TRULY_NT35695) += panel-longcheer-truly-nt35695.o
+obj-$(CONFIG_DRM_PANEL_LONGCHEER_TRULY_OTM1288A) += panel-longcheer-truly-otm1288a.o
+obj-$(CONFIG_DRM_PANEL_LONGCHEER_YUSHUN_NT35520) += panel-longcheer-yushun-nt35520.o
+obj-$(CONFIG_DRM_PANEL_LONGCHEER_YUSHUN_NT35521S) += panel-longcheer-yushun-nt35521s.o
+obj-$(CONFIG_DRM_PANEL_MOTOROLA_HARPIA_BOE) += panel-motorola-harpia-boe.o
+obj-$(CONFIG_DRM_PANEL_MOTOROLA_HARPIA_TIANMA) += panel-motorola-harpia-tianma.o
+obj-$(CONFIG_DRM_PANEL_MOTOROLA_OSPREY_INX) += panel-motorola-osprey-inx.o
+obj-$(CONFIG_DRM_PANEL_MOTOROLA_SURNIA_BOE) += panel-motorola-surnia-boe.o
+obj-$(CONFIG_DRM_PANEL_MOTOROLA_SURNIA_INX) += panel-motorola-surnia-inx.o
+obj-$(CONFIG_DRM_PANEL_SAMSUNG_EA8061_AMS549BU19_ID400418) += panel-samsung-ea8061-ams549bu19-id400418.o
+obj-$(CONFIG_DRM_PANEL_SAMSUNG_EA8061V_AMS497EE01) += panel-samsung-ea8061v-ams497ee01.o
+obj-$(CONFIG_DRM_PANEL_SAMSUNG_HX8389C_GH9607501A) += panel-samsung-hx8389c-gh9607501a.o
+obj-$(CONFIG_DRM_PANEL_SAMSUNG_NT51017_B4P096WX5VP09) += panel-samsung-nt51017-b4p096wx5vp09.o
+obj-$(CONFIG_DRM_PANEL_SAMSUNG_S6288A0) += panel-samsung-s6288a0.o
+obj-$(CONFIG_DRM_PANEL_SAMSUNG_S6D2AA0X62_LPM053A250A) += panel-samsung-s6d2aa0x62-lpm053a250a.o
+obj-$(CONFIG_DRM_PANEL_SAMSUNG_S6D78A0_GH9607501A) += panel-samsung-s6d78a0-gh9607501a.o
+obj-$(CONFIG_DRM_PANEL_SAMSUNG_S6E3FA2_AMS549EH01) += panel-samsung-s6e3fa2-ams549eh01.o
+obj-$(CONFIG_DRM_PANEL_SAMSUNG_S6E88A0_AMS427AP24) += panel-samsung-s6e88a0-ams427ap24.o
+obj-$(CONFIG_DRM_PANEL_SAMSUNG_S6E8AA5X01_AMS497HY01) += panel-samsung-s6e8aa5x01-ams497hy01.o
+obj-$(CONFIG_DRM_PANEL_SAMSUNG_S6E8AA5X01_AMS520KT01) += panel-samsung-s6e8aa5x01-ams520kt01.o
+obj-$(CONFIG_DRM_PANEL_SAMSUNG_SC7798A_BV045WVM) += panel-samsung-sc7798a-bv045wvm.o
+obj-$(CONFIG_DRM_PANEL_WINGTECH_AUO_NT35521) += panel-wingtech-auo-nt35521.o
+obj-$(CONFIG_DRM_PANEL_WINGTECH_AUO_R61308) += panel-wingtech-auo-r61308.o
+obj-$(CONFIG_DRM_PANEL_WINGTECH_BOE_HX8394F) += panel-wingtech-boe-hx8394f.o
+obj-$(CONFIG_DRM_PANEL_WINGTECH_BOE_NT35521S) += panel-wingtech-boe-nt35521s.o
+obj-$(CONFIG_DRM_PANEL_WINGTECH_EBBG_OTM1285A) += panel-wingtech-ebbg-otm1285a.o
+obj-$(CONFIG_DRM_PANEL_WINGTECH_OTM_ILI9881C) += panel-wingtech-otm-ili9881c.o
+obj-$(CONFIG_DRM_PANEL_WINGTECH_QIMEI_ILI9881) += panel-wingtech-qimei-ili9881.o
+obj-$(CONFIG_DRM_PANEL_WINGTECH_SHARP_R69431) += panel-wingtech-sharp-r69431.o
+obj-$(CONFIG_DRM_PANEL_WINGTECH_TIANMA_HX8394D) += panel-wingtech-tianma-hx8394d.o
+obj-$(CONFIG_DRM_PANEL_WINGTECH_TM_OTM1901A) += panel-wingtech-tm-otm1901a.o
+obj-$(CONFIG_DRM_PANEL_WINGTECH_YASSY_ILI9881) += panel-wingtech-yassy-ili9881.o
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-acer-a1-724-hx8394d.c b/drivers/gpu/drm/panel/msm8916-generated/panel-acer-a1-724-hx8394d.c
new file mode 100644
index 000000000000..30883bb1b21a
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-acer-a1-724-hx8394d.c
@@ -0,0 +1,328 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct hx8394d {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct hx8394d *to_hx8394d(struct drm_panel *panel)
+{
+	return container_of(panel, struct hx8394d, panel);
+}
+
+static void hx8394d_reset(struct hx8394d *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int hx8394d_on(struct hx8394d *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0xff, 0x83, 0x94);
+	mipi_dsi_dcs_write_seq(dsi, 0xba,
+			       0x73, 0x43, 0xa0, 0x65, 0xb2, 0x89, 0x09, 0x40,
+			       0x50, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x00, 0x00, 0x7d, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1,
+			       0x6c, 0x15, 0x15, 0x24, 0x04, 0x11, 0xf1, 0x80,
+			       0xe4, 0x97, 0x23, 0x80, 0xc0, 0xd2, 0x58);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2,
+			       0x00, 0x64, 0x10, 0x07, 0x22, 0x1c, 0x08, 0x08,
+			       0x1c, 0x4d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4,
+			       0x00, 0xff, 0x03, 0x5a, 0x03, 0x5a, 0x03, 0x5a,
+			       0x01, 0x6a, 0x30, 0x6a);
+	mipi_dsi_dcs_write_seq(dsi, 0xbc, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0xbf, 0x41, 0x0e, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3,
+			       0x00, 0x06, 0x00, 0x40, 0x07, 0x08, 0x00, 0x32,
+			       0x10, 0x07, 0x00, 0x07, 0x54, 0x15, 0x0f, 0x05,
+			       0x04, 0x02, 0x12, 0x10, 0x05, 0x07, 0x33, 0x33,
+			       0x0b, 0x0b, 0x37, 0x10, 0x07, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0xd5,
+			       0x04, 0x05, 0x06, 0x07, 0x00, 0x01, 0x02, 0x03,
+			       0x20, 0x21, 0x22, 0x23, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18, 0x19, 0x19, 0x18, 0x18,
+			       0x18, 0x18, 0x1b, 0x1b, 0x1a, 0x1a, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xd6,
+			       0x03, 0x02, 0x01, 0x00, 0x07, 0x06, 0x05, 0x04,
+			       0x23, 0x22, 0x21, 0x20, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x58, 0x58, 0x18, 0x18, 0x19, 0x19,
+			       0x18, 0x18, 0x1b, 0x1b, 0x1a, 0x1a, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xb6, 0x4c, 0x4c);
+	mipi_dsi_dcs_write_seq(dsi, 0xe0,
+			       0x00, 0x10, 0x16, 0x2d, 0x33, 0x3f, 0x23, 0x3e,
+			       0x07, 0x0b, 0x0d, 0x17, 0x0e, 0x12, 0x14, 0x12,
+			       0x13, 0x06, 0x11, 0x13, 0x18, 0x00, 0x0f, 0x16,
+			       0x2e, 0x33, 0x3f, 0x23, 0x3d, 0x07, 0x0b, 0x0d,
+			       0x18, 0x0f, 0x12, 0x14, 0x12, 0x14, 0x07, 0x11,
+			       0x12, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x30, 0x14);
+	mipi_dsi_dcs_write_seq(dsi, 0xc7, 0x00, 0xc0, 0x40, 0xc0);
+	mipi_dsi_dcs_write_seq(dsi, 0xdf, 0x8e);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0x66);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(200);
+
+	mipi_dsi_dcs_write_seq(dsi, 0xc9, 0x1f, 0x00, 0x14);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x01);
+	usleep_range(5000, 6000);
+
+	return 0;
+}
+
+static int hx8394d_off(struct hx8394d *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hx8394d_prepare(struct drm_panel *panel)
+{
+	struct hx8394d *ctx = to_hx8394d(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	hx8394d_reset(ctx);
+
+	ret = hx8394d_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hx8394d_unprepare(struct drm_panel *panel)
+{
+	struct hx8394d *ctx = to_hx8394d(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = hx8394d_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode hx8394d_mode = {
+	.clock = (720 + 50 + 50 + 50) * (1280 + 9 + 2 + 16) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 50,
+	.hsync_end = 720 + 50 + 50,
+	.htotal = 720 + 50 + 50 + 50,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 9,
+	.vsync_end = 1280 + 9 + 2,
+	.vtotal = 1280 + 9 + 2 + 16,
+	.width_mm = 88,
+	.height_mm = 160,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int hx8394d_get_modes(struct drm_panel *panel,
+			     struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &hx8394d_mode);
+}
+
+static const struct drm_panel_funcs hx8394d_panel_funcs = {
+	.prepare = hx8394d_prepare,
+	.unprepare = hx8394d_unprepare,
+	.get_modes = hx8394d_get_modes,
+};
+
+static int hx8394d_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct backlight_ops hx8394d_bl_ops = {
+	.update_status = hx8394d_bl_update_status,
+};
+
+static struct backlight_device *
+hx8394d_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 225,
+		.max_brightness = 225,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &hx8394d_bl_ops, &props);
+}
+
+static int hx8394d_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct hx8394d *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &hx8394d_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ctx->panel.backlight = hx8394d_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void hx8394d_remove(struct mipi_dsi_device *dsi)
+{
+	struct hx8394d *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id hx8394d_of_match[] = {
+	{ .compatible = "acer,a1-724-hx8394d" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, hx8394d_of_match);
+
+static struct mipi_dsi_driver hx8394d_driver = {
+	.probe = hx8394d_probe,
+	.remove = hx8394d_remove,
+	.driver = {
+		.name = "panel-acer-a1-724-hx8394d",
+		.of_match_table = hx8394d_of_match,
+	},
+};
+module_mipi_dsi_driver(hx8394d_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for hx8394d 720p video mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-alcatel-auo-hx8394d.c b/drivers/gpu/drm/panel/msm8916-generated/panel-alcatel-auo-hx8394d.c
new file mode 100644
index 000000000000..8faa85cc8967
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-alcatel-auo-hx8394d.c
@@ -0,0 +1,295 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct hx8394d_auo {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct hx8394d_auo *to_hx8394d_auo(struct drm_panel *panel)
+{
+	return container_of(panel, struct hx8394d_auo, panel);
+}
+
+static void hx8394d_auo_reset(struct hx8394d_auo *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(50);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(120);
+}
+
+static int hx8394d_auo_on(struct hx8394d_auo *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0xff, 0x83, 0x94);
+	mipi_dsi_dcs_write_seq(dsi, 0xba,
+			       0x73, 0x83, 0xa0, 0x65, 0xb2, 0x3f, 0x4f, 0x40,
+			       0x50, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1,
+			       0x6c, 0x12, 0x12, 0x34, 0x04, 0x11, 0xf1, 0x80,
+			       0x9f, 0xa0, 0x23, 0x80, 0xc0, 0xd2, 0x58);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2,
+			       0x00, 0x64, 0x05, 0x07, 0x22, 0x1c, 0x08, 0x08,
+			       0x1c, 0x4d, 0x00, 0x03, 0x20, 0x46, 0x48);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4,
+			       0x00, 0xff, 0x03, 0x5a, 0x03, 0x5a, 0x03, 0x5a,
+			       0x01, 0x70, 0x01, 0x70);
+	mipi_dsi_dcs_write_seq(dsi, 0xbc, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0xe0,
+			       0x12, 0x2d, 0x36, 0x30, 0x33, 0x39, 0x39, 0x4a,
+			       0x09, 0x0c, 0x0e, 0x18, 0x0f, 0x12, 0x15, 0x13,
+			       0x14, 0x06, 0x10, 0x10, 0x18, 0x12, 0x2d, 0x36,
+			       0x30, 0x33, 0x39, 0x39, 0x4a, 0x09, 0x0c, 0x0e,
+			       0x18, 0x0f, 0x12, 0x15, 0x13, 0x14, 0x0a, 0x16,
+			       0x18, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3,
+			       0x00, 0x06, 0x00, 0x01, 0x01, 0x10, 0x00, 0x32,
+			       0x10, 0x00, 0x00, 0x00, 0x32, 0x15, 0x04, 0x35,
+			       0x04, 0x32, 0x15, 0x14, 0x05, 0x14, 0x37, 0x33,
+			       0x00, 0x00, 0x37, 0x00, 0x07, 0x37);
+	mipi_dsi_dcs_write_seq(dsi, 0xd5,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x25, 0x24,
+			       0x27, 0x26, 0x18, 0x18, 0x47, 0x46, 0x43, 0x42,
+			       0x41, 0x40, 0x45, 0x44, 0x05, 0x04, 0x01, 0x00,
+			       0x07, 0x06, 0x03, 0x02, 0x21, 0x20, 0x23, 0x22,
+			       0x18, 0x18, 0x18, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xd6,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x22, 0x23,
+			       0x20, 0x21, 0x18, 0x18, 0x00, 0x01, 0x04, 0x05,
+			       0x06, 0x07, 0x02, 0x03, 0x02, 0x03, 0x06, 0x07,
+			       0x00, 0x01, 0x04, 0x05, 0x26, 0x27, 0x24, 0x25,
+			       0x18, 0x18, 0x18, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xbd, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xd8,
+			       0xaa, 0xab, 0xef, 0xff, 0xff, 0xf0, 0xaa, 0xab,
+			       0xef, 0xff, 0xff, 0xf0, 0xaa, 0xab, 0xef, 0xff,
+			       0xff, 0xf0, 0xaa, 0xab, 0xef, 0xff, 0xff, 0xf0,
+			       0xaa, 0xab, 0xef, 0xff, 0xff, 0xf0, 0xaa, 0xab,
+			       0xef, 0xff, 0xff, 0xf0);
+	mipi_dsi_dcs_write_seq(dsi, 0xbd, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd8,
+			       0xaa, 0xab, 0xef, 0xff, 0xff, 0xf0, 0xaa, 0xab,
+			       0xef, 0xff, 0xff, 0xf0);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xb6, 0x62, 0x62);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x30, 0x14);
+	mipi_dsi_dcs_write_seq(dsi, 0xc7, 0x00, 0xc0, 0x40, 0xc0);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0x02);
+
+	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set tear on: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+static int hx8394d_auo_off(struct hx8394d_auo *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int hx8394d_auo_prepare(struct drm_panel *panel)
+{
+	struct hx8394d_auo *ctx = to_hx8394d_auo(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	hx8394d_auo_reset(ctx);
+
+	ret = hx8394d_auo_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hx8394d_auo_unprepare(struct drm_panel *panel)
+{
+	struct hx8394d_auo *ctx = to_hx8394d_auo(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = hx8394d_auo_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode hx8394d_auo_mode = {
+	.clock = (720 + 52 + 24 + 100) * (1280 + 9 + 2 + 5) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 52,
+	.hsync_end = 720 + 52 + 24,
+	.htotal = 720 + 52 + 24 + 100,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 9,
+	.vsync_end = 1280 + 9 + 2,
+	.vtotal = 1280 + 9 + 2 + 5,
+	.width_mm = 59,
+	.height_mm = 104,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int hx8394d_auo_get_modes(struct drm_panel *panel,
+				 struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &hx8394d_auo_mode);
+}
+
+static const struct drm_panel_funcs hx8394d_auo_panel_funcs = {
+	.prepare = hx8394d_auo_prepare,
+	.unprepare = hx8394d_auo_unprepare,
+	.get_modes = hx8394d_auo_get_modes,
+};
+
+static int hx8394d_auo_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct hx8394d_auo *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &hx8394d_auo_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void hx8394d_auo_remove(struct mipi_dsi_device *dsi)
+{
+	struct hx8394d_auo *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id hx8394d_auo_of_match[] = {
+	{ .compatible = "alcatel,auo-hx8394d" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, hx8394d_auo_of_match);
+
+static struct mipi_dsi_driver hx8394d_auo_driver = {
+	.probe = hx8394d_auo_probe,
+	.remove = hx8394d_auo_remove,
+	.driver = {
+		.name = "panel-alcatel-auo-hx8394d",
+		.of_match_table = hx8394d_auo_of_match,
+	},
+};
+module_mipi_dsi_driver(hx8394d_auo_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for hx8394d auo 720p video mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-alcatel-idol3-nt35596.c b/drivers/gpu/drm/panel/msm8916-generated/panel-alcatel-idol3-nt35596.c
new file mode 100644
index 000000000000..252632f390b1
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-alcatel-idol3-nt35596.c
@@ -0,0 +1,745 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct nt35596 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct nt35596 *to_nt35596(struct drm_panel *panel)
+{
+	return container_of(panel, struct nt35596, panel);
+}
+
+static void nt35596_reset(struct nt35596 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int nt35596_on(struct nt35596 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x05);
+	usleep_range(1000, 2000);
+	mipi_dsi_dcs_write_seq(dsi, 0x90, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x93, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x94, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x9b, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0xa4, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x91, 0x44);
+	mipi_dsi_dcs_write_seq(dsi, 0x92, 0x79);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x01, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x02, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x03, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x04, 0x0b);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x06, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x08, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x09, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x0a, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x0b, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x0c, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0d, 0x13);
+	mipi_dsi_dcs_write_seq(dsi, 0x0e, 0x15);
+	mipi_dsi_dcs_write_seq(dsi, 0x0f, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x13, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x14, 0x0b);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x17, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x18, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x19, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x1a, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x1b, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x1c, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x1d, 0x13);
+	mipi_dsi_dcs_write_seq(dsi, 0x1e, 0x15);
+	mipi_dsi_dcs_write_seq(dsi, 0x1f, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0x20, 0x09);
+	mipi_dsi_dcs_write_seq(dsi, 0x21, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x23, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x24, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x25, 0x6d);
+	mipi_dsi_dcs_write_seq(dsi, 0x2f, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x30, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x31, 0x49);
+	mipi_dsi_dcs_write_seq(dsi, 0x32, 0x23);
+	mipi_dsi_dcs_write_seq(dsi, 0x33, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x34, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0x69);
+	mipi_dsi_dcs_write_seq(dsi, 0x36, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x37, 0x2d);
+	mipi_dsi_dcs_write_seq(dsi, 0x38, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x29, 0x58);
+	mipi_dsi_dcs_write_seq(dsi, 0x2a, 0x16);
+	mipi_dsi_dcs_write_seq(dsi, 0x2b, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0x5b, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x5f, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, 0x63, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x67, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x6c, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x5c, 0x2c);
+	mipi_dsi_dcs_write_seq(dsi, 0x60, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, 0x64, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x68, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x6c, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x5d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x61, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, 0x65, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x69, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x6c, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x6c, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x7a, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x7b, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0x7c, 0xd8);
+	mipi_dsi_dcs_write_seq(dsi, 0x7d, 0x60);
+	mipi_dsi_dcs_write_seq(dsi, 0x7e, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0x7f, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0x80, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x81, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x82, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x83, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x84, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x85, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x86, 0x1b);
+	mipi_dsi_dcs_write_seq(dsi, 0x87, 0x1b);
+	mipi_dsi_dcs_write_seq(dsi, 0x88, 0x1b);
+	mipi_dsi_dcs_write_seq(dsi, 0x89, 0x1b);
+	mipi_dsi_dcs_write_seq(dsi, 0x8a, 0x33);
+	mipi_dsi_dcs_write_seq(dsi, 0x8b, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x8c, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x73, 0xd0);
+	mipi_dsi_dcs_write_seq(dsi, 0x74, 0x0d);
+	mipi_dsi_dcs_write_seq(dsi, 0x75, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x76, 0x16);
+	mipi_dsi_dcs_write_seq(dsi, 0x99, 0x33);
+	mipi_dsi_dcs_write_seq(dsi, 0x98, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x01);
+	usleep_range(1000, 2000);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0x50);
+	mipi_dsi_dcs_write_seq(dsi, 0x06, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0x14, 0x9e);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0xa8);
+	mipi_dsi_dcs_write_seq(dsi, 0x0b, 0xaf);
+	mipi_dsi_dcs_write_seq(dsi, 0x0c, 0xaf);
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0x21);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x21);
+	mipi_dsi_dcs_write_seq(dsi, 0x08, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0x13);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x13);
+	mipi_dsi_dcs_write_seq(dsi, 0x6d, 0x44);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0xe0);
+	usleep_range(1000, 2000);
+	mipi_dsi_dcs_write_seq(dsi, 0x46, 0x63);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x75, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x76, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x77, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x78, 0x0b);
+	mipi_dsi_dcs_write_seq(dsi, 0x79, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x7a, 0x59);
+	mipi_dsi_dcs_write_seq(dsi, 0x7b, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x7c, 0x88);
+	mipi_dsi_dcs_write_seq(dsi, 0x7d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x7e, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, 0x7f, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x80, 0xbd);
+	mipi_dsi_dcs_write_seq(dsi, 0x81, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x82, 0xd2);
+	mipi_dsi_dcs_write_seq(dsi, 0x83, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x84, 0xe2);
+	mipi_dsi_dcs_write_seq(dsi, 0x85, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x86, 0xf2);
+	mipi_dsi_dcs_write_seq(dsi, 0x87, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x88, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0x89, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x8a, 0x4b);
+	mipi_dsi_dcs_write_seq(dsi, 0x8b, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x8c, 0x86);
+	mipi_dsi_dcs_write_seq(dsi, 0x8d, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x8e, 0xb3);
+	mipi_dsi_dcs_write_seq(dsi, 0x8f, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x90, 0xfa);
+	mipi_dsi_dcs_write_seq(dsi, 0x91, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x92, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0x93, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x94, 0x31);
+	mipi_dsi_dcs_write_seq(dsi, 0x95, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x96, 0x62);
+	mipi_dsi_dcs_write_seq(dsi, 0x97, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x98, 0x94);
+	mipi_dsi_dcs_write_seq(dsi, 0x99, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x9a, 0xb5);
+	mipi_dsi_dcs_write_seq(dsi, 0x9b, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x9c, 0xe1);
+	mipi_dsi_dcs_write_seq(dsi, 0x9d, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x9e, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x9f, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa0, 0x2b);
+	mipi_dsi_dcs_write_seq(dsi, 0xa2, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa3, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0xa4, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa5, 0x47);
+	mipi_dsi_dcs_write_seq(dsi, 0xa6, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa7, 0x59);
+	mipi_dsi_dcs_write_seq(dsi, 0xa9, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xaa, 0x6d);
+	mipi_dsi_dcs_write_seq(dsi, 0xab, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xac, 0x86);
+	mipi_dsi_dcs_write_seq(dsi, 0xad, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xae, 0xa4);
+	mipi_dsi_dcs_write_seq(dsi, 0xaf, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0xe1);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb6, 0x0b);
+	mipi_dsi_dcs_write_seq(dsi, 0xb7, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0x59);
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xba, 0x88);
+	mipi_dsi_dcs_write_seq(dsi, 0xbb, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xbc, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, 0xbd, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xbe, 0xbd);
+	mipi_dsi_dcs_write_seq(dsi, 0xbf, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0xd2);
+	mipi_dsi_dcs_write_seq(dsi, 0xc1, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc2, 0xe2);
+	mipi_dsi_dcs_write_seq(dsi, 0xc3, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc4, 0xf2);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc6, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0xc7, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc8, 0x4b);
+	mipi_dsi_dcs_write_seq(dsi, 0xc9, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xca, 0x86);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0xb3);
+	mipi_dsi_dcs_write_seq(dsi, 0xcd, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xce, 0xfa);
+	mipi_dsi_dcs_write_seq(dsi, 0xcf, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd0, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xd1, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0x31);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd4, 0x62);
+	mipi_dsi_dcs_write_seq(dsi, 0xd5, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd6, 0x94);
+	mipi_dsi_dcs_write_seq(dsi, 0xd7, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd8, 0xb5);
+	mipi_dsi_dcs_write_seq(dsi, 0xd9, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xda, 0xe1);
+	mipi_dsi_dcs_write_seq(dsi, 0xdb, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xdc, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xdd, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xde, 0x2b);
+	mipi_dsi_dcs_write_seq(dsi, 0xdf, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe0, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0xe1, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe2, 0x47);
+	mipi_dsi_dcs_write_seq(dsi, 0xe3, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe4, 0x59);
+	mipi_dsi_dcs_write_seq(dsi, 0xe5, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe6, 0x6d);
+	mipi_dsi_dcs_write_seq(dsi, 0xe7, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe8, 0x86);
+	mipi_dsi_dcs_write_seq(dsi, 0xe9, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xea, 0xa4);
+	mipi_dsi_dcs_write_seq(dsi, 0xeb, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xec, 0xe1);
+	mipi_dsi_dcs_write_seq(dsi, 0xed, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xee, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xef, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf1, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf2, 0x0b);
+	mipi_dsi_dcs_write_seq(dsi, 0xf3, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf4, 0x59);
+	mipi_dsi_dcs_write_seq(dsi, 0xf5, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf6, 0x88);
+	mipi_dsi_dcs_write_seq(dsi, 0xf7, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf8, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, 0xf9, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xfa, 0xbd);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x01, 0xd2);
+	mipi_dsi_dcs_write_seq(dsi, 0x02, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x03, 0xe2);
+	mipi_dsi_dcs_write_seq(dsi, 0x04, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0xf2);
+	mipi_dsi_dcs_write_seq(dsi, 0x06, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0x08, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x09, 0x4b);
+	mipi_dsi_dcs_write_seq(dsi, 0x0a, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0b, 0x86);
+	mipi_dsi_dcs_write_seq(dsi, 0x0c, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0d, 0xb3);
+	mipi_dsi_dcs_write_seq(dsi, 0x0e, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0f, 0xfa);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x13, 0x31);
+	mipi_dsi_dcs_write_seq(dsi, 0x14, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0x62);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x17, 0x94);
+	mipi_dsi_dcs_write_seq(dsi, 0x18, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x19, 0xb5);
+	mipi_dsi_dcs_write_seq(dsi, 0x1a, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x1b, 0xe1);
+	mipi_dsi_dcs_write_seq(dsi, 0x1c, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x1d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x1e, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x1f, 0x2b);
+	mipi_dsi_dcs_write_seq(dsi, 0x20, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x21, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x23, 0x47);
+	mipi_dsi_dcs_write_seq(dsi, 0x24, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x25, 0x59);
+	mipi_dsi_dcs_write_seq(dsi, 0x26, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x27, 0x6d);
+	mipi_dsi_dcs_write_seq(dsi, 0x28, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x29, 0x86);
+	mipi_dsi_dcs_write_seq(dsi, 0x2a, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x2b, 0xa4);
+	mipi_dsi_dcs_write_seq(dsi, 0x2d, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x2f, 0xe1);
+	mipi_dsi_dcs_write_seq(dsi, 0x30, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x31, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x32, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x33, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x34, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0x0b);
+	mipi_dsi_dcs_write_seq(dsi, 0x36, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x37, 0x59);
+	mipi_dsi_dcs_write_seq(dsi, 0x38, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x39, 0x88);
+	mipi_dsi_dcs_write_seq(dsi, 0x3a, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, 0x3d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x3f, 0xbd);
+	mipi_dsi_dcs_write_seq(dsi, 0x40, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x41, 0xd2);
+	mipi_dsi_dcs_write_seq(dsi, 0x42, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x43, 0xe2);
+	mipi_dsi_dcs_write_seq(dsi, 0x44, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x45, 0xf2);
+	mipi_dsi_dcs_write_seq(dsi, 0x46, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x47, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0x48, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x49, 0x4b);
+	mipi_dsi_dcs_write_seq(dsi, 0x4a, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x4b, 0x86);
+	mipi_dsi_dcs_write_seq(dsi, 0x4c, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x4d, 0xb3);
+	mipi_dsi_dcs_write_seq(dsi, 0x4e, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x4f, 0xfa);
+	mipi_dsi_dcs_write_seq(dsi, 0x50, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x51, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0x52, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x53, 0x31);
+	mipi_dsi_dcs_write_seq(dsi, 0x54, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0x62);
+	mipi_dsi_dcs_write_seq(dsi, 0x56, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x58, 0x94);
+	mipi_dsi_dcs_write_seq(dsi, 0x59, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5a, 0xb5);
+	mipi_dsi_dcs_write_seq(dsi, 0x5b, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5c, 0xe1);
+	mipi_dsi_dcs_write_seq(dsi, 0x5d, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x5e, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x5f, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x60, 0x2b);
+	mipi_dsi_dcs_write_seq(dsi, 0x61, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x62, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x63, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x64, 0x47);
+	mipi_dsi_dcs_write_seq(dsi, 0x65, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x66, 0x59);
+	mipi_dsi_dcs_write_seq(dsi, 0x67, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x68, 0x6d);
+	mipi_dsi_dcs_write_seq(dsi, 0x69, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x6a, 0x86);
+	mipi_dsi_dcs_write_seq(dsi, 0x6b, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x6c, 0xa4);
+	mipi_dsi_dcs_write_seq(dsi, 0x6d, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x6e, 0xe1);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x70, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x71, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x72, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x73, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x74, 0x0b);
+	mipi_dsi_dcs_write_seq(dsi, 0x75, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x76, 0x59);
+	mipi_dsi_dcs_write_seq(dsi, 0x77, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x78, 0x88);
+	mipi_dsi_dcs_write_seq(dsi, 0x79, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x7a, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, 0x7b, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x7c, 0xbd);
+	mipi_dsi_dcs_write_seq(dsi, 0x7d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x7e, 0xd2);
+	mipi_dsi_dcs_write_seq(dsi, 0x7f, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x80, 0xe2);
+	mipi_dsi_dcs_write_seq(dsi, 0x81, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x82, 0xf2);
+	mipi_dsi_dcs_write_seq(dsi, 0x83, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x84, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0x85, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x86, 0x4b);
+	mipi_dsi_dcs_write_seq(dsi, 0x87, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x88, 0x86);
+	mipi_dsi_dcs_write_seq(dsi, 0x89, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x8a, 0xb3);
+	mipi_dsi_dcs_write_seq(dsi, 0x8b, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x8c, 0xfa);
+	mipi_dsi_dcs_write_seq(dsi, 0x8d, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x8e, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0x8f, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x90, 0x31);
+	mipi_dsi_dcs_write_seq(dsi, 0x91, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x92, 0x62);
+	mipi_dsi_dcs_write_seq(dsi, 0x93, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x94, 0x94);
+	mipi_dsi_dcs_write_seq(dsi, 0x95, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x96, 0xb5);
+	mipi_dsi_dcs_write_seq(dsi, 0x97, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x98, 0xe1);
+	mipi_dsi_dcs_write_seq(dsi, 0x99, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x9a, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x9b, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x9c, 0x2b);
+	mipi_dsi_dcs_write_seq(dsi, 0x9d, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x9e, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x9f, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa0, 0x47);
+	mipi_dsi_dcs_write_seq(dsi, 0xa2, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa3, 0x59);
+	mipi_dsi_dcs_write_seq(dsi, 0xa4, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa5, 0x6d);
+	mipi_dsi_dcs_write_seq(dsi, 0xa6, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa7, 0x86);
+	mipi_dsi_dcs_write_seq(dsi, 0xa9, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xaa, 0xa4);
+	mipi_dsi_dcs_write_seq(dsi, 0xab, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xac, 0xe1);
+	mipi_dsi_dcs_write_seq(dsi, 0xad, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xae, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xaf, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0x0b);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4, 0x59);
+	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb6, 0x88);
+	mipi_dsi_dcs_write_seq(dsi, 0xb7, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xba, 0xbd);
+	mipi_dsi_dcs_write_seq(dsi, 0xbb, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xbc, 0xd2);
+	mipi_dsi_dcs_write_seq(dsi, 0xbd, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xbe, 0xe2);
+	mipi_dsi_dcs_write_seq(dsi, 0xbf, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0xf2);
+	mipi_dsi_dcs_write_seq(dsi, 0xc1, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc2, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0xc3, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc4, 0x4b);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc6, 0x86);
+	mipi_dsi_dcs_write_seq(dsi, 0xc7, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc8, 0xb3);
+	mipi_dsi_dcs_write_seq(dsi, 0xc9, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xca, 0xfa);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xcd, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xce, 0x31);
+	mipi_dsi_dcs_write_seq(dsi, 0xcf, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd0, 0x62);
+	mipi_dsi_dcs_write_seq(dsi, 0xd1, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0x94);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd4, 0xb5);
+	mipi_dsi_dcs_write_seq(dsi, 0xd5, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd6, 0xe1);
+	mipi_dsi_dcs_write_seq(dsi, 0xd7, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xd8, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xd9, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xda, 0x2b);
+	mipi_dsi_dcs_write_seq(dsi, 0xdb, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xdc, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0xdd, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xde, 0x47);
+	mipi_dsi_dcs_write_seq(dsi, 0xdf, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe0, 0x59);
+	mipi_dsi_dcs_write_seq(dsi, 0xe1, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe2, 0x6d);
+	mipi_dsi_dcs_write_seq(dsi, 0xe3, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe4, 0x86);
+	mipi_dsi_dcs_write_seq(dsi, 0xe5, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe6, 0xa4);
+	mipi_dsi_dcs_write_seq(dsi, 0xe7, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe8, 0xe1);
+	mipi_dsi_dcs_write_seq(dsi, 0xe9, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xea, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x00);
+	usleep_range(1000, 2000);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0xd4, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xe7, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x01);
+	usleep_range(1000, 2000);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	usleep_range(1000, 2000);
+	mipi_dsi_dcs_write_seq(dsi, 0x5c, 0x84);
+	usleep_range(1000, 2000);
+	mipi_dsi_dcs_write_seq(dsi, 0x5d, 0x84);
+	usleep_range(1000, 2000);
+	mipi_dsi_dcs_write_seq(dsi, 0x5e, 0x04);
+	usleep_range(1000, 2000);
+	mipi_dsi_dcs_write_seq(dsi, 0x5f, 0x04);
+	usleep_range(1000, 2000);
+	mipi_dsi_dcs_write_seq(dsi, 0x60, 0x11);
+	usleep_range(1000, 2000);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x00);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	return 0;
+}
+
+static int nt35596_off(struct nt35596 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int nt35596_prepare(struct drm_panel *panel)
+{
+	struct nt35596 *ctx = to_nt35596(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	nt35596_reset(ctx);
+
+	ret = nt35596_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nt35596_unprepare(struct drm_panel *panel)
+{
+	struct nt35596 *ctx = to_nt35596(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = nt35596_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode nt35596_mode = {
+	.clock = (1080 + 100 + 20 + 96) * (1920 + 2 + 5 + 7) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 100,
+	.hsync_end = 1080 + 100 + 20,
+	.htotal = 1080 + 100 + 20 + 96,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 2,
+	.vsync_end = 1920 + 2 + 5,
+	.vtotal = 1920 + 2 + 5 + 7,
+	.width_mm = 68,
+	.height_mm = 121,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int nt35596_get_modes(struct drm_panel *panel,
+			     struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &nt35596_mode);
+}
+
+static const struct drm_panel_funcs nt35596_panel_funcs = {
+	.prepare = nt35596_prepare,
+	.unprepare = nt35596_unprepare,
+	.get_modes = nt35596_get_modes,
+};
+
+static int nt35596_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct nt35596 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "enp";
+	ctx->supplies[1].supply = "enn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_HSE |
+			  MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &nt35596_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void nt35596_remove(struct mipi_dsi_device *dsi)
+{
+	struct nt35596 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id nt35596_of_match[] = {
+	{ .compatible = "alcatel,idol3-panel-nt35596" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, nt35596_of_match);
+
+static struct mipi_dsi_driver nt35596_driver = {
+	.probe = nt35596_probe,
+	.remove = nt35596_remove,
+	.driver = {
+		.name = "panel-alcatel-idol3-nt35596",
+		.of_match_table = nt35596_of_match,
+	},
+};
+module_mipi_dsi_driver(nt35596_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for nt35596 1080p videomode panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-alcatel-idol3-r63315.c b/drivers/gpu/drm/panel/msm8916-generated/panel-alcatel-idol3-r63315.c
new file mode 100644
index 000000000000..8c1ae9473055
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-alcatel-idol3-r63315.c
@@ -0,0 +1,277 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct r63315 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct r63315 *to_r63315(struct drm_panel *panel)
+{
+	return container_of(panel, struct r63315, panel);
+}
+
+static void r63315_reset(struct r63315 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int r63315_on(struct r63315 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x04);
+	mipi_dsi_generic_write_seq(dsi, 0xb3,
+				   0x14, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb6, 0x3a, 0xb3);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xc1,
+				   0x84, 0x60, 0x10, 0xeb, 0xff, 0x6f, 0xce,
+				   0xff, 0xff, 0x17, 0x12, 0x58, 0x73, 0xae,
+				   0x31, 0x20, 0xc6, 0xff, 0xff, 0x1f, 0xf3,
+				   0xff, 0x5f, 0x10, 0x10, 0x10, 0x10, 0x00,
+				   0x62, 0x01, 0x22, 0x22, 0x00, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xc2,
+				   0x31, 0xf7, 0x80, 0x06, 0x08, 0x80, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xc4,
+				   0x70, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00,
+				   0x33, 0x22, 0x0c, 0x06, 0x00, 0x00, 0x00,
+				   0x00, 0x33, 0x00, 0x00, 0x33, 0x22, 0x0c,
+				   0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xc6,
+				   0x77, 0x00, 0x69, 0x00, 0x69, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x10, 0x16, 0x0a, 0x77,
+				   0x00, 0x69, 0x00, 0x69, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x16, 0x18, 0x08);
+	mipi_dsi_generic_write_seq(dsi, 0xc7,
+				   0x00, 0x12, 0x19, 0x22, 0x2e, 0x3a, 0x42,
+				   0x51, 0x35, 0x3d, 0x49, 0x57, 0x61, 0x6a,
+				   0x72, 0x00, 0x12, 0x19, 0x22, 0x2e, 0x3a,
+				   0x42, 0x51, 0x35, 0x3d, 0x49, 0x57, 0x61,
+				   0x6a, 0x72);
+	mipi_dsi_generic_write_seq(dsi, 0xc8,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0xfc, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x31, 0xfc, 0x3f, 0x8c, 0x00, 0x00, 0x00,
+				   0x00, 0xc0);
+	mipi_dsi_generic_write_seq(dsi, 0xcc, 0x0b);
+	mipi_dsi_generic_write_seq(dsi, 0xd0,
+				   0x44, 0x81, 0xbb, 0x19, 0xd9, 0x4c, 0x19,
+				   0x19, 0x04, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd3,
+				   0x1b, 0x33, 0xbb, 0xbb, 0xb3, 0x33, 0x33,
+				   0x33, 0x01, 0x01, 0x00, 0xa0, 0xd8, 0xa0,
+				   0x0d, 0x48, 0x48, 0x44, 0x3b, 0x22, 0x72,
+				   0x07, 0x3d, 0xbf, 0x33);
+	mipi_dsi_generic_write_seq(dsi, 0xd5,
+				   0x06, 0x00, 0x00, 0x01, 0x43, 0x01, 0x43);
+	mipi_dsi_generic_write_seq(dsi, 0xd6, 0x01);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int r63315_off(struct r63315 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x04);
+	msleep(50);
+	mipi_dsi_generic_write_seq(dsi, 0xb1, 0x01);
+	msleep(120);
+
+	return 0;
+}
+
+static int r63315_prepare(struct drm_panel *panel)
+{
+	struct r63315 *ctx = to_r63315(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	r63315_reset(ctx);
+
+	ret = r63315_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int r63315_unprepare(struct drm_panel *panel)
+{
+	struct r63315 *ctx = to_r63315(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = r63315_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode r63315_mode = {
+	.clock = (1080 + 100 + 20 + 96) * (1920 + 8 + 2 + 4) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 100,
+	.hsync_end = 1080 + 100 + 20,
+	.htotal = 1080 + 100 + 20 + 96,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 8,
+	.vsync_end = 1920 + 8 + 2,
+	.vtotal = 1920 + 8 + 2 + 4,
+	.width_mm = 68,
+	.height_mm = 121,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int r63315_get_modes(struct drm_panel *panel,
+			    struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &r63315_mode);
+}
+
+static const struct drm_panel_funcs r63315_panel_funcs = {
+	.prepare = r63315_prepare,
+	.unprepare = r63315_unprepare,
+	.get_modes = r63315_get_modes,
+};
+
+static int r63315_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct r63315 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "enp";
+	ctx->supplies[1].supply = "enn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_HSE |
+			  MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &r63315_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void r63315_remove(struct mipi_dsi_device *dsi)
+{
+	struct r63315 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id r63315_of_match[] = {
+	{ .compatible = "alcatel,idol3-panel-r63315" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, r63315_of_match);
+
+static struct mipi_dsi_driver r63315_driver = {
+	.probe = r63315_probe,
+	.remove = r63315_remove,
+	.driver = {
+		.name = "panel-alcatel-idol3-r63315",
+		.of_match_table = r63315_of_match,
+	},
+};
+module_mipi_dsi_driver(r63315_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for r63315 1080p videomode panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-asus-z00l-otm1284a.c b/drivers/gpu/drm/panel/msm8916-generated/panel-asus-z00l-otm1284a.c
new file mode 100644
index 000000000000..e0776697517c
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-asus-z00l-otm1284a.c
@@ -0,0 +1,293 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct otm1284a {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *backlight_gpio;
+};
+
+static inline struct otm1284a *to_otm1284a(struct drm_panel *panel)
+{
+	return container_of(panel, struct otm1284a, panel);
+}
+
+static void otm1284a_reset(struct otm1284a *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int otm1284a_on(struct otm1284a *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x12, 0x84, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x12, 0x84);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb1);
+	mipi_dsi_generic_write_seq(dsi, 0xc6, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb4);
+	mipi_dsi_generic_write_seq(dsi, 0xc6, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0xff, 0xff, 0xff);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(125);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(5000, 6000);
+
+	mipi_dsi_generic_write_seq(dsi, 0x53, 0x24);
+	mipi_dsi_generic_write_seq(dsi, 0x5e, 0x0d);
+
+	return 0;
+}
+
+static int otm1284a_off(struct otm1284a *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	mipi_dsi_generic_write_seq(dsi, 0x53, 0x00);
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(150);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int otm1284a_prepare(struct drm_panel *panel)
+{
+	struct otm1284a *ctx = to_otm1284a(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	otm1284a_reset(ctx);
+
+	ret = otm1284a_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int otm1284a_unprepare(struct drm_panel *panel)
+{
+	struct otm1284a *ctx = to_otm1284a(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = otm1284a_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode otm1284a_mode = {
+	.clock = (720 + 92 + 12 + 64) * (1280 + 10 + 5 + 13) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 92,
+	.hsync_end = 720 + 92 + 12,
+	.htotal = 720 + 92 + 12 + 64,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 10,
+	.vsync_end = 1280 + 10 + 5,
+	.vtotal = 1280 + 10 + 5 + 13,
+	.width_mm = 68,
+	.height_mm = 121,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int otm1284a_get_modes(struct drm_panel *panel,
+			      struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &otm1284a_mode);
+}
+
+static const struct drm_panel_funcs otm1284a_panel_funcs = {
+	.prepare = otm1284a_prepare,
+	.unprepare = otm1284a_unprepare,
+	.get_modes = otm1284a_get_modes,
+};
+
+static int otm1284a_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	struct otm1284a *ctx = mipi_dsi_get_drvdata(dsi);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	gpiod_set_value_cansleep(ctx->backlight_gpio, !!brightness);
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct backlight_ops otm1284a_bl_ops = {
+	.update_status = otm1284a_bl_update_status,
+};
+
+static struct backlight_device *
+otm1284a_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 255,
+		.max_brightness = 255,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &otm1284a_bl_ops, &props);
+}
+
+static int otm1284a_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct otm1284a *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->backlight_gpio = devm_gpiod_get(dev, "backlight", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->backlight_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->backlight_gpio),
+				     "Failed to get backlight-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &otm1284a_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ctx->panel.backlight = otm1284a_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void otm1284a_remove(struct mipi_dsi_device *dsi)
+{
+	struct otm1284a *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id otm1284a_of_match[] = {
+	{ .compatible = "asus,z00l-otm1284a" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, otm1284a_of_match);
+
+static struct mipi_dsi_driver otm1284a_driver = {
+	.probe = otm1284a_probe,
+	.remove = otm1284a_remove,
+	.driver = {
+		.name = "panel-asus-z00l-otm1284a",
+		.of_match_table = otm1284a_of_match,
+	},
+};
+module_mipi_dsi_driver(otm1284a_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for otm1284a 720p video mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-asus-z010d-r69339.c b/drivers/gpu/drm/panel/msm8916-generated/panel-asus-z010d-r69339.c
new file mode 100644
index 000000000000..418a6fbd9726
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-asus-z010d-r69339.c
@@ -0,0 +1,304 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct r69339 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct r69339 *to_r69339(struct drm_panel *panel)
+{
+	return container_of(panel, struct r69339, panel);
+}
+
+static void r69339_reset(struct r69339 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int r69339_on(struct r69339 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x0001);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x00);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(150);
+
+	return 0;
+}
+
+static int r69339_off(struct r69339 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x0000);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int r69339_prepare(struct drm_panel *panel)
+{
+	struct r69339 *ctx = to_r69339(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	r69339_reset(ctx);
+
+	ret = r69339_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int r69339_unprepare(struct drm_panel *panel)
+{
+	struct r69339 *ctx = to_r69339(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = r69339_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode r69339_mode = {
+	.clock = (720 + 100 + 12 + 40) * (1280 + 13 + 1 + 11) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 100,
+	.hsync_end = 720 + 100 + 12,
+	.htotal = 720 + 100 + 12 + 40,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 13,
+	.vsync_end = 1280 + 13 + 1,
+	.vtotal = 1280 + 13 + 1 + 11,
+	.width_mm = 68,
+	.height_mm = 121,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int r69339_get_modes(struct drm_panel *panel,
+			    struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &r69339_mode);
+}
+
+static const struct drm_panel_funcs r69339_panel_funcs = {
+	.prepare = r69339_prepare,
+	.unprepare = r69339_unprepare,
+	.get_modes = r69339_get_modes,
+};
+
+static int r69339_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+// TODO: Check if /sys/class/backlight/.../actual_brightness actually returns
+// correct values. If not, remove this function.
+static int r69339_bl_get_brightness(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_get_display_brightness(dsi, &brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return brightness & 0xff;
+}
+
+static const struct backlight_ops r69339_bl_ops = {
+	.update_status = r69339_bl_update_status,
+	.get_brightness = r69339_bl_get_brightness,
+};
+
+static struct backlight_device *
+r69339_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 255,
+		.max_brightness = 255,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &r69339_bl_ops, &props);
+}
+
+static int r69339_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct r69339 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &r69339_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ctx->panel.backlight = r69339_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void r69339_remove(struct mipi_dsi_device *dsi)
+{
+	struct r69339 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id r69339_of_match[] = {
+	{ .compatible = "asus,z010d-r69339" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, r69339_of_match);
+
+static struct mipi_dsi_driver r69339_driver = {
+	.probe = r69339_probe,
+	.remove = r69339_remove,
+	.driver = {
+		.name = "panel-asus-z010d-r69339",
+		.of_match_table = r69339_of_match,
+	},
+};
+module_mipi_dsi_driver(r69339_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for sharp 720p video mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-gplus-fl8005a-hx8394d.c b/drivers/gpu/drm/panel/msm8916-generated/panel-gplus-fl8005a-hx8394d.c
new file mode 100644
index 000000000000..0e19a9635c4e
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-gplus-fl8005a-hx8394d.c
@@ -0,0 +1,280 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct hx8394d_800p {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct hx8394d_800p *to_hx8394d_800p(struct drm_panel *panel)
+{
+	return container_of(panel, struct hx8394d_800p, panel);
+}
+
+static void hx8394d_800p_reset(struct hx8394d_800p *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(25);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(250);
+}
+
+static int hx8394d_800p_on(struct hx8394d_800p *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0xff, 0x83, 0x94);
+	mipi_dsi_dcs_write_seq(dsi, 0xba, 0x33, 0x83);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1,
+			       0x6c, 0x15, 0x15, 0x24, 0xe4, 0x11, 0xf1, 0x80,
+			       0xe4, 0x97, 0x23, 0x80, 0xc0, 0xd2, 0x58);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2,
+			       0x00, 0x64, 0x10, 0x07, 0x20, 0x1c, 0x08, 0x08,
+			       0x1c, 0x4d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4,
+			       0x00, 0xff, 0x03, 0x64, 0x03, 0x64, 0x03, 0x64,
+			       0x01, 0x74, 0x01, 0x74);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3,
+			       0x00, 0x06, 0x00, 0x40, 0x1a, 0x08, 0x00, 0x32,
+			       0x10, 0x07, 0x00, 0x07, 0x54, 0x15, 0x0f, 0x05,
+			       0x04, 0x02, 0x12, 0x10, 0x05, 0x07, 0x33, 0x33,
+			       0x0b, 0x0b, 0x37, 0x10, 0x07, 0x07, 0x08, 0x00,
+			       0x00, 0x00, 0x0a, 0x00, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xd5,
+			       0x19, 0x19, 0x18, 0x18, 0x1a, 0x1a, 0x1b, 0x1b,
+			       0x04, 0x05, 0x06, 0x07, 0x00, 0x01, 0x02, 0x03,
+			       0x20, 0x21, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x22, 0x23,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xd6,
+			       0x18, 0x18, 0x19, 0x19, 0x1a, 0x1a, 0x1b, 0x1b,
+			       0x03, 0x02, 0x01, 0x00, 0x07, 0x06, 0x05, 0x04,
+			       0x23, 0x22, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x21, 0x20,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xe0,
+			       0x00, 0x06, 0x0c, 0x31, 0x34, 0x3f, 0x1d, 0x41,
+			       0x06, 0x0a, 0x0c, 0x17, 0x0f, 0x12, 0x15, 0x13,
+			       0x14, 0x07, 0x12, 0x15, 0x16, 0x00, 0x06, 0x0c,
+			       0x31, 0x34, 0x3f, 0x1d, 0x41, 0x06, 0x0a, 0x0c,
+			       0x17, 0x0f, 0x12, 0x15, 0x13, 0x14, 0x07, 0x12,
+			       0x15, 0x16);
+	mipi_dsi_dcs_write_seq(dsi, 0xb6, 0x2a, 0x2a);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0x09);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0x55);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x30, 0x14);
+	mipi_dsi_dcs_write_seq(dsi, 0xbc, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0xbf, 0x41, 0x0e, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc7, 0x00, 0xc0, 0x00, 0xc0);
+	mipi_dsi_dcs_write_seq(dsi, 0xdf, 0x8e);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(150);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(200);
+
+	return 0;
+}
+
+static int hx8394d_800p_off(struct hx8394d_800p *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hx8394d_800p_prepare(struct drm_panel *panel)
+{
+	struct hx8394d_800p *ctx = to_hx8394d_800p(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	hx8394d_800p_reset(ctx);
+
+	ret = hx8394d_800p_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hx8394d_800p_unprepare(struct drm_panel *panel)
+{
+	struct hx8394d_800p *ctx = to_hx8394d_800p(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = hx8394d_800p_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode hx8394d_800p_mode = {
+	.clock = (800 + 90 + 20 + 30) * (1280 + 9 + 2 + 16) * 60 / 1000,
+	.hdisplay = 800,
+	.hsync_start = 800 + 90,
+	.hsync_end = 800 + 90 + 20,
+	.htotal = 800 + 90 + 20 + 30,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 9,
+	.vsync_end = 1280 + 9 + 2,
+	.vtotal = 1280 + 9 + 2 + 16,
+	.width_mm = 0,
+	.height_mm = 0,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int hx8394d_800p_get_modes(struct drm_panel *panel,
+				  struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &hx8394d_800p_mode);
+}
+
+static const struct drm_panel_funcs hx8394d_800p_panel_funcs = {
+	.prepare = hx8394d_800p_prepare,
+	.unprepare = hx8394d_800p_unprepare,
+	.get_modes = hx8394d_800p_get_modes,
+};
+
+static int hx8394d_800p_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct hx8394d_800p *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &hx8394d_800p_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void hx8394d_800p_remove(struct mipi_dsi_device *dsi)
+{
+	struct hx8394d_800p *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id hx8394d_800p_of_match[] = {
+	{ .compatible = "gplus,fl8005a-hx8394d" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, hx8394d_800p_of_match);
+
+static struct mipi_dsi_driver hx8394d_800p_driver = {
+	.probe = hx8394d_800p_probe,
+	.remove = hx8394d_800p_remove,
+	.driver = {
+		.name = "panel-gplus-fl8005a-hx8394d",
+		.of_match_table = hx8394d_800p_of_match,
+	},
+};
+module_mipi_dsi_driver(hx8394d_800p_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for hx8394d 800p video mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-huawei-boe-otm8019a.c b/drivers/gpu/drm/panel/msm8916-generated/panel-huawei-boe-otm8019a.c
new file mode 100644
index 000000000000..016321a00d95
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-huawei-boe-otm8019a.c
@@ -0,0 +1,468 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct boe_otm8019a_5p0 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline
+struct boe_otm8019a_5p0 *to_boe_otm8019a_5p0(struct drm_panel *panel)
+{
+	return container_of(panel, struct boe_otm8019a_5p0, panel);
+}
+
+static void boe_otm8019a_5p0_reset(struct boe_otm8019a_5p0 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(120);
+}
+
+static int boe_otm8019a_5p0_on(struct boe_otm8019a_5p0 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x80, 0x19, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x80, 0x19);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x92);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x45);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa2);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x00, 0x1b);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xc0,
+				   0x00, 0x58, 0x00, 0x14, 0x16, 0x00, 0x58,
+				   0x14, 0x16);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb4);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb5);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x18);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x81);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x04);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x8a);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x40);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xc1, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xc0,
+				   0x00, 0x15, 0x00, 0x00, 0x00, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x30);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	mipi_dsi_generic_write_seq(dsi, 0xc1, 0xe8);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x98);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa9);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x0a);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb0);
+	mipi_dsi_generic_write_seq(dsi, 0xc1, 0x20, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xe1);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x40, 0x30);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xb6, 0xb4);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x87);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x18);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x89);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x08);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x82);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x4e, 0x29, 0x00, 0x7b, 0x44);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd8, 0x5f);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xd8, 0x5f);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x81);
+	mipi_dsi_generic_write_seq(dsi, 0xc1, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa1);
+	mipi_dsi_generic_write_seq(dsi, 0xc1, 0x08);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb1);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x29);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xe1,
+				   0x1c, 0x2a, 0x34, 0x40, 0x4d, 0x5c, 0x5c,
+				   0x82, 0x73, 0x8b, 0x7a, 0x65, 0x77, 0x55,
+				   0x52, 0x41, 0x34, 0x29, 0x23, 0x1f);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xe2,
+				   0x1c, 0x2a, 0x34, 0x40, 0x4d, 0x5c, 0x5c,
+				   0x82, 0x73, 0x8b, 0x7a, 0x65, 0x77, 0x55,
+				   0x52, 0x41, 0x34, 0x29, 0x23, 0x1f);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xce,
+				   0x86, 0x01, 0x00, 0x85, 0x01, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	mipi_dsi_generic_write_seq(dsi, 0xce,
+				   0x18, 0x05, 0x83, 0x5a, 0x86, 0x04, 0x00,
+				   0x18, 0x04, 0x83, 0x5b, 0x86, 0x04, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb0);
+	mipi_dsi_generic_write_seq(dsi, 0xce,
+				   0x18, 0x03, 0x83, 0x5c, 0x86, 0x04, 0x00,
+				   0x18, 0x02, 0x83, 0x5d, 0x86, 0x04, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc0);
+	mipi_dsi_generic_write_seq(dsi, 0xcf,
+				   0x01, 0x01, 0x20, 0x20, 0x00, 0x00, 0x01,
+				   0x01, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xd0);
+	mipi_dsi_generic_write_seq(dsi, 0xcf, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb0);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc0);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xd0);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xe0);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
+				   0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xf0);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+				   0xff, 0xff, 0xff);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xcc,
+				   0x00, 0x26, 0x09, 0x0b, 0x01, 0x25, 0x00,
+				   0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xcc,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	mipi_dsi_generic_write_seq(dsi, 0xcc,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x02,
+				   0x0c, 0x0a, 0x26, 0x00, 0x00, 0x00, 0x00,
+				   0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb0);
+	mipi_dsi_generic_write_seq(dsi, 0xcc,
+				   0x00, 0x25, 0x0a, 0x0c, 0x02, 0x26, 0x00,
+				   0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc0);
+	mipi_dsi_generic_write_seq(dsi, 0xcc,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xd0);
+	mipi_dsi_generic_write_seq(dsi, 0xcc,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x01,
+				   0x0b, 0x09, 0x25, 0x00, 0x00, 0x00, 0x00,
+				   0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb0);
+	mipi_dsi_generic_write_seq(dsi, 0xca, 0x09);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb3);
+	mipi_dsi_generic_write_seq(dsi, 0xca, 0x50);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xfb, 0x00);
+	msleep(50);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0xff, 0xff, 0xff);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x0000);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_CABC_MIN_BRIGHTNESS, 0x28);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	return 0;
+}
+
+static int boe_otm8019a_5p0_off(struct boe_otm8019a_5p0 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int boe_otm8019a_5p0_prepare(struct drm_panel *panel)
+{
+	struct boe_otm8019a_5p0 *ctx = to_boe_otm8019a_5p0(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	boe_otm8019a_5p0_reset(ctx);
+
+	ret = boe_otm8019a_5p0_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int boe_otm8019a_5p0_unprepare(struct drm_panel *panel)
+{
+	struct boe_otm8019a_5p0 *ctx = to_boe_otm8019a_5p0(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = boe_otm8019a_5p0_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode boe_otm8019a_5p0_mode = {
+	.clock = (480 + 92 + 12 + 88) * (854 + 18 + 4 + 18) * 60 / 1000,
+	.hdisplay = 480,
+	.hsync_start = 480 + 92,
+	.hsync_end = 480 + 92 + 12,
+	.htotal = 480 + 92 + 12 + 88,
+	.vdisplay = 854,
+	.vsync_start = 854 + 18,
+	.vsync_end = 854 + 18 + 4,
+	.vtotal = 854 + 18 + 4 + 18,
+	.width_mm = 62,
+	.height_mm = 110,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int boe_otm8019a_5p0_get_modes(struct drm_panel *panel,
+				      struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &boe_otm8019a_5p0_mode);
+}
+
+static const struct drm_panel_funcs boe_otm8019a_5p0_panel_funcs = {
+	.prepare = boe_otm8019a_5p0_prepare,
+	.unprepare = boe_otm8019a_5p0_unprepare,
+	.get_modes = boe_otm8019a_5p0_get_modes,
+};
+
+static int boe_otm8019a_5p0_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+// TODO: Check if /sys/class/backlight/.../actual_brightness actually returns
+// correct values. If not, remove this function.
+static int boe_otm8019a_5p0_bl_get_brightness(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_get_display_brightness(dsi, &brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return brightness & 0xff;
+}
+
+static const struct backlight_ops boe_otm8019a_5p0_bl_ops = {
+	.update_status = boe_otm8019a_5p0_bl_update_status,
+	.get_brightness = boe_otm8019a_5p0_bl_get_brightness,
+};
+
+static struct backlight_device *
+boe_otm8019a_5p0_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 250,
+		.max_brightness = 250,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &boe_otm8019a_5p0_bl_ops, &props);
+}
+
+static int boe_otm8019a_5p0_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct boe_otm8019a_5p0 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 2;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &boe_otm8019a_5p0_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ctx->panel.backlight = boe_otm8019a_5p0_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void boe_otm8019a_5p0_remove(struct mipi_dsi_device *dsi)
+{
+	struct boe_otm8019a_5p0 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id boe_otm8019a_5p0_of_match[] = {
+	{ .compatible = "huawei,boe-otm8019a" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, boe_otm8019a_5p0_of_match);
+
+static struct mipi_dsi_driver boe_otm8019a_5p0_driver = {
+	.probe = boe_otm8019a_5p0_probe,
+	.remove = boe_otm8019a_5p0_remove,
+	.driver = {
+		.name = "panel-huawei-boe-otm8019a",
+		.of_match_table = boe_otm8019a_5p0_of_match,
+	},
+};
+module_mipi_dsi_driver(boe_otm8019a_5p0_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for BOE_OTM8019A_5P0_FWVGA_VIDEO");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-huawei-kiwi-cmi-nt35532.c b/drivers/gpu/drm/panel/msm8916-generated/panel-huawei-kiwi-cmi-nt35532.c
new file mode 100644
index 000000000000..919952c7bbd3
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-huawei-kiwi-cmi-nt35532.c
@@ -0,0 +1,845 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct cmi_nt35532_5p5xa {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline
+struct cmi_nt35532_5p5xa *to_cmi_nt35532_5p5xa(struct drm_panel *panel)
+{
+	return container_of(panel, struct cmi_nt35532_5p5xa, panel);
+}
+
+static void cmi_nt35532_5p5xa_reset(struct cmi_nt35532_5p5xa *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(15000, 16000);
+}
+
+static int cmi_nt35532_5p5xa_on(struct cmi_nt35532_5p5xa *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x01, 0x55);
+	mipi_dsi_dcs_write_seq(dsi, 0x02, 0x59);
+	mipi_dsi_dcs_write_seq(dsi, 0x04, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0x3b);
+	mipi_dsi_dcs_write_seq(dsi, 0x06, 0x6e);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0xc6);
+	mipi_dsi_dcs_write_seq(dsi, 0x0d, 0xc5);
+	mipi_dsi_dcs_write_seq(dsi, 0x0e, 0xc5);
+	mipi_dsi_dcs_write_seq(dsi, 0x0f, 0xe0);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0x64);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0x17, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0x68, 0x13);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x75, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x76, 0xea);
+	mipi_dsi_dcs_write_seq(dsi, 0x77, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x78, 0xee);
+	mipi_dsi_dcs_write_seq(dsi, 0x79, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x7a, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x7b, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x7c, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0x7d, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x7e, 0x2f);
+	mipi_dsi_dcs_write_seq(dsi, 0x7f, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x80, 0x3e);
+	mipi_dsi_dcs_write_seq(dsi, 0x81, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x82, 0x4c);
+	mipi_dsi_dcs_write_seq(dsi, 0x83, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x84, 0x58);
+	mipi_dsi_dcs_write_seq(dsi, 0x85, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x86, 0x64);
+	mipi_dsi_dcs_write_seq(dsi, 0x87, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x88, 0x89);
+	mipi_dsi_dcs_write_seq(dsi, 0x89, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x8a, 0xa8);
+	mipi_dsi_dcs_write_seq(dsi, 0x8b, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x8c, 0xd9);
+	mipi_dsi_dcs_write_seq(dsi, 0x8d, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x8e, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x8f, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x90, 0x41);
+	mipi_dsi_dcs_write_seq(dsi, 0x91, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x92, 0x72);
+	mipi_dsi_dcs_write_seq(dsi, 0x93, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x94, 0x74);
+	mipi_dsi_dcs_write_seq(dsi, 0x95, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x96, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0x97, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x98, 0xcc);
+	mipi_dsi_dcs_write_seq(dsi, 0x99, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x9a, 0xeb);
+	mipi_dsi_dcs_write_seq(dsi, 0x9b, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x9c, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0x9d, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x9e, 0x34);
+	mipi_dsi_dcs_write_seq(dsi, 0x9f, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa0, 0x5e);
+	mipi_dsi_dcs_write_seq(dsi, 0xa2, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa3, 0x66);
+	mipi_dsi_dcs_write_seq(dsi, 0xa4, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa5, 0x73);
+	mipi_dsi_dcs_write_seq(dsi, 0xa6, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa7, 0x82);
+	mipi_dsi_dcs_write_seq(dsi, 0xa9, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xaa, 0x91);
+	mipi_dsi_dcs_write_seq(dsi, 0xab, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xac, 0xa4);
+	mipi_dsi_dcs_write_seq(dsi, 0xad, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xae, 0xbb);
+	mipi_dsi_dcs_write_seq(dsi, 0xaf, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0xcd);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0xcf);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4, 0x76);
+	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb6, 0xda);
+	mipi_dsi_dcs_write_seq(dsi, 0xb7, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xba, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0xbb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xbc, 0x2f);
+	mipi_dsi_dcs_write_seq(dsi, 0xbd, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xbe, 0x3e);
+	mipi_dsi_dcs_write_seq(dsi, 0xbf, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x4c);
+	mipi_dsi_dcs_write_seq(dsi, 0xc1, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc2, 0x58);
+	mipi_dsi_dcs_write_seq(dsi, 0xc3, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc4, 0x64);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc6, 0x89);
+	mipi_dsi_dcs_write_seq(dsi, 0xc7, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc8, 0xa8);
+	mipi_dsi_dcs_write_seq(dsi, 0xc9, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xca, 0xd9);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xcd, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xce, 0x41);
+	mipi_dsi_dcs_write_seq(dsi, 0xcf, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd0, 0x72);
+	mipi_dsi_dcs_write_seq(dsi, 0xd1, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0x74);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd4, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0xd5, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd6, 0xcc);
+	mipi_dsi_dcs_write_seq(dsi, 0xd7, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd8, 0xeb);
+	mipi_dsi_dcs_write_seq(dsi, 0xd9, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xda, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0xdb, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xdc, 0x34);
+	mipi_dsi_dcs_write_seq(dsi, 0xdd, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xde, 0x5e);
+	mipi_dsi_dcs_write_seq(dsi, 0xdf, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe0, 0x66);
+	mipi_dsi_dcs_write_seq(dsi, 0xe1, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe2, 0x73);
+	mipi_dsi_dcs_write_seq(dsi, 0xe3, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe4, 0x82);
+	mipi_dsi_dcs_write_seq(dsi, 0xe5, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe6, 0x91);
+	mipi_dsi_dcs_write_seq(dsi, 0xe7, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe8, 0xa4);
+	mipi_dsi_dcs_write_seq(dsi, 0xe9, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xea, 0xbb);
+	mipi_dsi_dcs_write_seq(dsi, 0xeb, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xec, 0xcd);
+	mipi_dsi_dcs_write_seq(dsi, 0xed, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xee, 0xcf);
+	mipi_dsi_dcs_write_seq(dsi, 0xef, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0xea);
+	mipi_dsi_dcs_write_seq(dsi, 0xf1, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf2, 0xee);
+	mipi_dsi_dcs_write_seq(dsi, 0xf3, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xf4, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xf5, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xf6, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0xf7, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xf8, 0x2f);
+	mipi_dsi_dcs_write_seq(dsi, 0xf9, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xfa, 0x3e);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x01, 0x4c);
+	mipi_dsi_dcs_write_seq(dsi, 0x02, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x03, 0x58);
+	mipi_dsi_dcs_write_seq(dsi, 0x04, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0x64);
+	mipi_dsi_dcs_write_seq(dsi, 0x06, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0x89);
+	mipi_dsi_dcs_write_seq(dsi, 0x08, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x09, 0xa8);
+	mipi_dsi_dcs_write_seq(dsi, 0x0a, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0b, 0xd9);
+	mipi_dsi_dcs_write_seq(dsi, 0x0c, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0d, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x0e, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x0f, 0x41);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0x72);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x13, 0x74);
+	mipi_dsi_dcs_write_seq(dsi, 0x14, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x17, 0xcc);
+	mipi_dsi_dcs_write_seq(dsi, 0x18, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x19, 0xeb);
+	mipi_dsi_dcs_write_seq(dsi, 0x1a, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x1b, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0x1c, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x1d, 0x34);
+	mipi_dsi_dcs_write_seq(dsi, 0x1e, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x1f, 0x5e);
+	mipi_dsi_dcs_write_seq(dsi, 0x20, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x21, 0x66);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x23, 0x73);
+	mipi_dsi_dcs_write_seq(dsi, 0x24, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x25, 0x82);
+	mipi_dsi_dcs_write_seq(dsi, 0x26, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x27, 0x91);
+	mipi_dsi_dcs_write_seq(dsi, 0x28, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x29, 0xa4);
+	mipi_dsi_dcs_write_seq(dsi, 0x2a, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x2b, 0xbb);
+	mipi_dsi_dcs_write_seq(dsi, 0x2d, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x2f, 0xcd);
+	mipi_dsi_dcs_write_seq(dsi, 0x30, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x31, 0xcf);
+	mipi_dsi_dcs_write_seq(dsi, 0x32, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x33, 0x76);
+	mipi_dsi_dcs_write_seq(dsi, 0x34, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0xda);
+	mipi_dsi_dcs_write_seq(dsi, 0x36, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x37, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x38, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x39, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0x3a, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0x2f);
+	mipi_dsi_dcs_write_seq(dsi, 0x3d, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x3f, 0x3e);
+	mipi_dsi_dcs_write_seq(dsi, 0x40, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x41, 0x4c);
+	mipi_dsi_dcs_write_seq(dsi, 0x42, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x43, 0x58);
+	mipi_dsi_dcs_write_seq(dsi, 0x44, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x45, 0x64);
+	mipi_dsi_dcs_write_seq(dsi, 0x46, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x47, 0x89);
+	mipi_dsi_dcs_write_seq(dsi, 0x48, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x49, 0xa8);
+	mipi_dsi_dcs_write_seq(dsi, 0x4a, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x4b, 0xd9);
+	mipi_dsi_dcs_write_seq(dsi, 0x4c, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x4d, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x4e, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x4f, 0x41);
+	mipi_dsi_dcs_write_seq(dsi, 0x50, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x51, 0x72);
+	mipi_dsi_dcs_write_seq(dsi, 0x52, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x53, 0x74);
+	mipi_dsi_dcs_write_seq(dsi, 0x54, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0x56, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x58, 0xcc);
+	mipi_dsi_dcs_write_seq(dsi, 0x59, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5a, 0xeb);
+	mipi_dsi_dcs_write_seq(dsi, 0x5b, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x5c, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0x5d, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x5e, 0x34);
+	mipi_dsi_dcs_write_seq(dsi, 0x5f, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x60, 0x5e);
+	mipi_dsi_dcs_write_seq(dsi, 0x61, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x62, 0x66);
+	mipi_dsi_dcs_write_seq(dsi, 0x63, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x64, 0x73);
+	mipi_dsi_dcs_write_seq(dsi, 0x65, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x66, 0x82);
+	mipi_dsi_dcs_write_seq(dsi, 0x67, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x68, 0x91);
+	mipi_dsi_dcs_write_seq(dsi, 0x69, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x6a, 0xa4);
+	mipi_dsi_dcs_write_seq(dsi, 0x6b, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x6c, 0xbb);
+	mipi_dsi_dcs_write_seq(dsi, 0x6d, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x6e, 0xcd);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x70, 0xcf);
+	mipi_dsi_dcs_write_seq(dsi, 0x71, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x72, 0xea);
+	mipi_dsi_dcs_write_seq(dsi, 0x73, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x74, 0xee);
+	mipi_dsi_dcs_write_seq(dsi, 0x75, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x76, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x77, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x78, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0x79, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x7a, 0x2f);
+	mipi_dsi_dcs_write_seq(dsi, 0x7b, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x7c, 0x3e);
+	mipi_dsi_dcs_write_seq(dsi, 0x7d, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x7e, 0x4c);
+	mipi_dsi_dcs_write_seq(dsi, 0x7f, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x80, 0x58);
+	mipi_dsi_dcs_write_seq(dsi, 0x81, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x82, 0x64);
+	mipi_dsi_dcs_write_seq(dsi, 0x83, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x84, 0x89);
+	mipi_dsi_dcs_write_seq(dsi, 0x85, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x86, 0xa8);
+	mipi_dsi_dcs_write_seq(dsi, 0x87, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x88, 0xd9);
+	mipi_dsi_dcs_write_seq(dsi, 0x89, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x8a, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x8b, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x8c, 0x41);
+	mipi_dsi_dcs_write_seq(dsi, 0x8d, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x8e, 0x72);
+	mipi_dsi_dcs_write_seq(dsi, 0x8f, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x90, 0x74);
+	mipi_dsi_dcs_write_seq(dsi, 0x91, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x92, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0x93, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x94, 0xcc);
+	mipi_dsi_dcs_write_seq(dsi, 0x95, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x96, 0xeb);
+	mipi_dsi_dcs_write_seq(dsi, 0x97, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x98, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0x99, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x9a, 0x34);
+	mipi_dsi_dcs_write_seq(dsi, 0x9b, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x9c, 0x5e);
+	mipi_dsi_dcs_write_seq(dsi, 0x9d, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x9e, 0x66);
+	mipi_dsi_dcs_write_seq(dsi, 0x9f, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa0, 0x73);
+	mipi_dsi_dcs_write_seq(dsi, 0xa2, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa3, 0x82);
+	mipi_dsi_dcs_write_seq(dsi, 0xa4, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa5, 0x91);
+	mipi_dsi_dcs_write_seq(dsi, 0xa6, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa7, 0xa4);
+	mipi_dsi_dcs_write_seq(dsi, 0xa9, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xaa, 0xbb);
+	mipi_dsi_dcs_write_seq(dsi, 0xab, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xac, 0xcd);
+	mipi_dsi_dcs_write_seq(dsi, 0xad, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xae, 0xcf);
+	mipi_dsi_dcs_write_seq(dsi, 0xaf, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x76);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0xda);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xb6, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0xb7, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0x2f);
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xba, 0x3e);
+	mipi_dsi_dcs_write_seq(dsi, 0xbb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xbc, 0x4c);
+	mipi_dsi_dcs_write_seq(dsi, 0xbd, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xbe, 0x58);
+	mipi_dsi_dcs_write_seq(dsi, 0xbf, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x64);
+	mipi_dsi_dcs_write_seq(dsi, 0xc1, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc2, 0x89);
+	mipi_dsi_dcs_write_seq(dsi, 0xc3, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc4, 0xa8);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc6, 0xd9);
+	mipi_dsi_dcs_write_seq(dsi, 0xc7, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc8, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xc9, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xca, 0x41);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0x72);
+	mipi_dsi_dcs_write_seq(dsi, 0xcd, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xce, 0x74);
+	mipi_dsi_dcs_write_seq(dsi, 0xcf, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd0, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0xd1, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0xcc);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd4, 0xeb);
+	mipi_dsi_dcs_write_seq(dsi, 0xd5, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xd6, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0xd7, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xd8, 0x34);
+	mipi_dsi_dcs_write_seq(dsi, 0xd9, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xda, 0x5e);
+	mipi_dsi_dcs_write_seq(dsi, 0xdb, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xdc, 0x66);
+	mipi_dsi_dcs_write_seq(dsi, 0xdd, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xde, 0x73);
+	mipi_dsi_dcs_write_seq(dsi, 0xdf, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe0, 0x82);
+	mipi_dsi_dcs_write_seq(dsi, 0xe1, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe2, 0x91);
+	mipi_dsi_dcs_write_seq(dsi, 0xe3, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe4, 0xa4);
+	mipi_dsi_dcs_write_seq(dsi, 0xe5, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe6, 0xbb);
+	mipi_dsi_dcs_write_seq(dsi, 0xe7, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe8, 0xcd);
+	mipi_dsi_dcs_write_seq(dsi, 0xe9, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xea, 0xcf);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x13, 0xf3);
+	mipi_dsi_dcs_write_seq(dsi, 0x14, 0xf2);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0xf1);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0xf0);
+	mipi_dsi_dcs_write_seq(dsi, 0x21, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0xf4);
+	mipi_dsi_dcs_write_seq(dsi, 0x23, 0xe9);
+	mipi_dsi_dcs_write_seq(dsi, 0x24, 0xde);
+	mipi_dsi_dcs_write_seq(dsi, 0x25, 0xd3);
+	mipi_dsi_dcs_write_seq(dsi, 0x26, 0xc8);
+	mipi_dsi_dcs_write_seq(dsi, 0x27, 0xbd);
+	mipi_dsi_dcs_write_seq(dsi, 0x28, 0xb2);
+	mipi_dsi_dcs_write_seq(dsi, 0x29, 0xa7);
+	mipi_dsi_dcs_write_seq(dsi, 0x2a, 0x9c);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0x08, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0x46, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x01, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x02, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x03, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x04, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0x16);
+	mipi_dsi_dcs_write_seq(dsi, 0x06, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0x08, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0x09, 0x1e);
+	mipi_dsi_dcs_write_seq(dsi, 0x0a, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0x0b, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x0c, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x0d, 0x26);
+	mipi_dsi_dcs_write_seq(dsi, 0x0e, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0x0f, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x13, 0x0e);
+	mipi_dsi_dcs_write_seq(dsi, 0x14, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x17, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0x18, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x19, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0x1a, 0x19);
+	mipi_dsi_dcs_write_seq(dsi, 0x1b, 0x1b);
+	mipi_dsi_dcs_write_seq(dsi, 0x1c, 0x1d);
+	mipi_dsi_dcs_write_seq(dsi, 0x1d, 0x1f);
+	mipi_dsi_dcs_write_seq(dsi, 0x1e, 0x21);
+	mipi_dsi_dcs_write_seq(dsi, 0x1f, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x20, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x21, 0x26);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0x23, 0x09);
+	mipi_dsi_dcs_write_seq(dsi, 0x24, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x25, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x26, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x27, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x28, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x29, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x2a, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x2b, 0x09);
+	mipi_dsi_dcs_write_seq(dsi, 0x2d, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x2f, 0x19);
+	mipi_dsi_dcs_write_seq(dsi, 0x30, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0x31, 0x21);
+	mipi_dsi_dcs_write_seq(dsi, 0x32, 0x1f);
+	mipi_dsi_dcs_write_seq(dsi, 0x33, 0x1d);
+	mipi_dsi_dcs_write_seq(dsi, 0x34, 0x1b);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x36, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x37, 0x26);
+	mipi_dsi_dcs_write_seq(dsi, 0x38, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0x39, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0x3a, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x3d, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x3f, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x40, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x41, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x42, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x43, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x44, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x45, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0x46, 0x16);
+	mipi_dsi_dcs_write_seq(dsi, 0x47, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0x48, 0x1e);
+	mipi_dsi_dcs_write_seq(dsi, 0x49, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0x4a, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0x4b, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x4c, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x4d, 0x26);
+	mipi_dsi_dcs_write_seq(dsi, 0x4e, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0x4f, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x50, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x51, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x52, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x53, 0x0e);
+	mipi_dsi_dcs_write_seq(dsi, 0x54, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0x19);
+	mipi_dsi_dcs_write_seq(dsi, 0x59, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0x5b, 0x4f);
+	mipi_dsi_dcs_write_seq(dsi, 0x5c, 0x2c);
+	mipi_dsi_dcs_write_seq(dsi, 0x5d, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x5e, 0x22);
+	mipi_dsi_dcs_write_seq(dsi, 0x62, 0x21);
+	mipi_dsi_dcs_write_seq(dsi, 0x63, 0x69);
+	mipi_dsi_dcs_write_seq(dsi, 0x64, 0x12);
+	mipi_dsi_dcs_write_seq(dsi, 0x66, 0x57);
+	mipi_dsi_dcs_write_seq(dsi, 0x67, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0x68, 0x2b);
+	mipi_dsi_dcs_write_seq(dsi, 0x69, 0x12);
+	mipi_dsi_dcs_write_seq(dsi, 0x6a, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x6b, 0x29);
+	mipi_dsi_dcs_write_seq(dsi, 0x6c, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x6d, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x3c);
+	mipi_dsi_dcs_write_seq(dsi, 0x70, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x72, 0x22);
+	mipi_dsi_dcs_write_seq(dsi, 0x73, 0x22);
+	mipi_dsi_dcs_write_seq(dsi, 0x7d, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x7e, 0xaa);
+	mipi_dsi_dcs_write_seq(dsi, 0x7f, 0xaa);
+	mipi_dsi_dcs_write_seq(dsi, 0x80, 0xaa);
+	mipi_dsi_dcs_write_seq(dsi, 0x81, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x85, 0x3f);
+	mipi_dsi_dcs_write_seq(dsi, 0x86, 0x3f);
+	mipi_dsi_dcs_write_seq(dsi, 0xa2, 0xb0);
+	mipi_dsi_dcs_write_seq(dsi, 0xbd, 0xa6);
+	mipi_dsi_dcs_write_seq(dsi, 0xbe, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0xbf, 0x12);
+	mipi_dsi_dcs_write_seq(dsi, 0xc8, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc9, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xca, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0x09);
+	mipi_dsi_dcs_write_seq(dsi, 0xce, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xcf, 0x88);
+	mipi_dsi_dcs_write_seq(dsi, 0xd0, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xd1, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xd4, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0xd6, 0x22);
+	mipi_dsi_dcs_write_seq(dsi, 0x90, 0x7b);
+	mipi_dsi_dcs_write_seq(dsi, 0x91, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x92, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x98, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x99, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x9f, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xba, 0xc3);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xd4, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0xd5, 0x14);
+	mipi_dsi_dcs_write_seq(dsi, 0xd6, 0x14);
+	mipi_dsi_dcs_write_seq(dsi, 0x5e, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0x51, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x53, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0x01);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	return 0;
+}
+
+static int cmi_nt35532_5p5xa_off(struct cmi_nt35532_5p5xa *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int cmi_nt35532_5p5xa_prepare(struct drm_panel *panel)
+{
+	struct cmi_nt35532_5p5xa *ctx = to_cmi_nt35532_5p5xa(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	cmi_nt35532_5p5xa_reset(ctx);
+
+	ret = cmi_nt35532_5p5xa_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int cmi_nt35532_5p5xa_unprepare(struct drm_panel *panel)
+{
+	struct cmi_nt35532_5p5xa *ctx = to_cmi_nt35532_5p5xa(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = cmi_nt35532_5p5xa_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode cmi_nt35532_5p5xa_mode = {
+	.clock = (1080 + 94 + 12 + 85) * (1920 + 26 + 8 + 8) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 94,
+	.hsync_end = 1080 + 94 + 12,
+	.htotal = 1080 + 94 + 12 + 85,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 26,
+	.vsync_end = 1920 + 26 + 8,
+	.vtotal = 1920 + 26 + 8 + 8,
+	.width_mm = 68,
+	.height_mm = 121,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int cmi_nt35532_5p5xa_get_modes(struct drm_panel *panel,
+				       struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &cmi_nt35532_5p5xa_mode);
+}
+
+static const struct drm_panel_funcs cmi_nt35532_5p5xa_panel_funcs = {
+	.prepare = cmi_nt35532_5p5xa_prepare,
+	.unprepare = cmi_nt35532_5p5xa_unprepare,
+	.get_modes = cmi_nt35532_5p5xa_get_modes,
+};
+
+static int cmi_nt35532_5p5xa_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+// TODO: Check if /sys/class/backlight/.../actual_brightness actually returns
+// correct values. If not, remove this function.
+static int cmi_nt35532_5p5xa_bl_get_brightness(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_get_display_brightness(dsi, &brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return brightness & 0xff;
+}
+
+static const struct backlight_ops cmi_nt35532_5p5xa_bl_ops = {
+	.update_status = cmi_nt35532_5p5xa_bl_update_status,
+	.get_brightness = cmi_nt35532_5p5xa_bl_get_brightness,
+};
+
+static struct backlight_device *
+cmi_nt35532_5p5xa_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 255,
+		.max_brightness = 255,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &cmi_nt35532_5p5xa_bl_ops, &props);
+}
+
+static int cmi_nt35532_5p5xa_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct cmi_nt35532_5p5xa *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &cmi_nt35532_5p5xa_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ctx->panel.backlight = cmi_nt35532_5p5xa_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void cmi_nt35532_5p5xa_remove(struct mipi_dsi_device *dsi)
+{
+	struct cmi_nt35532_5p5xa *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id cmi_nt35532_5p5xa_of_match[] = {
+	{ .compatible = "huawei,kiwi-cmi-nt35532" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, cmi_nt35532_5p5xa_of_match);
+
+static struct mipi_dsi_driver cmi_nt35532_5p5xa_driver = {
+	.probe = cmi_nt35532_5p5xa_probe,
+	.remove = cmi_nt35532_5p5xa_remove,
+	.driver = {
+		.name = "panel-huawei-kiwi-cmi-nt35532",
+		.of_match_table = cmi_nt35532_5p5xa_of_match,
+	},
+};
+module_mipi_dsi_driver(cmi_nt35532_5p5xa_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for CMI_NT35532_5P5_1080PXA_VIDEO");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-huawei-kiwi-tianma-nt35596.c b/drivers/gpu/drm/panel/msm8916-generated/panel-huawei-kiwi-tianma-nt35596.c
new file mode 100644
index 000000000000..3d9ff1abb9cc
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-huawei-kiwi-tianma-nt35596.c
@@ -0,0 +1,404 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct tianma_nt35596_5p5xa {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline
+struct tianma_nt35596_5p5xa *to_tianma_nt35596_5p5xa(struct drm_panel *panel)
+{
+	return container_of(panel, struct tianma_nt35596_5p5xa, panel);
+}
+
+static void tianma_nt35596_5p5xa_reset(struct tianma_nt35596_5p5xa *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(15000, 16000);
+}
+
+static int tianma_nt35596_5p5xa_on(struct tianma_nt35596_5p5xa *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0xee);
+	mipi_dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x18, 0x40);
+	mipi_dsi_generic_write_seq(dsi, 0x18, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x5c, 0x82);
+	mipi_dsi_generic_write_seq(dsi, 0x5d, 0x82);
+	mipi_dsi_generic_write_seq(dsi, 0x5e, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x5f, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x60, 0x0a);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x50);
+	mipi_dsi_generic_write_seq(dsi, 0x01, 0x50);
+	mipi_dsi_generic_write_seq(dsi, 0x02, 0x50);
+	mipi_dsi_generic_write_seq(dsi, 0x03, 0x50);
+	mipi_dsi_generic_write_seq(dsi, 0x04, 0x50);
+	mipi_dsi_generic_write_seq(dsi, 0x05, 0x50);
+	mipi_dsi_generic_write_seq(dsi, 0x06, 0x50);
+	mipi_dsi_generic_write_seq(dsi, 0x07, 0x50);
+	mipi_dsi_generic_write_seq(dsi, 0x08, 0x50);
+	mipi_dsi_generic_write_seq(dsi, 0x09, 0x46);
+	mipi_dsi_generic_write_seq(dsi, 0x0a, 0x3c);
+	mipi_dsi_generic_write_seq(dsi, 0x0b, 0x32);
+	mipi_dsi_generic_write_seq(dsi, 0x0c, 0x28);
+	mipi_dsi_generic_write_seq(dsi, 0x0d, 0x20);
+	mipi_dsi_generic_write_seq(dsi, 0x0e, 0x18);
+	mipi_dsi_generic_write_seq(dsi, 0x0f, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0x10, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x11, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x12, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x13, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x32, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x33, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x34, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x35, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x36, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0x37, 0x0d);
+	mipi_dsi_generic_write_seq(dsi, 0x38, 0x0d);
+	mipi_dsi_generic_write_seq(dsi, 0x39, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0x3a, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0x3b, 0x0e);
+	mipi_dsi_generic_write_seq(dsi, 0x3f, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0x40, 0x12);
+	mipi_dsi_generic_write_seq(dsi, 0x41, 0x14);
+	mipi_dsi_generic_write_seq(dsi, 0x42, 0x14);
+	mipi_dsi_generic_write_seq(dsi, 0x43, 0x12);
+	mipi_dsi_generic_write_seq(dsi, 0x44, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0x45, 0x0e);
+	mipi_dsi_generic_write_seq(dsi, 0x46, 0x0c);
+	mipi_dsi_generic_write_seq(dsi, 0x47, 0x0a);
+	mipi_dsi_generic_write_seq(dsi, 0x48, 0x08);
+	mipi_dsi_generic_write_seq(dsi, 0x49, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0x4a, 0x04);
+	mipi_dsi_generic_write_seq(dsi, 0x4b, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x4c, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x4e, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0x1a, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x53, 0x77);
+	mipi_dsi_generic_write_seq(dsi, 0x54, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x55, 0x77);
+	mipi_dsi_generic_write_seq(dsi, 0x5b, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x63, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x04);
+	mipi_dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x13, 0xf3);
+	mipi_dsi_generic_write_seq(dsi, 0x14, 0xf2);
+	mipi_dsi_generic_write_seq(dsi, 0x15, 0xf1);
+	mipi_dsi_generic_write_seq(dsi, 0x16, 0xf0);
+	mipi_dsi_generic_write_seq(dsi, 0x21, 0xff);
+	mipi_dsi_generic_write_seq(dsi, 0x22, 0xf4);
+	mipi_dsi_generic_write_seq(dsi, 0x23, 0xe9);
+	mipi_dsi_generic_write_seq(dsi, 0x24, 0xde);
+	mipi_dsi_generic_write_seq(dsi, 0x25, 0xd3);
+	mipi_dsi_generic_write_seq(dsi, 0x26, 0xc8);
+	mipi_dsi_generic_write_seq(dsi, 0x27, 0xbd);
+	mipi_dsi_generic_write_seq(dsi, 0x28, 0xb2);
+	mipi_dsi_generic_write_seq(dsi, 0x29, 0xa7);
+	mipi_dsi_generic_write_seq(dsi, 0x2a, 0x9c);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x04);
+	mipi_dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x07, 0x20);
+	mipi_dsi_generic_write_seq(dsi, 0x08, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x23, 0x5c);
+	mipi_dsi_generic_write_seq(dsi, 0x35, 0x5f);
+	mipi_dsi_generic_write_seq(dsi, 0x7a, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x7e, 0x04);
+	mipi_dsi_generic_write_seq(dsi, 0x7f, 0x1a);
+	mipi_dsi_generic_write_seq(dsi, 0x81, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0x82, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x84, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0x92, 0x63);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x35, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x53, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x5e, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0x51, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0xd4, 0x08);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(40);
+
+	return 0;
+}
+
+static int tianma_nt35596_5p5xa_off(struct tianma_nt35596_5p5xa *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xfb, 0x01);
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(40);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int tianma_nt35596_5p5xa_prepare(struct drm_panel *panel)
+{
+	struct tianma_nt35596_5p5xa *ctx = to_tianma_nt35596_5p5xa(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	tianma_nt35596_5p5xa_reset(ctx);
+
+	ret = tianma_nt35596_5p5xa_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int tianma_nt35596_5p5xa_unprepare(struct drm_panel *panel)
+{
+	struct tianma_nt35596_5p5xa *ctx = to_tianma_nt35596_5p5xa(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = tianma_nt35596_5p5xa_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode tianma_nt35596_5p5xa_mode = {
+	.clock = (1080 + 184 + 8 + 20) * (1920 + 8 + 2 + 2) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 184,
+	.hsync_end = 1080 + 184 + 8,
+	.htotal = 1080 + 184 + 8 + 20,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 8,
+	.vsync_end = 1920 + 8 + 2,
+	.vtotal = 1920 + 8 + 2 + 2,
+	.width_mm = 68,
+	.height_mm = 121,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int tianma_nt35596_5p5xa_get_modes(struct drm_panel *panel,
+					  struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &tianma_nt35596_5p5xa_mode);
+}
+
+static const struct drm_panel_funcs tianma_nt35596_5p5xa_panel_funcs = {
+	.prepare = tianma_nt35596_5p5xa_prepare,
+	.unprepare = tianma_nt35596_5p5xa_unprepare,
+	.get_modes = tianma_nt35596_5p5xa_get_modes,
+};
+
+static int tianma_nt35596_5p5xa_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+// TODO: Check if /sys/class/backlight/.../actual_brightness actually returns
+// correct values. If not, remove this function.
+static int tianma_nt35596_5p5xa_bl_get_brightness(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_get_display_brightness(dsi, &brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return brightness & 0xff;
+}
+
+static const struct backlight_ops tianma_nt35596_5p5xa_bl_ops = {
+	.update_status = tianma_nt35596_5p5xa_bl_update_status,
+	.get_brightness = tianma_nt35596_5p5xa_bl_get_brightness,
+};
+
+static struct backlight_device *
+tianma_nt35596_5p5xa_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 255,
+		.max_brightness = 255,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &tianma_nt35596_5p5xa_bl_ops, &props);
+}
+
+static int tianma_nt35596_5p5xa_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct tianma_nt35596_5p5xa *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &tianma_nt35596_5p5xa_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ctx->panel.backlight = tianma_nt35596_5p5xa_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void tianma_nt35596_5p5xa_remove(struct mipi_dsi_device *dsi)
+{
+	struct tianma_nt35596_5p5xa *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id tianma_nt35596_5p5xa_of_match[] = {
+	{ .compatible = "huawei,kiwi-tianma-nt35596" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, tianma_nt35596_5p5xa_of_match);
+
+static struct mipi_dsi_driver tianma_nt35596_5p5xa_driver = {
+	.probe = tianma_nt35596_5p5xa_probe,
+	.remove = tianma_nt35596_5p5xa_remove,
+	.driver = {
+		.name = "panel-huawei-kiwi-tianma-nt35596",
+		.of_match_table = tianma_nt35596_5p5xa_of_match,
+	},
+};
+module_mipi_dsi_driver(tianma_nt35596_5p5xa_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for TIANMA_NT35596_5P5_1080PXA_VIDEO");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-huawei-tianma-nt35521.c b/drivers/gpu/drm/panel/msm8916-generated/panel-huawei-tianma-nt35521.c
new file mode 100644
index 000000000000..56a77e0d7e19
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-huawei-tianma-nt35521.c
@@ -0,0 +1,502 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct tianma_nt35521_5p5 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline
+struct tianma_nt35521_5p5 *to_tianma_nt35521_5p5(struct drm_panel *panel)
+{
+	return container_of(panel, struct tianma_nt35521_5p5, panel);
+}
+
+static void tianma_nt35521_5p5_reset(struct tianma_nt35521_5p5 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(120);
+}
+
+static int tianma_nt35521_5p5_on(struct tianma_nt35521_5p5 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0xaa, 0x55, 0xa5, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0x6f, 0x11, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xf7, 0x20, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x6f, 0x11);
+	mipi_dsi_generic_write_seq(dsi, 0xf3, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb1, 0x60);
+	mipi_dsi_generic_write_seq(dsi, 0xbd, 0x01, 0xa0, 0x0c, 0x08, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x6f, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0xb8, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xbb, 0x11, 0x11);
+	mipi_dsi_generic_write_seq(dsi, 0xbc, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb6, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x09, 0x09);
+	mipi_dsi_generic_write_seq(dsi, 0xb1, 0x09, 0x09);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x28, 0x28);
+	mipi_dsi_generic_write_seq(dsi, 0xb4, 0x0f, 0x0f);
+	mipi_dsi_generic_write_seq(dsi, 0xb5, 0x03, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xb9, 0x34, 0x34);
+	mipi_dsi_generic_write_seq(dsi, 0xba, 0x15, 0x15);
+	mipi_dsi_generic_write_seq(dsi, 0xbc, 0x58, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xbd, 0x58, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x04);
+	mipi_dsi_generic_write_seq(dsi, 0xca, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0xee, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xb0,
+				   0x00, 0x05, 0x00, 0x2e, 0x00, 0x43, 0x00,
+				   0x6c, 0x00, 0x86, 0x00, 0xaf, 0x00, 0xd0,
+				   0x01, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0xb1,
+				   0x01, 0x2c, 0x01, 0x67, 0x01, 0x96, 0x01,
+				   0xe4, 0x02, 0x22, 0x02, 0x24, 0x02, 0x60,
+				   0x02, 0x9e);
+	mipi_dsi_generic_write_seq(dsi, 0xb2,
+				   0x02, 0xc5, 0x02, 0xf8, 0x03, 0x1d, 0x03,
+				   0x4e, 0x03, 0x68, 0x03, 0x7d, 0x03, 0xa2,
+				   0x03, 0xc7);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x03, 0xd7, 0x03, 0xdb);
+	mipi_dsi_generic_write_seq(dsi, 0xb4,
+				   0x00, 0x99, 0x00, 0xa3, 0x00, 0xb8, 0x00,
+				   0xc8, 0x00, 0xd7, 0x00, 0xf1, 0x01, 0x07,
+				   0x01, 0x2c);
+	mipi_dsi_generic_write_seq(dsi, 0xb5,
+				   0x01, 0x4b, 0x01, 0x7f, 0x01, 0xab, 0x01,
+				   0xf2, 0x02, 0x2b, 0x02, 0x2d, 0x02, 0x64,
+				   0x02, 0xa2);
+	mipi_dsi_generic_write_seq(dsi, 0xb6,
+				   0x02, 0xc9, 0x02, 0xfa, 0x03, 0x1c, 0x03,
+				   0x49, 0x03, 0x65, 0x03, 0x78, 0x03, 0x9e,
+				   0x03, 0xc4);
+	mipi_dsi_generic_write_seq(dsi, 0xb7, 0x03, 0xda, 0x03, 0xdb);
+	mipi_dsi_generic_write_seq(dsi, 0xb8,
+				   0x00, 0x02, 0x00, 0x03, 0x00, 0x11, 0x00,
+				   0x41, 0x00, 0x62, 0x00, 0x92, 0x00, 0xb5,
+				   0x00, 0xec);
+	mipi_dsi_generic_write_seq(dsi, 0xb9,
+				   0x01, 0x17, 0x01, 0x58, 0x01, 0x8a, 0x01,
+				   0xdd, 0x02, 0x1e, 0x02, 0x1f, 0x02, 0x5b,
+				   0x02, 0x9b);
+	mipi_dsi_generic_write_seq(dsi, 0xba,
+				   0x02, 0xc5, 0x02, 0xf9, 0x03, 0x22, 0x03,
+				   0x5c, 0x03, 0x8f, 0x03, 0xfd, 0x03, 0xfd,
+				   0x03, 0xfd);
+	mipi_dsi_generic_write_seq(dsi, 0xbb, 0x03, 0xfe, 0x03, 0xfe);
+	mipi_dsi_generic_write_seq(dsi, 0x6f, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0xf7, 0x47);
+	mipi_dsi_generic_write_seq(dsi, 0x6f, 0x0a);
+	mipi_dsi_generic_write_seq(dsi, 0xf7, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x6f, 0x17);
+	mipi_dsi_generic_write_seq(dsi, 0xf4, 0x70);
+	mipi_dsi_generic_write_seq(dsi, 0x6f, 0x11);
+	mipi_dsi_generic_write_seq(dsi, 0xf3, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x20, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb1, 0x20, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb2, 0x05, 0x00, 0x00, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x05, 0x00, 0x00, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xb4, 0x05, 0x00, 0x00, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xb5, 0x05, 0x00, 0x00, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xb6, 0x05, 0x00, 0x00, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xb7, 0x05, 0x00, 0x00, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xb8, 0x05, 0x00, 0x00, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xb9, 0x05, 0x00, 0x00, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xba, 0x53, 0x01, 0x00, 0x01, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xbb, 0x53, 0x01, 0x00, 0x01, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xbc, 0x53, 0x01, 0x00, 0x01, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xbd, 0x53, 0x01, 0x00, 0x01, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x60);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x40);
+	mipi_dsi_generic_write_seq(dsi, 0xc6, 0x60);
+	mipi_dsi_generic_write_seq(dsi, 0xc7, 0x40);
+	mipi_dsi_generic_write_seq(dsi, 0x6f, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xf9, 0x46);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0xed, 0x30);
+	mipi_dsi_generic_write_seq(dsi, 0xe5, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb8, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xbd, 0x03, 0x03, 0x01, 0x00, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xb1, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb9, 0x00, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xb2, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xba, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xbb, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb4, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb5, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb6, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb7, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xbc, 0x00, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xe5, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xe6, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xe7, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xe8, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xe9, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xea, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xeb, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xec, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x0b);
+	mipi_dsi_generic_write_seq(dsi, 0xc1, 0x09);
+	mipi_dsi_generic_write_seq(dsi, 0xc2, 0x0b);
+	mipi_dsi_generic_write_seq(dsi, 0xc3, 0x09);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0xc6, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0xc7, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0xc8, 0x08, 0x20);
+	mipi_dsi_generic_write_seq(dsi, 0xc9, 0x04, 0x20);
+	mipi_dsi_generic_write_seq(dsi, 0xca, 0x07, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xcb, 0x03, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd1, 0x00, 0x05, 0x00, 0x07, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0xd2, 0x00, 0x05, 0x04, 0x07, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0xd3, 0x00, 0x00, 0x0a, 0x07, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0xd4, 0x00, 0x00, 0x0a, 0x07, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0xd0,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd5,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd6,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd7,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x12, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0xb1, 0x18, 0x16);
+	mipi_dsi_generic_write_seq(dsi, 0xb2, 0x00, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xb4, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xb5, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xb6, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xb7, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xb8, 0x31, 0x08);
+	mipi_dsi_generic_write_seq(dsi, 0xb9, 0x2e, 0x2d);
+	mipi_dsi_generic_write_seq(dsi, 0xba, 0x2d, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xbb, 0x09, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xbc, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xbd, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xbe, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xbf, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xc1, 0x03, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xc2, 0x17, 0x19);
+	mipi_dsi_generic_write_seq(dsi, 0xc3, 0x11, 0x13);
+	mipi_dsi_generic_write_seq(dsi, 0xe5, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x17, 0x19);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x11, 0x13);
+	mipi_dsi_generic_write_seq(dsi, 0xc6, 0x03, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xc7, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xc8, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xc9, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xca, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xcb, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xcc, 0x31, 0x09);
+	mipi_dsi_generic_write_seq(dsi, 0xcd, 0x2d, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xce, 0x2e, 0x2d);
+	mipi_dsi_generic_write_seq(dsi, 0xcf, 0x08, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xd0, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xd1, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xd2, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xd3, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xd4, 0x31, 0x31);
+	mipi_dsi_generic_write_seq(dsi, 0xd5, 0x00, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0xd6, 0x12, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0xd7, 0x18, 0x16);
+	mipi_dsi_generic_write_seq(dsi, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xe7, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xe6, 0xff, 0xff, 0xfa, 0xfa);
+	mipi_dsi_generic_write_seq(dsi, 0xe8,
+				   0xf3, 0xe8, 0xe0, 0xd8, 0xce, 0xc4, 0xba,
+				   0xb0, 0xa6, 0x9c);
+	mipi_dsi_generic_write_seq(dsi, 0xcc,
+				   0x41, 0x36, 0x87, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x08,
+				   0xa5, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0xd1,
+				   0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03,
+				   0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x01,
+				   0x01, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd7,
+				   0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd8,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x02, 0x01, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd9, 0x02, 0x09);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x81);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x0000);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_CABC_MIN_BRIGHTNESS, 0x28);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	return 0;
+}
+
+static int tianma_nt35521_5p5_off(struct tianma_nt35521_5p5 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int tianma_nt35521_5p5_prepare(struct drm_panel *panel)
+{
+	struct tianma_nt35521_5p5 *ctx = to_tianma_nt35521_5p5(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	tianma_nt35521_5p5_reset(ctx);
+
+	ret = tianma_nt35521_5p5_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int tianma_nt35521_5p5_unprepare(struct drm_panel *panel)
+{
+	struct tianma_nt35521_5p5 *ctx = to_tianma_nt35521_5p5(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = tianma_nt35521_5p5_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode tianma_nt35521_5p5_mode = {
+	.clock = (720 + 88 + 12 + 88) * (1280 + 20 + 3 + 20) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 88,
+	.hsync_end = 720 + 88 + 12,
+	.htotal = 720 + 88 + 12 + 88,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 20,
+	.vsync_end = 1280 + 20 + 3,
+	.vtotal = 1280 + 20 + 3 + 20,
+	.width_mm = 68,
+	.height_mm = 121,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int tianma_nt35521_5p5_get_modes(struct drm_panel *panel,
+					struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &tianma_nt35521_5p5_mode);
+}
+
+static const struct drm_panel_funcs tianma_nt35521_5p5_panel_funcs = {
+	.prepare = tianma_nt35521_5p5_prepare,
+	.unprepare = tianma_nt35521_5p5_unprepare,
+	.get_modes = tianma_nt35521_5p5_get_modes,
+};
+
+static int tianma_nt35521_5p5_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct backlight_ops tianma_nt35521_5p5_bl_ops = {
+	.update_status = tianma_nt35521_5p5_bl_update_status,
+};
+
+static struct backlight_device *
+tianma_nt35521_5p5_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 250,
+		.max_brightness = 250,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &tianma_nt35521_5p5_bl_ops, &props);
+}
+
+static int tianma_nt35521_5p5_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct tianma_nt35521_5p5 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &tianma_nt35521_5p5_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ctx->panel.backlight = tianma_nt35521_5p5_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void tianma_nt35521_5p5_remove(struct mipi_dsi_device *dsi)
+{
+	struct tianma_nt35521_5p5 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id tianma_nt35521_5p5_of_match[] = {
+	{ .compatible = "huawei,tianma-nt35521" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, tianma_nt35521_5p5_of_match);
+
+static struct mipi_dsi_driver tianma_nt35521_5p5_driver = {
+	.probe = tianma_nt35521_5p5_probe,
+	.remove = tianma_nt35521_5p5_remove,
+	.driver = {
+		.name = "panel-huawei-tianma-nt35521",
+		.of_match_table = tianma_nt35521_5p5_of_match,
+	},
+};
+module_mipi_dsi_driver(tianma_nt35521_5p5_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for TIANMA_NT35521_5P5_720P_VIDEO");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-booyi-otm1287.c b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-booyi-otm1287.c
new file mode 100644
index 000000000000..3ef9d34d96d6
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-booyi-otm1287.c
@@ -0,0 +1,401 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct booyi_otm1287 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct booyi_otm1287 *to_booyi_otm1287(struct drm_panel *panel)
+{
+	return container_of(panel, struct booyi_otm1287, panel);
+}
+
+static void booyi_otm1287_reset(struct booyi_otm1287 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int booyi_otm1287_on(struct booyi_otm1287 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x12, 0x87, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x12, 0x87);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x92);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0,
+			       0x00, 0x64, 0x00, 0x0f, 0x11, 0x00, 0x64, 0x0f,
+			       0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x00, 0x5c, 0x00, 0x01, 0x00, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xa4);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xb3);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x00, 0x55);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x81);
+	mipi_dsi_dcs_write_seq(dsi, 0xc1, 0x55);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_dcs_write_seq(dsi, 0xf5, 0x02, 0x11, 0x02, 0x15);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0x50);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x94);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0x66);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xb2);
+	mipi_dsi_dcs_write_seq(dsi, 0xf5, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xb6);
+	mipi_dsi_dcs_write_seq(dsi, 0xf5, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x94);
+	mipi_dsi_dcs_write_seq(dsi, 0xf5, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xd2);
+	mipi_dsi_dcs_write_seq(dsi, 0xf5, 0x06, 0x15);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xb4);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0xcc);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0xc4,
+			       0x05, 0x10, 0x06, 0x02, 0x05, 0x15, 0x10, 0x05,
+			       0x10, 0x07, 0x02, 0x05, 0x15, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xb0);
+	mipi_dsi_dcs_write_seq(dsi, 0xc4, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x91);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0x19, 0x52);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xd8, 0xbc, 0xbc);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xb3);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0x84);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xbb);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0x8a);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x82);
+	mipi_dsi_dcs_write_seq(dsi, 0xc4, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xe1,
+			       0x05, 0x44, 0x54, 0x61, 0x72, 0x7f, 0x81, 0xa9,
+			       0x98, 0xb0, 0x55, 0x41, 0x56, 0x38, 0x3a, 0x2e,
+			       0x23, 0x19, 0x0c, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xe2,
+			       0x05, 0x44, 0x54, 0x61, 0x72, 0x80, 0x80, 0xa9,
+			       0x99, 0xb0, 0x54, 0x41, 0x56, 0x38, 0x3a, 0x2f,
+			       0x23, 0x1a, 0x0d, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xd9, 0x71);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xb0);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xc0);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb,
+			       0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xd0);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05,
+			       0x05, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xe0);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00, 0x00, 0x00, 0x05, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xf0);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb,
+			       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+			       0xff, 0xff, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc,
+			       0x09, 0x0b, 0x0d, 0x0f, 0x01, 0x03, 0x00, 0x00,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x2d, 0x0a,
+			       0x0c, 0x0e, 0x10, 0x02, 0x04, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00, 0x00, 0x00, 0x2e, 0x2d);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xb0);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc,
+			       0x10, 0x0e, 0x0c, 0x0a, 0x04, 0x02, 0x00, 0x00,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xc0);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x2e, 0x0f,
+			       0x0d, 0x0b, 0x09, 0x03, 0x01, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xd0);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00, 0x00, 0x00, 0x2d, 0x2e);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0xce,
+			       0x8b, 0x03, 0x00, 0x8a, 0x03, 0x00, 0x89, 0x03,
+			       0x00, 0x88, 0x03, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_dcs_write_seq(dsi, 0xce,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0xce,
+			       0x38, 0x07, 0x84, 0xfc, 0x8b, 0x04, 0x00, 0x38,
+			       0x06, 0x84, 0xfd, 0x8b, 0x04, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xb0);
+	mipi_dsi_dcs_write_seq(dsi, 0xce,
+			       0x38, 0x05, 0x84, 0xfe, 0x8b, 0x04, 0x00, 0x38,
+			       0x04, 0x84, 0xff, 0x8b, 0x04, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xc0);
+	mipi_dsi_dcs_write_seq(dsi, 0xce,
+			       0x38, 0x03, 0x85, 0x00, 0x8b, 0x04, 0x00, 0x38,
+			       0x02, 0x85, 0x01, 0x8b, 0x04, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xd0);
+	mipi_dsi_dcs_write_seq(dsi, 0xce,
+			       0x38, 0x01, 0x85, 0x02, 0x8b, 0x04, 0x00, 0x38,
+			       0x00, 0x85, 0x03, 0x8b, 0x04, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0xcf,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_dcs_write_seq(dsi, 0xcf,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0xcf,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xb0);
+	mipi_dsi_dcs_write_seq(dsi, 0xcf,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xc0);
+	mipi_dsi_dcs_write_seq(dsi, 0xcf,
+			       0x01, 0x01, 0x20, 0x20, 0x00, 0x00, 0x01, 0x01,
+			       0x00, 0x02, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xb5);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0x33, 0xf1, 0xff, 0x33, 0xf1, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0xb1);
+	mipi_dsi_dcs_write_seq(dsi, 0xc6, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0xff, 0xff, 0xff);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int booyi_otm1287_off(struct booyi_otm1287 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int booyi_otm1287_prepare(struct drm_panel *panel)
+{
+	struct booyi_otm1287 *ctx = to_booyi_otm1287(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	booyi_otm1287_reset(ctx);
+
+	ret = booyi_otm1287_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int booyi_otm1287_unprepare(struct drm_panel *panel)
+{
+	struct booyi_otm1287 *ctx = to_booyi_otm1287(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = booyi_otm1287_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode booyi_otm1287_mode = {
+	.clock = (720 + 90 + 10 + 90) * (1280 + 20 + 4 + 16) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 90,
+	.hsync_end = 720 + 90 + 10,
+	.htotal = 720 + 90 + 10 + 90,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 20,
+	.vsync_end = 1280 + 20 + 4,
+	.vtotal = 1280 + 20 + 4 + 16,
+	.width_mm = 62,
+	.height_mm = 110,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int booyi_otm1287_get_modes(struct drm_panel *panel,
+				   struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &booyi_otm1287_mode);
+}
+
+static const struct drm_panel_funcs booyi_otm1287_panel_funcs = {
+	.prepare = booyi_otm1287_prepare,
+	.unprepare = booyi_otm1287_unprepare,
+	.get_modes = booyi_otm1287_get_modes,
+};
+
+static int booyi_otm1287_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct booyi_otm1287 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			  MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &booyi_otm1287_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void booyi_otm1287_remove(struct mipi_dsi_device *dsi)
+{
+	struct booyi_otm1287 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id booyi_otm1287_of_match[] = {
+	{ .compatible = "longcheer,booyi-otm1287" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, booyi_otm1287_of_match);
+
+static struct mipi_dsi_driver booyi_otm1287_driver = {
+	.probe = booyi_otm1287_probe,
+	.remove = booyi_otm1287_remove,
+	.driver = {
+		.name = "panel-longcheer-booyi-otm1287",
+		.of_match_table = booyi_otm1287_of_match,
+	},
+};
+module_mipi_dsi_driver(booyi_otm1287_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for booyi OTM1287 720p video mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-dijing-ili9881c.c b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-dijing-ili9881c.c
new file mode 100644
index 000000000000..f1ecf26acf36
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-dijing-ili9881c.c
@@ -0,0 +1,421 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct dijing_ili9881c {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline
+struct dijing_ili9881c *to_dijing_ili9881c(struct drm_panel *panel)
+{
+	return container_of(panel, struct dijing_ili9881c, panel);
+}
+
+static void dijing_ili9881c_reset(struct dijing_ili9881c *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int dijing_ili9881c_on(struct dijing_ili9881c *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x98, 0x81, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0x01, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x02, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x03, 0x72);
+	mipi_dsi_generic_write_seq(dsi, 0x04, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x05, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x06, 0x09);
+	mipi_dsi_generic_write_seq(dsi, 0x07, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x08, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x09, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x0a, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x0b, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x0c, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x0d, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x0e, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x0f, 0x14);
+	mipi_dsi_generic_write_seq(dsi, 0x10, 0x14);
+	mipi_dsi_generic_write_seq(dsi, 0x11, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x12, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x13, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x14, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x15, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x16, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x17, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x18, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x19, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x1a, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x1b, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x1c, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x1d, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x1e, 0x40);
+	mipi_dsi_generic_write_seq(dsi, 0x1f, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0x20, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0x21, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x22, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x23, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x24, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x25, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x26, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x27, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x28, 0x33);
+	mipi_dsi_generic_write_seq(dsi, 0x29, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x2a, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x2b, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x2c, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x2d, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x2e, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x2f, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x30, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x31, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x32, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x33, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x34, 0x04);
+	mipi_dsi_generic_write_seq(dsi, 0x35, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x36, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x37, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x38, 0x78);
+	mipi_dsi_generic_write_seq(dsi, 0x39, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x3a, 0x40);
+	mipi_dsi_generic_write_seq(dsi, 0x3b, 0x40);
+	mipi_dsi_generic_write_seq(dsi, 0x3c, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x3d, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x3e, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x3f, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x40, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x41, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x42, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x43, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x44, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x50, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x51, 0x23);
+	mipi_dsi_generic_write_seq(dsi, 0x52, 0x45);
+	mipi_dsi_generic_write_seq(dsi, 0x53, 0x67);
+	mipi_dsi_generic_write_seq(dsi, 0x54, 0x89);
+	mipi_dsi_generic_write_seq(dsi, 0x55, 0xab);
+	mipi_dsi_generic_write_seq(dsi, 0x56, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x57, 0x23);
+	mipi_dsi_generic_write_seq(dsi, 0x58, 0x45);
+	mipi_dsi_generic_write_seq(dsi, 0x59, 0x67);
+	mipi_dsi_generic_write_seq(dsi, 0x5a, 0x89);
+	mipi_dsi_generic_write_seq(dsi, 0x5b, 0xab);
+	mipi_dsi_generic_write_seq(dsi, 0x5c, 0xcd);
+	mipi_dsi_generic_write_seq(dsi, 0x5d, 0xef);
+	mipi_dsi_generic_write_seq(dsi, 0x5e, 0x11);
+	mipi_dsi_generic_write_seq(dsi, 0x5f, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x60, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x61, 0x15);
+	mipi_dsi_generic_write_seq(dsi, 0x62, 0x14);
+	mipi_dsi_generic_write_seq(dsi, 0x63, 0x0e);
+	mipi_dsi_generic_write_seq(dsi, 0x64, 0x0f);
+	mipi_dsi_generic_write_seq(dsi, 0x65, 0x0c);
+	mipi_dsi_generic_write_seq(dsi, 0x66, 0x0d);
+	mipi_dsi_generic_write_seq(dsi, 0x67, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0x68, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x69, 0x07);
+	mipi_dsi_generic_write_seq(dsi, 0x6a, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x6b, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x6c, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x6d, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x6e, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x6f, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x70, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x71, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x72, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x73, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x74, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x75, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x76, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x77, 0x14);
+	mipi_dsi_generic_write_seq(dsi, 0x78, 0x15);
+	mipi_dsi_generic_write_seq(dsi, 0x79, 0x0e);
+	mipi_dsi_generic_write_seq(dsi, 0x7a, 0x0f);
+	mipi_dsi_generic_write_seq(dsi, 0x7b, 0x0c);
+	mipi_dsi_generic_write_seq(dsi, 0x7c, 0x0d);
+	mipi_dsi_generic_write_seq(dsi, 0x7d, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0x7e, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x7f, 0x07);
+	mipi_dsi_generic_write_seq(dsi, 0x80, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x81, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x82, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x83, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x84, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x85, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x86, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x87, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x88, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x89, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x8a, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x98, 0x81, 0x04);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0x6c, 0x15);
+	mipi_dsi_generic_write_seq(dsi, 0x6e, 0x2a);
+	mipi_dsi_generic_write_seq(dsi, 0x6f, 0x33);
+	mipi_dsi_generic_write_seq(dsi, 0x3a, 0x94);
+	mipi_dsi_generic_write_seq(dsi, 0x8d, 0x1a);
+	mipi_dsi_generic_write_seq(dsi, 0x87, 0xba);
+	mipi_dsi_generic_write_seq(dsi, 0x26, 0x76);
+	mipi_dsi_generic_write_seq(dsi, 0xb2, 0xd1);
+	mipi_dsi_generic_write_seq(dsi, 0xb5, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x98, 0x81, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x22, 0x0a);
+	mipi_dsi_generic_write_seq(dsi, 0x31, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x53, 0x81);
+	mipi_dsi_generic_write_seq(dsi, 0x55, 0x8f);
+	mipi_dsi_generic_write_seq(dsi, 0x50, 0xc0);
+	mipi_dsi_generic_write_seq(dsi, 0x51, 0xc0);
+	mipi_dsi_generic_write_seq(dsi, 0x60, 0x08);
+	mipi_dsi_generic_write_seq(dsi, 0xa0, 0x08);
+	mipi_dsi_generic_write_seq(dsi, 0xa1, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0xa2, 0x25);
+	mipi_dsi_generic_write_seq(dsi, 0xa3, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xa4, 0x24);
+	mipi_dsi_generic_write_seq(dsi, 0xa5, 0x19);
+	mipi_dsi_generic_write_seq(dsi, 0xa6, 0x12);
+	mipi_dsi_generic_write_seq(dsi, 0xa7, 0x1b);
+	mipi_dsi_generic_write_seq(dsi, 0xa8, 0x77);
+	mipi_dsi_generic_write_seq(dsi, 0xa9, 0x19);
+	mipi_dsi_generic_write_seq(dsi, 0xaa, 0x25);
+	mipi_dsi_generic_write_seq(dsi, 0xab, 0x6e);
+	mipi_dsi_generic_write_seq(dsi, 0xac, 0x20);
+	mipi_dsi_generic_write_seq(dsi, 0xad, 0x17);
+	mipi_dsi_generic_write_seq(dsi, 0xae, 0x54);
+	mipi_dsi_generic_write_seq(dsi, 0xaf, 0x24);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x27);
+	mipi_dsi_generic_write_seq(dsi, 0xb1, 0x52);
+	mipi_dsi_generic_write_seq(dsi, 0xb2, 0x63);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x39);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x08);
+	mipi_dsi_generic_write_seq(dsi, 0xc1, 0x20);
+	mipi_dsi_generic_write_seq(dsi, 0xc2, 0x23);
+	mipi_dsi_generic_write_seq(dsi, 0xc3, 0x22);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x34);
+	mipi_dsi_generic_write_seq(dsi, 0xc6, 0x25);
+	mipi_dsi_generic_write_seq(dsi, 0xc7, 0x20);
+	mipi_dsi_generic_write_seq(dsi, 0xc8, 0x86);
+	mipi_dsi_generic_write_seq(dsi, 0xc9, 0x1f);
+	mipi_dsi_generic_write_seq(dsi, 0xca, 0x2b);
+	mipi_dsi_generic_write_seq(dsi, 0xcb, 0x74);
+	mipi_dsi_generic_write_seq(dsi, 0xcc, 0x16);
+	mipi_dsi_generic_write_seq(dsi, 0xcd, 0x1b);
+	mipi_dsi_generic_write_seq(dsi, 0xce, 0x46);
+	mipi_dsi_generic_write_seq(dsi, 0xcf, 0x21);
+	mipi_dsi_generic_write_seq(dsi, 0xd0, 0x29);
+	mipi_dsi_generic_write_seq(dsi, 0xd1, 0x54);
+	mipi_dsi_generic_write_seq(dsi, 0xd2, 0x65);
+	mipi_dsi_generic_write_seq(dsi, 0xd3, 0x39);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x98, 0x81, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x35, 0x00);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dijing_ili9881c_off(struct dijing_ili9881c *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int dijing_ili9881c_prepare(struct drm_panel *panel)
+{
+	struct dijing_ili9881c *ctx = to_dijing_ili9881c(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	dijing_ili9881c_reset(ctx);
+
+	ret = dijing_ili9881c_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dijing_ili9881c_unprepare(struct drm_panel *panel)
+{
+	struct dijing_ili9881c *ctx = to_dijing_ili9881c(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = dijing_ili9881c_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode dijing_ili9881c_mode = {
+	.clock = (720 + 150 + 10 + 150) * (1280 + 20 + 2 + 19) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 150,
+	.hsync_end = 720 + 150 + 10,
+	.htotal = 720 + 150 + 10 + 150,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 20,
+	.vsync_end = 1280 + 20 + 2,
+	.vtotal = 1280 + 20 + 2 + 19,
+	.width_mm = 62,
+	.height_mm = 110,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int dijing_ili9881c_get_modes(struct drm_panel *panel,
+				     struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &dijing_ili9881c_mode);
+}
+
+static const struct drm_panel_funcs dijing_ili9881c_panel_funcs = {
+	.prepare = dijing_ili9881c_prepare,
+	.unprepare = dijing_ili9881c_unprepare,
+	.get_modes = dijing_ili9881c_get_modes,
+};
+
+static int dijing_ili9881c_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct dijing_ili9881c *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			  MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &dijing_ili9881c_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void dijing_ili9881c_remove(struct mipi_dsi_device *dsi)
+{
+	struct dijing_ili9881c *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id dijing_ili9881c_of_match[] = {
+	{ .compatible = "longcheer,dijing-ili9881c" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, dijing_ili9881c_of_match);
+
+static struct mipi_dsi_driver dijing_ili9881c_driver = {
+	.probe = dijing_ili9881c_probe,
+	.remove = dijing_ili9881c_remove,
+	.driver = {
+		.name = "panel-longcheer-dijing-ili9881c",
+		.of_match_table = dijing_ili9881c_of_match,
+	},
+};
+module_mipi_dsi_driver(dijing_ili9881c_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for dijing ILI9881C 720p video mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-truly-nt35695.c b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-truly-nt35695.c
new file mode 100644
index 000000000000..8904b8916ed8
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-truly-nt35695.c
@@ -0,0 +1,767 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct truly_nt35695 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct truly_nt35695 *to_truly_nt35695(struct drm_panel *panel)
+{
+	return container_of(panel, struct truly_nt35695, panel);
+}
+
+static void truly_nt35695_reset(struct truly_nt35695 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int truly_nt35695_on(struct truly_nt35695 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x20);
+	usleep_range(1000, 2000);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x30, 0x6f);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x01, 0x55);
+	mipi_dsi_dcs_write_seq(dsi, 0x02, 0x45);
+	mipi_dsi_dcs_write_seq(dsi, 0x03, 0x55);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0x50);
+	mipi_dsi_dcs_write_seq(dsi, 0x04, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x06, 0x9e);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0xa8);
+	mipi_dsi_dcs_write_seq(dsi, 0x08, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x09, 0x55);
+	mipi_dsi_dcs_write_seq(dsi, 0x0a, 0x55);
+	mipi_dsi_dcs_write_seq(dsi, 0x0d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x0b, 0x55);
+	mipi_dsi_dcs_write_seq(dsi, 0x0c, 0x55);
+	mipi_dsi_dcs_write_seq(dsi, 0x0e, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x0f, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0x27);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x63);
+	mipi_dsi_dcs_write_seq(dsi, 0x13, 0xf3);
+	mipi_dsi_dcs_write_seq(dsi, 0x14, 0x4a);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0x93);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x93);
+	mipi_dsi_dcs_write_seq(dsi, 0x17, 0x63);
+	mipi_dsi_dcs_write_seq(dsi, 0x18, 0x63);
+	mipi_dsi_dcs_write_seq(dsi, 0x19, 0x63);
+	mipi_dsi_dcs_write_seq(dsi, 0x1a, 0x63);
+	mipi_dsi_dcs_write_seq(dsi, 0x68, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x69, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0x6a, 0x33);
+	mipi_dsi_dcs_write_seq(dsi, 0x6b, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x6c, 0x33);
+	mipi_dsi_dcs_write_seq(dsi, 0x6d, 0x68);
+	mipi_dsi_dcs_write_seq(dsi, 0x75, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x76, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x77, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x78, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x79, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x7a, 0x21);
+	mipi_dsi_dcs_write_seq(dsi, 0x7b, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x7c, 0x35);
+	mipi_dsi_dcs_write_seq(dsi, 0x7d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x7e, 0x46);
+	mipi_dsi_dcs_write_seq(dsi, 0x7f, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x80, 0x56);
+	mipi_dsi_dcs_write_seq(dsi, 0x81, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x82, 0x64);
+	mipi_dsi_dcs_write_seq(dsi, 0x83, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x84, 0x72);
+	mipi_dsi_dcs_write_seq(dsi, 0x85, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x86, 0x7f);
+	mipi_dsi_dcs_write_seq(dsi, 0x87, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x88, 0xac);
+	mipi_dsi_dcs_write_seq(dsi, 0x89, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x8a, 0xd2);
+	mipi_dsi_dcs_write_seq(dsi, 0x8b, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x8c, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x8d, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x8e, 0x43);
+	mipi_dsi_dcs_write_seq(dsi, 0x8f, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x90, 0x95);
+	mipi_dsi_dcs_write_seq(dsi, 0x91, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x92, 0xd8);
+	mipi_dsi_dcs_write_seq(dsi, 0x93, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x94, 0xda);
+	mipi_dsi_dcs_write_seq(dsi, 0x95, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x96, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0x97, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x98, 0x63);
+	mipi_dsi_dcs_write_seq(dsi, 0x99, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x9a, 0x92);
+	mipi_dsi_dcs_write_seq(dsi, 0x9b, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x9c, 0xd1);
+	mipi_dsi_dcs_write_seq(dsi, 0x9d, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x9e, 0xfa);
+	mipi_dsi_dcs_write_seq(dsi, 0x9f, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa0, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xa2, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa3, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0xa4, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa5, 0x52);
+	mipi_dsi_dcs_write_seq(dsi, 0xa6, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa7, 0x67);
+	mipi_dsi_dcs_write_seq(dsi, 0xa9, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xaa, 0x7d);
+	mipi_dsi_dcs_write_seq(dsi, 0xab, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xac, 0x99);
+	mipi_dsi_dcs_write_seq(dsi, 0xad, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xae, 0xb1);
+	mipi_dsi_dcs_write_seq(dsi, 0xaf, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0xfb);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb6, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0xb7, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0x21);
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xba, 0x35);
+	mipi_dsi_dcs_write_seq(dsi, 0xbb, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xbc, 0x46);
+	mipi_dsi_dcs_write_seq(dsi, 0xbd, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xbe, 0x56);
+	mipi_dsi_dcs_write_seq(dsi, 0xbf, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x64);
+	mipi_dsi_dcs_write_seq(dsi, 0xc1, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc2, 0x72);
+	mipi_dsi_dcs_write_seq(dsi, 0xc3, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc4, 0x7f);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc6, 0xac);
+	mipi_dsi_dcs_write_seq(dsi, 0xc7, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc8, 0xd2);
+	mipi_dsi_dcs_write_seq(dsi, 0xc9, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xca, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0x43);
+	mipi_dsi_dcs_write_seq(dsi, 0xcd, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xce, 0x95);
+	mipi_dsi_dcs_write_seq(dsi, 0xcf, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xd0, 0xd8);
+	mipi_dsi_dcs_write_seq(dsi, 0xd1, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0xda);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd4, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0xd5, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd6, 0x63);
+	mipi_dsi_dcs_write_seq(dsi, 0xd7, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd8, 0x92);
+	mipi_dsi_dcs_write_seq(dsi, 0xd9, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xda, 0xd1);
+	mipi_dsi_dcs_write_seq(dsi, 0xdb, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xdc, 0xfa);
+	mipi_dsi_dcs_write_seq(dsi, 0xdd, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xde, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xdf, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe0, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0xe1, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe2, 0x52);
+	mipi_dsi_dcs_write_seq(dsi, 0xe3, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe4, 0x67);
+	mipi_dsi_dcs_write_seq(dsi, 0xe5, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe6, 0x7d);
+	mipi_dsi_dcs_write_seq(dsi, 0xe7, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe8, 0x99);
+	mipi_dsi_dcs_write_seq(dsi, 0xe9, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xea, 0xb1);
+	mipi_dsi_dcs_write_seq(dsi, 0xeb, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xec, 0xfb);
+	mipi_dsi_dcs_write_seq(dsi, 0xed, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xee, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xef, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf1, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf2, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0xf3, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf4, 0x21);
+	mipi_dsi_dcs_write_seq(dsi, 0xf5, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf6, 0x35);
+	mipi_dsi_dcs_write_seq(dsi, 0xf7, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf8, 0x46);
+	mipi_dsi_dcs_write_seq(dsi, 0xf9, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xfa, 0x56);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x21);
+	usleep_range(1000, 2000);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x01, 0x64);
+	mipi_dsi_dcs_write_seq(dsi, 0x02, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x03, 0x72);
+	mipi_dsi_dcs_write_seq(dsi, 0x04, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0x7f);
+	mipi_dsi_dcs_write_seq(dsi, 0x06, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0xac);
+	mipi_dsi_dcs_write_seq(dsi, 0x08, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x09, 0xd2);
+	mipi_dsi_dcs_write_seq(dsi, 0x0a, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0b, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x0c, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0d, 0x43);
+	mipi_dsi_dcs_write_seq(dsi, 0x0e, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0f, 0x95);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0xd8);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x13, 0xda);
+	mipi_dsi_dcs_write_seq(dsi, 0x14, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x17, 0x63);
+	mipi_dsi_dcs_write_seq(dsi, 0x18, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x19, 0x92);
+	mipi_dsi_dcs_write_seq(dsi, 0x1a, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x1b, 0xd1);
+	mipi_dsi_dcs_write_seq(dsi, 0x1c, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x1d, 0xfa);
+	mipi_dsi_dcs_write_seq(dsi, 0x1e, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x1f, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0x20, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x21, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x23, 0x52);
+	mipi_dsi_dcs_write_seq(dsi, 0x24, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x25, 0x67);
+	mipi_dsi_dcs_write_seq(dsi, 0x26, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x27, 0x7d);
+	mipi_dsi_dcs_write_seq(dsi, 0x28, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x29, 0x99);
+	mipi_dsi_dcs_write_seq(dsi, 0x2a, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x2b, 0xb1);
+	mipi_dsi_dcs_write_seq(dsi, 0x2d, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x2f, 0xfb);
+	mipi_dsi_dcs_write_seq(dsi, 0x30, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x31, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x32, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x33, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x34, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x36, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x37, 0x21);
+	mipi_dsi_dcs_write_seq(dsi, 0x38, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x39, 0x35);
+	mipi_dsi_dcs_write_seq(dsi, 0x3a, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0x46);
+	mipi_dsi_dcs_write_seq(dsi, 0x3d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x3f, 0x56);
+	mipi_dsi_dcs_write_seq(dsi, 0x40, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x41, 0x64);
+	mipi_dsi_dcs_write_seq(dsi, 0x42, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x43, 0x72);
+	mipi_dsi_dcs_write_seq(dsi, 0x44, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x45, 0x7f);
+	mipi_dsi_dcs_write_seq(dsi, 0x46, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x47, 0xac);
+	mipi_dsi_dcs_write_seq(dsi, 0x48, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x49, 0xd2);
+	mipi_dsi_dcs_write_seq(dsi, 0x4a, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x4b, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x4c, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x4d, 0x43);
+	mipi_dsi_dcs_write_seq(dsi, 0x4e, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x4f, 0x95);
+	mipi_dsi_dcs_write_seq(dsi, 0x50, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x51, 0xd8);
+	mipi_dsi_dcs_write_seq(dsi, 0x52, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x53, 0xda);
+	mipi_dsi_dcs_write_seq(dsi, 0x54, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0x56, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x58, 0x63);
+	mipi_dsi_dcs_write_seq(dsi, 0x59, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5a, 0x92);
+	mipi_dsi_dcs_write_seq(dsi, 0x5b, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5c, 0xd1);
+	mipi_dsi_dcs_write_seq(dsi, 0x5d, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5e, 0xfa);
+	mipi_dsi_dcs_write_seq(dsi, 0x5f, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x60, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0x61, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x62, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x63, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x64, 0x52);
+	mipi_dsi_dcs_write_seq(dsi, 0x65, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x66, 0x67);
+	mipi_dsi_dcs_write_seq(dsi, 0x67, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x68, 0x7d);
+	mipi_dsi_dcs_write_seq(dsi, 0x69, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x6a, 0x99);
+	mipi_dsi_dcs_write_seq(dsi, 0x6b, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x6c, 0xb1);
+	mipi_dsi_dcs_write_seq(dsi, 0x6d, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x6e, 0xfb);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x70, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x71, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x72, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x73, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x74, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x75, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x76, 0x21);
+	mipi_dsi_dcs_write_seq(dsi, 0x77, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x78, 0x35);
+	mipi_dsi_dcs_write_seq(dsi, 0x79, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x7a, 0x46);
+	mipi_dsi_dcs_write_seq(dsi, 0x7b, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x7c, 0x56);
+	mipi_dsi_dcs_write_seq(dsi, 0x7d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x7e, 0x64);
+	mipi_dsi_dcs_write_seq(dsi, 0x7f, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x80, 0x72);
+	mipi_dsi_dcs_write_seq(dsi, 0x81, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x82, 0x7f);
+	mipi_dsi_dcs_write_seq(dsi, 0x83, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x84, 0xac);
+	mipi_dsi_dcs_write_seq(dsi, 0x85, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x86, 0xd2);
+	mipi_dsi_dcs_write_seq(dsi, 0x87, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x88, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x89, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x8a, 0x43);
+	mipi_dsi_dcs_write_seq(dsi, 0x8b, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x8c, 0x95);
+	mipi_dsi_dcs_write_seq(dsi, 0x8d, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x8e, 0xd8);
+	mipi_dsi_dcs_write_seq(dsi, 0x8f, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x90, 0xda);
+	mipi_dsi_dcs_write_seq(dsi, 0x91, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x92, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0x93, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x94, 0x63);
+	mipi_dsi_dcs_write_seq(dsi, 0x95, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x96, 0x92);
+	mipi_dsi_dcs_write_seq(dsi, 0x97, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x98, 0xd1);
+	mipi_dsi_dcs_write_seq(dsi, 0x99, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x9a, 0xfa);
+	mipi_dsi_dcs_write_seq(dsi, 0x9b, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x9c, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0x9d, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x9e, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x9f, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa0, 0x52);
+	mipi_dsi_dcs_write_seq(dsi, 0xa2, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa3, 0x67);
+	mipi_dsi_dcs_write_seq(dsi, 0xa4, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa5, 0x7d);
+	mipi_dsi_dcs_write_seq(dsi, 0xa6, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xa7, 0x99);
+	mipi_dsi_dcs_write_seq(dsi, 0xa9, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xaa, 0xb1);
+	mipi_dsi_dcs_write_seq(dsi, 0xab, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xac, 0xfb);
+	mipi_dsi_dcs_write_seq(dsi, 0xad, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xae, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xaf, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4, 0x21);
+	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb6, 0x35);
+	mipi_dsi_dcs_write_seq(dsi, 0xb7, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0x46);
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xba, 0x56);
+	mipi_dsi_dcs_write_seq(dsi, 0xbb, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xbc, 0x64);
+	mipi_dsi_dcs_write_seq(dsi, 0xbd, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xbe, 0x72);
+	mipi_dsi_dcs_write_seq(dsi, 0xbf, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x7f);
+	mipi_dsi_dcs_write_seq(dsi, 0xc1, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc2, 0xac);
+	mipi_dsi_dcs_write_seq(dsi, 0xc3, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc4, 0xd2);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc6, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xc7, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc8, 0x43);
+	mipi_dsi_dcs_write_seq(dsi, 0xc9, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xca, 0x95);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0xd8);
+	mipi_dsi_dcs_write_seq(dsi, 0xcd, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xce, 0xda);
+	mipi_dsi_dcs_write_seq(dsi, 0xcf, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd0, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0xd1, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0x63);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd4, 0x92);
+	mipi_dsi_dcs_write_seq(dsi, 0xd5, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd6, 0xd1);
+	mipi_dsi_dcs_write_seq(dsi, 0xd7, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd8, 0xfa);
+	mipi_dsi_dcs_write_seq(dsi, 0xd9, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xda, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xdb, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xdc, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0xdd, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xde, 0x52);
+	mipi_dsi_dcs_write_seq(dsi, 0xdf, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe0, 0x67);
+	mipi_dsi_dcs_write_seq(dsi, 0xe1, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe2, 0x7d);
+	mipi_dsi_dcs_write_seq(dsi, 0xe3, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe4, 0x99);
+	mipi_dsi_dcs_write_seq(dsi, 0xe5, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe6, 0xb1);
+	mipi_dsi_dcs_write_seq(dsi, 0xe7, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xe8, 0xfb);
+	mipi_dsi_dcs_write_seq(dsi, 0xe9, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xea, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x24);
+	usleep_range(1000, 2000);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x00, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x02, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x03, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x04, 0x0b);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x06, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x08, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x09, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x0a, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x0b, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x0c, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0d, 0x13);
+	mipi_dsi_dcs_write_seq(dsi, 0x0e, 0x15);
+	mipi_dsi_dcs_write_seq(dsi, 0x0f, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x13, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x14, 0x0b);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x17, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x18, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x19, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x1a, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x1b, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x1c, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x1d, 0x13);
+	mipi_dsi_dcs_write_seq(dsi, 0x1e, 0x15);
+	mipi_dsi_dcs_write_seq(dsi, 0x1f, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0x20, 0x09);
+	mipi_dsi_dcs_write_seq(dsi, 0x21, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x23, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x24, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x25, 0x6d);
+	mipi_dsi_dcs_write_seq(dsi, 0x26, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x27, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x29, 0x58);
+	mipi_dsi_dcs_write_seq(dsi, 0x2a, 0x16);
+	mipi_dsi_dcs_write_seq(dsi, 0x2f, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x30, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x31, 0x49);
+	mipi_dsi_dcs_write_seq(dsi, 0x32, 0x23);
+	mipi_dsi_dcs_write_seq(dsi, 0x33, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x34, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0x6e);
+	mipi_dsi_dcs_write_seq(dsi, 0x36, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x37, 0x2d);
+	mipi_dsi_dcs_write_seq(dsi, 0x38, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x39, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x3a, 0x6e);
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x59, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5a, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x5b, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x5f, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, 0x63, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x67, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x5c, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x60, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, 0x64, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x68, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x6e, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x72, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x73, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x74, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0x75, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0x76, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x77, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x78, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x79, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x7a, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x7b, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0x7c, 0xd8);
+	mipi_dsi_dcs_write_seq(dsi, 0x7d, 0x60);
+	mipi_dsi_dcs_write_seq(dsi, 0x7e, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0x7f, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0x80, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x81, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x82, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x83, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x84, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x85, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0x86, 0x1b);
+	mipi_dsi_dcs_write_seq(dsi, 0x87, 0x39);
+	mipi_dsi_dcs_write_seq(dsi, 0x88, 0x1b);
+	mipi_dsi_dcs_write_seq(dsi, 0x89, 0x39);
+	mipi_dsi_dcs_write_seq(dsi, 0x8a, 0x33);
+	mipi_dsi_dcs_write_seq(dsi, 0x8b, 0xf4);
+	mipi_dsi_dcs_write_seq(dsi, 0x8c, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x8e, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x90, 0x95);
+	mipi_dsi_dcs_write_seq(dsi, 0x91, 0xc8);
+	mipi_dsi_dcs_write_seq(dsi, 0x92, 0x95);
+	mipi_dsi_dcs_write_seq(dsi, 0x93, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x94, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x95, 0x2b);
+	mipi_dsi_dcs_write_seq(dsi, 0x96, 0x95);
+	mipi_dsi_dcs_write_seq(dsi, 0x98, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x99, 0x33);
+	mipi_dsi_dcs_write_seq(dsi, 0x9a, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x9b, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x9c, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x9d, 0xb0);
+	mipi_dsi_dcs_write_seq(dsi, 0xa0, 0x33);
+	mipi_dsi_dcs_write_seq(dsi, 0xa6, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xde, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xc2, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0xc3, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xc4, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xc6, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xd1, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x10);
+	usleep_range(1000, 2000);
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0x03, 0x08, 0x02, 0x04, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0xbb, 0x03); /* 0x10 -> 0x03 for video mode */
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x51, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x53, 0x2c);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x5e, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x44, 0x05, 0x00);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int truly_nt35695_off(struct truly_nt35695 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	mipi_dsi_dcs_write_seq(dsi, 0x4f, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x6e, 0x10);
+
+	return 0;
+}
+
+static int truly_nt35695_prepare(struct drm_panel *panel)
+{
+	struct truly_nt35695 *ctx = to_truly_nt35695(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	truly_nt35695_reset(ctx);
+
+	ret = truly_nt35695_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int truly_nt35695_unprepare(struct drm_panel *panel)
+{
+	struct truly_nt35695 *ctx = to_truly_nt35695(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = truly_nt35695_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode truly_nt35695_mode = {
+	.clock = (1080 + 120 + 20 + 90) * (1920 + 20 + 1 + 8) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 120,
+	.hsync_end = 1080 + 120 + 20,
+	.htotal = 1080 + 120 + 20 + 90,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 20,
+	.vsync_end = 1920 + 20 + 1,
+	.vtotal = 1920 + 20 + 1 + 8,
+	.width_mm = 62,
+	.height_mm = 110,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int truly_nt35695_get_modes(struct drm_panel *panel,
+				   struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &truly_nt35695_mode);
+}
+
+static const struct drm_panel_funcs truly_nt35695_panel_funcs = {
+	.prepare = truly_nt35695_prepare,
+	.unprepare = truly_nt35695_unprepare,
+	.get_modes = truly_nt35695_get_modes,
+};
+
+static int truly_nt35695_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct truly_nt35695 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			  MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &truly_nt35695_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void truly_nt35695_remove(struct mipi_dsi_device *dsi)
+{
+	struct truly_nt35695 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id truly_nt35695_of_match[] = {
+	{ .compatible = "longcheer,truly-nt35695" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, truly_nt35695_of_match);
+
+static struct mipi_dsi_driver truly_nt35695_driver = {
+	.probe = truly_nt35695_probe,
+	.remove = truly_nt35695_remove,
+	.driver = {
+		.name = "panel-longcheer-truly-nt35695",
+		.of_match_table = truly_nt35695_of_match,
+	},
+};
+module_mipi_dsi_driver(truly_nt35695_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for TRULY NT35695 1080P command mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-truly-otm1288a.c b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-truly-otm1288a.c
new file mode 100644
index 000000000000..9957d84e4e6b
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-truly-otm1288a.c
@@ -0,0 +1,412 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct truly_otm1288a {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct truly_otm1288a *to_truly_otm1288a(struct drm_panel *panel)
+{
+	return container_of(panel, struct truly_otm1288a, panel);
+}
+
+static void truly_otm1288a_reset(struct truly_otm1288a *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int truly_otm1288a_on(struct truly_otm1288a *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x12, 0x88, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x12, 0x88);
+	/* keep the TE signal for ESD (unneeded for video mode I guess?)
+	 * mipi_dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	 * mipi_dsi_generic_write_seq(dsi, 0xf6, 0x02); */
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xc0,
+				   0x00, 0x64, 0x00, 0x10, 0x10, 0x00, 0x64,
+				   0x10, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xc0,
+				   0x00, 0x00, 0x00, 0x14, 0x00, 0x1b);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x1c, 0x32); /* 0x00 -> 0x32 for video mode */
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc0);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x4d);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa3);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x25);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb3);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x43);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa2);
+	mipi_dsi_generic_write_seq(dsi, 0xc1, 0x41);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb6);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x18);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x92);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x30, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x53);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x93);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x66);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	mipi_dsi_generic_write_seq(dsi, 0xc4,
+				   0x05, 0x10, 0x06, 0x02, 0x05, 0x15, 0x10,
+				   0x05, 0x10, 0x07, 0x02, 0x05, 0x15, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb0);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x00, 0x00, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x91);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x3d, 0xa6);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc2);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0xb1);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xe1);
+	mipi_dsi_generic_write_seq(dsi, 0xf5, 0x55);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc2);
+	mipi_dsi_generic_write_seq(dsi, 0xf5, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc4);
+	mipi_dsi_generic_write_seq(dsi, 0xf5, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc6);
+	mipi_dsi_generic_write_seq(dsi, 0xf5, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xf3);
+	mipi_dsi_generic_write_seq(dsi, 0xcf, 0x34);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x83);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x30);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd0, 0x40);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd1, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb0);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc0);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+				   0x05, 0x05, 0x00, 0x05, 0x00, 0x00, 0x00,
+				   0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xd0);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00,
+				   0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
+				   0x05);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xe0);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x05, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xf0);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+				   0xff, 0xff, 0xff, 0xff);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xcc,
+				   0x29, 0x2a, 0x0a, 0x0c, 0x0e, 0x10, 0x12,
+				   0x14, 0x06, 0x00, 0x08, 0x00, 0x00, 0x00,
+				   0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xcc,
+				   0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
+				   0x29, 0x2a, 0x09, 0x0b, 0x0d, 0x0f, 0x11,
+				   0x13);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	mipi_dsi_generic_write_seq(dsi, 0xcc,
+				   0x05, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb0);
+	mipi_dsi_generic_write_seq(dsi, 0xcc,
+				   0x29, 0x2a, 0x13, 0x11, 0x0f, 0x0d, 0x0b,
+				   0x09, 0x01, 0x00, 0x07, 0x00, 0x00, 0x00,
+				   0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc0);
+	mipi_dsi_generic_write_seq(dsi, 0xcc,
+				   0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00,
+				   0x29, 0x2a, 0x14, 0x12, 0x10, 0x0e, 0x0c,
+				   0x0a);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xd0);
+	mipi_dsi_generic_write_seq(dsi, 0xcc,
+				   0x02, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xce,
+				   0x87, 0x05, 0x10, 0x86, 0x05, 0x10, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xce,
+				   0x54, 0xff, 0x10, 0x55, 0x00, 0x10, 0x55,
+				   0x03, 0x10, 0x55, 0x04, 0x10, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	mipi_dsi_generic_write_seq(dsi, 0xce,
+				   0x58, 0x05, 0x04, 0xff, 0x00, 0x10, 0x00,
+				   0x58, 0x04, 0x05, 0x00, 0x00, 0x10, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb0);
+	mipi_dsi_generic_write_seq(dsi, 0xce,
+				   0x58, 0x03, 0x05, 0x01, 0x00, 0x10, 0x00,
+				   0x58, 0x02, 0x05, 0x02, 0x00, 0x10, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc0);
+	mipi_dsi_generic_write_seq(dsi, 0xce,
+				   0x58, 0x01, 0x05, 0x03, 0x00, 0x10, 0x00,
+				   0x58, 0x00, 0x05, 0x04, 0x00, 0x10, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xd0);
+	mipi_dsi_generic_write_seq(dsi, 0xce,
+				   0x50, 0x00, 0x05, 0x05, 0x00, 0x10, 0x00,
+				   0x50, 0x01, 0x05, 0x06, 0x00, 0x10, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xcf,
+				   0x50, 0x02, 0x05, 0x07, 0x00, 0x10, 0x00,
+				   0x50, 0x03, 0x05, 0x08, 0x00, 0x10, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xcf,
+				   0x50, 0x04, 0x05, 0x09, 0x00, 0x10, 0x00,
+				   0x50, 0x05, 0x05, 0x0a, 0x00, 0x10, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc0);
+	mipi_dsi_generic_write_seq(dsi, 0xcf,
+				   0x3d, 0x20, 0x00, 0x00, 0x01, 0x00, 0x20,
+				   0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xf3,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x92);
+	mipi_dsi_generic_write_seq(dsi, 0xf5, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc8);
+	mipi_dsi_generic_write_seq(dsi, 0xf5, 0x0b, 0x15);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd8, 0xb6, 0xb6);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xe1,
+				   0x02, 0x27, 0x35, 0x45, 0x54, 0x62, 0x64,
+				   0x8c, 0x7b, 0x93, 0x72, 0x5d, 0x6e, 0x48,
+				   0x45, 0x3a, 0x2d, 0x27, 0x21, 0x1f);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xe2,
+				   0x02, 0x27, 0x35, 0x45, 0x54, 0x62, 0x64,
+				   0x8c, 0x7b, 0x93, 0x72, 0x5d, 0x6e, 0x48,
+				   0x45, 0x3a, 0x2d, 0x27, 0x21, 0x1f);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0xff, 0xff, 0xff);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int truly_otm1288a_off(struct truly_otm1288a *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int truly_otm1288a_prepare(struct drm_panel *panel)
+{
+	struct truly_otm1288a *ctx = to_truly_otm1288a(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	truly_otm1288a_reset(ctx);
+
+	ret = truly_otm1288a_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int truly_otm1288a_unprepare(struct drm_panel *panel)
+{
+	struct truly_otm1288a *ctx = to_truly_otm1288a(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = truly_otm1288a_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode truly_otm1288a_mode = {
+	.clock = (720 + 40 + 12 + 30) * (1280 + 40 + 2 + 11) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 40,
+	.hsync_end = 720 + 40 + 12,
+	.htotal = 720 + 40 + 12 + 30,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 40,
+	.vsync_end = 1280 + 40 + 2,
+	.vtotal = 1280 + 40 + 2 + 11,
+	.width_mm = 62,
+	.height_mm = 111,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int truly_otm1288a_get_modes(struct drm_panel *panel,
+				    struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &truly_otm1288a_mode);
+}
+
+static const struct drm_panel_funcs truly_otm1288a_panel_funcs = {
+	.prepare = truly_otm1288a_prepare,
+	.unprepare = truly_otm1288a_unprepare,
+	.get_modes = truly_otm1288a_get_modes,
+};
+
+static int truly_otm1288a_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct truly_otm1288a *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &truly_otm1288a_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void truly_otm1288a_remove(struct mipi_dsi_device *dsi)
+{
+	struct truly_otm1288a *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id truly_otm1288a_of_match[] = {
+	{ .compatible = "longcheer,truly-otm1288a" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, truly_otm1288a_of_match);
+
+static struct mipi_dsi_driver truly_otm1288a_driver = {
+	.probe = truly_otm1288a_probe,
+	.remove = truly_otm1288a_remove,
+	.driver = {
+		.name = "panel-longcheer-truly-otm1288a",
+		.of_match_table = truly_otm1288a_of_match,
+	},
+};
+module_mipi_dsi_driver(truly_otm1288a_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for truly OTM1288A command mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-yushun-nt35520.c b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-yushun-nt35520.c
new file mode 100644
index 000000000000..fc7df9547a21
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-yushun-nt35520.c
@@ -0,0 +1,458 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+/* From panel-novatek-nt35510.c */
+#define NT35520_DOPCTR_0_DSIM BIT(4) /* Enable video mode on DSI */
+
+struct yushun_nt35520 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct yushun_nt35520 *to_yushun_nt35520(struct drm_panel *panel)
+{
+	return container_of(panel, struct yushun_nt35520, panel);
+}
+
+static void yushun_nt35520_reset(struct yushun_nt35520 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int yushun_nt35520_on(struct yushun_nt35520 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0xaa, 0x55, 0xa5, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0x6f, 0x13);
+	mipi_dsi_generic_write_seq(dsi, 0xf7, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x6f, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xf3, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb1, 0x68 | NT35520_DOPCTR_0_DSIM, 0x21);
+	mipi_dsi_generic_write_seq(dsi, 0xbd, 0x02, 0x67, 0x20, 0x20, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x6f, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0xb8, 0x08);
+	mipi_dsi_generic_write_seq(dsi, 0xbb, 0x11, 0x11);
+	mipi_dsi_generic_write_seq(dsi, 0xbc, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb6, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xc8, 0x83);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x0f, 0x0f);
+	mipi_dsi_generic_write_seq(dsi, 0xb1, 0x0f, 0x0f);
+	mipi_dsi_generic_write_seq(dsi, 0xce, 0x66);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x0c);
+	mipi_dsi_generic_write_seq(dsi, 0xb5, 0x05, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0xbe, 0x3e);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x28, 0x28);
+	mipi_dsi_generic_write_seq(dsi, 0xb4, 0x19, 0x19);
+	mipi_dsi_generic_write_seq(dsi, 0xb9, 0x34, 0x34);
+	mipi_dsi_generic_write_seq(dsi, 0xba, 0x24, 0x24);
+	mipi_dsi_generic_write_seq(dsi, 0xbc, 0x70, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xbd, 0x70, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xca, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0xee, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb0,
+				   0x00, 0xd2, 0x00, 0xde, 0x00, 0xf0, 0x01,
+				   0x01, 0x01, 0x11, 0x01, 0x29, 0x01, 0x41,
+				   0x01, 0x68);
+	mipi_dsi_generic_write_seq(dsi, 0xb1,
+				   0x01, 0x87, 0x01, 0xb8, 0x01, 0xe2, 0x02,
+				   0x23, 0x02, 0x57, 0x02, 0x5a, 0x02, 0x8e,
+				   0x02, 0xc6);
+	mipi_dsi_generic_write_seq(dsi, 0xb2,
+				   0x02, 0xef, 0x03, 0x20, 0x03, 0x3e, 0x03,
+				   0x63, 0x03, 0x7e, 0x03, 0x9c, 0x03, 0xaf,
+				   0x03, 0xbf);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x03, 0xfc, 0x03, 0xff);
+	mipi_dsi_generic_write_seq(dsi, 0xb4,
+				   0x00, 0x07, 0x00, 0x50, 0x00, 0x84, 0x00,
+				   0xa6, 0x00, 0xc1, 0x00, 0xe7, 0x01, 0x08,
+				   0x01, 0x3b);
+	mipi_dsi_generic_write_seq(dsi, 0xb5,
+				   0x01, 0x63, 0x01, 0xa0, 0x01, 0xcf, 0x02,
+				   0x18, 0x02, 0x50, 0x02, 0x52, 0x02, 0x88,
+				   0x02, 0xc1);
+	mipi_dsi_generic_write_seq(dsi, 0xb6,
+				   0x02, 0xea, 0x03, 0x1b, 0x03, 0x3a, 0x03,
+				   0x60, 0x03, 0x79, 0x03, 0x98, 0x03, 0xa9,
+				   0x03, 0xc6);
+	mipi_dsi_generic_write_seq(dsi, 0xb7, 0x03, 0xd6, 0x03, 0xff);
+	mipi_dsi_generic_write_seq(dsi, 0xb8,
+				   0x00, 0xb6, 0x00, 0xc1, 0x00, 0xd3, 0x00,
+				   0xe5, 0x00, 0xf5, 0x01, 0x0f, 0x01, 0x29,
+				   0x01, 0x51);
+	mipi_dsi_generic_write_seq(dsi, 0xb9,
+				   0x01, 0x73, 0x01, 0xa9, 0x01, 0xd6, 0x02,
+				   0x1c, 0x02, 0x52, 0x02, 0x55, 0x02, 0x8a,
+				   0x02, 0xc4);
+	mipi_dsi_generic_write_seq(dsi, 0xba,
+				   0x02, 0xef, 0x03, 0x24, 0x03, 0x4b, 0x03,
+				   0x73, 0x03, 0x87, 0x03, 0x9f, 0x03, 0xa3,
+				   0x03, 0xbd);
+	mipi_dsi_generic_write_seq(dsi, 0xbb, 0x03, 0xf2, 0x03, 0xff);
+	mipi_dsi_generic_write_seq(dsi, 0xbc,
+				   0x00, 0xd2, 0x00, 0xde, 0x00, 0xf0, 0x01,
+				   0x01, 0x01, 0x11, 0x01, 0x29, 0x01, 0x41,
+				   0x01, 0x68);
+	mipi_dsi_generic_write_seq(dsi, 0xbd,
+				   0x01, 0x87, 0x01, 0xb8, 0x01, 0xe2, 0x02,
+				   0x23, 0x02, 0x57, 0x02, 0x5a, 0x02, 0x8e,
+				   0x02, 0xc6);
+	mipi_dsi_generic_write_seq(dsi, 0xbe,
+				   0x02, 0xef, 0x03, 0x20, 0x03, 0x3e, 0x03,
+				   0x63, 0x03, 0x7e, 0x03, 0x9c, 0x03, 0xaf,
+				   0x03, 0xbf);
+	mipi_dsi_generic_write_seq(dsi, 0xbf, 0x03, 0xfc, 0x03, 0xff);
+	mipi_dsi_generic_write_seq(dsi, 0xc0,
+				   0x00, 0x07, 0x00, 0x50, 0x00, 0x84, 0x00,
+				   0xa6, 0x00, 0xc1, 0x00, 0xe7, 0x01, 0x08,
+				   0x01, 0x3b);
+	mipi_dsi_generic_write_seq(dsi, 0xc1,
+				   0x01, 0x63, 0x01, 0xa0, 0x01, 0xcf, 0x02,
+				   0x18, 0x02, 0x50, 0x02, 0x52, 0x02, 0x88,
+				   0x02, 0xc1);
+	mipi_dsi_generic_write_seq(dsi, 0xc2,
+				   0x02, 0xea, 0x03, 0x1b, 0x03, 0x3a, 0x03,
+				   0x60, 0x03, 0x79, 0x03, 0x98, 0x03, 0xa9,
+				   0x03, 0xc6);
+	mipi_dsi_generic_write_seq(dsi, 0xc3, 0x03, 0xd6, 0x03, 0xff);
+	mipi_dsi_generic_write_seq(dsi, 0xc4,
+				   0x00, 0xb6, 0x00, 0xc1, 0x00, 0xd3, 0x00,
+				   0xe5, 0x00, 0xf5, 0x01, 0x0f, 0x01, 0x29,
+				   0x01, 0x51);
+	mipi_dsi_generic_write_seq(dsi, 0xc5,
+				   0x01, 0x73, 0x01, 0xa9, 0x01, 0xd6, 0x02,
+				   0x1c, 0x02, 0x52, 0x02, 0x55, 0x02, 0x8a,
+				   0x02, 0xc4);
+	mipi_dsi_generic_write_seq(dsi, 0xc6,
+				   0x02, 0xef, 0x03, 0x24, 0x03, 0x4b, 0x03,
+				   0x73, 0x03, 0x87, 0x03, 0x9f, 0x03, 0xa3,
+				   0x03, 0xbd);
+	mipi_dsi_generic_write_seq(dsi, 0xc7, 0x03, 0xf2, 0x03, 0xff);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xb1, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xb2, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x2e, 0x09);
+	mipi_dsi_generic_write_seq(dsi, 0xb4, 0x0b, 0x23);
+	mipi_dsi_generic_write_seq(dsi, 0xb5, 0x1d, 0x1f);
+	mipi_dsi_generic_write_seq(dsi, 0xb6, 0x11, 0x17);
+	mipi_dsi_generic_write_seq(dsi, 0xb7, 0x13, 0x19);
+	mipi_dsi_generic_write_seq(dsi, 0xb8, 0x01, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xb9, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xba, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xbb, 0x02, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xbc, 0x18, 0x12);
+	mipi_dsi_generic_write_seq(dsi, 0xbd, 0x16, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0xbe, 0x1e, 0x1c);
+	mipi_dsi_generic_write_seq(dsi, 0xbf, 0x22, 0x0a);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x08, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xc1, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xc2, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xc3, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xe5, 0x25, 0x24);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xc6, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xc7, 0x2e, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0xc8, 0x00, 0x24);
+	mipi_dsi_generic_write_seq(dsi, 0xc9, 0x1e, 0x1c);
+	mipi_dsi_generic_write_seq(dsi, 0xca, 0x18, 0x12);
+	mipi_dsi_generic_write_seq(dsi, 0xcb, 0x16, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0xcc, 0x0a, 0x08);
+	mipi_dsi_generic_write_seq(dsi, 0xcd, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xce, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xcf, 0x09, 0x0b);
+	mipi_dsi_generic_write_seq(dsi, 0xd0, 0x11, 0x17);
+	mipi_dsi_generic_write_seq(dsi, 0xd1, 0x13, 0x19);
+	mipi_dsi_generic_write_seq(dsi, 0xd2, 0x1d, 0x1f);
+	mipi_dsi_generic_write_seq(dsi, 0xd3, 0x25, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xd4, 0x03, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xd5, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xd6, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xd7, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xe6, 0x22, 0x23);
+	mipi_dsi_generic_write_seq(dsi, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xe7, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0xed, 0x30);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x20, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb1, 0x20, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb8, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xbd, 0x0f, 0x03, 0x03, 0x00, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xb1, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb9, 0x00, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xb2, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xba, 0x00, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xbb, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb4, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb5, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb6, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb7, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xbc, 0x00, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xe5, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xe6, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xe7, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xe8, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xe9, 0x0a);
+	mipi_dsi_generic_write_seq(dsi, 0xea, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xeb, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xec, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x07);
+	mipi_dsi_generic_write_seq(dsi, 0xc1, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xb2, 0x04, 0x00, 0x52, 0x01, 0xce);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x04, 0x00, 0x52, 0x01, 0xce);
+	msleep(120);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x82);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xb6, 0x04, 0x00, 0x52, 0x01, 0xce);
+	mipi_dsi_generic_write_seq(dsi, 0xb7, 0x04, 0x00, 0x52, 0x01, 0xce);
+	msleep(120);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0xc8, 0x03, 0x20);
+	mipi_dsi_generic_write_seq(dsi, 0xc9, 0x01, 0x21);
+	mipi_dsi_generic_write_seq(dsi, 0xca, 0x03, 0x20);
+	mipi_dsi_generic_write_seq(dsi, 0xcb, 0x07, 0x20);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x60);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x40);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xba, 0x44, 0x00, 0x4b, 0x01, 0xbe);
+	mipi_dsi_generic_write_seq(dsi, 0xbb, 0x44, 0x00, 0x4b, 0x01, 0xbe);
+	mipi_dsi_generic_write_seq(dsi, 0xbc, 0x53, 0x00, 0x03, 0x00, 0x4b);
+	mipi_dsi_generic_write_seq(dsi, 0xbd, 0x53, 0x00, 0x03, 0x00, 0x4b);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0xd1,
+				   0x03, 0x05, 0x00, 0x05, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd2,
+				   0x03, 0x05, 0x00, 0x03, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd3,
+				   0x03, 0x05, 0x04, 0x05, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd4,
+				   0x03, 0x05, 0x04, 0x03, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x40);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x40);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int yushun_nt35520_off(struct yushun_nt35520 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int yushun_nt35520_prepare(struct drm_panel *panel)
+{
+	struct yushun_nt35520 *ctx = to_yushun_nt35520(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	yushun_nt35520_reset(ctx);
+
+	ret = yushun_nt35520_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int yushun_nt35520_unprepare(struct drm_panel *panel)
+{
+	struct yushun_nt35520 *ctx = to_yushun_nt35520(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = yushun_nt35520_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode yushun_nt35520_mode = {
+	.clock = (720 + 90 + 12 + 88) * (1280 + 20 + 4 + 16) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 90,
+	.hsync_end = 720 + 90 + 12,
+	.htotal = 720 + 90 + 12 + 88,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 20,
+	.vsync_end = 1280 + 20 + 4,
+	.vtotal = 1280 + 20 + 4 + 16,
+	.width_mm = 62,
+	.height_mm = 111,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int yushun_nt35520_get_modes(struct drm_panel *panel,
+				    struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &yushun_nt35520_mode);
+}
+
+static const struct drm_panel_funcs yushun_nt35520_panel_funcs = {
+	.prepare = yushun_nt35520_prepare,
+	.unprepare = yushun_nt35520_unprepare,
+	.get_modes = yushun_nt35520_get_modes,
+};
+
+static int yushun_nt35520_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct yushun_nt35520 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &yushun_nt35520_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void yushun_nt35520_remove(struct mipi_dsi_device *dsi)
+{
+	struct yushun_nt35520 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id yushun_nt35520_of_match[] = {
+	{ .compatible = "longcheer,yushun-nt35520" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, yushun_nt35520_of_match);
+
+static struct mipi_dsi_driver yushun_nt35520_driver = {
+	.probe = yushun_nt35520_probe,
+	.remove = yushun_nt35520_remove,
+	.driver = {
+		.name = "panel-longcheer-yushun-nt35520",
+		.of_match_table = yushun_nt35520_of_match,
+	},
+};
+module_mipi_dsi_driver(yushun_nt35520_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for yushun NT35520 720p command mode panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-yushun-nt35521s.c b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-yushun-nt35521s.c
new file mode 100644
index 000000000000..3fb90f8826f0
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-longcheer-yushun-nt35521s.c
@@ -0,0 +1,374 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct yushun_nt35521s {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline
+struct yushun_nt35521s *to_yushun_nt35521s(struct drm_panel *panel)
+{
+	return container_of(panel, struct yushun_nt35521s, panel);
+}
+
+static void yushun_nt35521s_reset(struct yushun_nt35521s *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int yushun_nt35521s_on(struct yushun_nt35521s *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0xaa, 0x55, 0xa5, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb1, 0x68, 0x21);
+	mipi_dsi_generic_write_seq(dsi, 0xb6, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x6f, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0xb8, 0x08);
+	mipi_dsi_generic_write_seq(dsi, 0xbb, 0x11, 0x11);
+	mipi_dsi_generic_write_seq(dsi, 0xbc, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xbd, 0x01, 0xa3, 0x10, 0x10, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xc8, 0x83);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x28, 0x28);
+	mipi_dsi_generic_write_seq(dsi, 0xb4, 0x19, 0x19);
+	mipi_dsi_generic_write_seq(dsi, 0xb5, 0x04, 0x04);
+	mipi_dsi_generic_write_seq(dsi, 0xb9, 0x35, 0x35);
+	mipi_dsi_generic_write_seq(dsi, 0xba, 0x25, 0x25);
+	mipi_dsi_generic_write_seq(dsi, 0xbc, 0x70, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xbd, 0x70, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xbe, 0x3e);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x0c);
+	mipi_dsi_generic_write_seq(dsi, 0xca, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0xee, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xb0,
+				   0x00, 0x00, 0x00, 0x23, 0x00, 0x54, 0x00,
+				   0x75, 0x00, 0x91, 0x00, 0xbd, 0x00, 0xe1,
+				   0x01, 0x18);
+	mipi_dsi_generic_write_seq(dsi, 0xb1,
+				   0x01, 0x43, 0x01, 0x88, 0x01, 0xbe, 0x02,
+				   0x13, 0x02, 0x57, 0x02, 0x58, 0x02, 0x95,
+				   0x02, 0xd6);
+	mipi_dsi_generic_write_seq(dsi, 0xb2,
+				   0x02, 0xfe, 0x03, 0x32, 0x03, 0x55, 0x03,
+				   0x82, 0x03, 0x9e, 0x03, 0xc1, 0x03, 0xd5,
+				   0x03, 0xeb);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x03, 0xfb, 0x03, 0xff);
+	mipi_dsi_generic_write_seq(dsi, 0xef, 0x0f, 0x0f, 0x10, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xb1, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xb2, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x2e, 0x09);
+	mipi_dsi_generic_write_seq(dsi, 0xb4, 0x0b, 0x23);
+	mipi_dsi_generic_write_seq(dsi, 0xb5, 0x1d, 0x1f);
+	mipi_dsi_generic_write_seq(dsi, 0xb6, 0x11, 0x17);
+	mipi_dsi_generic_write_seq(dsi, 0xb7, 0x13, 0x19);
+	mipi_dsi_generic_write_seq(dsi, 0xb8, 0x01, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xb9, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xba, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xbb, 0x02, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xbc, 0x18, 0x12);
+	mipi_dsi_generic_write_seq(dsi, 0xbd, 0x16, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0xbe, 0x1e, 0x1c);
+	mipi_dsi_generic_write_seq(dsi, 0xbf, 0x22, 0x0a);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x08, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xc1, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xc2, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xc3, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xe5, 0x25, 0x24);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xc6, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xc7, 0x2e, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0xc8, 0x00, 0x24);
+	mipi_dsi_generic_write_seq(dsi, 0xc9, 0x1e, 0x1c);
+	mipi_dsi_generic_write_seq(dsi, 0xca, 0x18, 0x12);
+	mipi_dsi_generic_write_seq(dsi, 0xcb, 0x16, 0x10);
+	mipi_dsi_generic_write_seq(dsi, 0xcc, 0x0a, 0x08);
+	mipi_dsi_generic_write_seq(dsi, 0xcd, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xce, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xcf, 0x09, 0x0b);
+	mipi_dsi_generic_write_seq(dsi, 0xd0, 0x11, 0x17);
+	mipi_dsi_generic_write_seq(dsi, 0xd1, 0x13, 0x19);
+	mipi_dsi_generic_write_seq(dsi, 0xd2, 0x1d, 0x1f);
+	mipi_dsi_generic_write_seq(dsi, 0xd3, 0x25, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xd4, 0x03, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xd5, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xd6, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xd7, 0x2e, 0x2e);
+	mipi_dsi_generic_write_seq(dsi, 0xe6, 0x22, 0x23);
+	mipi_dsi_generic_write_seq(dsi, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xe7, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x20, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb1, 0x20, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb2, 0x04, 0x00, 0x52, 0x01, 0x51);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x04, 0x00, 0x52, 0x01, 0x51);
+	mipi_dsi_generic_write_seq(dsi, 0xb6, 0x04, 0x00, 0x52, 0x01, 0x51);
+	mipi_dsi_generic_write_seq(dsi, 0xb7, 0x04, 0x00, 0x52, 0x01, 0x51);
+	mipi_dsi_generic_write_seq(dsi, 0xba, 0x44, 0x00, 0x60, 0x01, 0x72);
+	mipi_dsi_generic_write_seq(dsi, 0xbb, 0x44, 0x00, 0x60, 0x01, 0x72);
+	mipi_dsi_generic_write_seq(dsi, 0xbc, 0x53, 0x00, 0x03, 0x00, 0x48);
+	mipi_dsi_generic_write_seq(dsi, 0xbd, 0x53, 0x00, 0x03, 0x00, 0x48);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x40);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x40);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb1, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb2, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb4, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb5, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb6, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb7, 0x17, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xb8, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb9, 0x00, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xba, 0x00, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xbb, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xbc, 0x00, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xbd, 0x0f, 0x03, 0x03, 0x00, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xe5, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xe6, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xe7, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xe8, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xe9, 0x0a);
+	mipi_dsi_generic_write_seq(dsi, 0xea, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xeb, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xec, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x07);
+	mipi_dsi_generic_write_seq(dsi, 0xc1, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0xc4, 0x82);
+	mipi_dsi_generic_write_seq(dsi, 0xc5, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xc8, 0x03, 0x20);
+	mipi_dsi_generic_write_seq(dsi, 0xc9, 0x01, 0x21);
+	mipi_dsi_generic_write_seq(dsi, 0xca, 0x03, 0x20);
+	mipi_dsi_generic_write_seq(dsi, 0xcb, 0x07, 0x20);
+	mipi_dsi_generic_write_seq(dsi, 0xd1,
+				   0x03, 0x05, 0x00, 0x05, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd2,
+				   0x03, 0x05, 0x00, 0x03, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd3,
+				   0x03, 0x05, 0x04, 0x05, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd4,
+				   0x03, 0x05, 0x04, 0x03, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xed, 0x30);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int yushun_nt35521s_off(struct yushun_nt35521s *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int yushun_nt35521s_prepare(struct drm_panel *panel)
+{
+	struct yushun_nt35521s *ctx = to_yushun_nt35521s(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	yushun_nt35521s_reset(ctx);
+
+	ret = yushun_nt35521s_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int yushun_nt35521s_unprepare(struct drm_panel *panel)
+{
+	struct yushun_nt35521s *ctx = to_yushun_nt35521s(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = yushun_nt35521s_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode yushun_nt35521s_mode = {
+	.clock = (720 + 90 + 10 + 90) * (1280 + 20 + 4 + 16) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 90,
+	.hsync_end = 720 + 90 + 10,
+	.htotal = 720 + 90 + 10 + 90,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 20,
+	.vsync_end = 1280 + 20 + 4,
+	.vtotal = 1280 + 20 + 4 + 16,
+	.width_mm = 62,
+	.height_mm = 111,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int yushun_nt35521s_get_modes(struct drm_panel *panel,
+				     struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &yushun_nt35521s_mode);
+}
+
+static const struct drm_panel_funcs yushun_nt35521s_panel_funcs = {
+	.prepare = yushun_nt35521s_prepare,
+	.unprepare = yushun_nt35521s_unprepare,
+	.get_modes = yushun_nt35521s_get_modes,
+};
+
+static int yushun_nt35521s_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct yushun_nt35521s *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &yushun_nt35521s_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void yushun_nt35521s_remove(struct mipi_dsi_device *dsi)
+{
+	struct yushun_nt35521s *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id yushun_nt35521s_of_match[] = {
+	{ .compatible = "longcheer,yushun-nt35521s" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, yushun_nt35521s_of_match);
+
+static struct mipi_dsi_driver yushun_nt35521s_driver = {
+	.probe = yushun_nt35521s_probe,
+	.remove = yushun_nt35521s_remove,
+	.driver = {
+		.name = "panel-longcheer-yushun-nt35521s",
+		.of_match_table = yushun_nt35521s_of_match,
+	},
+};
+module_mipi_dsi_driver(yushun_nt35521s_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for yushun NT35521S 720p video mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-harpia-boe.c b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-harpia-boe.c
new file mode 100644
index 000000000000..3ee4766028a6
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-harpia-boe.c
@@ -0,0 +1,298 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct boe_499_v1 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *backlight_gpio;
+};
+
+static inline struct boe_499_v1 *to_boe_499_v1(struct drm_panel *panel)
+{
+	return container_of(panel, struct boe_499_v1, panel);
+}
+
+static void boe_499_v1_reset(struct boe_499_v1 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(50);
+}
+
+static int boe_499_v1_on(struct boe_499_v1 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0xff, 0x83, 0x94);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x0000);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+	usleep_range(5000, 6000);
+
+	mipi_dsi_dcs_write_seq(dsi, 0xc9,
+			       0x13, 0x00, 0x00, 0x14, 0xb1, 0x1e, 0x00, 0x91,
+			       0x00);
+	usleep_range(5000, 6000);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x01);
+	usleep_range(5000, 6000);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x2c);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+static int boe_499_v1_off(struct boe_499_v1 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(35);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int boe_499_v1_prepare(struct drm_panel *panel)
+{
+	struct boe_499_v1 *ctx = to_boe_499_v1(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	boe_499_v1_reset(ctx);
+
+	ret = boe_499_v1_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int boe_499_v1_unprepare(struct drm_panel *panel)
+{
+	struct boe_499_v1 *ctx = to_boe_499_v1(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = boe_499_v1_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode boe_499_v1_mode = {
+	.clock = (720 + 52 + 20 + 84) * (1280 + 20 + 8 + 20) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 52,
+	.hsync_end = 720 + 52 + 20,
+	.htotal = 720 + 52 + 20 + 84,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 20,
+	.vsync_end = 1280 + 20 + 8,
+	.vtotal = 1280 + 20 + 8 + 20,
+	.width_mm = 62,
+	.height_mm = 110,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int boe_499_v1_get_modes(struct drm_panel *panel,
+				struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &boe_499_v1_mode);
+}
+
+static const struct drm_panel_funcs boe_499_v1_panel_funcs = {
+	.prepare = boe_499_v1_prepare,
+	.unprepare = boe_499_v1_unprepare,
+	.get_modes = boe_499_v1_get_modes,
+};
+
+static int boe_499_v1_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	struct boe_499_v1 *ctx = mipi_dsi_get_drvdata(dsi);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	gpiod_set_value_cansleep(ctx->backlight_gpio, !!brightness);
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct backlight_ops boe_499_v1_bl_ops = {
+	.update_status = boe_499_v1_bl_update_status,
+};
+
+static struct backlight_device *
+boe_499_v1_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 255,
+		.max_brightness = 255,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &boe_499_v1_bl_ops, &props);
+}
+
+static int boe_499_v1_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct boe_499_v1 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->backlight_gpio = devm_gpiod_get(dev, "backlight", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->backlight_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->backlight_gpio),
+				     "Failed to get backlight-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &boe_499_v1_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ctx->panel.backlight = boe_499_v1_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void boe_499_v1_remove(struct mipi_dsi_device *dsi)
+{
+	struct boe_499_v1 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id boe_499_v1_of_match[] = {
+	{ .compatible = "motorola,harpia-panel-boe" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, boe_499_v1_of_match);
+
+static struct mipi_dsi_driver boe_499_v1_driver = {
+	.probe = boe_499_v1_probe,
+	.remove = boe_499_v1_remove,
+	.driver = {
+		.name = "panel-motorola-harpia-boe",
+		.of_match_table = boe_499_v1_of_match,
+	},
+};
+module_mipi_dsi_driver(boe_499_v1_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for mipi_mot_video_boe_720p_499");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-harpia-tianma.c b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-harpia-tianma.c
new file mode 100644
index 000000000000..6b656e326ff2
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-harpia-tianma.c
@@ -0,0 +1,293 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct tianma_499_v2 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *backlight_gpio;
+};
+
+static inline struct tianma_499_v2 *to_tianma_499_v2(struct drm_panel *panel)
+{
+	return container_of(panel, struct tianma_499_v2, panel);
+}
+
+static void tianma_499_v2_reset(struct tianma_499_v2 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int tianma_499_v2_on(struct tianma_499_v2 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x00);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x0000);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x2c);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x68, 0x06);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	return 0;
+}
+
+static int tianma_499_v2_off(struct tianma_499_v2 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int tianma_499_v2_prepare(struct drm_panel *panel)
+{
+	struct tianma_499_v2 *ctx = to_tianma_499_v2(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	tianma_499_v2_reset(ctx);
+
+	ret = tianma_499_v2_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int tianma_499_v2_unprepare(struct drm_panel *panel)
+{
+	struct tianma_499_v2 *ctx = to_tianma_499_v2(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = tianma_499_v2_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode tianma_499_v2_mode = {
+	.clock = (720 + 52 + 20 + 84) * (1280 + 20 + 8 + 20) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 52,
+	.hsync_end = 720 + 52 + 20,
+	.htotal = 720 + 52 + 20 + 84,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 20,
+	.vsync_end = 1280 + 20 + 8,
+	.vtotal = 1280 + 20 + 8 + 20,
+	.width_mm = 62,
+	.height_mm = 110,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int tianma_499_v2_get_modes(struct drm_panel *panel,
+				   struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &tianma_499_v2_mode);
+}
+
+static const struct drm_panel_funcs tianma_499_v2_panel_funcs = {
+	.prepare = tianma_499_v2_prepare,
+	.unprepare = tianma_499_v2_unprepare,
+	.get_modes = tianma_499_v2_get_modes,
+};
+
+static int tianma_499_v2_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	struct tianma_499_v2 *ctx = mipi_dsi_get_drvdata(dsi);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	gpiod_set_value_cansleep(ctx->backlight_gpio, !!brightness);
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness_large(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct backlight_ops tianma_499_v2_bl_ops = {
+	.update_status = tianma_499_v2_bl_update_status,
+};
+
+static struct backlight_device *
+tianma_499_v2_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 4095,
+		.max_brightness = 4095,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &tianma_499_v2_bl_ops, &props);
+}
+
+static int tianma_499_v2_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct tianma_499_v2 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->backlight_gpio = devm_gpiod_get(dev, "backlight", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->backlight_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->backlight_gpio),
+				     "Failed to get backlight-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &tianma_499_v2_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ctx->panel.backlight = tianma_499_v2_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void tianma_499_v2_remove(struct mipi_dsi_device *dsi)
+{
+	struct tianma_499_v2 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id tianma_499_v2_of_match[] = {
+	{ .compatible = "motorola,harpia-panel-tianma" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, tianma_499_v2_of_match);
+
+static struct mipi_dsi_driver tianma_499_v2_driver = {
+	.probe = tianma_499_v2_probe,
+	.remove = tianma_499_v2_remove,
+	.driver = {
+		.name = "panel-motorola-harpia-tianma",
+		.of_match_table = tianma_499_v2_of_match,
+	},
+};
+module_mipi_dsi_driver(tianma_499_v2_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for mipi_mot_video_tianma_720p_499");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-osprey-inx.c b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-osprey-inx.c
new file mode 100644
index 000000000000..5d1bae0a34b6
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-osprey-inx.c
@@ -0,0 +1,253 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct inx_500_v0 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[3];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct inx_500_v0 *to_inx_500_v0(struct drm_panel *panel)
+{
+	return container_of(panel, struct inx_500_v0, panel);
+}
+
+static void inx_500_v0_reset(struct inx_500_v0 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int inx_500_v0_on(struct inx_500_v0 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xe8,
+				   0xf3, 0xd9, 0xcc, 0xc0, 0xb8, 0xb0, 0xa0,
+				   0xa0, 0xa0, 0x9c);
+	mipi_dsi_generic_write_seq(dsi, 0xd9, 0x03, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xea, 0x09);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x00cf);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x2c);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0x03);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int inx_500_v0_off(struct inx_500_v0 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	usleep_range(17000, 18000);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int inx_500_v0_prepare(struct drm_panel *panel)
+{
+	struct inx_500_v0 *ctx = to_inx_500_v0(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	inx_500_v0_reset(ctx);
+
+	ret = inx_500_v0_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int inx_500_v0_unprepare(struct drm_panel *panel)
+{
+	struct inx_500_v0 *ctx = to_inx_500_v0(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = inx_500_v0_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode inx_500_v0_mode = {
+	.clock = (720 + 48 + 8 + 68) * (1280 + 52 + 6 + 50) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 48,
+	.hsync_end = 720 + 48 + 8,
+	.htotal = 720 + 48 + 8 + 68,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 52,
+	.vsync_end = 1280 + 52 + 6,
+	.vtotal = 1280 + 52 + 6 + 50,
+	.width_mm = 62,
+	.height_mm = 110,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int inx_500_v0_get_modes(struct drm_panel *panel,
+				struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &inx_500_v0_mode);
+}
+
+static const struct drm_panel_funcs inx_500_v0_panel_funcs = {
+	.prepare = inx_500_v0_prepare,
+	.unprepare = inx_500_v0_unprepare,
+	.get_modes = inx_500_v0_get_modes,
+};
+
+static int inx_500_v0_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct inx_500_v0 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ctx->supplies[2].supply = "vddio";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &inx_500_v0_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void inx_500_v0_remove(struct mipi_dsi_device *dsi)
+{
+	struct inx_500_v0 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id inx_500_v0_of_match[] = {
+	{ .compatible = "motorola,osprey-panel-inx" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, inx_500_v0_of_match);
+
+static struct mipi_dsi_driver inx_500_v0_driver = {
+	.probe = inx_500_v0_probe,
+	.remove = inx_500_v0_remove,
+	.driver = {
+		.name = "panel-motorola-osprey-inx",
+		.of_match_table = inx_500_v0_of_match,
+	},
+};
+module_mipi_dsi_driver(inx_500_v0_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for mipi_mot_video_inx_720p_500_v0");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-surnia-boe.c b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-surnia-boe.c
new file mode 100644
index 000000000000..e847cfc90024
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-surnia-boe.c
@@ -0,0 +1,241 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct boe_450_v3 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct boe_450_v3 *to_boe_450_v3(struct drm_panel *panel)
+{
+	return container_of(panel, struct boe_450_v3, panel);
+}
+
+static void boe_450_v3_reset(struct boe_450_v3 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(2000, 3000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(21);
+}
+
+static int boe_450_v3_on(struct boe_450_v3 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x2c);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x02);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x00ff);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(40);
+
+	return 0;
+}
+
+static int boe_450_v3_off(struct boe_450_v3 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int boe_450_v3_prepare(struct drm_panel *panel)
+{
+	struct boe_450_v3 *ctx = to_boe_450_v3(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	boe_450_v3_reset(ctx);
+
+	ret = boe_450_v3_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int boe_450_v3_unprepare(struct drm_panel *panel)
+{
+	struct boe_450_v3 *ctx = to_boe_450_v3(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = boe_450_v3_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode boe_450_v3_mode = {
+	.clock = (540 + 24 + 4 + 40) * (960 + 16 + 2 + 16) * 60 / 1000,
+	.hdisplay = 540,
+	.hsync_start = 540 + 24,
+	.hsync_end = 540 + 24 + 4,
+	.htotal = 540 + 24 + 4 + 40,
+	.vdisplay = 960,
+	.vsync_start = 960 + 16,
+	.vsync_end = 960 + 16 + 2,
+	.vtotal = 960 + 16 + 2 + 16,
+	.width_mm = 55,
+	.height_mm = 99,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int boe_450_v3_get_modes(struct drm_panel *panel,
+				struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &boe_450_v3_mode);
+}
+
+static const struct drm_panel_funcs boe_450_v3_panel_funcs = {
+	.prepare = boe_450_v3_prepare,
+	.unprepare = boe_450_v3_unprepare,
+	.get_modes = boe_450_v3_get_modes,
+};
+
+static int boe_450_v3_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct boe_450_v3 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 2;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS |
+			  MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &boe_450_v3_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void boe_450_v3_remove(struct mipi_dsi_device *dsi)
+{
+	struct boe_450_v3 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id boe_450_v3_of_match[] = {
+	{ .compatible = "motorola,surnia-panel-boe" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, boe_450_v3_of_match);
+
+static struct mipi_dsi_driver boe_450_v3_driver = {
+	.probe = boe_450_v3_probe,
+	.remove = boe_450_v3_remove,
+	.driver = {
+		.name = "panel-motorola-surnia-boe",
+		.of_match_table = boe_450_v3_of_match,
+	},
+};
+module_mipi_dsi_driver(boe_450_v3_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for mipi_mot_video_boe_qhd_450_v3");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-surnia-inx.c b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-surnia-inx.c
new file mode 100644
index 000000000000..d760c712034f
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-motorola-surnia-inx.c
@@ -0,0 +1,241 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct inx_450_v1 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct inx_450_v1 *to_inx_450_v1(struct drm_panel *panel)
+{
+	return container_of(panel, struct inx_450_v1, panel);
+}
+
+static void inx_450_v1_reset(struct inx_450_v1 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(2000, 3000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(21);
+}
+
+static int inx_450_v1_on(struct inx_450_v1 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x2c);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x02);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x00ff);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(40);
+
+	return 0;
+}
+
+static int inx_450_v1_off(struct inx_450_v1 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int inx_450_v1_prepare(struct drm_panel *panel)
+{
+	struct inx_450_v1 *ctx = to_inx_450_v1(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	inx_450_v1_reset(ctx);
+
+	ret = inx_450_v1_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int inx_450_v1_unprepare(struct drm_panel *panel)
+{
+	struct inx_450_v1 *ctx = to_inx_450_v1(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = inx_450_v1_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode inx_450_v1_mode = {
+	.clock = (540 + 24 + 4 + 40) * (960 + 16 + 2 + 19) * 60 / 1000,
+	.hdisplay = 540,
+	.hsync_start = 540 + 24,
+	.hsync_end = 540 + 24 + 4,
+	.htotal = 540 + 24 + 4 + 40,
+	.vdisplay = 960,
+	.vsync_start = 960 + 16,
+	.vsync_end = 960 + 16 + 2,
+	.vtotal = 960 + 16 + 2 + 19,
+	.width_mm = 55,
+	.height_mm = 99,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int inx_450_v1_get_modes(struct drm_panel *panel,
+				struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &inx_450_v1_mode);
+}
+
+static const struct drm_panel_funcs inx_450_v1_panel_funcs = {
+	.prepare = inx_450_v1_prepare,
+	.unprepare = inx_450_v1_unprepare,
+	.get_modes = inx_450_v1_get_modes,
+};
+
+static int inx_450_v1_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct inx_450_v1 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 2;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS |
+			  MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &inx_450_v1_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void inx_450_v1_remove(struct mipi_dsi_device *dsi)
+{
+	struct inx_450_v1 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id inx_450_v1_of_match[] = {
+	{ .compatible = "motorola,surnia-panel-inx" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, inx_450_v1_of_match);
+
+static struct mipi_dsi_driver inx_450_v1_driver = {
+	.probe = inx_450_v1_probe,
+	.remove = inx_450_v1_remove,
+	.driver = {
+		.name = "panel-motorola-surnia-inx",
+		.of_match_table = inx_450_v1_of_match,
+	},
+};
+module_mipi_dsi_driver(inx_450_v1_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for mipi_mot_video_inx_qhd_450_v1");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-ea8061-ams549bu19-id400418.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-ea8061-ams549bu19-id400418.c
new file mode 100644
index 000000000000..89f512cda72e
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-ea8061-ams549bu19-id400418.c
@@ -0,0 +1,276 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct ea8061_id400418 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline
+struct ea8061_id400418 *to_ea8061_id400418(struct drm_panel *panel)
+{
+	return container_of(panel, struct ea8061_id400418, panel);
+}
+
+static void ea8061_id400418_reset(struct ea8061_id400418 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int ea8061_id400418_on(struct ea8061_id400418 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xf7, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xc4,
+			       0x54, 0xb3, 0x54, 0xb3, 0x64, 0x9a, 0x64, 0x9a,
+			       0x00, 0x00, 0x0b, 0xfa, 0x00, 0x0b, 0xfa, 0x00,
+			       0x00, 0x09, 0x09, 0x09, 0x36, 0x68, 0xab, 0x00,
+			       0x00, 0x08, 0x02, 0x05, 0x00, 0x0c, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf7, 0xa5, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x00, 0x30, 0x00, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4, 0x33, 0x07, 0x00);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	mipi_dsi_dcs_write_seq(dsi, 0xf7, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xca,
+			       0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x80, 0x80,
+			       0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+			       0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+			       0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x00, 0x30, 0x00, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xf7, 0xa5, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2,
+			       0x0f, 0xb4, 0xa0, 0x13, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf1, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xd4, 0x38, 0x00, 0x48);
+	mipi_dsi_dcs_write_seq(dsi, 0xf1, 0xa5, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0x19);
+	mipi_dsi_dcs_write_seq(dsi, 0xf1, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xd4, 0x48);
+	mipi_dsi_dcs_write_seq(dsi, 0xf1, 0xa5, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0xf1, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xfc, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xd7, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0xf1, 0xa5, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, 0xfc, 0xa5, 0xa5);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(34);
+
+	return 0;
+}
+
+static int ea8061_id400418_off(struct ea8061_id400418 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(34);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(150);
+
+	return 0;
+}
+
+static int ea8061_id400418_prepare(struct drm_panel *panel)
+{
+	struct ea8061_id400418 *ctx = to_ea8061_id400418(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	ea8061_id400418_reset(ctx);
+
+	ret = ea8061_id400418_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ea8061_id400418_unprepare(struct drm_panel *panel)
+{
+	struct ea8061_id400418 *ctx = to_ea8061_id400418(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = ea8061_id400418_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode ea8061_id400418_mode = {
+	.clock = (720 + 114 + 96 + 114) * (1280 + 13 + 2 + 5) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 114,
+	.hsync_end = 720 + 114 + 96,
+	.htotal = 720 + 114 + 96 + 114,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 13,
+	.vsync_end = 1280 + 13 + 2,
+	.vtotal = 1280 + 13 + 2 + 5,
+	.width_mm = 68,
+	.height_mm = 122,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int ea8061_id400418_get_modes(struct drm_panel *panel,
+				     struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &ea8061_id400418_mode);
+}
+
+static const struct drm_panel_funcs ea8061_id400418_panel_funcs = {
+	.prepare = ea8061_id400418_prepare,
+	.unprepare = ea8061_id400418_unprepare,
+	.get_modes = ea8061_id400418_get_modes,
+};
+
+static int ea8061_id400418_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct ea8061_id400418 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vdd3";
+	ctx->supplies[1].supply = "vci";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_NO_EOT_PACKET;
+
+	drm_panel_init(&ctx->panel, dev, &ea8061_id400418_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void ea8061_id400418_remove(struct mipi_dsi_device *dsi)
+{
+	struct ea8061_id400418 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id ea8061_id400418_of_match[] = {
+	{ .compatible = "samsung,ea8061-ams549bu19-id400418" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ea8061_id400418_of_match);
+
+static struct mipi_dsi_driver ea8061_id400418_driver = {
+	.probe = ea8061_id400418_probe,
+	.remove = ea8061_id400418_remove,
+	.driver = {
+		.name = "panel-samsung-ea8061-ams549bu19-id400418",
+		.of_match_table = ea8061_id400418_of_match,
+	},
+};
+module_mipi_dsi_driver(ea8061_id400418_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for Samsung EA8061_ID400418 HD video mode panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-ea8061v-ams497ee01.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-ea8061v-ams497ee01.c
new file mode 100644
index 000000000000..352f40bf3919
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-ea8061v-ams497ee01.c
@@ -0,0 +1,253 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct ea8061v_ams497ee01 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline
+struct ea8061v_ams497ee01 *to_ea8061v_ams497ee01(struct drm_panel *panel)
+{
+	return container_of(panel, struct ea8061v_ams497ee01, panel);
+}
+
+static void ea8061v_ams497ee01_reset(struct ea8061v_ams497ee01 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int ea8061v_ams497ee01_on(struct ea8061v_ams497ee01 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xf1, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0x19, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xba, 0x57);
+	mipi_dsi_dcs_write_seq(dsi, 0xfc, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x0b);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0x00, 0x85);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb, 0x70);
+	mipi_dsi_dcs_write_seq(dsi, 0xfc, 0xa5, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, 0xca,
+			       0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x80, 0x80,
+			       0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+			       0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+			       0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00,
+			       0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0x00, 0x00, 0x00, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0xb6, 0x5c, 0x8a);
+	mipi_dsi_dcs_write_seq(dsi, 0xf7, 0x01);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	mipi_dsi_dcs_write_seq(dsi, 0xf1, 0xa5, 0xa5);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ea8061v_ams497ee01_off(struct ea8061v_ams497ee01 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(35);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(100);
+
+	return 0;
+}
+
+static int ea8061v_ams497ee01_prepare(struct drm_panel *panel)
+{
+	struct ea8061v_ams497ee01 *ctx = to_ea8061v_ams497ee01(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	ea8061v_ams497ee01_reset(ctx);
+
+	ret = ea8061v_ams497ee01_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ea8061v_ams497ee01_unprepare(struct drm_panel *panel)
+{
+	struct ea8061v_ams497ee01 *ctx = to_ea8061v_ams497ee01(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = ea8061v_ams497ee01_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode ea8061v_ams497ee01_mode = {
+	.clock = (720 + 80 + 96 + 128) * (1280 + 14 + 2 + 8) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 80,
+	.hsync_end = 720 + 80 + 96,
+	.htotal = 720 + 80 + 96 + 128,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 14,
+	.vsync_end = 1280 + 14 + 2,
+	.vtotal = 1280 + 14 + 2 + 8,
+	.width_mm = 62,
+	.height_mm = 110,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int ea8061v_ams497ee01_get_modes(struct drm_panel *panel,
+					struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &ea8061v_ams497ee01_mode);
+}
+
+static const struct drm_panel_funcs ea8061v_ams497ee01_panel_funcs = {
+	.prepare = ea8061v_ams497ee01_prepare,
+	.unprepare = ea8061v_ams497ee01_unprepare,
+	.get_modes = ea8061v_ams497ee01_get_modes,
+};
+
+static int ea8061v_ams497ee01_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct ea8061v_ams497ee01 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vdd3";
+	ctx->supplies[1].supply = "vci";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_NO_EOT_PACKET;
+
+	drm_panel_init(&ctx->panel, dev, &ea8061v_ams497ee01_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void ea8061v_ams497ee01_remove(struct mipi_dsi_device *dsi)
+{
+	struct ea8061v_ams497ee01 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id ea8061v_ams497ee01_of_match[] = {
+	{ .compatible = "samsung,ea8061v-ams497ee01" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ea8061v_ams497ee01_of_match);
+
+static struct mipi_dsi_driver ea8061v_ams497ee01_driver = {
+	.probe = ea8061v_ams497ee01_probe,
+	.remove = ea8061v_ams497ee01_remove,
+	.driver = {
+		.name = "panel-samsung-ea8061v-ams497ee01",
+		.of_match_table = ea8061v_ams497ee01_of_match,
+	},
+};
+module_mipi_dsi_driver(ea8061v_ams497ee01_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for ss_dsi_panel_EA8061V_AMS497EE01_HD");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-hx8389c-gh9607501a.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-hx8389c-gh9607501a.c
new file mode 100644
index 000000000000..1b5389228241
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-hx8389c-gh9607501a.c
@@ -0,0 +1,351 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct hx8389c_gh9607501a {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline
+struct hx8389c_gh9607501a *to_hx8389c_gh9607501a(struct drm_panel *panel)
+{
+	return container_of(panel, struct hx8389c_gh9607501a, panel);
+}
+
+static void hx8389c_gh9607501a_reset(struct hx8389c_gh9607501a *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(2000, 3000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(80);
+}
+
+static int hx8389c_gh9607501a_on(struct hx8389c_gh9607501a *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0xff, 0x83, 0x89);
+	usleep_range(10000, 11000);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1,
+			       0x7f, 0x10, 0x10, 0xd2, 0x32, 0x80, 0x10, 0xf0,
+			       0x56, 0x80, 0x20, 0x20, 0xf8, 0xaa, 0xaa, 0xa1,
+			       0x00, 0x80, 0x30, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2,
+			       0x82, 0x50, 0x05, 0x07, 0xf0, 0x38, 0x11, 0x64,
+			       0x5d, 0x09);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4,
+			       0x66, 0x66, 0x66, 0x70, 0x00, 0x00, 0x18, 0x76,
+			       0x28, 0x76, 0xa8);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0x33);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x30, 0x17, 0x00, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xc7, 0x00, 0x80, 0x00, 0xc0);
+	mipi_dsi_dcs_write_seq(dsi, 0xbf, 0x05, 0x50, 0x00, 0x3e);
+	usleep_range(10000, 11000);
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0xff, 0x83, 0x89);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0x0e);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x32,
+			       0x10, 0x00, 0x00, 0x00, 0x03, 0xc6, 0x03, 0xc6,
+			       0x00, 0x00, 0x00, 0x00, 0x35, 0x33, 0x04, 0x04,
+			       0x37, 0x00, 0x00, 0x00, 0x05, 0x08, 0x00, 0x00,
+			       0x0a, 0x00, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xd5,
+			       0x18, 0x18, 0x18, 0x18, 0x19, 0x19, 0x18, 0x18,
+			       0x20, 0x21, 0x24, 0x25, 0x18, 0x18, 0x18, 0x18,
+			       0x00, 0x01, 0x04, 0x05, 0x02, 0x03, 0x06, 0x07,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xd6,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x19, 0x19,
+			       0x25, 0x24, 0x21, 0x20, 0x18, 0x18, 0x18, 0x18,
+			       0x07, 0x06, 0x03, 0x02, 0x05, 0x04, 0x01, 0x00,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xb7, 0x20, 0x80, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xe0,
+			       0x00, 0x02, 0x06, 0x38, 0x3c, 0x3f, 0x1b, 0x46,
+			       0x06, 0x09, 0x0c, 0x17, 0x10, 0x13, 0x16, 0x13,
+			       0x14, 0x08, 0x13, 0x15, 0x19, 0x00, 0x02, 0x06,
+			       0x37, 0x3c, 0x3f, 0x1a, 0x45, 0x05, 0x09, 0x0b,
+			       0x16, 0x0f, 0x13, 0x15, 0x13, 0x14, 0x07, 0x12,
+			       0x14, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xbd, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc1,
+			       0x00, 0x00, 0x08, 0x10, 0x18, 0x20, 0x28, 0x30,
+			       0x38, 0x40, 0x48, 0x50, 0x58, 0x60, 0x68, 0x70,
+			       0x78, 0x80, 0x88, 0x90, 0x98, 0xa0, 0xa8, 0xb0,
+			       0xb8, 0xc0, 0xc8, 0xd0, 0xd8, 0xe0, 0xe8, 0xf0,
+			       0xf8, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xbd, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc1,
+			       0x00, 0x08, 0x10, 0x18, 0x20, 0x28, 0x30, 0x38,
+			       0x40, 0x48, 0x50, 0x58, 0x60, 0x68, 0x70, 0x78,
+			       0x80, 0x88, 0x90, 0x98, 0xa0, 0xa8, 0xb0, 0xb8,
+			       0xc0, 0xc8, 0xd0, 0xd8, 0xe0, 0xe8, 0xf0, 0xf8,
+			       0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xbd, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xc1,
+			       0x00, 0x08, 0x10, 0x18, 0x20, 0x28, 0x30, 0x38,
+			       0x40, 0x48, 0x50, 0x58, 0x60, 0x68, 0x70, 0x78,
+			       0x80, 0x88, 0x90, 0x98, 0xa0, 0xa8, 0xb0, 0xb8,
+			       0xc0, 0xc8, 0xd0, 0xd8, 0xe0, 0xe8, 0xf0, 0xf8,
+			       0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc9,
+			       0x1f, 0x00, 0x0f, 0x1e, 0x81, 0x1e, 0x00, 0x00,
+			       0x01, 0x19, 0x00, 0x00, 0x20);
+	usleep_range(5000, 6000);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x00);
+	usleep_range(5000, 6000);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+	usleep_range(5000, 6000);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(125);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(5000, 6000);
+
+	return 0;
+}
+
+static int hx8389c_gh9607501a_off(struct hx8389c_gh9607501a *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0x28, 0x00);
+	msleep(60);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x00);
+	msleep(60);
+
+	return 0;
+}
+
+static int hx8389c_gh9607501a_prepare(struct drm_panel *panel)
+{
+	struct hx8389c_gh9607501a *ctx = to_hx8389c_gh9607501a(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	hx8389c_gh9607501a_reset(ctx);
+
+	ret = hx8389c_gh9607501a_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hx8389c_gh9607501a_unprepare(struct drm_panel *panel)
+{
+	struct hx8389c_gh9607501a *ctx = to_hx8389c_gh9607501a(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = hx8389c_gh9607501a_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode hx8389c_gh9607501a_mode = {
+	.clock = (540 + 10 + 14 + 10) * (960 + 9 + 2 + 5) * 60 / 1000,
+	.hdisplay = 540,
+	.hsync_start = 540 + 10,
+	.hsync_end = 540 + 10 + 14,
+	.htotal = 540 + 10 + 14 + 10,
+	.vdisplay = 960,
+	.vsync_start = 960 + 9,
+	.vsync_end = 960 + 9 + 2,
+	.vtotal = 960 + 9 + 2 + 5,
+	.width_mm = 62,
+	.height_mm = 110,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int hx8389c_gh9607501a_get_modes(struct drm_panel *panel,
+					struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &hx8389c_gh9607501a_mode);
+}
+
+static const struct drm_panel_funcs hx8389c_gh9607501a_panel_funcs = {
+	.prepare = hx8389c_gh9607501a_prepare,
+	.unprepare = hx8389c_gh9607501a_unprepare,
+	.get_modes = hx8389c_gh9607501a_get_modes,
+};
+
+static int hx8389c_gh9607501a_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct backlight_ops hx8389c_gh9607501a_bl_ops = {
+	.update_status = hx8389c_gh9607501a_bl_update_status,
+};
+
+static struct backlight_device *
+hx8389c_gh9607501a_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 255,
+		.max_brightness = 255,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &hx8389c_gh9607501a_bl_ops, &props);
+}
+
+static int hx8389c_gh9607501a_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct hx8389c_gh9607501a *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vddio";
+	ctx->supplies[1].supply = "vdd";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 2;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			  MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &hx8389c_gh9607501a_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	/* Fallback to DCS backlight if no backlight is defined in DT */
+	if (!ctx->panel.backlight) {
+		ctx->panel.backlight = hx8389c_gh9607501a_create_backlight(dsi);
+		if (IS_ERR(ctx->panel.backlight))
+			return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+					     "Failed to create backlight\n");
+	}
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void hx8389c_gh9607501a_remove(struct mipi_dsi_device *dsi)
+{
+	struct hx8389c_gh9607501a *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id hx8389c_gh9607501a_of_match[] = {
+	{ .compatible = "samsung,hx8389c-gh9607501a" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, hx8389c_gh9607501a_of_match);
+
+static struct mipi_dsi_driver hx8389c_gh9607501a_driver = {
+	.probe = hx8389c_gh9607501a_probe,
+	.remove = hx8389c_gh9607501a_remove,
+	.driver = {
+		.name = "panel-samsung-hx8389c-gh9607501a",
+		.of_match_table = hx8389c_gh9607501a_of_match,
+	},
+};
+module_mipi_dsi_driver(hx8389c_gh9607501a_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for HX8389C qhd video mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-nt51017-b4p096wx5vp09.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-nt51017-b4p096wx5vp09.c
new file mode 100644
index 000000000000..e0ce0ee86d3f
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-nt51017-b4p096wx5vp09.c
@@ -0,0 +1,192 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct nt51017 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+};
+
+static inline struct nt51017 *to_nt51017(struct drm_panel *panel)
+{
+	return container_of(panel, struct nt51017, panel);
+}
+
+static int nt51017_on(struct nt51017 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+
+	mipi_dsi_dcs_write_seq(dsi, 0x83, 0x96);
+	mipi_dsi_dcs_write_seq(dsi, 0x84, 0x69);
+	mipi_dsi_dcs_write_seq(dsi, 0x92, 0x19);
+	mipi_dsi_dcs_write_seq(dsi, 0x95, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x83, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x84, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x90, 0x77);
+	mipi_dsi_dcs_write_seq(dsi, 0x94, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x96, 0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0x91, 0xfd);
+	mipi_dsi_dcs_write_seq(dsi, 0x90, 0x77);
+
+	return 0;
+}
+
+static int nt51017_off(struct nt51017 *ctx)
+{
+	return 0;
+}
+
+static int nt51017_prepare(struct drm_panel *panel)
+{
+	struct nt51017 *ctx = to_nt51017(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	msleep(30);
+
+	ret = nt51017_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nt51017_unprepare(struct drm_panel *panel)
+{
+	struct nt51017 *ctx = to_nt51017(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = nt51017_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode nt51017_mode = {
+	.clock = (800 + 152 + 8 + 128) * (1280 + 18 + 1 + 23) * 60 / 1000,
+	.hdisplay = 800,
+	.hsync_start = 800 + 152,
+	.hsync_end = 800 + 152 + 8,
+	.htotal = 800 + 152 + 8 + 128,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 18,
+	.vsync_end = 1280 + 18 + 1,
+	.vtotal = 1280 + 18 + 1 + 23,
+	.width_mm = 129,
+	.height_mm = 206,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int nt51017_get_modes(struct drm_panel *panel,
+			     struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &nt51017_mode);
+}
+
+static const struct drm_panel_funcs nt51017_panel_funcs = {
+	.prepare = nt51017_prepare,
+	.unprepare = nt51017_unprepare,
+	.get_modes = nt51017_get_modes,
+};
+
+static int nt51017_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct nt51017 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "lcd");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get lcd regulator\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_MODE_VIDEO_NO_HFP |
+			  MIPI_DSI_MODE_VIDEO_NO_HBP |
+			  MIPI_DSI_MODE_VIDEO_NO_HSA;
+
+	drm_panel_init(&ctx->panel, dev, &nt51017_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void nt51017_remove(struct mipi_dsi_device *dsi)
+{
+	struct nt51017 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id nt51017_of_match[] = {
+	{ .compatible = "samsung,nt51017-b4p096wx5vp09" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, nt51017_of_match);
+
+static struct mipi_dsi_driver nt51017_driver = {
+	.probe = nt51017_probe,
+	.remove = nt51017_remove,
+	.driver = {
+		.name = "panel-samsung-nt51017-b4p096wx5vp09",
+		.of_match_table = nt51017_of_match,
+	},
+};
+module_mipi_dsi_driver(nt51017_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for NT51017 wxga video mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6288a0.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6288a0.c
new file mode 100644
index 000000000000..5ed1cf48c795
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6288a0.c
@@ -0,0 +1,350 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+//From downstream dt property "samsung,panel-aid-cmds-list-350"
+#define AID_MIN 8
+#define AID_MAX 785
+#define MAX_BRIGHTNESS (AID_MAX - AID_MIN)
+
+struct samsung {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct samsung *to_samsung(struct drm_panel *panel)
+{
+	return container_of(panel, struct samsung, panel);
+}
+
+static void samsung_reset(struct samsung *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int samsung_send_dcs_aid(struct mipi_dsi_device *dsi, u16 brightness)
+{
+	u8 payload[5] = { 0x40, 0x08, 0x20, 0, 0 };
+	int ret;
+	u16 aid;
+
+	//Calculate AID value from brightness level
+	if (brightness > MAX_BRIGHTNESS)
+		brightness = MAX_BRIGHTNESS;
+	aid = (MAX_BRIGHTNESS - brightness) + AID_MIN;
+	payload[3] = (aid >> 8) & 0xff;
+	payload[4] = aid & 0xff;
+
+	//Set AID
+	ret = mipi_dsi_dcs_write(dsi, 0xb2, payload, sizeof(payload));
+	if (ret < 0) {
+		dev_err(&dsi->dev, "Failed to set AID: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int samsung_on(struct samsung *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	//Tesk key ON - Enable level 1 control commands
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	//Enable level 2 control commands
+	mipi_dsi_dcs_write_seq(dsi, 0xfc, 0x5a, 0x5a);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	//AVDD Setting
+	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0x38, 0x0b, 0x30);
+
+	//Brightness gamma
+	mipi_dsi_dcs_write_seq(dsi, 0xca,
+				0x01, 0x00, 0x01, 0x00, 0x01, 0x00, // V255 RGB
+				0x80, 0x80, 0x80,                   // V203 RGB
+				0x80, 0x80, 0x80,                   // V151 RGB
+				0x80, 0x80, 0x80,                   // V87  RGB
+				0x80, 0x80, 0x80,                   // V51  RGB
+				0x80, 0x80, 0x80,                   // V35  RGB
+				0x80, 0x80, 0x80,                   // V23  RGB
+				0x80, 0x80, 0x80,                   // V11  RGB
+				0x80, 0x80, 0x80,                   // V3   RGB
+				0x00, 0x00, 0x00);                  // VT   RGB
+
+	//Set AID
+	// We need the actual backlight value even while blank, hence why the
+	// value is read directly instead of via backlight_get_brightness()
+	samsung_send_dcs_aid(dsi, ctx->panel.backlight->props.brightness);
+
+	//Set ELVSS condition
+	mipi_dsi_dcs_write_seq(dsi, 0xb6, 0x28, 0x0b);
+
+	//Set ACL
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x00);
+
+	//Update gamma, LTPS(AID)
+	mipi_dsi_dcs_write_seq(dsi, 0xf7, 0x03);
+
+	//Disable level 2 control commands
+	mipi_dsi_dcs_write_seq(dsi, 0xfc, 0xa5, 0xa5);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int samsung_off(struct samsung *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	//Tesk key OFF - Disable level 1 control commands
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0xa5, 0xa5);
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(35);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int samsung_prepare(struct drm_panel *panel)
+{
+	struct samsung *ctx = to_samsung(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	samsung_reset(ctx);
+
+	ret = samsung_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int samsung_unprepare(struct drm_panel *panel)
+{
+	struct samsung *ctx = to_samsung(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = samsung_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode samsung_mode = {
+	.clock = (480 + 90 + 2 + 50) * (800 + 13 + 1 + 2) * 60 / 1000,
+	.hdisplay = 480,
+	.hsync_start = 480 + 90,
+	.hsync_end = 480 + 90 + 2,
+	.htotal = 480 + 90 + 2 + 50,
+	.vdisplay = 800,
+	.vsync_start = 800 + 13,
+	.vsync_end = 800 + 13 + 1,
+	.vtotal = 800 + 13 + 1 + 2,
+	.width_mm = 56,
+	.height_mm = 94,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int samsung_get_modes(struct drm_panel *panel,
+			     struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &samsung_mode);
+}
+
+static const struct drm_panel_funcs samsung_panel_funcs = {
+	.prepare = samsung_prepare,
+	.unprepare = samsung_unprepare,
+	.get_modes = samsung_get_modes,
+};
+
+static int samsung_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	int ret;
+	u16 brightness = backlight_get_brightness(bl);
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	//Set AID
+	ret = samsung_send_dcs_aid(dsi, brightness);
+	if (ret != 0)
+		return ret;
+
+	//Update gamma, LTPS(AID)
+	mipi_dsi_dcs_write_seq(dsi, 0xf7, 0x03);
+
+	//TODO: downstream driver also updates ACL and ELVSS based on brightness
+	// check out dsi-panel-samsung-wvga-video.dtsi
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct backlight_ops samsung_bl_ops = {
+	.update_status = samsung_bl_update_status,
+};
+
+static struct backlight_device *
+samsung_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = MAX_BRIGHTNESS,
+		.max_brightness = MAX_BRIGHTNESS,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &samsung_bl_ops, &props);
+}
+
+static int samsung_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct samsung *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vddio";
+	ctx->supplies[1].supply = "vdd";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 2;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_NO_EOT_PACKET | MIPI_DSI_MODE_VIDEO_NO_HFP;
+
+	drm_panel_init(&ctx->panel, dev, &samsung_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ctx->panel.backlight = samsung_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void samsung_remove(struct mipi_dsi_device *dsi)
+{
+	struct samsung *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id samsung_of_match[] = {
+	{ .compatible = "samsung,s6288a0" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, samsung_of_match);
+
+static struct mipi_dsi_driver samsung_driver = {
+	.probe = samsung_probe,
+	.remove = samsung_remove,
+	.driver = {
+		.name = "panel-samsung-s6288a0",
+		.of_match_table = samsung_of_match,
+	},
+};
+module_mipi_dsi_driver(samsung_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for Samsung WVGA video mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6d2aa0x62-lpm053a250a.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6d2aa0x62-lpm053a250a.c
new file mode 100644
index 000000000000..960b00e487b1
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6d2aa0x62-lpm053a250a.c
@@ -0,0 +1,296 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct s6d2aa0x {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[3];
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *backlight_gpio;
+};
+
+static inline struct s6d2aa0x *to_s6d2aa0x(struct drm_panel *panel)
+{
+	return container_of(panel, struct s6d2aa0x, panel);
+}
+
+static void s6d2aa0x_reset(struct s6d2aa0x *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(100);
+}
+
+static int s6d2aa0x_on(struct s6d2aa0x *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0x00);
+	msleep(120);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc9,
+			       0x0c, 0x19, 0x1c, 0x28, 0x32, 0x3e, 0x48, 0x57,
+			       0x3b, 0x43, 0x51, 0x5f, 0x68, 0x70, 0x7f, 0x0c,
+			       0x19, 0x1c, 0x28, 0x32, 0x3e, 0x48, 0x57, 0x3b,
+			       0x43, 0x51, 0x5f, 0x68, 0x70, 0x7f);
+	mipi_dsi_dcs_write_seq(dsi, 0xca,
+			       0x01, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00,
+			       0xff, 0x00, 0xfe, 0xb6, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0xfc, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb7, 0x78, 0x64, 0x10, 0x64, 0xab);
+	mipi_dsi_dcs_write_seq(dsi, 0xb8,
+			       0xb4, 0x40, 0x43, 0x49, 0x55, 0x62, 0x71, 0x82,
+			       0x94, 0xa8, 0xb9, 0xcb, 0xdb, 0xe9, 0xf5, 0xfc,
+			       0xff);
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0xb4, 0xa0);
+	mipi_dsi_dcs_write_seq(dsi, 0xbb, 0x2e);
+	mipi_dsi_dcs_write_seq(dsi, 0xbc, 0x01, 0x38, 0x04, 0x04, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0x00);
+	msleep(20);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x26);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_CABC_MIN_BRIGHTNESS, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x29, 0x00);
+	usleep_range(10000, 11000);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x00);
+
+	return 0;
+}
+
+static int s6d2aa0x_off(struct s6d2aa0x *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int s6d2aa0x_prepare(struct drm_panel *panel)
+{
+	struct s6d2aa0x *ctx = to_s6d2aa0x(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	s6d2aa0x_reset(ctx);
+
+	ret = s6d2aa0x_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int s6d2aa0x_unprepare(struct drm_panel *panel)
+{
+	struct s6d2aa0x *ctx = to_s6d2aa0x(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = s6d2aa0x_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode s6d2aa0x_mode = {
+	.clock = (720 + 134 + 4 + 117) * (1280 + 8 + 2 + 6) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 134,
+	.hsync_end = 720 + 134 + 4,
+	.htotal = 720 + 134 + 4 + 117,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 8,
+	.vsync_end = 1280 + 8 + 2,
+	.vtotal = 1280 + 8 + 2 + 6,
+	.width_mm = 69,
+	.height_mm = 124,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int s6d2aa0x_get_modes(struct drm_panel *panel,
+			      struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &s6d2aa0x_mode);
+}
+
+static const struct drm_panel_funcs s6d2aa0x_panel_funcs = {
+	.prepare = s6d2aa0x_prepare,
+	.unprepare = s6d2aa0x_unprepare,
+	.get_modes = s6d2aa0x_get_modes,
+};
+
+static int s6d2aa0x_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	struct s6d2aa0x *ctx = mipi_dsi_get_drvdata(dsi);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	gpiod_set_value_cansleep(ctx->backlight_gpio, !!brightness);
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct backlight_ops s6d2aa0x_bl_ops = {
+	.update_status = s6d2aa0x_bl_update_status,
+};
+
+static struct backlight_device *
+s6d2aa0x_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 255,
+		.max_brightness = 255,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &s6d2aa0x_bl_ops, &props);
+}
+
+static int s6d2aa0x_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct s6d2aa0x *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vcc";
+	ctx->supplies[1].supply = "vsp";
+	ctx->supplies[2].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->backlight_gpio = devm_gpiod_get(dev, "backlight", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->backlight_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->backlight_gpio),
+				     "Failed to get backlight-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_NO_EOT_PACKET | MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &s6d2aa0x_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ctx->panel.backlight = s6d2aa0x_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void s6d2aa0x_remove(struct mipi_dsi_device *dsi)
+{
+	struct s6d2aa0x *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id s6d2aa0x_of_match[] = {
+	{ .compatible = "samsung,s6d2aa0x62-lpm053a250a" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, s6d2aa0x_of_match);
+
+static struct mipi_dsi_driver s6d2aa0x_driver = {
+	.probe = s6d2aa0x_probe,
+	.remove = s6d2aa0x_remove,
+	.driver = {
+		.name = "panel-samsung-s6d2aa0x62-lpm053a250a",
+		.of_match_table = s6d2aa0x_of_match,
+	},
+};
+module_mipi_dsi_driver(s6d2aa0x_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for s6d2aa0x hd video mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6d78a0-gh9607501a.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6d78a0-gh9607501a.c
new file mode 100644
index 000000000000..49815ed976c3
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6d78a0-gh9607501a.c
@@ -0,0 +1,316 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct s6d78a0_gh9607501a {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline
+struct s6d78a0_gh9607501a *to_s6d78a0_gh9607501a(struct drm_panel *panel)
+{
+	return container_of(panel, struct s6d78a0_gh9607501a, panel);
+}
+
+static void s6d78a0_gh9607501a_reset(struct s6d78a0_gh9607501a *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(30);
+}
+
+static int s6d78a0_gh9607501a_on(struct s6d78a0_gh9607501a *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xf1, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xfc, 0xa5, 0xa5);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	mipi_dsi_dcs_write_seq(dsi, 0xb1, 0x93);
+	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xf4,
+			       0x01, 0x10, 0x32, 0x00, 0x24, 0x26, 0x28, 0x27,
+			       0x27, 0x27, 0xb7, 0x2b, 0x2c, 0x65, 0x6a, 0x34,
+			       0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0xef,
+			       0x01, 0x01, 0x81, 0x22, 0x83, 0x04, 0x00, 0x00,
+			       0x00, 0x00, 0x28, 0x81, 0x00, 0x21, 0x21, 0x03,
+			       0x03, 0x40, 0x00, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xf2,
+			       0x19, 0x04, 0x08, 0x08, 0x08, 0x14, 0x14, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf6, 0x93, 0x23, 0x15, 0x07, 0x07, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0xe1, 0x01, 0xff, 0x01, 0x1b, 0x20, 0x17);
+	mipi_dsi_dcs_write_seq(dsi, 0xe2, 0xed, 0xc7, 0x23);
+	mipi_dsi_dcs_write_seq(dsi, 0xf7,
+			       0x01, 0x01, 0x0a, 0x0b, 0x05, 0x1b, 0x1a, 0x01,
+			       0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+			       0x01, 0x01, 0x01, 0x01, 0x01, 0x08, 0x09, 0x04,
+			       0x1b, 0x1a, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+			       0x01, 0x01, 0x01, 0x01, 0x01, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0xfa,
+			       0x00, 0x19, 0x21, 0x1e, 0x14, 0x0b, 0x10, 0x0e,
+			       0x09, 0x0b, 0x00, 0x00, 0x0a, 0x00, 0x1d, 0x21,
+			       0x1e, 0x14, 0x0b, 0x10, 0x0e, 0x09, 0x0b, 0x00,
+			       0x00, 0x0a, 0x00, 0x1c, 0x21, 0x1e, 0x14, 0x0b,
+			       0x10, 0x0e, 0x09, 0x0b, 0x00, 0x00, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0xfb,
+			       0x07, 0x2d, 0x22, 0x24, 0x18, 0x0e, 0x11, 0x0c,
+			       0x05, 0x05, 0x00, 0x00, 0x0a, 0x00, 0x29, 0x22,
+			       0x24, 0x18, 0x0e, 0x11, 0x0c, 0x05, 0x05, 0x00,
+			       0x00, 0x0a, 0x07, 0x2a, 0x22, 0x24, 0x18, 0x0e,
+			       0x11, 0x0c, 0x05, 0x05, 0x00, 0x00, 0x0a);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0xa5, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, 0xf1, 0xa5, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, 0xfc, 0x5a, 0x5a);
+
+	return 0;
+}
+
+static int s6d78a0_gh9607501a_off(struct s6d78a0_gh9607501a *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0x28, 0x00);
+	msleep(40);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x00);
+	msleep(100);
+
+	return 0;
+}
+
+static int s6d78a0_gh9607501a_prepare(struct drm_panel *panel)
+{
+	struct s6d78a0_gh9607501a *ctx = to_s6d78a0_gh9607501a(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	s6d78a0_gh9607501a_reset(ctx);
+
+	ret = s6d78a0_gh9607501a_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int s6d78a0_gh9607501a_unprepare(struct drm_panel *panel)
+{
+	struct s6d78a0_gh9607501a *ctx = to_s6d78a0_gh9607501a(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = s6d78a0_gh9607501a_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode s6d78a0_gh9607501a_mode = {
+	.clock = (540 + 10 + 14 + 10) * (960 + 8 + 2 + 6) * 60 / 1000,
+	.hdisplay = 540,
+	.hsync_start = 540 + 10,
+	.hsync_end = 540 + 10 + 14,
+	.htotal = 540 + 10 + 14 + 10,
+	.vdisplay = 960,
+	.vsync_start = 960 + 8,
+	.vsync_end = 960 + 8 + 2,
+	.vtotal = 960 + 8 + 2 + 6,
+	.width_mm = 62,
+	.height_mm = 110,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int s6d78a0_gh9607501a_get_modes(struct drm_panel *panel,
+					struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &s6d78a0_gh9607501a_mode);
+}
+
+static const struct drm_panel_funcs s6d78a0_gh9607501a_panel_funcs = {
+	.prepare = s6d78a0_gh9607501a_prepare,
+	.unprepare = s6d78a0_gh9607501a_unprepare,
+	.get_modes = s6d78a0_gh9607501a_get_modes,
+};
+
+static int s6d78a0_gh9607501a_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct backlight_ops s6d78a0_gh9607501a_bl_ops = {
+	.update_status = s6d78a0_gh9607501a_bl_update_status,
+};
+
+static struct backlight_device *
+s6d78a0_gh9607501a_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 255,
+		.max_brightness = 255,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &s6d78a0_gh9607501a_bl_ops, &props);
+}
+
+static int s6d78a0_gh9607501a_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct s6d78a0_gh9607501a *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vddio";
+	ctx->supplies[1].supply = "vdd";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 2;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			  MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &s6d78a0_gh9607501a_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	/* Fallback to DCS backlight if no backlight is defined in DT */
+	if (!ctx->panel.backlight) {
+		ctx->panel.backlight = s6d78a0_gh9607501a_create_backlight(dsi);
+		if (IS_ERR(ctx->panel.backlight))
+			return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+					     "Failed to create backlight\n");
+	}
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void s6d78a0_gh9607501a_remove(struct mipi_dsi_device *dsi)
+{
+	struct s6d78a0_gh9607501a *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id s6d78a0_gh9607501a_of_match[] = {
+	{ .compatible = "samsung,s6d78a0-gh9607501a" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, s6d78a0_gh9607501a_of_match);
+
+static struct mipi_dsi_driver s6d78a0_gh9607501a_driver = {
+	.probe = s6d78a0_gh9607501a_probe,
+	.remove = s6d78a0_gh9607501a_remove,
+	.driver = {
+		.name = "panel-samsung-s6d78a0-gh9607501a",
+		.of_match_table = s6d78a0_gh9607501a_of_match,
+	},
+};
+module_mipi_dsi_driver(s6d78a0_gh9607501a_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for S6D78A0 qhd video mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6e3fa2-ams549eh01.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6e3fa2-ams549eh01.c
new file mode 100644
index 000000000000..a8e2f3002c44
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6e3fa2-ams549eh01.c
@@ -0,0 +1,265 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct s6e3fa2_ams549eh01 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[3];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline
+struct s6e3fa2_ams549eh01 *to_s6e3fa2_ams549eh01(struct drm_panel *panel)
+{
+	return container_of(panel, struct s6e3fa2_ams549eh01, panel);
+}
+
+static void s6e3fa2_ams549eh01_reset(struct s6e3fa2_ams549eh01 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int s6e3fa2_ams549eh01_on(struct s6e3fa2_ams549eh01 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	mipi_dsi_generic_write_seq(dsi, 0xca,
+				   0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x80,
+				   0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+				   0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+				   0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+				   0x80, 0x80, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xb2, 0x00, 0x0e, 0x00, 0x0e);
+	mipi_dsi_generic_write_seq(dsi, 0xb6, 0x8c, 0x0b);
+	mipi_dsi_generic_write_seq(dsi, 0xf7, 0x03);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0xa5, 0xa5);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x05);
+	mipi_dsi_generic_write_seq(dsi, 0xb8, 0x19);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0xa5, 0xa5);
+	mipi_dsi_generic_write_seq(dsi, 0x35, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	mipi_dsi_generic_write_seq(dsi, 0xfc, 0x5a, 0x5a);
+	mipi_dsi_generic_write_seq(dsi, 0xfd, 0xb8);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x14);
+	mipi_dsi_generic_write_seq(dsi, 0xd7, 0x75);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x20);
+	mipi_dsi_generic_write_seq(dsi, 0xd7, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xfe, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xfe, 0x00);
+	msleep(120);
+	mipi_dsi_generic_write_seq(dsi, 0xf0, 0xa5, 0xa5);
+	mipi_dsi_generic_write_seq(dsi, 0xfc, 0xa5, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_MEMORY_START);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_MEMORY_CONTINUE);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int s6e3fa2_ams549eh01_off(struct s6e3fa2_ams549eh01 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(150);
+
+	return 0;
+}
+
+static int s6e3fa2_ams549eh01_prepare(struct drm_panel *panel)
+{
+	struct s6e3fa2_ams549eh01 *ctx = to_s6e3fa2_ams549eh01(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	s6e3fa2_ams549eh01_reset(ctx);
+
+	ret = s6e3fa2_ams549eh01_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int s6e3fa2_ams549eh01_unprepare(struct drm_panel *panel)
+{
+	struct s6e3fa2_ams549eh01 *ctx = to_s6e3fa2_ams549eh01(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = s6e3fa2_ams549eh01_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode s6e3fa2_ams549eh01_mode = {
+	.clock = (1080 + 160 + 12 + 36) * (1920 + 12 + 2 + 3) * 50 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 160,
+	.hsync_end = 1080 + 160 + 12,
+	.htotal = 1080 + 160 + 12 + 36,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 12,
+	.vsync_end = 1920 + 12 + 2,
+	.vtotal = 1920 + 12 + 2 + 3,
+	.width_mm = 69,
+	.height_mm = 122,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int s6e3fa2_ams549eh01_get_modes(struct drm_panel *panel,
+					struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &s6e3fa2_ams549eh01_mode);
+}
+
+static const struct drm_panel_funcs s6e3fa2_ams549eh01_panel_funcs = {
+	.prepare = s6e3fa2_ams549eh01_prepare,
+	.unprepare = s6e3fa2_ams549eh01_unprepare,
+	.get_modes = s6e3fa2_ams549eh01_get_modes,
+};
+
+static int s6e3fa2_ams549eh01_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct s6e3fa2_ams549eh01 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vdd3";
+	ctx->supplies[1].supply = "vddr";
+	ctx->supplies[2].supply = "vcc";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO_BURST;
+
+	drm_panel_init(&ctx->panel, dev, &s6e3fa2_ams549eh01_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void s6e3fa2_ams549eh01_remove(struct mipi_dsi_device *dsi)
+{
+	struct s6e3fa2_ams549eh01 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id s6e3fa2_ams549eh01_of_match[] = {
+	{ .compatible = "samsung,s6e3fa2-ams549eh01" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, s6e3fa2_ams549eh01_of_match);
+
+static struct mipi_dsi_driver s6e3fa2_ams549eh01_driver = {
+	.probe = s6e3fa2_ams549eh01_probe,
+	.remove = s6e3fa2_ams549eh01_remove,
+	.driver = {
+		.name = "panel-samsung-s6e3fa2-ams549eh01",
+		.of_match_table = s6e3fa2_ams549eh01_of_match,
+	},
+};
+module_mipi_dsi_driver(s6e3fa2_ams549eh01_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for ss_dsi_panel_S6E3FA2_AMS549EH01_FHD");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6e88a0-ams427ap24.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6e88a0-ams427ap24.c
new file mode 100644
index 000000000000..96bf07e93957
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6e88a0-ams427ap24.c
@@ -0,0 +1,760 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+#define NUM_STEPS_CANDELA	54
+#define NUM_STEPS_AID		39
+#define NUM_STEPS_ELVSS		17
+
+#define SEQ_LENGTH_AID		5
+#define SEQ_LENGTH_ELVSS	2
+#define SEQ_LENGTH_GAMMA	33
+
+struct s6e88a0_ams427ap24 {
+	struct drm_panel panel;
+	struct backlight_device *bl_dev;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+	bool flip_horizontal;
+};
+
+static inline
+struct s6e88a0_ams427ap24 *to_s6e88a0_ams427ap24(struct drm_panel *panel)
+{
+	return container_of(panel, struct s6e88a0_ams427ap24, panel);
+}
+
+enum candela {
+	CANDELA_10CD, /* 0 */
+	CANDELA_11CD,
+	CANDELA_12CD,
+	CANDELA_13CD,
+	CANDELA_14CD,
+	CANDELA_15CD,
+	CANDELA_16CD,
+	CANDELA_17CD,
+	CANDELA_19CD,
+	CANDELA_20CD,
+	CANDELA_21CD,
+	CANDELA_22CD,
+	CANDELA_24CD,
+	CANDELA_25CD,
+	CANDELA_27CD,
+	CANDELA_29CD,
+	CANDELA_30CD,
+	CANDELA_32CD,
+	CANDELA_34CD,
+	CANDELA_37CD,
+	CANDELA_39CD,
+	CANDELA_41CD,
+	CANDELA_44CD,
+	CANDELA_47CD,
+	CANDELA_50CD,
+	CANDELA_53CD,
+	CANDELA_56CD,
+	CANDELA_60CD,
+	CANDELA_64CD,
+	CANDELA_68CD,
+	CANDELA_72CD,
+	CANDELA_77CD,
+	CANDELA_82CD,
+	CANDELA_87CD,
+	CANDELA_93CD,
+	CANDELA_98CD,
+	CANDELA_105CD,
+	CANDELA_111CD,
+	CANDELA_119CD,
+	CANDELA_126CD,
+	CANDELA_134CD,
+	CANDELA_143CD,
+	CANDELA_152CD,
+	CANDELA_162CD,
+	CANDELA_172CD,
+	CANDELA_183CD,
+	CANDELA_195CD,
+	CANDELA_207CD,
+	CANDELA_220CD,
+	CANDELA_234CD,
+	CANDELA_249CD,
+	CANDELA_265CD,
+	CANDELA_282CD,
+	CANDELA_300CD, /* 53 */
+};
+
+static int const s6e88a0_ams427ap24_br_to_cd[NUM_STEPS_CANDELA] = {
+	/* brightness till, candela */
+	10, /* 10CD */
+	11, /* 11CD */
+	12, /* 12CD */
+	13, /* 13CD */
+	14, /* 14CD */
+	15, /* 15CD */
+	16, /* 16CD */
+	17, /* 17CD */
+	18, /* 19CD */
+	19, /* 20CD */
+	20, /* 21CD */
+	21, /* 22CD */
+	22, /* 24CD */
+	23, /* 25CD */
+	24, /* 27CD */
+	25, /* 29CD */
+	26, /* 30CD */
+	27, /* 32CD */
+	28, /* 34CD */
+	29, /* 37CD */
+	30, /* 39CD */
+	32, /* 41CD */
+	34, /* 44CD */
+	36, /* 47CD */
+	38, /* 50CD */
+	40, /* 53CD */
+	43, /* 56CD */
+	46, /* 60CD */
+	49, /* 64CD */
+	52, /* 68CD */
+	56, /* 72CD */
+	59, /* 77CD */
+	63, /* 82CD */
+	67, /* 87CD */
+	71, /* 93CD */
+	76, /* 98CD */
+	80, /* 105CD */
+	86, /* 111CD */
+	91, /* 119CD */
+	97, /* 126CD */
+	104, /* 134CD */
+	110, /* 143CD */
+	118, /* 152CD */
+	125, /* 162CD */
+	133, /* 172CD */
+	142, /* 183CD */
+	150, /* 195CD */
+	160, /* 207CD */
+	170, /* 220CD */
+	181, /* 234CD */
+	205, /* 249CD */
+	234, /* 265CD */
+	254, /* 282CD */
+	255, /* 300CD */
+};
+
+static u8 const s6e88a0_ams427ap24_aid[NUM_STEPS_AID][SEQ_LENGTH_AID] = {
+	{ 0x40, 0x08, 0x20, 0x03, 0x77 }, /* AOR 90.9%, 10CD */
+	{ 0x40, 0x08, 0x20, 0x03, 0x73 }, /* AOR 90.5%, 11CD */
+	{ 0x40, 0x08, 0x20, 0x03, 0x69 }, /* AOR 89.4%, 12CD */
+	{ 0x40, 0x08, 0x20, 0x03, 0x65 }, /* AOR 89.0%, 13CD */
+	{ 0x40, 0x08, 0x20, 0x03, 0x61 }, /* AOR 88.6%, 14CD */
+	{ 0x40, 0x08, 0x20, 0x03, 0x55 }, /* AOR 87.4%, 15CD */
+	{ 0x40, 0x08, 0x20, 0x03, 0x50 }, /* AOR 86.9%, 16CD */
+	{ 0x40, 0x08, 0x20, 0x03, 0x45 }, /* AOR 85.8%, 17CD */
+	{ 0x40, 0x08, 0x20, 0x03, 0x35 }, /* AOR 84.1%, 19CD */
+	{ 0x40, 0x08, 0x20, 0x03, 0x27 }, /* AOR 82.7%, 20CD */
+	{ 0x40, 0x08, 0x20, 0x03, 0x23 }, /* AOR 82.3%, 21CD */
+	{ 0x40, 0x08, 0x20, 0x03, 0x17 }, /* AOR 81.0%, 22CD */
+	{ 0x40, 0x08, 0x20, 0x03, 0x11 }, /* AOR 80.4%, 24CD */
+	{ 0x40, 0x08, 0x20, 0x03, 0x04 }, /* AOR 79.1%, 25CD */
+	{ 0x40, 0x08, 0x20, 0x02, 0xf4 }, /* AOR 77.5%, 27CD */
+	{ 0x40, 0x08, 0x20, 0x02, 0xe3 }, /* AOR 75.7%, 29CD */
+	{ 0x40, 0x08, 0x20, 0x02, 0xd7 }, /* AOR 74.5%, 30CD */
+	{ 0x40, 0x08, 0x20, 0x02, 0xc6 }, /* AOR 72.7%, 32CD */
+	{ 0x40, 0x08, 0x20, 0x02, 0xb7 }, /* AOR 71.2%, 34CD */
+	{ 0x40, 0x08, 0x20, 0x02, 0xa1 }, /* AOR 69.0%, 37CD */
+	{ 0x40, 0x08, 0x20, 0x02, 0x91 }, /* AOR 67.3%, 39CD */
+	{ 0x40, 0x08, 0x20, 0x02, 0x78 }, /* AOR 64.8%, 41CD */
+	{ 0x40, 0x08, 0x20, 0x02, 0x62 }, /* AOR 62.5%, 44CD */
+	{ 0x40, 0x08, 0x20, 0x02, 0x45 }, /* AOR 59.5%, 47CD */
+	{ 0x40, 0x08, 0x20, 0x02, 0x30 }, /* AOR 57.4%, 50CD */
+	{ 0x40, 0x08, 0x20, 0x02, 0x13 }, /* AOR 54.4%, 53CD */
+	{ 0x40, 0x08, 0x20, 0x01, 0xf5 }, /* AOR 51.3%, 56CD */
+	{ 0x40, 0x08, 0x20, 0x01, 0xd3 }, /* AOR 47.8%, 60CD */
+	{ 0x40, 0x08, 0x20, 0x01, 0xb1 }, /* AOR 44.4%, 64CD */
+	{ 0x40, 0x08, 0x20, 0x01, 0x87 }, /* AOR 40.1%, 68CD */
+	{ 0x40, 0x08, 0x20, 0x01, 0x63 }, /* AOR 36.6%, 72CD */
+	{ 0x40, 0x08, 0x20, 0x01, 0x35 }, /* AOR 31.7%, 77CD */
+	{ 0x40, 0x08, 0x20, 0x01, 0x05 }, /* AOR 26.9%, 82CD */
+	{ 0x40, 0x08, 0x20, 0x00, 0xd5 }, /* AOR 21.8%, 87CD */
+	{ 0x40, 0x08, 0x20, 0x00, 0xa1 }, /* AOR 16.5%, 93CD */
+	{ 0x40, 0x08, 0x20, 0x00, 0x6f }, /* AOR 11.4%, 98CD */
+	{ 0x40, 0x08, 0x20, 0x00, 0x31 }, /* AOR 5.0%, 105CD */
+	{ 0x40, 0x08, 0x20, 0x01, 0x86 }, /* AOR 40,00Â %, 111CD ~ 172CD */
+	{ 0x40, 0x08, 0x20, 0x00, 0x08 }, /* AOR 0.6%, 183CD ~ 300CD */
+};
+
+static u8 const s6e88a0_ams427ap24_elvss[NUM_STEPS_ELVSS][SEQ_LENGTH_ELVSS] = {
+	{ 0x28, 0x14 }, /* 10CD ~ 111CD */
+	{ 0x28, 0x13 }, /* 119CD */
+	{ 0x28, 0x12 }, /* 126CD */
+	{ 0x28, 0x12 }, /* 134CD */
+	{ 0x28, 0x11 }, /* 143CD */
+	{ 0x28, 0x10 }, /* 152CD */
+	{ 0x28, 0x0f }, /* 162CD */
+	{ 0x28, 0x0e }, /* 172CD */
+	{ 0x28, 0x11 }, /* 183CD */
+	{ 0x28, 0x11 }, /* 195CD */
+	{ 0x28, 0x10 }, /* 207CD */
+	{ 0x28, 0x0f }, /* 220CD */
+	{ 0x28, 0x0f }, /* 234CD */
+	{ 0x28, 0x0e }, /* 249CD */
+	{ 0x28, 0x0d }, /* 265CD */
+	{ 0x28, 0x0c }, /* 282CD */
+	{ 0x28, 0x0b }, /* 300CD */
+};
+
+static u8 const s6e88a0_ams427ap24_gamma[NUM_STEPS_CANDELA][SEQ_LENGTH_GAMMA] = {
+	/* 10CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x8a, 0x8c, 0x8b,
+	  0x8c, 0x87, 0x89, 0x89, 0x88, 0x87, 0x8c, 0x80, 0x82, 0x88, 0x7b,
+	  0x72, 0x8c, 0x60, 0x68, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 11CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x8a, 0x8c, 0x8b,
+	  0x8c, 0x87, 0x89, 0x89, 0x88, 0x87, 0x8c, 0x80, 0x82, 0x88, 0x7b,
+	  0x72, 0x8c, 0x60, 0x68, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 12CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x8a, 0x8b, 0x8b,
+	  0x8c, 0x88, 0x89, 0x8a, 0x88, 0x87, 0x8c, 0x81, 0x82, 0x87, 0x7a,
+	  0x72, 0x8b, 0x60, 0x68, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 13CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x8a, 0x8b, 0x8b,
+	  0x8c, 0x88, 0x89, 0x8a, 0x88, 0x87, 0x8c, 0x81, 0x82, 0x87, 0x7a,
+	  0x72, 0x8b, 0x61, 0x69, 0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 14CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x89, 0x8c, 0x8b,
+	  0x8c, 0x88, 0x89, 0x8a, 0x87, 0x86, 0x8a, 0x82, 0x82, 0x87, 0x79,
+	  0x71, 0x89, 0x63, 0x6c, 0x8e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 15CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x8a, 0x8c, 0x8c,
+	  0x8c, 0x86, 0x87, 0x88, 0x85, 0x85, 0x8a, 0x83, 0x83, 0x88, 0x78,
+	  0x72, 0x89, 0x64, 0x6c, 0x8e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 16CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x89, 0x8c, 0x8b,
+	  0x8c, 0x86, 0x88, 0x88, 0x86, 0x86, 0x8a, 0x84, 0x84, 0x88, 0x78,
+	  0x72, 0x89, 0x5d, 0x67, 0x8b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 17CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x87, 0x89, 0x89, 0x86, 0x86, 0x8a, 0x84, 0x83, 0x87, 0x78,
+	  0x73, 0x89, 0x64, 0x6e, 0x8e, 0x38, 0x32, 0x24, 0x00, 0x00, 0x00 },
+	/* 19CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x87, 0x89, 0x89, 0x86, 0x86, 0x89, 0x84, 0x84, 0x87, 0x77,
+	  0x72, 0x88, 0x65, 0x6f, 0x8e, 0x38, 0x32, 0x24, 0x00, 0x00, 0x00 },
+	/* 20CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x88, 0x89, 0x89, 0x85, 0x85, 0x88, 0x82, 0x83, 0x85, 0x79,
+	  0x73, 0x88, 0x65, 0x6f, 0x8e, 0x38, 0x32, 0x24, 0x00, 0x00, 0x00 },
+	/* 21CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x88, 0x89, 0x89, 0x85, 0x85, 0x88, 0x82, 0x83, 0x85, 0x79,
+	  0x74, 0x88, 0x65, 0x6f, 0x8e, 0x38, 0x32, 0x24, 0x00, 0x00, 0x00 },
+	/* 22CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x89, 0x8c, 0x8b,
+	  0x8c, 0x86, 0x88, 0x87, 0x86, 0x86, 0x89, 0x82, 0x83, 0x85, 0x7c,
+	  0x75, 0x87, 0x65, 0x6f, 0x8e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 24CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x89, 0x8c, 0x8b,
+	  0x8c, 0x86, 0x88, 0x87, 0x86, 0x86, 0x89, 0x82, 0x83, 0x85, 0x7c,
+	  0x76, 0x86, 0x66, 0x6f, 0x8e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
+	/* 25CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x86, 0x89, 0x88, 0x87, 0x87, 0x89, 0x82, 0x82, 0x84, 0x7f,
+	  0x7a, 0x89, 0x6b, 0x73, 0x8f, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 27CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x86, 0x89, 0x88, 0x87, 0x87, 0x89, 0x82, 0x82, 0x84, 0x7f,
+	  0x7a, 0x89, 0x6b, 0x73, 0x8f, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 29CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x86, 0x89, 0x88, 0x85, 0x84, 0x87, 0x84, 0x85, 0x86, 0x80,
+	  0x7b, 0x88, 0x6a, 0x73, 0x8f, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 30CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x86, 0x89, 0x88, 0x85, 0x84, 0x87, 0x84, 0x85, 0x86, 0x80,
+	  0x7b, 0x88, 0x6a, 0x73, 0x8f, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 32CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x86, 0x89, 0x88, 0x85, 0x84, 0x87, 0x84, 0x85, 0x86, 0x80,
+	  0x7b, 0x88, 0x6a, 0x73, 0x8f, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 34CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8c, 0x8a, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x86, 0x89, 0x88, 0x85, 0x84, 0x87, 0x83, 0x84, 0x84, 0x7f,
+	  0x79, 0x86, 0x6c, 0x76, 0x91, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 37CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8b, 0x89, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x86, 0x88, 0x88, 0x87, 0x86, 0x87, 0x83, 0x84, 0x84, 0x7f,
+	  0x79, 0x86, 0x6c, 0x76, 0x90, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 39CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8b, 0x89, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x86, 0x88, 0x87, 0x84, 0x84, 0x86, 0x83, 0x85, 0x85, 0x80,
+	  0x79, 0x85, 0x6c, 0x76, 0x90, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 41CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8b, 0x89, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x86, 0x88, 0x87, 0x84, 0x84, 0x86, 0x81, 0x84, 0x83, 0x7f,
+	  0x79, 0x84, 0x6e, 0x79, 0x93, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 44CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8b, 0x89, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x86, 0x88, 0x87, 0x84, 0x84, 0x86, 0x81, 0x84, 0x83, 0x7f,
+	  0x79, 0x84, 0x6e, 0x79, 0x92, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 47CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8b, 0x89, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x86, 0x88, 0x87, 0x84, 0x85, 0x86, 0x81, 0x84, 0x83, 0x7f,
+	  0x79, 0x83, 0x6f, 0x79, 0x91, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 50CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8b, 0x89, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x86, 0x88, 0x87, 0x84, 0x85, 0x86, 0x82, 0x84, 0x83, 0x7f,
+	  0x79, 0x83, 0x6f, 0x79, 0x90, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 53CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8b, 0x89, 0x89, 0x8b, 0x8b,
+	  0x8b, 0x86, 0x88, 0x87, 0x83, 0x83, 0x85, 0x84, 0x85, 0x85, 0x7f,
+	  0x79, 0x83, 0x70, 0x79, 0x8f, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 56CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8b, 0x89, 0x89, 0x8b, 0x8a,
+	  0x8a, 0x87, 0x89, 0x87, 0x83, 0x83, 0x85, 0x84, 0x85, 0x84, 0x7f,
+	  0x79, 0x82, 0x70, 0x7a, 0x8e, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 60CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8b, 0x89, 0x89, 0x8b, 0x8a,
+	  0x8a, 0x87, 0x89, 0x87, 0x83, 0x83, 0x85, 0x84, 0x85, 0x84, 0x7e,
+	  0x79, 0x82, 0x71, 0x7a, 0x8d, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 64CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8b, 0x89, 0x89, 0x8b, 0x8a,
+	  0x8a, 0x86, 0x88, 0x86, 0x84, 0x84, 0x86, 0x82, 0x83, 0x82, 0x80,
+	  0x7a, 0x84, 0x71, 0x7a, 0x8c, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 68CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8a, 0x89, 0x89, 0x8c, 0x8a,
+	  0x8a, 0x86, 0x88, 0x86, 0x84, 0x84, 0x86, 0x82, 0x84, 0x82, 0x81,
+	  0x7b, 0x83, 0x72, 0x7b, 0x8b, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 72CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8a, 0x89, 0x89, 0x8c, 0x8a,
+	  0x8a, 0x86, 0x88, 0x86, 0x85, 0x85, 0x86, 0x82, 0x84, 0x82, 0x81,
+	  0x7b, 0x83, 0x72, 0x7c, 0x8a, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 77CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8a, 0x89, 0x89, 0x8c, 0x8a,
+	  0x8a, 0x85, 0x87, 0x85, 0x85, 0x87, 0x87, 0x82, 0x84, 0x82, 0x81,
+	  0x7c, 0x82, 0x72, 0x7c, 0x89, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 82CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8a, 0x89, 0x89, 0x8c, 0x8a,
+	  0x8a, 0x85, 0x87, 0x85, 0x85, 0x87, 0x87, 0x82, 0x84, 0x82, 0x81,
+	  0x7c, 0x82, 0x73, 0x7c, 0x88, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 87CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8a, 0x89, 0x89, 0x8c, 0x8a,
+	  0x8a, 0x85, 0x87, 0x85, 0x84, 0x84, 0x86, 0x80, 0x84, 0x81, 0x80,
+	  0x7a, 0x82, 0x76, 0x7f, 0x89, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 93CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8a, 0x89, 0x89, 0x8b, 0x8a,
+	  0x8a, 0x86, 0x87, 0x85, 0x84, 0x85, 0x86, 0x80, 0x84, 0x80, 0x80,
+	  0x7a, 0x82, 0x76, 0x80, 0x88, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 98CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x8a, 0x89, 0x89, 0x8b, 0x8a,
+	  0x8a, 0x86, 0x87, 0x85, 0x85, 0x85, 0x86, 0x80, 0x84, 0x80, 0x80,
+	  0x7a, 0x82, 0x76, 0x80, 0x88, 0x33, 0x2f, 0x22, 0x00, 0x00, 0x00 },
+	/* 105CD */
+	{ 0x00, 0xc8, 0x00, 0xc4, 0x00, 0xc5, 0x89, 0x88, 0x88, 0x8b, 0x8a,
+	  0x8a, 0x84, 0x87, 0x85, 0x85, 0x85, 0x85, 0x80, 0x84, 0x80, 0x7f,
+	  0x79, 0x81, 0x71, 0x7d, 0x87, 0x38, 0x32, 0x24, 0x00, 0x00, 0x00 },
+	/* 111CD */
+	{ 0x00, 0xdf, 0x00, 0xde, 0x00, 0xde, 0x85, 0x85, 0x84, 0x87, 0x86,
+	  0x87, 0x85, 0x86, 0x85, 0x83, 0x83, 0x83, 0x81, 0x82, 0x82, 0x80,
+	  0x7d, 0x82, 0x75, 0x7f, 0x86, 0x85, 0x85, 0x82, 0x00, 0x00, 0x00 },
+	/* 119CD */
+	{ 0x00, 0xe3, 0x00, 0xe1, 0x00, 0xe2, 0x85, 0x85, 0x84, 0x86, 0x85,
+	  0x85, 0x84, 0x85, 0x84, 0x83, 0x83, 0x83, 0x82, 0x82, 0x82, 0x7e,
+	  0x7b, 0x81, 0x75, 0x7f, 0x86, 0x85, 0x85, 0x82, 0x00, 0x00, 0x00 },
+	/* 126CD */
+	{ 0x00, 0xe6, 0x00, 0xe5, 0x00, 0xe5, 0x85, 0x84, 0x84, 0x85, 0x85,
+	  0x85, 0x84, 0x84, 0x84, 0x82, 0x83, 0x83, 0x80, 0x81, 0x81, 0x80,
+	  0x7f, 0x83, 0x73, 0x7c, 0x84, 0x85, 0x85, 0x82, 0x00, 0x00, 0x00 },
+	/* 134CD */
+	{ 0x00, 0xe9, 0x00, 0xe8, 0x00, 0xe8, 0x84, 0x84, 0x83, 0x85, 0x85,
+	  0x85, 0x84, 0x84, 0x83, 0x81, 0x82, 0x82, 0x81, 0x81, 0x81, 0x7f,
+	  0x7d, 0x81, 0x73, 0x7c, 0x83, 0x85, 0x85, 0x82, 0x00, 0x00, 0x00 },
+	/* 143CD */
+	{ 0x00, 0xed, 0x00, 0xec, 0x00, 0xec, 0x84, 0x83, 0x83, 0x84, 0x84,
+	  0x84, 0x84, 0x84, 0x83, 0x82, 0x83, 0x83, 0x81, 0x80, 0x81, 0x7f,
+	  0x7e, 0x81, 0x70, 0x79, 0x81, 0x85, 0x85, 0x82, 0x00, 0x00, 0x00 },
+	/* 152CD */
+	{ 0x00, 0xf0, 0x00, 0xf0, 0x00, 0xf0, 0x83, 0x83, 0x83, 0x83, 0x83,
+	  0x83, 0x84, 0x84, 0x83, 0x81, 0x81, 0x81, 0x80, 0x80, 0x81, 0x80,
+	  0x80, 0x82, 0x6f, 0x78, 0x7f, 0x85, 0x85, 0x82, 0x00, 0x00, 0x00 },
+	/* 162CD */
+	{ 0x00, 0xf4, 0x00, 0xf3, 0x00, 0xf4, 0x83, 0x83, 0x83, 0x83, 0x83,
+	  0x83, 0x82, 0x81, 0x81, 0x81, 0x81, 0x81, 0x80, 0x80, 0x81, 0x80,
+	  0x7f, 0x82, 0x6f, 0x78, 0x7f, 0x85, 0x85, 0x82, 0x00, 0x00, 0x00 },
+	/* 172CD */
+	{ 0x00, 0xf8, 0x00, 0xf8, 0x00, 0xf8, 0x82, 0x82, 0x82, 0x82, 0x82,
+	  0x82, 0x82, 0x81, 0x81, 0x80, 0x81, 0x80, 0x80, 0x80, 0x81, 0x81,
+	  0x80, 0x83, 0x6d, 0x76, 0x7d, 0x85, 0x85, 0x82, 0x00, 0x00, 0x00 },
+	/* 183CD */
+	{ 0x00, 0xe0, 0x00, 0xdf, 0x00, 0xdf, 0x84, 0x84, 0x83, 0x86, 0x86,
+	  0x86, 0x83, 0x84, 0x83, 0x82, 0x82, 0x82, 0x81, 0x83, 0x81, 0x81,
+	  0x7e, 0x81, 0x80, 0x82, 0x84, 0x85, 0x85, 0x82, 0x00, 0x00, 0x00 },
+	/* 195CD */
+	{ 0x00, 0xe4, 0x00, 0xe3, 0x00, 0xe3, 0x84, 0x83, 0x83, 0x85, 0x85,
+	  0x85, 0x83, 0x84, 0x83, 0x81, 0x82, 0x82, 0x82, 0x83, 0x81, 0x81,
+	  0x80, 0x82, 0x7d, 0x7f, 0x81, 0x85, 0x85, 0x82, 0x00, 0x00, 0x00 },
+	/* 207CD */
+	{ 0x00, 0xe7, 0x00, 0xe6, 0x00, 0xe6, 0x83, 0x82, 0x82, 0x85, 0x85,
+	  0x85, 0x82, 0x83, 0x83, 0x82, 0x82, 0x82, 0x80, 0x81, 0x80, 0x81,
+	  0x80, 0x82, 0x7d, 0x7f, 0x81, 0x85, 0x85, 0x82, 0x00, 0x00, 0x00 },
+	/* 220CD */
+	{ 0x00, 0xeb, 0x00, 0xea, 0x00, 0xea, 0x83, 0x83, 0x82, 0x84, 0x84,
+	  0x84, 0x82, 0x83, 0x82, 0x81, 0x81, 0x82, 0x81, 0x82, 0x81, 0x80,
+	  0x7e, 0x80, 0x7d, 0x7f, 0x81, 0x85, 0x85, 0x82, 0x00, 0x00, 0x00 },
+	/* 234CD */
+	{ 0x00, 0xef, 0x00, 0xee, 0x00, 0xee, 0x83, 0x82, 0x82, 0x83, 0x83,
+	  0x83, 0x82, 0x82, 0x82, 0x81, 0x81, 0x81, 0x80, 0x80, 0x80, 0x80,
+	  0x80, 0x81, 0x7b, 0x7c, 0x7f, 0x85, 0x85, 0x82, 0x00, 0x00, 0x00 },
+	/* 249CD */
+	{ 0x00, 0xf3, 0x00, 0xf2, 0x00, 0xf2, 0x82, 0x81, 0x81, 0x83, 0x83,
+	  0x83, 0x82, 0x82, 0x82, 0x81, 0x81, 0x81, 0x80, 0x81, 0x80, 0x7f,
+	  0x7e, 0x7f, 0x7b, 0x7c, 0x7f, 0x85, 0x85, 0x82, 0x00, 0x00, 0x00 },
+	/* 265CD */
+	{ 0x00, 0xf7, 0x00, 0xf7, 0x00, 0xf7, 0x81, 0x81, 0x80, 0x82, 0x82,
+	  0x82, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x81, 0x80, 0x7f,
+	  0x7e, 0x7f, 0x7b, 0x7c, 0x7f, 0x85, 0x85, 0x82, 0x00, 0x00, 0x00 },
+	/* 282CD */
+	{ 0x00, 0xfb, 0x00, 0xfb, 0x00, 0xfb, 0x80, 0x80, 0x80, 0x81, 0x81,
+	  0x81, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x7f, 0x7f, 0x7f, 0x7f,
+	  0x7f, 0x7f, 0x78, 0x79, 0x7d, 0x85, 0x85, 0x82, 0x00, 0x00, 0x00 },
+	/* 300CD */
+	{ 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80,
+	  0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+	  0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00 },
+};
+
+static int s6e88a0_ams427ap24_set_brightness(struct backlight_device *bd)
+{
+	struct s6e88a0_ams427ap24 *ctx = bl_get_data(bd);
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int brightness = bd->props.brightness;
+	int candela_enum;
+	u8 b2[SEQ_LENGTH_AID], b6[SEQ_LENGTH_ELVSS], ca[SEQ_LENGTH_GAMMA];
+
+	/* get candela enum from brightness */
+	for (candela_enum = 0; candela_enum < NUM_STEPS_CANDELA; candela_enum++)
+		if (brightness <= s6e88a0_ams427ap24_br_to_cd[candela_enum])
+			break;
+
+	/* get aid */
+	switch (candela_enum) {
+	case CANDELA_10CD ... CANDELA_105CD:
+		memcpy(b2, s6e88a0_ams427ap24_aid[candela_enum], sizeof(b2));
+		break;
+	case CANDELA_111CD ... CANDELA_172CD:
+		memcpy(b2, s6e88a0_ams427ap24_aid[CANDELA_111CD], sizeof(b2));
+		break;
+	case CANDELA_183CD ... CANDELA_300CD:
+		memcpy(b2, s6e88a0_ams427ap24_aid[CANDELA_111CD + 1], sizeof(b2));
+		break;
+	default:
+		dev_err(dev, "Failed to get aid data\n");
+		return -EINVAL;
+	}
+
+	/* get elvss */
+	if (candela_enum <= CANDELA_111CD) {
+		memcpy(b6, s6e88a0_ams427ap24_elvss[0], sizeof(b6));
+	} else {
+		memcpy(b6, s6e88a0_ams427ap24_elvss[candela_enum - CANDELA_111CD],
+		       sizeof(b6));
+	}
+
+	/* get gamma */
+	memcpy(ca, s6e88a0_ams427ap24_gamma[candela_enum], sizeof(ca));
+
+	/* write data */
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x5a, 0x5a);		/* level 1 key on */
+	mipi_dsi_dcs_write(dsi, 0xb2, b2, ARRAY_SIZE(b2));	/* aid */
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0x00);		/* acl off */
+	mipi_dsi_dcs_write(dsi, 0xb6, b6, ARRAY_SIZE(b6));	/* elvss */
+	mipi_dsi_dcs_write(dsi, 0xca, ca, ARRAY_SIZE(ca));	/* gamma */
+	mipi_dsi_dcs_write_seq(dsi, 0xf7, 0x03);		/* gamma update */
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0xa5, 0xa5);		/* level 1 key off */
+
+	return 0;
+}
+
+static void s6e88a0_ams427ap24_reset(struct s6e88a0_ams427ap24 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(18000, 19000);
+}
+
+static int s6e88a0_ams427ap24_on(struct s6e88a0_ams427ap24 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xfc, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0xfd, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x13);
+	mipi_dsi_dcs_write_seq(dsi, 0xfd, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0x30);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	mipi_dsi_dcs_write_seq(dsi, 0xf1, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0x4c);
+	mipi_dsi_dcs_write_seq(dsi, 0xf2, 0x03, 0x0d);
+	mipi_dsi_dcs_write_seq(dsi, 0xf1, 0xa5, 0xa5);
+
+	if (ctx->flip_horizontal)
+		mipi_dsi_dcs_write_seq(dsi, 0xcb, 0x0e);
+
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0xa5, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, 0xfc, 0xa5, 0xa5);
+
+	ret = s6e88a0_ams427ap24_set_brightness(ctx->bl_dev);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set brightness: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int s6e88a0_ams427ap24_off(struct s6e88a0_ams427ap24 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int s6e88a0_ams427ap24_prepare(struct drm_panel *panel)
+{
+	struct s6e88a0_ams427ap24 *ctx = to_s6e88a0_ams427ap24(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	s6e88a0_ams427ap24_reset(ctx);
+
+	ret = s6e88a0_ams427ap24_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int s6e88a0_ams427ap24_unprepare(struct drm_panel *panel)
+{
+	struct s6e88a0_ams427ap24 *ctx = to_s6e88a0_ams427ap24(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = s6e88a0_ams427ap24_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode s6e88a0_ams427ap24_mode = {
+	.clock = (540 + 94 + 4 + 18) * (960 + 12 + 1 + 3) * 60 / 1000,
+	.hdisplay = 540,
+	.hsync_start = 540 + 94,
+	.hsync_end = 540 + 94 + 4,
+	.htotal = 540 + 94 + 4 + 18,
+	.vdisplay = 960,
+	.vsync_start = 960 + 12,
+	.vsync_end = 960 + 12 + 1,
+	.vtotal = 960 + 12 + 1 + 3,
+	.width_mm = 55,
+	.height_mm = 95,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int s6e88a0_ams427ap24_get_modes(struct drm_panel *panel,
+					struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &s6e88a0_ams427ap24_mode);
+}
+
+static const struct drm_panel_funcs s6e88a0_ams427ap24_panel_funcs = {
+	.prepare = s6e88a0_ams427ap24_prepare,
+	.unprepare = s6e88a0_ams427ap24_unprepare,
+	.get_modes = s6e88a0_ams427ap24_get_modes,
+};
+
+static const struct backlight_ops s6e88a0_ams427ap24_bl_ops = {
+	.update_status	= s6e88a0_ams427ap24_set_brightness,
+};
+
+static int s6e88a0_ams427ap24_register_backlight(struct s6e88a0_ams427ap24 *ctx)
+{
+	struct backlight_properties props = {
+		.type		= BACKLIGHT_RAW,
+		.brightness	= 180,
+		.max_brightness = 255,
+	};
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret = 0;
+
+	ctx->bl_dev = devm_backlight_device_register(dev, dev_name(dev), dev, ctx,
+						     &s6e88a0_ams427ap24_bl_ops,
+						     &props);
+	if (IS_ERR(ctx->bl_dev)) {
+		ret = PTR_ERR(ctx->bl_dev);
+		dev_err(dev, "error registering backlight device (%d)\n", ret);
+	}
+
+	return ret;
+}
+
+static void s6e88a0_ams427ap24_parse_dt(struct s6e88a0_ams427ap24 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	struct device_node *np = dev->of_node;
+
+	ctx->flip_horizontal = of_property_read_bool(np, "flip-horizontal");
+}
+
+static int s6e88a0_ams427ap24_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct s6e88a0_ams427ap24 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vdd3";
+	ctx->supplies[1].supply = "vci";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 2;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_NO_EOT_PACKET | MIPI_DSI_MODE_VIDEO_NO_HFP;
+
+	drm_panel_init(&ctx->panel, dev, &s6e88a0_ams427ap24_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	s6e88a0_ams427ap24_parse_dt(ctx);
+
+	ret = s6e88a0_ams427ap24_register_backlight(ctx);
+	if (ret < 0)
+		return ret;
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void s6e88a0_ams427ap24_remove(struct mipi_dsi_device *dsi)
+{
+	struct s6e88a0_ams427ap24 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id s6e88a0_ams427ap24_of_match[] = {
+	{ .compatible = "samsung,s6e88a0-ams427ap24" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, s6e88a0_ams427ap24_of_match);
+
+static struct mipi_dsi_driver s6e88a0_ams427ap24_driver = {
+	.probe = s6e88a0_ams427ap24_probe,
+	.remove = s6e88a0_ams427ap24_remove,
+	.driver = {
+		.name = "panel-samsung-s6e88a0-ams427ap24",
+		.of_match_table = s6e88a0_ams427ap24_of_match,
+	},
+};
+module_mipi_dsi_driver(s6e88a0_ams427ap24_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for ss_dsi_panel_S6E88A0_AMS427AP24_QHD");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6e8aa5x01-ams497hy01.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6e8aa5x01-ams497hy01.c
new file mode 100644
index 000000000000..30f7973d07ce
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6e8aa5x01-ams497hy01.c
@@ -0,0 +1,250 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct s6e8aa5x01_ams497hy01 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline
+struct s6e8aa5x01_ams497hy01 *to_s6e8aa5x01_ams497hy01(struct drm_panel *panel)
+{
+	return container_of(panel, struct s6e8aa5x01_ams497hy01, panel);
+}
+
+static void s6e8aa5x01_ams497hy01_reset(struct s6e8aa5x01_ams497hy01 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int s6e8aa5x01_ams497hy01_on(struct s6e8aa5x01_ams497hy01 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0x4c);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	mipi_dsi_dcs_write_seq(dsi, 0xca,
+			       0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x80, 0x80,
+			       0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+			       0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+			       0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00,
+			       0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0x00, 0x0f, 0x00, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0xb6, 0xbc, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0xf7, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xf7, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0xd8, 0xd8, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0xb8,
+			       0x38, 0x00, 0x00, 0x60, 0x44, 0x00, 0xa8);
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0xa5, 0xa5);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int s6e8aa5x01_ams497hy01_off(struct s6e8aa5x01_ams497hy01 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(35);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int s6e8aa5x01_ams497hy01_prepare(struct drm_panel *panel)
+{
+	struct s6e8aa5x01_ams497hy01 *ctx = to_s6e8aa5x01_ams497hy01(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	s6e8aa5x01_ams497hy01_reset(ctx);
+
+	ret = s6e8aa5x01_ams497hy01_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int s6e8aa5x01_ams497hy01_unprepare(struct drm_panel *panel)
+{
+	struct s6e8aa5x01_ams497hy01 *ctx = to_s6e8aa5x01_ams497hy01(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = s6e8aa5x01_ams497hy01_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode s6e8aa5x01_ams497hy01_mode = {
+	.clock = (720 + 226 + 20 + 100) * (1280 + 14 + 2 + 8) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 226,
+	.hsync_end = 720 + 226 + 20,
+	.htotal = 720 + 226 + 20 + 100,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 14,
+	.vsync_end = 1280 + 14 + 2,
+	.vtotal = 1280 + 14 + 2 + 8,
+	.width_mm = 62,
+	.height_mm = 106,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int s6e8aa5x01_ams497hy01_get_modes(struct drm_panel *panel,
+					   struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &s6e8aa5x01_ams497hy01_mode);
+}
+
+static const struct drm_panel_funcs s6e8aa5x01_ams497hy01_panel_funcs = {
+	.prepare = s6e8aa5x01_ams497hy01_prepare,
+	.unprepare = s6e8aa5x01_ams497hy01_unprepare,
+	.get_modes = s6e8aa5x01_ams497hy01_get_modes,
+};
+
+static int s6e8aa5x01_ams497hy01_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct s6e8aa5x01_ams497hy01 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vdd3";
+	ctx->supplies[1].supply = "vci";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_NO_HFP;
+
+	drm_panel_init(&ctx->panel, dev, &s6e8aa5x01_ams497hy01_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void s6e8aa5x01_ams497hy01_remove(struct mipi_dsi_device *dsi)
+{
+	struct s6e8aa5x01_ams497hy01 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id s6e8aa5x01_ams497hy01_of_match[] = {
+	{ .compatible = "samsung,s6e8aa5x01-ams497hy01" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, s6e8aa5x01_ams497hy01_of_match);
+
+static struct mipi_dsi_driver s6e8aa5x01_ams497hy01_driver = {
+	.probe = s6e8aa5x01_ams497hy01_probe,
+	.remove = s6e8aa5x01_ams497hy01_remove,
+	.driver = {
+		.name = "panel-samsung-s6e8aa5x01-ams497hy01",
+		.of_match_table = s6e8aa5x01_ams497hy01_of_match,
+	},
+};
+module_mipi_dsi_driver(s6e8aa5x01_ams497hy01_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for ss_dsi_panel_S6E8AA5X01_AMS497HY01_720p");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6e8aa5x01-ams520kt01.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6e8aa5x01-ams520kt01.c
new file mode 100644
index 000000000000..444557f8e087
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-s6e8aa5x01-ams520kt01.c
@@ -0,0 +1,250 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct s6e8aa5x01_ams520kt01 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline
+struct s6e8aa5x01_ams520kt01 *to_s6e8aa5x01_ams520kt01(struct drm_panel *panel)
+{
+	return container_of(panel, struct s6e8aa5x01_ams520kt01, panel);
+}
+
+static void s6e8aa5x01_ams520kt01_reset(struct s6e8aa5x01_ams520kt01 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int s6e8aa5x01_ams520kt01_on(struct s6e8aa5x01_ams520kt01 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0x4c);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	mipi_dsi_dcs_write_seq(dsi, 0xca,
+			       0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x80, 0x80,
+			       0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+			       0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+			       0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00,
+			       0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0x04, 0xee);
+	mipi_dsi_dcs_write_seq(dsi, 0xb6, 0xac, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0xf7, 0x03);
+	usleep_range(16000, 17000);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0xd8, 0xd8, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0xa8);
+	msleep(120);
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0xa5, 0xa5);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int s6e8aa5x01_ams520kt01_off(struct s6e8aa5x01_ams520kt01 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int s6e8aa5x01_ams520kt01_prepare(struct drm_panel *panel)
+{
+	struct s6e8aa5x01_ams520kt01 *ctx = to_s6e8aa5x01_ams520kt01(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	s6e8aa5x01_ams520kt01_reset(ctx);
+
+	ret = s6e8aa5x01_ams520kt01_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int s6e8aa5x01_ams520kt01_unprepare(struct drm_panel *panel)
+{
+	struct s6e8aa5x01_ams520kt01 *ctx = to_s6e8aa5x01_ams520kt01(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = s6e8aa5x01_ams520kt01_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode s6e8aa5x01_ams520kt01_mode = {
+	.clock = (720 + 224 + 20 + 100) * (1280 + 14 + 2 + 8) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 224,
+	.hsync_end = 720 + 224 + 20,
+	.htotal = 720 + 224 + 20 + 100,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 14,
+	.vsync_end = 1280 + 14 + 2,
+	.vtotal = 1280 + 14 + 2 + 8,
+	.width_mm = 65,
+	.height_mm = 115,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int s6e8aa5x01_ams520kt01_get_modes(struct drm_panel *panel,
+					   struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &s6e8aa5x01_ams520kt01_mode);
+}
+
+static const struct drm_panel_funcs s6e8aa5x01_ams520kt01_panel_funcs = {
+	.prepare = s6e8aa5x01_ams520kt01_prepare,
+	.unprepare = s6e8aa5x01_ams520kt01_unprepare,
+	.get_modes = s6e8aa5x01_ams520kt01_get_modes,
+};
+
+static int s6e8aa5x01_ams520kt01_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct s6e8aa5x01_ams520kt01 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vdd3";
+	ctx->supplies[1].supply = "vci";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_NO_HFP;
+
+	drm_panel_init(&ctx->panel, dev, &s6e8aa5x01_ams520kt01_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void s6e8aa5x01_ams520kt01_remove(struct mipi_dsi_device *dsi)
+{
+	struct s6e8aa5x01_ams520kt01 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id s6e8aa5x01_ams520kt01_of_match[] = {
+	{ .compatible = "samsung,s6e8aa5x01-ams520kt01" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, s6e8aa5x01_ams520kt01_of_match);
+
+static struct mipi_dsi_driver s6e8aa5x01_ams520kt01_driver = {
+	.probe = s6e8aa5x01_ams520kt01_probe,
+	.remove = s6e8aa5x01_ams520kt01_remove,
+	.driver = {
+		.name = "panel-samsung-s6e8aa5x01-ams520kt01",
+		.of_match_table = s6e8aa5x01_ams520kt01_of_match,
+	},
+};
+module_mipi_dsi_driver(s6e8aa5x01_ams520kt01_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for ss_dsi_panel_S6E8AA5X01_AMS520KT01_HD");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-sc7798a-bv045wvm.c b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-sc7798a-bv045wvm.c
new file mode 100644
index 000000000000..08bc942d4733
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-samsung-sc7798a-bv045wvm.c
@@ -0,0 +1,308 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct sc7798a_bv045wvm {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline
+struct sc7798a_bv045wvm *to_sc7798a_bv045wvm(struct drm_panel *panel)
+{
+	return container_of(panel, struct sc7798a_bv045wvm, panel);
+}
+
+static void sc7798a_bv045wvm_reset(struct sc7798a_bv045wvm *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(150);
+}
+
+static int sc7798a_bv045wvm_on(struct sc7798a_bv045wvm *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0xf1, 0x08, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1,
+			       0x31, 0x0c, 0x0c, 0xa7, 0x33, 0x01, 0xb7);
+	mipi_dsi_dcs_write_seq(dsi, 0xc6, 0x00, 0x00, 0xfd);
+	mipi_dsi_dcs_write_seq(dsi, 0xe3, 0x03, 0x03, 0x03, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xb8, 0x06, 0x22);
+	usleep_range(10000, 11000);
+	mipi_dsi_dcs_write_seq(dsi, 0xba,
+			       0x31, 0x00, 0x44, 0x25, 0x91, 0x0a, 0x00, 0x00,
+			       0xc2, 0x34, 0x00, 0x00, 0x04, 0x02, 0x1d, 0xb9,
+			       0xee, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3,
+			       0x00, 0x00, 0x00, 0x00, 0x0c, 0x0a, 0x25, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0x0e);
+	mipi_dsi_dcs_write_seq(dsi, 0xbc, 0x67);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x73, 0x50, 0x00, 0x08, 0x70);
+	mipi_dsi_dcs_write_seq(dsi, 0xe9,
+			       0x00, 0x00, 0x06, 0x00, 0x00, 0x6e, 0x29, 0x12,
+			       0x30, 0x00, 0x48, 0x08, 0x6e, 0x29, 0x47, 0x03,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00,
+			       0x89, 0x98, 0x33, 0x11, 0x77, 0x55, 0x13, 0x00,
+			       0x00, 0x89, 0x98, 0x22, 0x00, 0x66, 0x44, 0x02,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xea,
+			       0x00, 0x00, 0x98, 0x98, 0x44, 0x66, 0x00, 0x22,
+			       0x20, 0x00, 0x00, 0x98, 0x98, 0x55, 0x77, 0x11,
+			       0x33, 0x31, 0x30, 0x00, 0x00, 0xff, 0x01, 0x00,
+			       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			       0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xe0,
+			       0x01, 0x09, 0x0d, 0x2e, 0x36, 0x3f, 0x10, 0x31,
+			       0x07, 0x0d, 0x11, 0x15, 0x13, 0x16, 0x15, 0x32,
+			       0x38, 0x01, 0x05, 0x05, 0x30, 0x35, 0x3f, 0x0e,
+			       0x30, 0x04, 0x09, 0x0a, 0x0d, 0x12, 0x0d, 0x0f,
+			       0x2c, 0x35);
+	mipi_dsi_dcs_write_seq(dsi, 0xc7, 0xc0);
+	mipi_dsi_dcs_write_seq(dsi, 0xc8, 0x11, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+static int sc7798a_bv045wvm_off(struct sc7798a_bv045wvm *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0x28, 0x00);
+	msleep(70);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x00);
+	msleep(70);
+
+	return 0;
+}
+
+static int sc7798a_bv045wvm_prepare(struct drm_panel *panel)
+{
+	struct sc7798a_bv045wvm *ctx = to_sc7798a_bv045wvm(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	sc7798a_bv045wvm_reset(ctx);
+
+	ret = sc7798a_bv045wvm_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sc7798a_bv045wvm_unprepare(struct drm_panel *panel)
+{
+	struct sc7798a_bv045wvm *ctx = to_sc7798a_bv045wvm(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = sc7798a_bv045wvm_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode sc7798a_bv045wvm_mode = {
+	.clock = (480 + 140 + 4 + 132) * (800 + 10 + 4 + 12) * 60 / 1000,
+	.hdisplay = 480,
+	.hsync_start = 480 + 140,
+	.hsync_end = 480 + 140 + 4,
+	.htotal = 480 + 140 + 4 + 132,
+	.vdisplay = 800,
+	.vsync_start = 800 + 10,
+	.vsync_end = 800 + 10 + 4,
+	.vtotal = 800 + 10 + 4 + 12,
+	.width_mm = 62,
+	.height_mm = 106,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int sc7798a_bv045wvm_get_modes(struct drm_panel *panel,
+				      struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &sc7798a_bv045wvm_mode);
+}
+
+static const struct drm_panel_funcs sc7798a_bv045wvm_panel_funcs = {
+	.prepare = sc7798a_bv045wvm_prepare,
+	.unprepare = sc7798a_bv045wvm_unprepare,
+	.get_modes = sc7798a_bv045wvm_get_modes,
+};
+
+static int sc7798a_bv045wvm_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+static const struct backlight_ops sc7798a_bv045wvm_bl_ops = {
+	.update_status = sc7798a_bv045wvm_bl_update_status,
+};
+
+static struct backlight_device *
+sc7798a_bv045wvm_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 255,
+		.max_brightness = 255,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &sc7798a_bv045wvm_bl_ops, &props);
+}
+
+static int sc7798a_bv045wvm_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct sc7798a_bv045wvm *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vddio";
+	ctx->supplies[1].supply = "vdd";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 2;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &sc7798a_bv045wvm_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ctx->panel.backlight = sc7798a_bv045wvm_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void sc7798a_bv045wvm_remove(struct mipi_dsi_device *dsi)
+{
+	struct sc7798a_bv045wvm *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id sc7798a_bv045wvm_of_match[] = {
+	{ .compatible = "samsung,sc7798a-bv045wvm" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, sc7798a_bv045wvm_of_match);
+
+static struct mipi_dsi_driver sc7798a_bv045wvm_driver = {
+	.probe = sc7798a_bv045wvm_probe,
+	.remove = sc7798a_bv045wvm_remove,
+	.driver = {
+		.name = "panel-samsung-sc7798a-bv045wvm",
+		.of_match_table = sc7798a_bv045wvm_of_match,
+	},
+};
+module_mipi_dsi_driver(sc7798a_bv045wvm_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for SC7798A wvga video mode dsi panel");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-auo-nt35521.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-auo-nt35521.c
new file mode 100644
index 000000000000..c9f8eb926ae3
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-auo-nt35521.c
@@ -0,0 +1,244 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct nt35521 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct nt35521 *to_nt35521(struct drm_panel *panel)
+{
+	return container_of(panel, struct nt35521, panel);
+}
+
+static void nt35521_reset(struct nt35521 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(30);
+}
+
+static int nt35521_on(struct nt35521 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc8, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xef, 0x11, 0x08, 0x16, 0x19);
+	mipi_dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xb5, 0x04, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0x35, 0x35);
+	mipi_dsi_dcs_write_seq(dsi, 0xba, 0x25, 0x25);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nt35521_off(struct nt35521 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nt35521_prepare(struct drm_panel *panel)
+{
+	struct nt35521 *ctx = to_nt35521(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	nt35521_reset(ctx);
+
+	ret = nt35521_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nt35521_unprepare(struct drm_panel *panel)
+{
+	struct nt35521 *ctx = to_nt35521(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = nt35521_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode nt35521_mode = {
+	.clock = (720 + 160 + 20 + 160) * (1280 + 16 + 2 + 16) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 160,
+	.hsync_end = 720 + 160 + 20,
+	.htotal = 720 + 160 + 20 + 160,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 16,
+	.vsync_end = 1280 + 16 + 2,
+	.vtotal = 1280 + 16 + 2 + 16,
+	.width_mm = 58,
+	.height_mm = 103,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int nt35521_get_modes(struct drm_panel *panel,
+			     struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &nt35521_mode);
+}
+
+static const struct drm_panel_funcs nt35521_panel_funcs = {
+	.prepare = nt35521_prepare,
+	.unprepare = nt35521_unprepare,
+	.get_modes = nt35521_get_modes,
+};
+
+static int nt35521_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct nt35521 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 3;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS |
+			  MIPI_DSI_MODE_VIDEO_NO_HFP |
+			  MIPI_DSI_MODE_VIDEO_NO_HBP |
+			  MIPI_DSI_MODE_VIDEO_NO_HSA;
+
+	drm_panel_init(&ctx->panel, dev, &nt35521_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void nt35521_remove(struct mipi_dsi_device *dsi)
+{
+	struct nt35521 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id nt35521_of_match[] = {
+	{ .compatible = "wingtech,auo-nt35521" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, nt35521_of_match);
+
+static struct mipi_dsi_driver nt35521_driver = {
+	.probe = nt35521_probe,
+	.remove = nt35521_remove,
+	.driver = {
+		.name = "panel-wingtech-auo-nt35521",
+		.of_match_table = nt35521_of_match,
+	},
+};
+module_mipi_dsi_driver(nt35521_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for nt35521_HD720p_video_AUO5");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-auo-r61308.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-auo-r61308.c
new file mode 100644
index 000000000000..aff7880f736d
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-auo-r61308.c
@@ -0,0 +1,265 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct r61308 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct r61308 *to_r61308(struct drm_panel *panel)
+{
+	return container_of(panel, struct r61308, panel);
+}
+
+static void r61308_reset(struct r61308 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(30);
+}
+
+static int r61308_on(struct r61308 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0x00);
+
+	ret = mipi_dsi_dcs_set_pixel_format(dsi, 0x07);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set pixel format: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x04);
+	mipi_dsi_generic_write_seq(dsi, 0xc1,
+				   0x50, 0x02, 0x22, 0x00, 0x00, 0xed, 0x11);
+	mipi_dsi_generic_write_seq(dsi, 0xc8,
+				   0x1a, 0x24, 0x29, 0x2d, 0x32, 0x37, 0x14,
+				   0x13, 0x10, 0x0c, 0x0a, 0x06, 0x1a, 0x24,
+				   0x28, 0x2d, 0x32, 0x37, 0x14, 0x13, 0x10,
+				   0x0c, 0x0a, 0x06);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x10, 0x20, 0x40, 0x80, 0xa0, 0xc0, 0xd0,
+				   0xe0);
+	mipi_dsi_generic_write_seq(dsi, 0xcc, 0xc8, 0xd8, 0xff);
+	mipi_dsi_generic_write_seq(dsi, 0xcd,
+				   0x1c, 0x1e, 0x1e, 0x1d, 0x1c, 0x1e, 0x1e);
+	mipi_dsi_generic_write_seq(dsi, 0xce,
+				   0x1e, 0x1e, 0x1e, 0x1d, 0x1d, 0x1e, 0x1e);
+	mipi_dsi_generic_write_seq(dsi, 0xcf,
+				   0x1e, 0x1f, 0x20, 0x20, 0x20, 0x20, 0x21);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x03);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+static int r61308_off(struct r61308 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int r61308_prepare(struct drm_panel *panel)
+{
+	struct r61308 *ctx = to_r61308(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	r61308_reset(ctx);
+
+	ret = r61308_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int r61308_unprepare(struct drm_panel *panel)
+{
+	struct r61308 *ctx = to_r61308(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = r61308_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode r61308_mode = {
+	.clock = (720 + 120 + 2 + 50) * (1280 + 6 + 1 + 14) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 120,
+	.hsync_end = 720 + 120 + 2,
+	.htotal = 720 + 120 + 2 + 50,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 6,
+	.vsync_end = 1280 + 6 + 1,
+	.vtotal = 1280 + 6 + 1 + 14,
+	.width_mm = 58,
+	.height_mm = 103,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int r61308_get_modes(struct drm_panel *panel,
+			    struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &r61308_mode);
+}
+
+static const struct drm_panel_funcs r61308_panel_funcs = {
+	.prepare = r61308_prepare,
+	.unprepare = r61308_unprepare,
+	.get_modes = r61308_get_modes,
+};
+
+static int r61308_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct r61308 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 3;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &r61308_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void r61308_remove(struct mipi_dsi_device *dsi)
+{
+	struct r61308 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id r61308_of_match[] = {
+	{ .compatible = "wingtech,auo-r61308" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, r61308_of_match);
+
+static struct mipi_dsi_driver r61308_driver = {
+	.probe = r61308_probe,
+	.remove = r61308_remove,
+	.driver = {
+		.name = "panel-wingtech-auo-r61308",
+		.of_match_table = r61308_of_match,
+	},
+};
+module_mipi_dsi_driver(r61308_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for r61308_HD720p_video_AUO3.5");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-boe-hx8394f.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-boe-hx8394f.c
new file mode 100644
index 000000000000..d7497c383daa
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-boe-hx8394f.c
@@ -0,0 +1,239 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct hx8394f {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct hx8394f *to_hx8394f(struct drm_panel *panel)
+{
+	return container_of(panel, struct hx8394f, panel);
+}
+
+static void hx8394f_reset(struct hx8394f *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(50);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+}
+
+static int hx8394f_on(struct hx8394f *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0xff, 0x83, 0x94);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	return 0;
+}
+
+static int hx8394f_off(struct hx8394f *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int hx8394f_prepare(struct drm_panel *panel)
+{
+	struct hx8394f *ctx = to_hx8394f(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	hx8394f_reset(ctx);
+
+	ret = hx8394f_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hx8394f_unprepare(struct drm_panel *panel)
+{
+	struct hx8394f *ctx = to_hx8394f(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = hx8394f_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode hx8394f_mode = {
+	.clock = (720 + 64 + 30 + 54) * (1280 + 8 + 2 + 12) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 64,
+	.hsync_end = 720 + 64 + 30,
+	.htotal = 720 + 64 + 30 + 54,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 8,
+	.vsync_end = 1280 + 8 + 2,
+	.vtotal = 1280 + 8 + 2 + 12,
+	.width_mm = 65,
+	.height_mm = 118,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int hx8394f_get_modes(struct drm_panel *panel,
+			     struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &hx8394f_mode);
+}
+
+static const struct drm_panel_funcs hx8394f_panel_funcs = {
+	.prepare = hx8394f_prepare,
+	.unprepare = hx8394f_unprepare,
+	.get_modes = hx8394f_get_modes,
+};
+
+static int hx8394f_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct hx8394f *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &hx8394f_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void hx8394f_remove(struct mipi_dsi_device *dsi)
+{
+	struct hx8394f *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id hx8394f_of_match[] = {
+	{ .compatible = "wingtech,boe-hx8394f" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, hx8394f_of_match);
+
+static struct mipi_dsi_driver hx8394f_driver = {
+	.probe = hx8394f_probe,
+	.remove = hx8394f_remove,
+	.driver = {
+		.name = "panel-wingtech-boe-hx8394f",
+		.of_match_table = hx8394f_of_match,
+	},
+};
+module_mipi_dsi_driver(hx8394f_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for hx8394F_HD720p_video_BOE");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-boe-nt35521s.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-boe-nt35521s.c
new file mode 100644
index 000000000000..9c52e3c39018
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-boe-nt35521s.c
@@ -0,0 +1,241 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct nt35521s {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct nt35521s *to_nt35521s(struct drm_panel *panel)
+{
+	return container_of(panel, struct nt35521s, panel);
+}
+
+static void nt35521s_reset(struct nt35521s *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(30);
+}
+
+static int nt35521s_on(struct nt35521s *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0xaa, 0x55, 0x25, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x6f, 0x21);
+	mipi_dsi_generic_write_seq(dsi, 0xf7, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x6f, 0x21);
+	mipi_dsi_generic_write_seq(dsi, 0xf7, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0xaa, 0x55, 0x25, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x35, 0x00);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nt35521s_off(struct nt35521s *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int nt35521s_prepare(struct drm_panel *panel)
+{
+	struct nt35521s *ctx = to_nt35521s(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	nt35521s_reset(ctx);
+
+	ret = nt35521s_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nt35521s_unprepare(struct drm_panel *panel)
+{
+	struct nt35521s *ctx = to_nt35521s(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = nt35521s_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode nt35521s_mode = {
+	.clock = (720 + 160 + 20 + 160) * (1280 + 16 + 2 + 16) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 160,
+	.hsync_end = 720 + 160 + 20,
+	.htotal = 720 + 160 + 20 + 160,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 16,
+	.vsync_end = 1280 + 16 + 2,
+	.vtotal = 1280 + 16 + 2 + 16,
+	.width_mm = 58,
+	.height_mm = 103,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int nt35521s_get_modes(struct drm_panel *panel,
+			      struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &nt35521s_mode);
+}
+
+static const struct drm_panel_funcs nt35521s_panel_funcs = {
+	.prepare = nt35521s_prepare,
+	.unprepare = nt35521s_unprepare,
+	.get_modes = nt35521s_get_modes,
+};
+
+static int nt35521s_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct nt35521s *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 3;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_HSE |
+			  MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &nt35521s_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void nt35521s_remove(struct mipi_dsi_device *dsi)
+{
+	struct nt35521s *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id nt35521s_of_match[] = {
+	{ .compatible = "wingtech,boe-nt35521s" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, nt35521s_of_match);
+
+static struct mipi_dsi_driver nt35521s_driver = {
+	.probe = nt35521s_probe,
+	.remove = nt35521s_remove,
+	.driver = {
+		.name = "panel-wingtech-boe-nt35521s",
+		.of_match_table = nt35521s_of_match,
+	},
+};
+module_mipi_dsi_driver(nt35521s_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for nt35521s_HD720p_video_BOE");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-ebbg-otm1285a.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-ebbg-otm1285a.c
new file mode 100644
index 000000000000..03988a0daa33
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-ebbg-otm1285a.c
@@ -0,0 +1,229 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct otm1285a_otp {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct otm1285a_otp *to_otm1285a_otp(struct drm_panel *panel)
+{
+	return container_of(panel, struct otm1285a_otp, panel);
+}
+
+static void otm1285a_otp_reset(struct otm1285a_otp *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int otm1285a_otp_on(struct otm1285a_otp *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x12, 0x85, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x12, 0x85);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x11);
+	msleep(120);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x29);
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+static int otm1285a_otp_off(struct otm1285a_otp *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int otm1285a_otp_prepare(struct drm_panel *panel)
+{
+	struct otm1285a_otp *ctx = to_otm1285a_otp(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	otm1285a_otp_reset(ctx);
+
+	ret = otm1285a_otp_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int otm1285a_otp_unprepare(struct drm_panel *panel)
+{
+	struct otm1285a_otp *ctx = to_otm1285a_otp(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = otm1285a_otp_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode otm1285a_otp_mode = {
+	.clock = (720 + 28 + 2 + 28) * (1280 + 30 + 2 + 30) * 59 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 28,
+	.hsync_end = 720 + 28 + 2,
+	.htotal = 720 + 28 + 2 + 28,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 30,
+	.vsync_end = 1280 + 30 + 2,
+	.vtotal = 1280 + 30 + 2 + 30,
+	.width_mm = 58,
+	.height_mm = 103,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int otm1285a_otp_get_modes(struct drm_panel *panel,
+				  struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &otm1285a_otp_mode);
+}
+
+static const struct drm_panel_funcs otm1285a_otp_panel_funcs = {
+	.prepare = otm1285a_otp_prepare,
+	.unprepare = otm1285a_otp_unprepare,
+	.get_modes = otm1285a_otp_get_modes,
+};
+
+static int otm1285a_otp_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct otm1285a_otp *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 3;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_HSE |
+			  MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &otm1285a_otp_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void otm1285a_otp_remove(struct mipi_dsi_device *dsi)
+{
+	struct otm1285a_otp *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id otm1285a_otp_of_match[] = {
+	{ .compatible = "wingtech,ebbg-otm1285a" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, otm1285a_otp_of_match);
+
+static struct mipi_dsi_driver otm1285a_otp_driver = {
+	.probe = otm1285a_otp_probe,
+	.remove = otm1285a_otp_remove,
+	.driver = {
+		.name = "panel-wingtech-ebbg-otm1285a",
+		.of_match_table = otm1285a_otp_of_match,
+	},
+};
+module_mipi_dsi_driver(otm1285a_otp_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for otm1285a_otp_720p_video_EBBG");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-otm-ili9881c.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-otm-ili9881c.c
new file mode 100644
index 000000000000..ab79549a1ab7
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-otm-ili9881c.c
@@ -0,0 +1,431 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct ili9881c {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct ili9881c *to_ili9881c(struct drm_panel *panel)
+{
+	return container_of(panel, struct ili9881c, panel);
+}
+
+static void ili9881c_reset(struct ili9881c *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(120);
+}
+
+static int ili9881c_on(struct ili9881c *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x01, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x02, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x03, 0x73);
+	mipi_dsi_dcs_write_seq(dsi, 0x04, 0xd3);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x06, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0x0e);
+	mipi_dsi_dcs_write_seq(dsi, 0x08, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x09, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0a, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0b, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0c, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0d, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0e, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x0f, 0x15);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x15);
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x13, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x14, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x17, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x18, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x19, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x1a, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x1b, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x1c, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x1d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x1e, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x1f, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0x20, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x21, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x23, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x24, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x25, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x26, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x27, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x28, 0x33);
+	mipi_dsi_dcs_write_seq(dsi, 0x29, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x2a, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x2b, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x2c, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x2d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x2e, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x2f, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x30, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x31, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x32, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x33, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x34, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x36, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x37, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x38, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x39, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x3a, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x3c, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x3d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x3e, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x3f, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x40, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x41, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x42, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x43, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x44, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x50, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x51, 0x23);
+	mipi_dsi_dcs_write_seq(dsi, 0x52, 0x45);
+	mipi_dsi_dcs_write_seq(dsi, 0x53, 0x67);
+	mipi_dsi_dcs_write_seq(dsi, 0x54, 0x89);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0xab);
+	mipi_dsi_dcs_write_seq(dsi, 0x56, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x57, 0x23);
+	mipi_dsi_dcs_write_seq(dsi, 0x58, 0x45);
+	mipi_dsi_dcs_write_seq(dsi, 0x59, 0x67);
+	mipi_dsi_dcs_write_seq(dsi, 0x5a, 0x89);
+	mipi_dsi_dcs_write_seq(dsi, 0x5b, 0xab);
+	mipi_dsi_dcs_write_seq(dsi, 0x5c, 0xcd);
+	mipi_dsi_dcs_write_seq(dsi, 0x5d, 0xef);
+	mipi_dsi_dcs_write_seq(dsi, 0x5e, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0x5f, 0x0d);
+	mipi_dsi_dcs_write_seq(dsi, 0x60, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x61, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x62, 0x0e);
+	mipi_dsi_dcs_write_seq(dsi, 0x63, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x64, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0x65, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x66, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x67, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x68, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x69, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x6a, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x6b, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x6c, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x6d, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x6e, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x70, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x71, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x72, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x73, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x74, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x75, 0x0d);
+	mipi_dsi_dcs_write_seq(dsi, 0x76, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x77, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x78, 0x0e);
+	mipi_dsi_dcs_write_seq(dsi, 0x79, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x7a, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0x7b, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x7c, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x7d, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x7e, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x7f, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x80, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x81, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x82, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x83, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x84, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x85, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x86, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x87, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x88, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x89, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x8a, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x6c, 0x15);
+	mipi_dsi_dcs_write_seq(dsi, 0x6e, 0x3b);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x37);
+	mipi_dsi_dcs_write_seq(dsi, 0x8d, 0x14);
+	mipi_dsi_dcs_write_seq(dsi, 0x3a, 0xa4);
+	mipi_dsi_dcs_write_seq(dsi, 0x87, 0xba);
+	mipi_dsi_dcs_write_seq(dsi, 0x26, 0x76);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0xd1);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0x31, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x50, 0x96);
+	mipi_dsi_dcs_write_seq(dsi, 0x51, 0x96);
+	mipi_dsi_dcs_write_seq(dsi, 0x53, 0x6f);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0x6e);
+	mipi_dsi_dcs_write_seq(dsi, 0x60, 0x14);
+	mipi_dsi_dcs_write_seq(dsi, 0xa0, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xa1, 0x36);
+	mipi_dsi_dcs_write_seq(dsi, 0xa2, 0x3f);
+	mipi_dsi_dcs_write_seq(dsi, 0xa3, 0x14);
+	mipi_dsi_dcs_write_seq(dsi, 0xa4, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0xa5, 0x2b);
+	mipi_dsi_dcs_write_seq(dsi, 0xa6, 0x1e);
+	mipi_dsi_dcs_write_seq(dsi, 0xa7, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0xa8, 0xac);
+	mipi_dsi_dcs_write_seq(dsi, 0xa9, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0xaa, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0xab, 0x92);
+	mipi_dsi_dcs_write_seq(dsi, 0xac, 0x1d);
+	mipi_dsi_dcs_write_seq(dsi, 0xad, 0x1d);
+	mipi_dsi_dcs_write_seq(dsi, 0xae, 0x53);
+	mipi_dsi_dcs_write_seq(dsi, 0xaf, 0x25);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1, 0x48);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0x4c);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x1f);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xc1, 0x36);
+	mipi_dsi_dcs_write_seq(dsi, 0xc2, 0x3f);
+	mipi_dsi_dcs_write_seq(dsi, 0xc3, 0x14);
+	mipi_dsi_dcs_write_seq(dsi, 0xc4, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0x2b);
+	mipi_dsi_dcs_write_seq(dsi, 0xc6, 0x1e);
+	mipi_dsi_dcs_write_seq(dsi, 0xc7, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0xc8, 0xac);
+	mipi_dsi_dcs_write_seq(dsi, 0xc9, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0xca, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb, 0x92);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0x1d);
+	mipi_dsi_dcs_write_seq(dsi, 0xcd, 0x1d);
+	mipi_dsi_dcs_write_seq(dsi, 0xce, 0x53);
+	mipi_dsi_dcs_write_seq(dsi, 0xcf, 0x25);
+	mipi_dsi_dcs_write_seq(dsi, 0xd0, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0xd1, 0x48);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0x4c);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3, 0x1f);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x51, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x53, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0x00);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(116);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	return 0;
+}
+
+static int ili9881c_off(struct ili9881c *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(140);
+
+	return 0;
+}
+
+static int ili9881c_prepare(struct drm_panel *panel)
+{
+	struct ili9881c *ctx = to_ili9881c(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	ili9881c_reset(ctx);
+
+	ret = ili9881c_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ili9881c_unprepare(struct drm_panel *panel)
+{
+	struct ili9881c *ctx = to_ili9881c(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = ili9881c_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode ili9881c_mode = {
+	.clock = (720 + 176 + 28 + 252) * (1280 + 28 + 4 + 20) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 176,
+	.hsync_end = 720 + 176 + 28,
+	.htotal = 720 + 176 + 28 + 252,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 28,
+	.vsync_end = 1280 + 28 + 4,
+	.vtotal = 1280 + 28 + 4 + 20,
+	.width_mm = 59,
+	.height_mm = 104,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int ili9881c_get_modes(struct drm_panel *panel,
+			      struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &ili9881c_mode);
+}
+
+static const struct drm_panel_funcs ili9881c_panel_funcs = {
+	.prepare = ili9881c_prepare,
+	.unprepare = ili9881c_unprepare,
+	.get_modes = ili9881c_get_modes,
+};
+
+static int ili9881c_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct ili9881c *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS |
+			  MIPI_DSI_MODE_VIDEO_NO_HFP |
+			  MIPI_DSI_MODE_VIDEO_NO_HBP |
+			  MIPI_DSI_MODE_VIDEO_NO_HSA;
+
+	drm_panel_init(&ctx->panel, dev, &ili9881c_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void ili9881c_remove(struct mipi_dsi_device *dsi)
+{
+	struct ili9881c *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id ili9881c_of_match[] = {
+	{ .compatible = "wingtech,otm-ili9881c" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ili9881c_of_match);
+
+static struct mipi_dsi_driver ili9881c_driver = {
+	.probe = ili9881c_probe,
+	.remove = ili9881c_remove,
+	.driver = {
+		.name = "panel-wingtech-otm-ili9881c",
+		.of_match_table = ili9881c_of_match,
+	},
+};
+module_mipi_dsi_driver(ili9881c_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for ili9881_HD720p_video_tianma");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-qimei-ili9881.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-qimei-ili9881.c
new file mode 100644
index 000000000000..5c4707e5fb47
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-qimei-ili9881.c
@@ -0,0 +1,409 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct ili9881_qimei {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct ili9881_qimei *to_ili9881_qimei(struct drm_panel *panel)
+{
+	return container_of(panel, struct ili9881_qimei, panel);
+}
+
+static void ili9881_qimei_reset(struct ili9881_qimei *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(30);
+}
+
+static int ili9881_qimei_on(struct ili9881_qimei *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0x03, 0x21);
+	mipi_dsi_dcs_write_seq(dsi, 0x04, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x06, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x08, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x09, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x0a, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x0b, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x0c, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x0d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x0e, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x0f, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x0b);
+	mipi_dsi_dcs_write_seq(dsi, 0x13, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x14, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x17, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x18, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x19, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x1a, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x1b, 0x54);
+	mipi_dsi_dcs_write_seq(dsi, 0x1c, 0xbb);
+	mipi_dsi_dcs_write_seq(dsi, 0x1d, 0x3c);
+	mipi_dsi_dcs_write_seq(dsi, 0x1e, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x1f, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x20, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x21, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x23, 0xc0);
+	mipi_dsi_dcs_write_seq(dsi, 0x24, 0x50);
+	mipi_dsi_dcs_write_seq(dsi, 0x25, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x26, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x27, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x30, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x31, 0x23);
+	mipi_dsi_dcs_write_seq(dsi, 0x32, 0x45);
+	mipi_dsi_dcs_write_seq(dsi, 0x33, 0x67);
+	mipi_dsi_dcs_write_seq(dsi, 0x34, 0x89);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0xab);
+	mipi_dsi_dcs_write_seq(dsi, 0x36, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x37, 0x23);
+	mipi_dsi_dcs_write_seq(dsi, 0x38, 0x45);
+	mipi_dsi_dcs_write_seq(dsi, 0x39, 0x67);
+	mipi_dsi_dcs_write_seq(dsi, 0x3a, 0x89);
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0xab);
+	mipi_dsi_dcs_write_seq(dsi, 0x3c, 0xcd);
+	mipi_dsi_dcs_write_seq(dsi, 0x3d, 0xef);
+	mipi_dsi_dcs_write_seq(dsi, 0x50, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x51, 0x14);
+	mipi_dsi_dcs_write_seq(dsi, 0x52, 0x15);
+	mipi_dsi_dcs_write_seq(dsi, 0x53, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x54, 0x0d);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0x0e);
+	mipi_dsi_dcs_write_seq(dsi, 0x56, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x57, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x58, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0x59, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x5a, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5b, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0x5c, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5d, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5e, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5f, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x60, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x61, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x62, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x63, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x64, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x65, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x66, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x67, 0x14);
+	mipi_dsi_dcs_write_seq(dsi, 0x68, 0x15);
+	mipi_dsi_dcs_write_seq(dsi, 0x69, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0x6a, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x6b, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x6c, 0x0e);
+	mipi_dsi_dcs_write_seq(dsi, 0x6d, 0x0d);
+	mipi_dsi_dcs_write_seq(dsi, 0x6e, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x70, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x71, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0x72, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x73, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x74, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x75, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x76, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x77, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x78, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x79, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x7a, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x7b, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x7c, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x1f, 0x75);
+	mipi_dsi_dcs_write_seq(dsi, 0xab, 0x74);
+	mipi_dsi_dcs_write_seq(dsi, 0x5d, 0x4c);
+	mipi_dsi_dcs_write_seq(dsi, 0x8a, 0xc0);
+	mipi_dsi_dcs_write_seq(dsi, 0xe4, 0xe0);
+	mipi_dsi_dcs_write_seq(dsi, 0x76, 0xd4);
+	mipi_dsi_dcs_write_seq(dsi, 0x78, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x74, 0x3b);
+	mipi_dsi_dcs_write_seq(dsi, 0x8e, 0x15);
+	mipi_dsi_dcs_write_seq(dsi, 0x40, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x7b, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x72, 0x25);
+	mipi_dsi_dcs_write_seq(dsi, 0x87, 0x3a);
+	mipi_dsi_dcs_write_seq(dsi, 0x6c, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x49, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x2d, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0x32, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x3c, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x41, 0x32);
+	mipi_dsi_dcs_write_seq(dsi, 0x42, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0x31, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x53, 0x81);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0x88);
+	mipi_dsi_dcs_write_seq(dsi, 0x50, 0xa3);
+	mipi_dsi_dcs_write_seq(dsi, 0x51, 0xa3);
+	mipi_dsi_dcs_write_seq(dsi, 0x60, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0xa0, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xa1, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0xa2, 0x2c);
+	mipi_dsi_dcs_write_seq(dsi, 0xa3, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xa4, 0x1b);
+	mipi_dsi_dcs_write_seq(dsi, 0xa5, 0x2e);
+	mipi_dsi_dcs_write_seq(dsi, 0xa6, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0xa7, 0x21);
+	mipi_dsi_dcs_write_seq(dsi, 0xa8, 0x88);
+	mipi_dsi_dcs_write_seq(dsi, 0xa9, 0x1f);
+	mipi_dsi_dcs_write_seq(dsi, 0xaa, 0x2a);
+	mipi_dsi_dcs_write_seq(dsi, 0xab, 0x6d);
+	mipi_dsi_dcs_write_seq(dsi, 0xac, 0x1b);
+	mipi_dsi_dcs_write_seq(dsi, 0xad, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0xae, 0x4f);
+	mipi_dsi_dcs_write_seq(dsi, 0xaf, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x27);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1, 0x43);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0x56);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x3f);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xc1, 0x22);
+	mipi_dsi_dcs_write_seq(dsi, 0xc2, 0x32);
+	mipi_dsi_dcs_write_seq(dsi, 0xc3, 0x12);
+	mipi_dsi_dcs_write_seq(dsi, 0xc4, 0x14);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0x27);
+	mipi_dsi_dcs_write_seq(dsi, 0xc6, 0x1b);
+	mipi_dsi_dcs_write_seq(dsi, 0xc7, 0x1d);
+	mipi_dsi_dcs_write_seq(dsi, 0xc8, 0x8d);
+	mipi_dsi_dcs_write_seq(dsi, 0xc9, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0xca, 0x26);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb, 0x7a);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0x19);
+	mipi_dsi_dcs_write_seq(dsi, 0xcd, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xce, 0x4c);
+	mipi_dsi_dcs_write_seq(dsi, 0xcf, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0xd0, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0xd1, 0x51);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0x5c);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3, 0x3f);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x00);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+static int ili9881_qimei_off(struct ili9881_qimei *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(140);
+
+	return 0;
+}
+
+static int ili9881_qimei_prepare(struct drm_panel *panel)
+{
+	struct ili9881_qimei *ctx = to_ili9881_qimei(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	ili9881_qimei_reset(ctx);
+
+	ret = ili9881_qimei_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ili9881_qimei_unprepare(struct drm_panel *panel)
+{
+	struct ili9881_qimei *ctx = to_ili9881_qimei(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = ili9881_qimei_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode ili9881_qimei_mode = {
+	.clock = (720 + 168 + 24 + 240) * (1280 + 12 + 4 + 20) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 168,
+	.hsync_end = 720 + 168 + 24,
+	.htotal = 720 + 168 + 24 + 240,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 12,
+	.vsync_end = 1280 + 12 + 4,
+	.vtotal = 1280 + 12 + 4 + 20,
+	.width_mm = 59,
+	.height_mm = 104,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int ili9881_qimei_get_modes(struct drm_panel *panel,
+				   struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &ili9881_qimei_mode);
+}
+
+static const struct drm_panel_funcs ili9881_qimei_panel_funcs = {
+	.prepare = ili9881_qimei_prepare,
+	.unprepare = ili9881_qimei_unprepare,
+	.get_modes = ili9881_qimei_get_modes,
+};
+
+static int ili9881_qimei_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct ili9881_qimei *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS |
+			  MIPI_DSI_MODE_VIDEO_NO_HFP |
+			  MIPI_DSI_MODE_VIDEO_NO_HBP |
+			  MIPI_DSI_MODE_VIDEO_NO_HSA;
+
+	drm_panel_init(&ctx->panel, dev, &ili9881_qimei_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void ili9881_qimei_remove(struct mipi_dsi_device *dsi)
+{
+	struct ili9881_qimei *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id ili9881_qimei_of_match[] = {
+	{ .compatible = "wingtech,qimei-ili9881" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ili9881_qimei_of_match);
+
+static struct mipi_dsi_driver ili9881_qimei_driver = {
+	.probe = ili9881_qimei_probe,
+	.remove = ili9881_qimei_remove,
+	.driver = {
+		.name = "panel-wingtech-qimei-ili9881",
+		.of_match_table = ili9881_qimei_of_match,
+	},
+};
+module_mipi_dsi_driver(ili9881_qimei_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for ili9881_qimei_HD720p_video_Yassy");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-sharp-r69431.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-sharp-r69431.c
new file mode 100644
index 000000000000..35002b2d978c
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-sharp-r69431.c
@@ -0,0 +1,239 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct r69431 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator *supply;
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct r69431 *to_r69431(struct drm_panel *panel)
+{
+	return container_of(panel, struct r69431, panel);
+}
+
+static void r69431_reset(struct r69431 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int r69431_on(struct r69431 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xd6, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0xb3, 0x1c);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x03);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int r69431_off(struct r69431 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(220);
+
+	return 0;
+}
+
+static int r69431_prepare(struct drm_panel *panel)
+{
+	struct r69431 *ctx = to_r69431(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_enable(ctx->supply);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulator: %d\n", ret);
+		return ret;
+	}
+
+	r69431_reset(ctx);
+
+	ret = r69431_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_disable(ctx->supply);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int r69431_unprepare(struct drm_panel *panel)
+{
+	struct r69431 *ctx = to_r69431(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = r69431_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_disable(ctx->supply);
+
+	return 0;
+}
+
+static const struct drm_display_mode r69431_mode = {
+	.clock = (720 + 120 + 10 + 20) * (1280 + 13 + 1 + 11) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 120,
+	.hsync_end = 720 + 120 + 10,
+	.htotal = 720 + 120 + 10 + 20,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 13,
+	.vsync_end = 1280 + 13 + 1,
+	.vtotal = 1280 + 13 + 1 + 11,
+	.width_mm = 58,
+	.height_mm = 103,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int r69431_get_modes(struct drm_panel *panel,
+			    struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &r69431_mode);
+}
+
+static const struct drm_panel_funcs r69431_panel_funcs = {
+	.prepare = r69431_prepare,
+	.unprepare = r69431_unprepare,
+	.get_modes = r69431_get_modes,
+};
+
+static int r69431_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct r69431 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply))
+		return dev_err_probe(dev, PTR_ERR(ctx->supply),
+				     "Failed to get power regulator\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 3;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &r69431_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void r69431_remove(struct mipi_dsi_device *dsi)
+{
+	struct r69431 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id r69431_of_match[] = {
+	{ .compatible = "wingtech,sharp-r69431" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, r69431_of_match);
+
+static struct mipi_dsi_driver r69431_driver = {
+	.probe = r69431_probe,
+	.remove = r69431_remove,
+	.driver = {
+		.name = "panel-wingtech-sharp-r69431",
+		.of_match_table = r69431_of_match,
+	},
+};
+module_mipi_dsi_driver(r69431_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for r69431_HD720p_video_sharp");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-tianma-hx8394d.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-tianma-hx8394d.c
new file mode 100644
index 000000000000..2fec767181cd
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-tianma-hx8394d.c
@@ -0,0 +1,305 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct hx8394d {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct hx8394d *to_hx8394d(struct drm_panel *panel)
+{
+	return container_of(panel, struct hx8394d, panel);
+}
+
+static void hx8394d_reset(struct hx8394d *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(50);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+}
+
+static int hx8394d_on(struct hx8394d *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xb9, 0xff, 0x83, 0x94);
+	mipi_dsi_dcs_write_seq(dsi, 0xba, 0x33, 0x83, 0x20, 0x65, 0xb2, 0x09);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1,
+			       0x6c, 0x11, 0x11, 0x37, 0x04, 0x11, 0xf1, 0x80,
+			       0xdf, 0x94, 0x23, 0x80, 0xc0, 0xd2, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2,
+			       0x00, 0x64, 0x0e, 0x0d, 0x32, 0x23, 0x08, 0x08,
+			       0x1c, 0x4d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xb4,
+			       0x00, 0xff, 0x03, 0x46, 0x03, 0x46, 0x03, 0x46,
+			       0x01, 0x6a, 0x01, 0x6a);
+	mipi_dsi_dcs_write_seq(dsi, 0xbf, 0x41, 0x0e, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3,
+			       0x00, 0x07, 0x00, 0x00, 0x00, 0x10, 0x00, 0x32,
+			       0x10, 0x05, 0x00, 0x05, 0x32, 0x10, 0x00, 0x00,
+			       0x00, 0x32, 0x10, 0x00, 0x00, 0x00, 0x36, 0x03,
+			       0x09, 0x09, 0x37, 0x00, 0x00, 0x37, 0x00, 0x00,
+			       0x00, 0x00, 0x0a, 0x00, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xd5,
+			       0x02, 0x03, 0x00, 0x01, 0x06, 0x07, 0x04, 0x05,
+			       0x20, 0x21, 0x22, 0x23, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x24, 0x25,
+			       0x18, 0x18, 0x19, 0x19);
+	mipi_dsi_dcs_write_seq(dsi, 0xd6,
+			       0x05, 0x04, 0x07, 0x06, 0x01, 0x00, 0x03, 0x02,
+			       0x23, 0x22, 0x21, 0x20, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x58, 0x58, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
+			       0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x25, 0x24,
+			       0x19, 0x19, 0x18, 0x18);
+	mipi_dsi_dcs_write_seq(dsi, 0xe0,
+			       0x02, 0x10, 0x14, 0x2c, 0x2f, 0x3f, 0x22, 0x40,
+			       0x06, 0x0a, 0x0c, 0x17, 0x0e, 0x12, 0x14, 0x13,
+			       0x14, 0x08, 0x12, 0x14, 0x1b, 0x02, 0x10, 0x14,
+			       0x2c, 0x2f, 0x3f, 0x22, 0x40, 0x06, 0x0a, 0x0c,
+			       0x17, 0x0e, 0x12, 0x14, 0x13, 0x14, 0x08, 0x12,
+			       0x14, 0x1b);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0x09);
+	mipi_dsi_dcs_write_seq(dsi, 0xc7, 0x00, 0xc0, 0x40, 0xc0);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x30, 0x14);
+	mipi_dsi_dcs_write_seq(dsi, 0xbc, 0x07);
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x00ff);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+	mipi_dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xe4, 0x51, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xe6,
+			       0x00, 0x00, 0x00, 0x05, 0x05, 0x10, 0x0a, 0x08,
+			       0x10, 0x20, 0x20, 0x0c, 0x08, 0x0f, 0x20, 0x20,
+			       0x20);
+
+	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set tear on: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(200);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hx8394d_off(struct hx8394d *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int hx8394d_prepare(struct drm_panel *panel)
+{
+	struct hx8394d *ctx = to_hx8394d(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	hx8394d_reset(ctx);
+
+	ret = hx8394d_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hx8394d_unprepare(struct drm_panel *panel)
+{
+	struct hx8394d *ctx = to_hx8394d(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = hx8394d_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode hx8394d_mode = {
+	.clock = (720 + 168 + 24 + 240) * (1280 + 20 + 4 + 12) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 168,
+	.hsync_end = 720 + 168 + 24,
+	.htotal = 720 + 168 + 24 + 240,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 20,
+	.vsync_end = 1280 + 20 + 4,
+	.vtotal = 1280 + 20 + 4 + 12,
+	.width_mm = 59,
+	.height_mm = 104,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int hx8394d_get_modes(struct drm_panel *panel,
+			     struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &hx8394d_mode);
+}
+
+static const struct drm_panel_funcs hx8394d_panel_funcs = {
+	.prepare = hx8394d_prepare,
+	.unprepare = hx8394d_unprepare,
+	.get_modes = hx8394d_get_modes,
+};
+
+static int hx8394d_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct hx8394d *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS |
+			  MIPI_DSI_MODE_VIDEO_NO_HFP |
+			  MIPI_DSI_MODE_VIDEO_NO_HBP |
+			  MIPI_DSI_MODE_VIDEO_NO_HSA;
+
+	drm_panel_init(&ctx->panel, dev, &hx8394d_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void hx8394d_remove(struct mipi_dsi_device *dsi)
+{
+	struct hx8394d *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id hx8394d_of_match[] = {
+	{ .compatible = "wingtech,tianma-hx8394d" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, hx8394d_of_match);
+
+static struct mipi_dsi_driver hx8394d_driver = {
+	.probe = hx8394d_probe,
+	.remove = hx8394d_remove,
+	.driver = {
+		.name = "panel-wingtech-tianma-hx8394d",
+		.of_match_table = hx8394d_of_match,
+	},
+};
+module_mipi_dsi_driver(hx8394d_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for hx8394d_HD720p_video_Tianma");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-tm-otm1901a.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-tm-otm1901a.c
new file mode 100644
index 000000000000..e4cfb43e2ac1
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-tm-otm1901a.c
@@ -0,0 +1,326 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct otm1901a_tm {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct otm1901a_tm *to_otm1901a_tm(struct drm_panel *panel)
+{
+	return container_of(panel, struct otm1901a_tm, panel);
+}
+
+static void otm1901a_tm_reset(struct otm1901a_tm *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(2000, 3000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(20);
+}
+
+static int otm1901a_tm_on(struct otm1901a_tm *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x19, 0x01, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xff, 0x19, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xb0, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x1c, 0x33);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xcd);
+	mipi_dsi_generic_write_seq(dsi, 0xf5, 0x19);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc1);
+	mipi_dsi_generic_write_seq(dsi, 0xf5, 0x15);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc3);
+	mipi_dsi_generic_write_seq(dsi, 0xf5, 0x15);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xdb);
+	mipi_dsi_generic_write_seq(dsi, 0xf5, 0x19);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x8d);
+	mipi_dsi_generic_write_seq(dsi, 0xf5, 0x20);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xf5);
+	mipi_dsi_generic_write_seq(dsi, 0xc1, 0x40);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa2);
+	mipi_dsi_generic_write_seq(dsi, 0xc1, 0x30);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb9);
+	mipi_dsi_generic_write_seq(dsi, 0xc0, 0x11);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0xfd, 0xfe, 0xfd, 0xfd, 0xfd, 0xfd);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xe0);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x33, 0x33, 0x33, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xf0);
+	mipi_dsi_generic_write_seq(dsi, 0xcb,
+				   0x31, 0x31, 0x31, 0x01, 0x01, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x82);
+	mipi_dsi_generic_write_seq(dsi, 0xd6, 0x02);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	mipi_dsi_generic_write_seq(dsi, 0xd6,
+				   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				   0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb0);
+	mipi_dsi_generic_write_seq(dsi, 0xd6,
+				   0x00, 0x00, 0x00, 0x33, 0xcd, 0x33, 0x33,
+				   0x33, 0x80, 0x33, 0x33, 0x33);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc0);
+	mipi_dsi_generic_write_seq(dsi, 0xd6,
+				   0x44, 0x00, 0x00, 0x22, 0x89, 0x22, 0x22,
+				   0x22, 0x55, 0x22, 0x22, 0x22);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xd0);
+	mipi_dsi_generic_write_seq(dsi, 0xd6,
+				   0x44, 0x00, 0x00, 0x11, 0x44, 0x11, 0x11,
+				   0x11, 0x2b, 0x11, 0x11, 0x11);
+	mipi_dsi_generic_write_seq(dsi, 0x81, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x80);
+	mipi_dsi_generic_write_seq(dsi, 0xd8,
+				   0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x03,
+				   0x03, 0x02, 0x02, 0x81, 0x84);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x90);
+	mipi_dsi_generic_write_seq(dsi, 0xd8,
+				   0x00, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03,
+				   0x04, 0x05, 0x06, 0x0e, 0x15);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xa0);
+	mipi_dsi_generic_write_seq(dsi, 0xd8,
+				   0x01, 0x02, 0x04, 0x05, 0x08, 0x0b, 0x0e,
+				   0x10, 0x11, 0x4c, 0x66, 0x7f);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xb0);
+	mipi_dsi_generic_write_seq(dsi, 0xd8,
+				   0x00, 0x80, 0x80, 0x81, 0x81, 0x82, 0x83,
+				   0x84, 0x84, 0x8e, 0x93, 0x97);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc0);
+	mipi_dsi_generic_write_seq(dsi, 0xd8,
+				   0x81, 0x82, 0x82, 0x83, 0x85, 0x87, 0x89,
+				   0x8b, 0x8e, 0x95, 0x9b, 0xa0);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xd0);
+	mipi_dsi_generic_write_seq(dsi, 0xd8,
+				   0x01, 0x03, 0x04, 0x05, 0x08, 0x0a, 0x0d,
+				   0x0f, 0x12, 0x25, 0x34, 0x42);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0xc0);
+	mipi_dsi_generic_write_seq(dsi, 0xd7, 0x82, 0x80, 0xc0, 0xff);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x35, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x51, 0xff);
+	mipi_dsi_generic_write_seq(dsi, 0x53, 0x2c);
+	mipi_dsi_generic_write_seq(dsi, 0x55, 0x01);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0x84, 0xc6);
+	mipi_dsi_generic_write_seq(dsi, 0x81, 0x83);
+	mipi_dsi_generic_write_seq(dsi, 0x00, 0x00);
+	mipi_dsi_generic_write_seq(dsi, 0xfb, 0x01);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(150);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	return 0;
+}
+
+static int otm1901a_tm_off(struct otm1901a_tm *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int otm1901a_tm_prepare(struct drm_panel *panel)
+{
+	struct otm1901a_tm *ctx = to_otm1901a_tm(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	otm1901a_tm_reset(ctx);
+
+	ret = otm1901a_tm_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int otm1901a_tm_unprepare(struct drm_panel *panel)
+{
+	struct otm1901a_tm *ctx = to_otm1901a_tm(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = otm1901a_tm_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode otm1901a_tm_mode = {
+	.clock = (1080 + 60 + 12 + 60) * (1920 + 80 + 4 + 30) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 60,
+	.hsync_end = 1080 + 60 + 12,
+	.htotal = 1080 + 60 + 12 + 60,
+	.vdisplay = 1920,
+	.vsync_start = 1920 + 80,
+	.vsync_end = 1920 + 80 + 4,
+	.vtotal = 1920 + 80 + 4 + 30,
+	.width_mm = 64,
+	.height_mm = 117,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int otm1901a_tm_get_modes(struct drm_panel *panel,
+				 struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &otm1901a_tm_mode);
+}
+
+static const struct drm_panel_funcs otm1901a_tm_panel_funcs = {
+	.prepare = otm1901a_tm_prepare,
+	.unprepare = otm1901a_tm_unprepare,
+	.get_modes = otm1901a_tm_get_modes,
+};
+
+static int otm1901a_tm_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct otm1901a_tm *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &otm1901a_tm_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void otm1901a_tm_remove(struct mipi_dsi_device *dsi)
+{
+	struct otm1901a_tm *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id otm1901a_tm_of_match[] = {
+	{ .compatible = "wingtech,tm-otm1901a" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, otm1901a_tm_of_match);
+
+static struct mipi_dsi_driver otm1901a_tm_driver = {
+	.probe = otm1901a_tm_probe,
+	.remove = otm1901a_tm_remove,
+	.driver = {
+		.name = "panel-wingtech-tm-otm1901a",
+		.of_match_table = otm1901a_tm_of_match,
+	},
+};
+module_mipi_dsi_driver(otm1901a_tm_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for otm1901a_1080p_video_TianMa");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-yassy-ili9881.c b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-yassy-ili9881.c
new file mode 100644
index 000000000000..2dc44cfbb156
--- /dev/null
+++ b/drivers/gpu/drm/panel/msm8916-generated/panel-wingtech-yassy-ili9881.c
@@ -0,0 +1,414 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2024 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct ili9881 {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct regulator_bulk_data supplies[2];
+	struct gpio_desc *reset_gpio;
+};
+
+static inline struct ili9881 *to_ili9881(struct drm_panel *panel)
+{
+	return container_of(panel, struct ili9881, panel);
+}
+
+static void ili9881_reset(struct ili9881 *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(5000, 6000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(30);
+}
+
+static int ili9881_on(struct ili9881 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x07);
+	mipi_dsi_dcs_write_seq(dsi, 0x03, 0x20);
+	mipi_dsi_dcs_write_seq(dsi, 0x04, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x05, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x06, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x07, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x08, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x09, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x0a, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x0b, 0x2f);
+	mipi_dsi_dcs_write_seq(dsi, 0x0c, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x0d, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x0e, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x0f, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x10, 0x40);
+	mipi_dsi_dcs_write_seq(dsi, 0x11, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x12, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x13, 0x90);
+	mipi_dsi_dcs_write_seq(dsi, 0x14, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x15, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x16, 0x2f);
+	mipi_dsi_dcs_write_seq(dsi, 0x17, 0x2f);
+	mipi_dsi_dcs_write_seq(dsi, 0x18, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x19, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x1a, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x1b, 0x50);
+	mipi_dsi_dcs_write_seq(dsi, 0x1c, 0x2c);
+	mipi_dsi_dcs_write_seq(dsi, 0x1d, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x1e, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x1f, 0x87);
+	mipi_dsi_dcs_write_seq(dsi, 0x20, 0x86);
+	mipi_dsi_dcs_write_seq(dsi, 0x21, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x23, 0xc0);
+	mipi_dsi_dcs_write_seq(dsi, 0x24, 0x30);
+	mipi_dsi_dcs_write_seq(dsi, 0x25, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x26, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x27, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x30, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x31, 0x23);
+	mipi_dsi_dcs_write_seq(dsi, 0x32, 0x45);
+	mipi_dsi_dcs_write_seq(dsi, 0x33, 0x67);
+	mipi_dsi_dcs_write_seq(dsi, 0x34, 0x89);
+	mipi_dsi_dcs_write_seq(dsi, 0x35, 0xab);
+	mipi_dsi_dcs_write_seq(dsi, 0x36, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x37, 0x23);
+	mipi_dsi_dcs_write_seq(dsi, 0x38, 0x45);
+	mipi_dsi_dcs_write_seq(dsi, 0x39, 0x67);
+	mipi_dsi_dcs_write_seq(dsi, 0x3a, 0x89);
+	mipi_dsi_dcs_write_seq(dsi, 0x3b, 0xab);
+	mipi_dsi_dcs_write_seq(dsi, 0x3c, 0xcd);
+	mipi_dsi_dcs_write_seq(dsi, 0x3d, 0xef);
+	mipi_dsi_dcs_write_seq(dsi, 0x50, 0x11);
+	mipi_dsi_dcs_write_seq(dsi, 0x51, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x52, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x53, 0x0d);
+	mipi_dsi_dcs_write_seq(dsi, 0x54, 0x0e);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x56, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x57, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x58, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x59, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5a, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5b, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5c, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5d, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5e, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5f, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x60, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x61, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x62, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x63, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x64, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x65, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x66, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x67, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x68, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x69, 0x0d);
+	mipi_dsi_dcs_write_seq(dsi, 0x6a, 0x0e);
+	mipi_dsi_dcs_write_seq(dsi, 0x6b, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0x6c, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x6d, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x6e, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x6f, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x70, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x71, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x72, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x73, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x74, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x75, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x76, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x77, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x78, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x79, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x7a, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x7b, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x7c, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x08);
+	mipi_dsi_dcs_write_seq(dsi, 0x76, 0xb4);
+	mipi_dsi_dcs_write_seq(dsi, 0x78, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x74, 0x2b);
+	mipi_dsi_dcs_write_seq(dsi, 0x8e, 0x15);
+	mipi_dsi_dcs_write_seq(dsi, 0x40, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x7b, 0x04);
+	mipi_dsi_dcs_write_seq(dsi, 0x72, 0x25);
+	mipi_dsi_dcs_write_seq(dsi, 0x87, 0x3a);
+	mipi_dsi_dcs_write_seq(dsi, 0x7e, 0x4c);
+	mipi_dsi_dcs_write_seq(dsi, 0x6c, 0x05);
+	mipi_dsi_dcs_write_seq(dsi, 0x49, 0x10);
+	mipi_dsi_dcs_write_seq(dsi, 0x2d, 0x80);
+	mipi_dsi_dcs_write_seq(dsi, 0x50, 0x65);
+	mipi_dsi_dcs_write_seq(dsi, 0x53, 0x29);
+	mipi_dsi_dcs_write_seq(dsi, 0x54, 0x65);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0x38);
+	mipi_dsi_dcs_write_seq(dsi, 0x57, 0x47);
+	mipi_dsi_dcs_write_seq(dsi, 0x58, 0x47);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0x53, 0x91);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0x78);
+	mipi_dsi_dcs_write_seq(dsi, 0x50, 0xa5);
+	mipi_dsi_dcs_write_seq(dsi, 0x51, 0xa2);
+	mipi_dsi_dcs_write_seq(dsi, 0x31, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0xa0, 0x0a);
+	mipi_dsi_dcs_write_seq(dsi, 0xa1, 0x1f);
+	mipi_dsi_dcs_write_seq(dsi, 0xa2, 0x2e);
+	mipi_dsi_dcs_write_seq(dsi, 0xa3, 0x16);
+	mipi_dsi_dcs_write_seq(dsi, 0xa4, 0x1b);
+	mipi_dsi_dcs_write_seq(dsi, 0xa5, 0x27);
+	mipi_dsi_dcs_write_seq(dsi, 0xa6, 0x1f);
+	mipi_dsi_dcs_write_seq(dsi, 0xa7, 0x1e);
+	mipi_dsi_dcs_write_seq(dsi, 0xa8, 0x94);
+	mipi_dsi_dcs_write_seq(dsi, 0xa9, 0x1e);
+	mipi_dsi_dcs_write_seq(dsi, 0xaa, 0x2b);
+	mipi_dsi_dcs_write_seq(dsi, 0xab, 0x93);
+	mipi_dsi_dcs_write_seq(dsi, 0xac, 0x1e);
+	mipi_dsi_dcs_write_seq(dsi, 0xad, 0x1d);
+	mipi_dsi_dcs_write_seq(dsi, 0xae, 0x53);
+	mipi_dsi_dcs_write_seq(dsi, 0xaf, 0x26);
+	mipi_dsi_dcs_write_seq(dsi, 0xb0, 0x2d);
+	mipi_dsi_dcs_write_seq(dsi, 0xb1, 0x55);
+	mipi_dsi_dcs_write_seq(dsi, 0xb2, 0x68);
+	mipi_dsi_dcs_write_seq(dsi, 0xb3, 0x3f);
+	mipi_dsi_dcs_write_seq(dsi, 0xc0, 0x01);
+	mipi_dsi_dcs_write_seq(dsi, 0xc1, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0xc2, 0x19);
+	mipi_dsi_dcs_write_seq(dsi, 0xc3, 0x16);
+	mipi_dsi_dcs_write_seq(dsi, 0xc4, 0x14);
+	mipi_dsi_dcs_write_seq(dsi, 0xc5, 0x25);
+	mipi_dsi_dcs_write_seq(dsi, 0xc6, 0x15);
+	mipi_dsi_dcs_write_seq(dsi, 0xc7, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0xc8, 0x78);
+	mipi_dsi_dcs_write_seq(dsi, 0xc9, 0x1d);
+	mipi_dsi_dcs_write_seq(dsi, 0xca, 0x28);
+	mipi_dsi_dcs_write_seq(dsi, 0xcb, 0x6a);
+	mipi_dsi_dcs_write_seq(dsi, 0xcc, 0x1c);
+	mipi_dsi_dcs_write_seq(dsi, 0xcd, 0x1a);
+	mipi_dsi_dcs_write_seq(dsi, 0xce, 0x4c);
+	mipi_dsi_dcs_write_seq(dsi, 0xcf, 0x1f);
+	mipi_dsi_dcs_write_seq(dsi, 0xd0, 0x25);
+	mipi_dsi_dcs_write_seq(dsi, 0xd1, 0x54);
+	mipi_dsi_dcs_write_seq(dsi, 0xd2, 0x62);
+	mipi_dsi_dcs_write_seq(dsi, 0xd3, 0x3f);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x1b, 0x02);
+	mipi_dsi_dcs_write_seq(dsi, 0x5a, 0x03);
+	mipi_dsi_dcs_write_seq(dsi, 0x1a, 0x06);
+	mipi_dsi_dcs_write_seq(dsi, 0x20, 0x09);
+	mipi_dsi_dcs_write_seq(dsi, 0x21, 0x0c);
+	mipi_dsi_dcs_write_seq(dsi, 0x22, 0x0f);
+	mipi_dsi_dcs_write_seq(dsi, 0xff, 0x98, 0x81, 0x00);
+	mipi_dsi_dcs_write_seq(dsi, 0x55, 0x80);
+	// WARNING: Ignoring weird SET_MAXIMUM_RETURN_PACKET_SIZE
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+static int ili9881_off(struct ili9881 *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	return 0;
+}
+
+static int ili9881_prepare(struct drm_panel *panel)
+{
+	struct ili9881 *ctx = to_ili9881(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+
+	ili9881_reset(ctx);
+
+	ret = ili9881_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ili9881_unprepare(struct drm_panel *panel)
+{
+	struct ili9881 *ctx = to_ili9881(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = ili9881_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+
+	return 0;
+}
+
+static const struct drm_display_mode ili9881_mode = {
+	.clock = (720 + 168 + 24 + 240) * (1280 + 12 + 4 + 20) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 168,
+	.hsync_end = 720 + 168 + 24,
+	.htotal = 720 + 168 + 24 + 240,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 12,
+	.vsync_end = 1280 + 12 + 4,
+	.vtotal = 1280 + 12 + 4 + 20,
+	.width_mm = 59,
+	.height_mm = 104,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int ili9881_get_modes(struct drm_panel *panel,
+			     struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &ili9881_mode);
+}
+
+static const struct drm_panel_funcs ili9881_panel_funcs = {
+	.prepare = ili9881_prepare,
+	.unprepare = ili9881_unprepare,
+	.get_modes = ili9881_get_modes,
+};
+
+static int ili9881_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct ili9881 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->supplies[0].supply = "vsp";
+	ctx->supplies[1].supply = "vsn";
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ctx->supplies),
+				      ctx->supplies);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_NO_EOT_PACKET |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS |
+			  MIPI_DSI_MODE_VIDEO_NO_HFP |
+			  MIPI_DSI_MODE_VIDEO_NO_HBP |
+			  MIPI_DSI_MODE_VIDEO_NO_HSA;
+
+	drm_panel_init(&ctx->panel, dev, &ili9881_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void ili9881_remove(struct mipi_dsi_device *dsi)
+{
+	struct ili9881 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id ili9881_of_match[] = {
+	{ .compatible = "wingtech,yassy-ili9881" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ili9881_of_match);
+
+static struct mipi_dsi_driver ili9881_driver = {
+	.probe = ili9881_probe,
+	.remove = ili9881_remove,
+	.driver = {
+		.name = "panel-wingtech-yassy-ili9881",
+		.of_match_table = ili9881_of_match,
+	},
+};
+module_mipi_dsi_driver(ili9881_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for ili9881_HD720p_video_Yassy");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/panel/panel-samsung-s6e88a0-ams452ef01.c b/drivers/gpu/drm/panel/panel-samsung-s6e88a0-ams452ef01.c
index d2df227abbea..5a8b99774925 100644
--- a/drivers/gpu/drm/panel/panel-samsung-s6e88a0-ams452ef01.c
+++ b/drivers/gpu/drm/panel/panel-samsung-s6e88a0-ams452ef01.c
@@ -223,6 +223,7 @@ static int s6e88a0_ams452ef01_probe(struct mipi_dsi_device *dsi)
 
 	drm_panel_init(&ctx->panel, dev, &s6e88a0_ams452ef01_panel_funcs,
 		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
 
 	drm_panel_add(&ctx->panel);
 
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index 86735430462f..22605e2412dd 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -5162,6 +5162,38 @@ static const struct panel_desc_dsi boe_tv080wum_nl0 = {
 	.lanes = 4,
 };
 
+static const struct drm_display_mode lg_c50_panel_mode = {
+	.clock = (480 + 24 + 8 + 88) * (854 + 1070 + 4 + 12) * 60 / 1000,
+	.hdisplay = 480,
+	.hsync_start = 480 + 24,
+	.hsync_end = 480 + 24 + 8,
+	.htotal = 480 + 24 + 8 + 88,
+	.vdisplay = 854,
+	.vsync_start = 854 + 1070,
+	.vsync_end = 854 + 1070 + 4,
+	.vtotal = 854 + 1070 + 4 + 12,
+	.width_mm = 55,
+	.height_mm = 99,
+};
+
+static const struct panel_desc_dsi lg_c50_panel = {
+	.desc = {
+		.modes = &lg_c50_panel_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 55,
+			.height = 99,
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_NO_EOT_PACKET |
+		 MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 2,
+};
+
+
 static const struct drm_display_mode lg_ld070wx3_sl01_mode = {
 	.clock = 71000,
 	.hdisplay = 800,
@@ -5218,6 +5250,36 @@ static const struct panel_desc_dsi lg_lh500wx1_sd03 = {
 	.lanes = 4,
 };
 
+static const struct drm_display_mode lgd_incell_m2db7400_mode = {
+	.clock = (720 + 82 + 4 + 120) * (1280 + 540 + 1 + 11) * 60 / 1000,
+	.hdisplay = 720,
+	.hsync_start = 720 + 82,
+	.hsync_end = 720 + 82 + 4,
+	.htotal = 720 + 82 + 4 + 120,
+	.vdisplay = 1280,
+	.vsync_start = 1280 + 540,
+	.vsync_end = 1280 + 540 + 1,
+	.vtotal = 1280 + 540 + 1 + 11,
+	.width_mm = 66,
+	.height_mm = 117,
+};
+
+static const struct panel_desc_dsi lgd_incell_m2db7400 = {
+	.desc = {
+		.modes = &lgd_incell_m2db7400_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 66,
+			.height = 117,
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_NO_EOT_PACKET,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
 static const struct drm_display_mode panasonic_vvx10f004b00_mode = {
 	.clock = 157200,
 	.hdisplay = 1920,
@@ -5306,6 +5368,37 @@ static const struct panel_desc_dsi osd101t2045_53ts = {
 	.lanes = 4,
 };
 
+static const struct drm_display_mode tc358764_ltl101a106_mode = {
+	.clock = (1280 + 52 + 4 + 48) * (800 + 32 + 6 + 64) * 60 / 1000,
+	.hdisplay = 1280,
+	.hsync_start = 1280 + 52,
+	.hsync_end = 1280 + 52 + 4,
+	.htotal = 1280 + 52 + 4 + 48,
+	.vdisplay = 800,
+	.vsync_start = 800 + 32,
+	.vsync_end = 800 + 32 + 6,
+	.vtotal = 800 + 32 + 6 + 64,
+	.width_mm = 228,
+	.height_mm = 149,
+};
+
+static const struct panel_desc_dsi tc358764_ltl101a106 = {
+	.desc = {
+		.modes = &tc358764_ltl101a106_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 228,
+			.height = 149,
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
+		 MIPI_DSI_MODE_NO_EOT_PACKET,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
 static const struct of_device_id dsi_of_match[] = {
 	{
 		.compatible = "auo,b080uan01",
@@ -5313,12 +5406,18 @@ static const struct of_device_id dsi_of_match[] = {
 	}, {
 		.compatible = "boe,tv080wum-nl0",
 		.data = &boe_tv080wum_nl0
+	}, {
+		.compatible = "lg,c50-panel",
+		.data = &lg_c50_panel
 	}, {
 		.compatible = "lg,ld070wx3-sl01",
 		.data = &lg_ld070wx3_sl01
 	}, {
 		.compatible = "lg,lh500wx1-sd03",
 		.data = &lg_lh500wx1_sd03
+	}, {
+		.compatible = "lg,m2db7400-incell-simple",
+		.data = &lgd_incell_m2db7400
 	}, {
 		.compatible = "panasonic,vvx10f004b00",
 		.data = &panasonic_vvx10f004b00
@@ -5328,6 +5427,9 @@ static const struct of_device_id dsi_of_match[] = {
 	}, {
 		.compatible = "osddisplays,osd101t2045-53ts",
 		.data = &osd101t2045_53ts
+	}, {
+		.compatible = "samsung,tc358764-ltl101al06-simple",
+		.data = &tc358764_ltl101a106
 	}, {
 		/* sentinel */
 	}
diff --git a/drivers/input/rmi4/rmi_f12.c b/drivers/input/rmi4/rmi_f12.c
index 8246fe77114b..75913f21980d 100644
--- a/drivers/input/rmi4/rmi_f12.c
+++ b/drivers/input/rmi4/rmi_f12.c
@@ -4,6 +4,7 @@
  */
 #include <linux/input.h>
 #include <linux/input/mt.h>
+#include <linux/of.h>
 #include <linux/rmi.h>
 #include "rmi_driver.h"
 #include "rmi_2d_sensor.h"
@@ -40,6 +41,7 @@ struct f12_data {
 	/* F12 Data1 describes sensed objects */
 	const struct rmi_register_desc_item *data1;
 	u16 data1_offset;
+	u8 data1_bytes_per_obj;
 
 	/* F12 Data5 describes finger ACM */
 	const struct rmi_register_desc_item *data5;
@@ -166,12 +168,12 @@ static int rmi_f12_read_sensor_tuning(struct f12_data *f12)
 
 static void rmi_f12_process_objects(struct f12_data *f12, u8 *data1, int size)
 {
-	int i;
+	int i, j;
 	struct rmi_2d_sensor *sensor = &f12->sensor;
 	int objects = f12->data1->num_subpackets;
 
-	if ((f12->data1->num_subpackets * F12_DATA1_BYTES_PER_OBJ) > size)
-		objects = size / F12_DATA1_BYTES_PER_OBJ;
+	if ((f12->data1->num_subpackets * f12->data1_bytes_per_obj) > size)
+		objects = size / f12->data1_bytes_per_obj;
 
 	for (i = 0; i < objects; i++) {
 		struct rmi_2d_sensor_abs_object *obj = &sensor->objs[i];
@@ -198,13 +200,17 @@ static void rmi_f12_process_objects(struct f12_data *f12, u8 *data1, int size)
 
 		obj->x = (data1[2] << 8) | data1[1];
 		obj->y = (data1[4] << 8) | data1[3];
-		obj->z = data1[5];
-		obj->wx = data1[6];
-		obj->wy = data1[7];
+		j = 5;
+		if ((f12->data1_bytes_per_obj & 1) == 0) /* 6 or 8 */
+			obj->z = data1[j++];
+		if (f12->data1_bytes_per_obj > 6) {
+			obj->wx = data1[j++];
+			obj->wy = data1[j++];
+		}
 
 		rmi_2d_sensor_abs_process(sensor, obj, i);
 
-		data1 += F12_DATA1_BYTES_PER_OBJ;
+		data1 += f12->data1_bytes_per_obj;
 	}
 
 	if (sensor->kernel_tracking)
@@ -560,6 +566,18 @@ static int rmi_f12_probe(struct rmi_function *fn)
 	if (ret)
 		return ret;
 
+	f12->data1_bytes_per_obj = F12_DATA1_BYTES_PER_OBJ;
+	if (of_property_read_bool(fn->dev.of_node, "syna,no-pressure")) {
+		f12->data1_bytes_per_obj -= 1;
+		__clear_bit(ABS_MT_PRESSURE, sensor->input->absbit);
+	}
+	if (of_property_read_bool(fn->dev.of_node, "syna,no-width")) {
+		f12->data1_bytes_per_obj -= 2;
+		__clear_bit(ABS_MT_TOUCH_MAJOR, sensor->input->absbit);
+		__clear_bit(ABS_MT_TOUCH_MINOR, sensor->input->absbit);
+		__clear_bit(ABS_MT_ORIENTATION, sensor->input->absbit);
+	}
+
 	return 0;
 }
 
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 1ac26fc2e3eb..da1bffe53aad 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -428,6 +428,16 @@ config TOUCHSCREEN_HIDEEP
 	  To compile this driver as a module, choose M here : the
 	  module will be called hideep_ts.
 
+config TOUCHSCREEN_HIMAX_HX852X
+	tristate "Himax HX852x(ES) touchscreen"
+	depends on I2C
+	help
+	  Say Y here if you have a Himax HX852x(ES) touchscreen.
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called himax_hx852x.
+
 config TOUCHSCREEN_HYCON_HY46XX
 	tristate "Hycon hy46xx touchscreen support"
 	depends on I2C
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 82bc837ca01e..8055087b4ebb 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -48,6 +48,7 @@ obj-$(CONFIG_TOUCHSCREEN_GOODIX_BERLIN_CORE)	+= goodix_berlin_core.o
 obj-$(CONFIG_TOUCHSCREEN_GOODIX_BERLIN_I2C)	+= goodix_berlin_i2c.o
 obj-$(CONFIG_TOUCHSCREEN_GOODIX_BERLIN_SPI)	+= goodix_berlin_spi.o
 obj-$(CONFIG_TOUCHSCREEN_HIDEEP)	+= hideep.o
+obj-$(CONFIG_TOUCHSCREEN_HIMAX_HX852X)	+= himax_hx852x.o
 obj-$(CONFIG_TOUCHSCREEN_HYNITRON_CSTXXX)	+= hynitron_cstxxx.o
 obj-$(CONFIG_TOUCHSCREEN_ILI210X)	+= ili210x.o
 obj-$(CONFIG_TOUCHSCREEN_ILITEK)	+= ilitek_ts_i2c.o
diff --git a/drivers/input/touchscreen/himax_hx852x.c b/drivers/input/touchscreen/himax_hx852x.c
new file mode 100644
index 000000000000..3a418557645b
--- /dev/null
+++ b/drivers/input/touchscreen/himax_hx852x.c
@@ -0,0 +1,500 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Himax HX852x(ES) Touchscreen Driver
+ * Copyright (c) 2020-2024 Stephan Gerhold <stephan@gerhold.net>
+ * Copyright (c) 2020 Jonathan Albrieux <jonathan.albrieux@gmail.com>
+ *
+ * Based on the Himax Android Driver Sample Code Ver 0.3 for HMX852xES chipset:
+ * Copyright (c) 2014 Himax Corporation.
+ */
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/input/touchscreen.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+#include <linux/unaligned.h>
+
+#define HX852X_COORD_SIZE(fingers)	((fingers) * sizeof(struct hx852x_coord))
+#define HX852X_WIDTH_SIZE(fingers)	ALIGN(fingers, 4)
+#define HX852X_BUF_SIZE(fingers)	(HX852X_COORD_SIZE(fingers) + \
+					 HX852X_WIDTH_SIZE(fingers) + \
+					 sizeof(struct hx852x_touch_info))
+
+#define HX852X_MAX_FINGERS		12
+#define HX852X_MAX_KEY_COUNT		4
+#define HX852X_MAX_BUF_SIZE		HX852X_BUF_SIZE(HX852X_MAX_FINGERS)
+
+#define HX852X_TS_SLEEP_IN		0x80
+#define HX852X_TS_SLEEP_OUT		0x81
+#define HX852X_TS_SENSE_OFF		0x82
+#define HX852X_TS_SENSE_ON		0x83
+#define HX852X_READ_ONE_EVENT		0x85
+#define HX852X_READ_ALL_EVENTS		0x86
+#define HX852X_READ_LATEST_EVENT	0x87
+#define HX852X_CLEAR_EVENT_STACK	0x88
+
+#define HX852X_REG_SRAM_SWITCH		0x8c
+#define HX852X_REG_SRAM_ADDR		0x8b
+#define HX852X_REG_FLASH_RPLACE		0x5a
+
+#define HX852X_SRAM_SWITCH_TEST_MODE	0x14
+#define HX852X_SRAM_ADDR_CONFIG		0x7000
+
+struct hx852x {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct touchscreen_properties props;
+	struct gpio_desc *reset_gpiod;
+	struct regulator_bulk_data supplies[2];
+	unsigned int max_fingers;
+	unsigned int keycount;
+	unsigned int keycodes[HX852X_MAX_KEY_COUNT];
+};
+
+struct hx852x_config {
+	u8 rx_num;
+	u8 tx_num;
+	u8 max_pt;
+	u8 padding1[3];
+	__be16 x_res;
+	__be16 y_res;
+	u8 padding2[2];
+} __packed __aligned(4);
+
+struct hx852x_coord {
+	__be16 x;
+	__be16 y;
+} __packed __aligned(4);
+
+struct hx852x_touch_info {
+	u8 finger_num;
+	__le16 finger_pressed;
+	u8 padding;
+} __packed __aligned(4);
+
+static int hx852x_i2c_read(struct hx852x *hx, u8 cmd, void *data, u16 len)
+{
+	struct i2c_client *client = hx->client;
+	int ret;
+
+	struct i2c_msg msg[] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = &cmd,
+		},
+		{
+			.addr = client->addr,
+			.flags = I2C_M_RD,
+			.len = len,
+			.buf = data,
+		},
+	};
+
+	ret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
+	if (ret != ARRAY_SIZE(msg)) {
+		dev_err(&client->dev, "failed to read %#x: %d\n", cmd, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int hx852x_power_on(struct hx852x *hx)
+{
+	struct device *dev = &hx->client->dev;
+	int error;
+
+	error = regulator_bulk_enable(ARRAY_SIZE(hx->supplies), hx->supplies);
+	if (error) {
+		dev_err(dev, "failed to enable regulators: %d\n", error);
+		return error;
+	}
+
+	gpiod_set_value_cansleep(hx->reset_gpiod, 1);
+	msleep(20);
+	gpiod_set_value_cansleep(hx->reset_gpiod, 0);
+	msleep(50);
+
+	return 0;
+}
+
+static int hx852x_start(struct hx852x *hx)
+{
+	struct device *dev = &hx->client->dev;
+	int error;
+
+	error = i2c_smbus_write_byte(hx->client, HX852X_TS_SLEEP_OUT);
+	if (error) {
+		dev_err(dev, "failed to send TS_SLEEP_OUT: %d\n", error);
+		return error;
+	}
+	msleep(30);
+
+	error = i2c_smbus_write_byte(hx->client, HX852X_TS_SENSE_ON);
+	if (error) {
+		dev_err(dev, "failed to send TS_SENSE_ON: %d\n", error);
+		return error;
+	}
+	msleep(20);
+
+	return 0;
+}
+
+static int hx852x_stop(struct hx852x *hx)
+{
+	struct device *dev = &hx->client->dev;
+	int error;
+
+	error = i2c_smbus_write_byte(hx->client, HX852X_TS_SENSE_OFF);
+	if (error) {
+		dev_err(dev, "failed to send TS_SENSE_OFF: %d\n", error);
+		return error;
+	}
+	msleep(20);
+
+	error = i2c_smbus_write_byte(hx->client, HX852X_TS_SLEEP_IN);
+	if (error) {
+		dev_err(dev, "failed to send TS_SLEEP_IN: %d\n", error);
+		return error;
+	}
+	msleep(30);
+
+	return 0;
+}
+
+static int hx852x_power_off(struct hx852x *hx)
+{
+	struct device *dev = &hx->client->dev;
+	int error;
+
+	error = regulator_bulk_disable(ARRAY_SIZE(hx->supplies), hx->supplies);
+	if (error) {
+		dev_err(dev, "failed to disable regulators: %d\n", error);
+		return error;
+	}
+
+	return 0;
+}
+
+static int hx852x_read_config(struct hx852x *hx)
+{
+	struct device *dev = &hx->client->dev;
+	struct hx852x_config conf;
+	int x_res, y_res;
+	int error;
+
+	error = hx852x_power_on(hx);
+	if (error)
+		return error;
+
+	/* Sensing must be turned on briefly to load the config */
+	error = hx852x_start(hx);
+	if (error)
+		goto err_power_off;
+
+	error = hx852x_stop(hx);
+	if (error)
+		goto err_power_off;
+
+	error = i2c_smbus_write_byte_data(hx->client, HX852X_REG_SRAM_SWITCH,
+					  HX852X_SRAM_SWITCH_TEST_MODE);
+	if (error)
+		goto err_power_off;
+
+	error = i2c_smbus_write_word_data(hx->client, HX852X_REG_SRAM_ADDR,
+					  HX852X_SRAM_ADDR_CONFIG);
+	if (error)
+		goto err_test_mode;
+
+	error = hx852x_i2c_read(hx, HX852X_REG_FLASH_RPLACE, &conf, sizeof(conf));
+	if (error)
+		goto err_test_mode;
+
+	x_res = be16_to_cpu(conf.x_res);
+	y_res = be16_to_cpu(conf.y_res);
+	hx->max_fingers = (conf.max_pt & 0xf0) >> 4;
+	dev_dbg(dev, "x res: %u, y res: %u, max fingers: %u\n",
+		x_res, y_res, hx->max_fingers);
+
+	if (hx->max_fingers > HX852X_MAX_FINGERS) {
+		dev_err(dev, "max supported fingers: %u, found: %u\n",
+			HX852X_MAX_FINGERS, hx->max_fingers);
+		error = -EINVAL;
+		goto err_test_mode;
+	}
+
+	if (x_res && y_res) {
+		input_set_abs_params(hx->input_dev, ABS_MT_POSITION_X, 0, x_res - 1, 0, 0);
+		input_set_abs_params(hx->input_dev, ABS_MT_POSITION_Y, 0, y_res - 1, 0, 0);
+	}
+
+err_test_mode:
+	error = i2c_smbus_write_byte_data(hx->client, HX852X_REG_SRAM_SWITCH, 0) ? : error;
+err_power_off:
+	return hx852x_power_off(hx) ? : error;
+}
+
+static int hx852x_handle_events(struct hx852x *hx)
+{
+	/*
+	 * The event packets have variable size, depending on the amount of
+	 * supported fingers (hx->max_fingers). They are laid out as follows:
+	 *  - struct hx852x_coord[hx->max_fingers]: Coordinates for each finger
+	 *  - u8[ALIGN(hx->max_fingers, 4)]: Touch width for each finger
+	 *      with padding for 32-bit alignment
+	 *  - struct hx852x_touch_info
+	 *
+	 * Load everything into a 32-bit aligned buffer so the coordinates
+	 * can be assigned directly, without using get_unaligned_*().
+	 */
+	u8 buf[HX852X_MAX_BUF_SIZE] __aligned(4);
+	struct hx852x_coord *coord = (struct hx852x_coord *)buf;
+	u8 *width = &buf[HX852X_COORD_SIZE(hx->max_fingers)];
+	struct hx852x_touch_info *info = (struct hx852x_touch_info *)
+		&width[HX852X_WIDTH_SIZE(hx->max_fingers)];
+	unsigned long finger_pressed, key_pressed;
+	unsigned int i, x, y, w;
+	int error;
+
+	error = hx852x_i2c_read(hx, HX852X_READ_ALL_EVENTS, buf,
+				HX852X_BUF_SIZE(hx->max_fingers));
+	if (error)
+		return error;
+
+	finger_pressed = get_unaligned_le16(&info->finger_pressed);
+	key_pressed = finger_pressed >> HX852X_MAX_FINGERS;
+
+	/* All bits are set when no touch is detected */
+	if (info->finger_num == 0xff || !(info->finger_num & 0x0f))
+		finger_pressed = 0;
+	if (key_pressed == 0xf)
+		key_pressed = 0;
+
+	for_each_set_bit(i, &finger_pressed, hx->max_fingers) {
+		x = be16_to_cpu(coord[i].x);
+		y = be16_to_cpu(coord[i].y);
+		w = width[i];
+
+		input_mt_slot(hx->input_dev, i);
+		input_mt_report_slot_state(hx->input_dev, MT_TOOL_FINGER, 1);
+		touchscreen_report_pos(hx->input_dev, &hx->props, x, y, true);
+		input_report_abs(hx->input_dev, ABS_MT_TOUCH_MAJOR, w);
+	}
+	input_mt_sync_frame(hx->input_dev);
+
+	for (i = 0; i < hx->keycount; i++)
+		input_report_key(hx->input_dev, hx->keycodes[i], key_pressed & BIT(i));
+
+	input_sync(hx->input_dev);
+	return 0;
+}
+
+static irqreturn_t hx852x_interrupt(int irq, void *ptr)
+{
+	struct hx852x *hx = ptr;
+	int error;
+
+	error = hx852x_handle_events(hx);
+	if (error) {
+		dev_err_ratelimited(&hx->client->dev, "failed to handle events: %d\n", error);
+		return IRQ_NONE;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int hx852x_input_open(struct input_dev *dev)
+{
+	struct hx852x *hx = input_get_drvdata(dev);
+	int error;
+
+	error = hx852x_power_on(hx);
+	if (error)
+		return error;
+
+	error = hx852x_start(hx);
+	if (error) {
+		hx852x_power_off(hx);
+		return error;
+	}
+
+	enable_irq(hx->client->irq);
+	return 0;
+}
+
+static void hx852x_input_close(struct input_dev *dev)
+{
+	struct hx852x *hx = input_get_drvdata(dev);
+
+	hx852x_stop(hx);
+	disable_irq(hx->client->irq);
+	hx852x_power_off(hx);
+}
+
+static int hx852x_parse_properties(struct hx852x *hx)
+{
+	struct device *dev = &hx->client->dev;
+	int error, count;
+
+	count = device_property_count_u32(dev, "linux,keycodes");
+	if (count == -EINVAL) {
+		/* Property does not exist, keycodes are optional */
+		return 0;
+	} else if (count < 0) {
+		dev_err(dev, "Failed to read linux,keycodes: %d\n", count);
+		return count;
+	} else if (count > HX852X_MAX_KEY_COUNT) {
+		dev_err(dev, "max supported keys: %u, found: %u\n",
+			HX852X_MAX_KEY_COUNT, hx->keycount);
+		return -EINVAL;
+	}
+	hx->keycount = count;
+
+	error = device_property_read_u32_array(dev, "linux,keycodes",
+					       hx->keycodes, hx->keycount);
+	if (error) {
+		dev_err(dev, "failed to read linux,keycodes: %d\n", error);
+		return error;
+	}
+
+	return 0;
+}
+
+static int hx852x_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct hx852x *hx;
+	int error, i;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |
+				     I2C_FUNC_SMBUS_WRITE_BYTE |
+				     I2C_FUNC_SMBUS_WRITE_BYTE_DATA |
+				     I2C_FUNC_SMBUS_WRITE_WORD_DATA)) {
+		dev_err(dev, "not all required i2c functionality supported\n");
+		return -ENXIO;
+	}
+
+	hx = devm_kzalloc(dev, sizeof(*hx), GFP_KERNEL);
+	if (!hx)
+		return -ENOMEM;
+
+	hx->client = client;
+	hx->input_dev = devm_input_allocate_device(dev);
+	if (!hx->input_dev)
+		return -ENOMEM;
+
+	hx->input_dev->name = "Himax HX852x";
+	hx->input_dev->id.bustype = BUS_I2C;
+	hx->input_dev->open = hx852x_input_open;
+	hx->input_dev->close = hx852x_input_close;
+
+	i2c_set_clientdata(client, hx);
+	input_set_drvdata(hx->input_dev, hx);
+
+	hx->supplies[0].supply = "vcca";
+	hx->supplies[1].supply = "vccd";
+	error = devm_regulator_bulk_get(dev, ARRAY_SIZE(hx->supplies), hx->supplies);
+	if (error)
+		return dev_err_probe(dev, error, "failed to get regulators\n");
+
+	hx->reset_gpiod = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(hx->reset_gpiod))
+		return dev_err_probe(dev, PTR_ERR(hx->reset_gpiod),
+				     "failed to get reset gpio\n");
+
+	error = devm_request_threaded_irq(dev, client->irq, NULL, hx852x_interrupt,
+					  IRQF_ONESHOT | IRQF_NO_AUTOEN, NULL, hx);
+	if (error)
+		return dev_err_probe(dev, error, "failed to request irq %d", client->irq);
+
+	error = hx852x_read_config(hx);
+	if (error)
+		return error;
+
+	input_set_capability(hx->input_dev, EV_ABS, ABS_MT_POSITION_X);
+	input_set_capability(hx->input_dev, EV_ABS, ABS_MT_POSITION_Y);
+	input_set_abs_params(hx->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+
+	touchscreen_parse_properties(hx->input_dev, true, &hx->props);
+	error = hx852x_parse_properties(hx);
+	if (error)
+		return error;
+
+	hx->input_dev->keycode = hx->keycodes;
+	hx->input_dev->keycodemax = hx->keycount;
+	hx->input_dev->keycodesize = sizeof(hx->keycodes[0]);
+	for (i = 0; i < hx->keycount; i++)
+		input_set_capability(hx->input_dev, EV_KEY, hx->keycodes[i]);
+
+	error = input_mt_init_slots(hx->input_dev, hx->max_fingers,
+				    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);
+	if (error)
+		return dev_err_probe(dev, error, "failed to init MT slots\n");
+
+	error = input_register_device(hx->input_dev);
+	if (error)
+		return dev_err_probe(dev, error, "failed to register input device\n");
+
+	return 0;
+}
+
+static int hx852x_suspend(struct device *dev)
+{
+	struct hx852x *hx = dev_get_drvdata(dev);
+	int error = 0;
+
+	mutex_lock(&hx->input_dev->mutex);
+	if (input_device_enabled(hx->input_dev))
+		error = hx852x_stop(hx);
+	mutex_unlock(&hx->input_dev->mutex);
+
+	return error;
+}
+
+static int hx852x_resume(struct device *dev)
+{
+	struct hx852x *hx = dev_get_drvdata(dev);
+	int error = 0;
+
+	mutex_lock(&hx->input_dev->mutex);
+	if (input_device_enabled(hx->input_dev))
+		error = hx852x_start(hx);
+	mutex_unlock(&hx->input_dev->mutex);
+
+	return error;
+}
+
+static DEFINE_SIMPLE_DEV_PM_OPS(hx852x_pm_ops, hx852x_suspend, hx852x_resume);
+
+#ifdef CONFIG_OF
+static const struct of_device_id hx852x_of_match[] = {
+	{ .compatible = "himax,hx852es" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, hx852x_of_match);
+#endif
+
+static struct i2c_driver hx852x_driver = {
+	.probe = hx852x_probe,
+	.driver = {
+		.name = "himax_hx852x",
+		.pm = pm_sleep_ptr(&hx852x_pm_ops),
+		.of_match_table = of_match_ptr(hx852x_of_match),
+	},
+};
+module_i2c_driver(hx852x_driver);
+
+MODULE_DESCRIPTION("Himax HX852x(ES) Touchscreen Driver");
+MODULE_AUTHOR("Jonathan Albrieux <jonathan.albrieux@gmail.com>");
+MODULE_AUTHOR("Stephan Gerhold <stephan@gerhold.net>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/stmfts.c b/drivers/input/touchscreen/stmfts.c
index 119cd26851cf..9c0236e94dec 100644
--- a/drivers/input/touchscreen/stmfts.c
+++ b/drivers/input/touchscreen/stmfts.c
@@ -68,6 +68,7 @@
 #define STMFTS_DATA_MAX_SIZE	(STMFTS_EVENT_SIZE * STMFTS_STACK_DEPTH)
 #define STMFTS_MAX_FINGERS	10
 #define STMFTS_DEV_NAME		"stmfts"
+#define STMFTS_RETRY_COUNT	3
 
 enum stmfts_regulators {
 	STMFTS_REGULATOR_VDD,
@@ -317,19 +318,20 @@ static irqreturn_t stmfts_irq_handler(int irq, void *dev)
 
 static int stmfts_command(struct stmfts_data *sdata, const u8 cmd)
 {
-	int err;
+	int err, retry;
 
 	reinit_completion(&sdata->cmd_done);
 
-	err = i2c_smbus_write_byte(sdata->client, cmd);
-	if (err)
-		return err;
-
-	if (!wait_for_completion_timeout(&sdata->cmd_done,
-					 msecs_to_jiffies(1000)))
-		return -ETIMEDOUT;
+	for (retry = 0; retry < STMFTS_RETRY_COUNT; retry++) {
+		err = i2c_smbus_write_byte(sdata->client, cmd);
+		if (err)
+			return err;
 
-	return 0;
+		if (wait_for_completion_timeout(&sdata->cmd_done,
+						msecs_to_jiffies(1000)))
+			return 0;
+	}
+	return -ETIMEDOUT;
 }
 
 static int stmfts_input_open(struct input_dev *dev)
diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig
index b3aa1f5d5321..0faf80b2fa68 100644
--- a/drivers/iommu/Kconfig
+++ b/drivers/iommu/Kconfig
@@ -321,7 +321,7 @@ config ARM_SMMU
 	depends on !GENERIC_ATOMIC64	# for IOMMU_IO_PGTABLE_LPAE
 	select IOMMU_API
 	select IOMMU_IO_PGTABLE_LPAE
-	select ARM_DMA_USE_IOMMU if ARM
+	select ARM_DMA_USE_IOMMU if ARM && !IOMMU_DMA
 	help
 	  Support for implementations of the ARM System MMU architecture
 	  versions 1 and 2.
@@ -482,7 +482,7 @@ config QCOM_IOMMU
 	select QCOM_SCM
 	select IOMMU_API
 	select IOMMU_IO_PGTABLE_LPAE
-	select ARM_DMA_USE_IOMMU
+	select ARM_DMA_USE_IOMMU if !IOMMU_DMA
 	help
 	  Support for IOMMU on certain Qualcomm SoCs.
 
diff --git a/drivers/leds/flash/leds-ktd2692.c b/drivers/leds/flash/leds-ktd2692.c
index 16a01a200c0b..f52c8568a290 100644
--- a/drivers/leds/flash/leds-ktd2692.c
+++ b/drivers/leds/flash/leds-ktd2692.c
@@ -214,7 +214,7 @@ static int ktd2692_parse_dt(struct ktd2692_context *led, struct device *dev,
 	if (!np)
 		return -ENXIO;
 
-	led->props.ctrl_gpio = devm_gpiod_get(dev, "ctrl", GPIOD_ASIS);
+	led->props.ctrl_gpio = devm_gpiod_get(dev, "ctrl", GPIOD_OUT_HIGH);
 	ret = PTR_ERR_OR_ZERO(led->props.ctrl_gpio);
 	if (ret)
 		return dev_err_probe(dev, ret, "cannot get ctrl-gpios\n");
@@ -292,6 +292,7 @@ static int ktd2692_probe(struct platform_device *pdev)
 
 	fled_cdev = &led->fled_cdev;
 	led_cdev = &fled_cdev->led_cdev;
+	led->props.timing = ktd2692_timing;
 
 	ret = ktd2692_parse_dt(led, &pdev->dev, &led_cfg);
 	if (ret)
diff --git a/drivers/net/wireless/ath/wcn36xx/txrx.c b/drivers/net/wireless/ath/wcn36xx/txrx.c
index 8826998797d6..bd6c4cae84d6 100644
--- a/drivers/net/wireless/ath/wcn36xx/txrx.c
+++ b/drivers/net/wireless/ath/wcn36xx/txrx.c
@@ -367,7 +367,13 @@ int wcn36xx_rx_skb(struct wcn36xx *wcn, struct sk_buff *skb)
 		 */
 		u8 hwch = (bd->reserved0 << 4) + bd->rx_ch;
 
-		if (bd->rf_band != 1 && hwch <= sizeof(ab_rx_ch_map) && hwch >= 1) {
+		/* FIXME: For some reason WCN3620 sometimes sends packets that
+		 * look like 5 GHz even though it is 2.4 GHz only...
+		 */
+		if (bd->rf_band != 1 && hwch <= sizeof(ab_rx_ch_map) && hwch >= 1 &&
+		    !DO_ONCE_LITE_IF(wcn->rf_id == RF_IRIS_WCN3620, wcn36xx_warn,
+				     "Received 5 GHz band packet on WCN3620? "
+				     "(rf_band %d, hwch %d)\n", bd->rf_band, hwch)) {
 			status.band = NL80211_BAND_5GHZ;
 			status.freq = ieee80211_channel_to_frequency(ab_rx_ch_map[hwch - 1],
 								     status.band);
diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index bcfa63fb9f1e..c84db0624c18 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -650,6 +650,18 @@ config CHARGER_QCOM_SMBB
 	  documentation for more detail.  The base name for this driver is
 	  'pm8941_charger'.
 
+config SMB1360
+	tristate "Qualcomm SMB1360 charger and fuel gauge"
+	depends on I2C
+	depends on OF
+	select REGMAP_I2C
+	help
+	  Say Y to enable support for Qualcomm SMB1360 charger and fuel gauge.
+
+config SMB1360_DEBUG
+	bool "Dump SMB1360 registers before/after driver initialization"
+	depends on SMB1360
+
 config BATTERY_PM8916_BMS_VM
 	tristate "Qualcomm PM8916 BMS-VM support"
 	depends on MFD_SPMI_PMIC || COMPILE_TEST
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index 8dcb41545317..5b1b00860b83 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -86,6 +86,9 @@ obj-$(CONFIG_CHARGER_MP2629)	+= mp2629_charger.o
 obj-$(CONFIG_CHARGER_MT6360)	+= mt6360_charger.o
 obj-$(CONFIG_CHARGER_MT6370)	+= mt6370-charger.o
 obj-$(CONFIG_CHARGER_QCOM_SMBB)	+= qcom_smbb.o
+smb1360-y			:= smb1360-driver.o
+smb1360-$(CONFIG_SMB1360_DEBUG)	+= smb1360-dump.o
+obj-$(CONFIG_SMB1360)		+= smb1360.o
 obj-$(CONFIG_BATTERY_PM8916_BMS_VM)	+= pm8916_bms_vm.o
 obj-$(CONFIG_CHARGER_PM8916_LBC)	+= pm8916_lbc.o
 obj-$(CONFIG_CHARGER_BQ2415X)	+= bq2415x_charger.o
diff --git a/drivers/power/supply/pm8916_bms_vm.c b/drivers/power/supply/pm8916_bms_vm.c
index 5d0dd842509c..d1b4ccda357a 100644
--- a/drivers/power/supply/pm8916_bms_vm.c
+++ b/drivers/power/supply/pm8916_bms_vm.c
@@ -53,6 +53,7 @@ struct pm8916_bms_vm_battery {
 	unsigned int last_ocv;
 	time64_t last_ocv_time;
 	unsigned int vbat_now;
+	unsigned int fake_ocv;
 };
 
 static int pm8916_bms_vm_battery_get_property(struct power_supply *psy,
@@ -84,6 +85,10 @@ static int pm8916_bms_vm_battery_get_property(struct power_supply *psy,
 			val->intval = POWER_SUPPLY_HEALTH_GOOD;
 		return 0;
 
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = power_supply_batinfo_ocv2cap(info, bat->fake_ocv, 20);
+		return 0;
+
 	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
 		val->intval = bat->vbat_now;
 		return 0;
@@ -109,28 +114,75 @@ static enum power_supply_property pm8916_bms_vm_battery_properties[] = {
 	POWER_SUPPLY_PROP_VOLTAGE_NOW,
 	POWER_SUPPLY_PROP_VOLTAGE_OCV,
 	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_CAPACITY,
 };
 
 static irqreturn_t pm8916_bms_vm_fifo_update_done_irq(int irq, void *data)
 {
 	struct pm8916_bms_vm_battery *bat = data;
+	struct power_supply_battery_info *info = bat->info;
 	u16 vbat_data[PM8916_BMS_VM_FIFO_COUNT];
-	int ret;
+	int i, ret, delta = 0, loc_delta;
+	unsigned int tmp = 0;
+	int supplied;
 
 	ret = regmap_bulk_read(bat->regmap, bat->reg + PM8916_BMS_VM_BMS_FIFO_REG_0_LSB,
 			       &vbat_data, PM8916_BMS_VM_FIFO_COUNT * 2);
 	if (ret)
 		return IRQ_HANDLED;
 
+	/* We assume that we don't charge if no charger is present */
+	supplied = power_supply_am_i_supplied(bat->battery);
+	if (supplied == -ENODEV)
+		supplied = 0;
+	else if (supplied < 0)
+		return IRQ_HANDLED;
+
+	for (i = 0; i < PM8916_BMS_VM_FIFO_COUNT; i++) {
+		tmp = vbat_data[i] * 300 - 100000;
+
+		loc_delta = tmp - bat->vbat_now;
+		delta += loc_delta;
+		bat->vbat_now = tmp;
+	}
+
 	/*
 	 * The VM-BMS hardware only collects voltage data and the software
 	 * has to process it to calculate the OCV and SoC. Hardware provides
 	 * up to 8 averaged measurements for software to take in account.
 	 *
-	 * Just use the last measured value for now to report the current
-	 * battery voltage.
+	 * NOTE: Since VM-BMS is mostly implemented in software, OCV needs to be estimated.
+	 * This driver makes some assumptions to estimate OCV from averaged VBAT measurements
+	 * and initial OCV measurements taken on boot or while in suspend:
+	 *
+	 *  - When charger is online, ocv can only increase.
+	 *  - When charger is offline, ocv can only decrease and ocv > vbat.
+	 *  - ocv can't change more than 0.025v between the measurements.
+	 *  - When charger is in CV mode (vbat = const vbat-max), ocv increases by
+	 *    0.004v every measurement until it reaches vbat.
+	 *
+	 * Those assumptions give somewhat realistic estimation of ocv and capacity, though
+	 * in some worst case scenarios it will perform poorly.
+	 * Ideally proper BMS algorithm should be implemented in userspace.
 	 */
-	bat->vbat_now = vbat_data[PM8916_BMS_VM_FIFO_COUNT - 1] * 300;
+
+	if ((supplied && delta > 0) || (!supplied && delta < 0))
+		if (abs(delta) < 25000) /* 0.025v */
+			bat->fake_ocv += delta;
+
+	if (!supplied && bat->fake_ocv < bat->vbat_now)
+		bat->fake_ocv = bat->vbat_now;
+
+	regmap_write(bat->regmap, bat->reg + PM8916_BMS_VM_STATUS1, 0);
+	regmap_read(bat->regmap, bat->reg + PM8916_BMS_VM_STATUS1, &tmp);
+
+	if (PM8916_BMS_VM_FSM_STATE(tmp) == PM8916_BMS_VM_FSM_STATE_S2 &&
+	    bat->fake_ocv < bat->vbat_now - 10000 /* 0.01v */) {
+		bat->fake_ocv += 4000; /* 0.004v */
+	}
+
+	if (supplied && bat->fake_ocv > info->voltage_max_design_uv)
+		bat->fake_ocv = info->voltage_max_design_uv;
 
 	power_supply_changed(bat->battery);
 
@@ -208,6 +260,7 @@ static int pm8916_bms_vm_battery_probe(struct platform_device *pdev)
 	bat->last_ocv_time = ktime_get_seconds();
 	bat->last_ocv = tmp * 300;
 	bat->vbat_now = bat->last_ocv;
+	bat->fake_ocv = bat->last_ocv;
 
 	psy_cfg.drv_data = bat;
 	psy_cfg.of_node = dev->of_node;
@@ -266,6 +319,7 @@ static int pm8916_bms_vm_battery_resume(struct platform_device *pdev)
 
 	bat->last_ocv_time = ktime_get_seconds();
 	bat->last_ocv = tmp * 300;
+	bat->fake_ocv = bat->last_ocv;
 
 	ret = regmap_write(bat->regmap,
 			   bat->reg + PM8916_SEC_ACCESS, PM8916_SEC_MAGIC);
diff --git a/drivers/power/supply/smb1360-driver.c b/drivers/power/supply/smb1360-driver.c
new file mode 120000
index 000000000000..577704623ebc
--- /dev/null
+++ b/drivers/power/supply/smb1360-driver.c
@@ -0,0 +1 @@
+smb1360.c
\ No newline at end of file
diff --git a/drivers/power/supply/smb1360-dump.c b/drivers/power/supply/smb1360-dump.c
new file mode 100644
index 000000000000..c4ed494ace9b
--- /dev/null
+++ b/drivers/power/supply/smb1360-dump.c
@@ -0,0 +1,298 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+#define pr_fmt(fmt) "smb1360-dump: " fmt
+
+#include <linux/i2c.h>
+
+enum smb1360_reg_type {
+	LITTLE_ENDIAN,
+	BIG_ENDIAN,
+	RAW
+};
+
+struct smb1360_reg {
+	u8 addr;
+	const char *name;
+	u8 size;
+	enum smb1360_reg_type type;
+};
+
+struct smb1360_regset {
+	const char *name;
+	u8 start, end;
+	struct smb1360_reg regs[];
+};
+
+static const struct smb1360_regset smb1360_cfg = {
+	.name	= "configuration",
+	.start	= 0x00,
+	.end	= 0x1c,
+	.regs	= {
+		{ 0x00, "CFG_BATT_CHG_REG", 1 },
+		{ 0x05, "CFG_BATT_CHG_ICL_REG", 1 },
+		{ 0x06, "CFG_GLITCH_FLT_REG", 1 },
+		{ 0x07, "CFG_CHG_MISC_REG", 1 },
+		{ 0x08, "CFG_CHG_FUNC_CTRL_REG", 1 },
+		{ 0x09, "CFG_STAT_CTRL_REG", 1 },
+		{ 0x0a, "CFG_SFY_TIMER_CTRL_REG", 1 },
+		{ 0x0d, "CFG_BATT_MISSING_REG", 1 },
+		{ 0x0e, "CFG_FG_BATT_CTRL_REG", 1 },
+		{ 0x0f, "IRQ_CFG_REG", 1 },
+		{ 0x10, "IRQ2_CFG_REG", 1 },
+		{ 0x11, "IRQ3_CFG_REG", 1 },
+		{ 0x12, "PRE_TO_FAST_REG", 1 },
+		{ 0x13, "CHG_CURRENT_REG", 1 },
+		{ 0x14, "CHG_CMP_CFG", 1 },
+		{ 0x15, "BATT_CHG_FLT_VTG_REG", 1 },
+		{ 0x16, "CFG_FVC_REG", 1 },
+		{ 0x1a, "SHDN_CTRL_REG", 1 },
+		{ 0x1c, "TRIM_1C_REG", 1 },
+		{ }
+	}
+};
+
+static const struct smb1360_regset smb1360_fg_cfg = {
+	.name	= "fg configuration",
+	.start	= 0x20,
+	.end	= 0x2f,
+	.regs	= {
+		{ 0x20, "SHDW_FG_ESR_ACTUAL", 2 },
+		{ 0x24, "SOC_MAX_REG", 1 },
+		{ 0x25, "SOC_MIN_REG", 1 },
+		{ 0x26, "VTG_EMPTY_REG", 1 },
+		{ 0x27, "Temp_external", 1 },
+		{ 0x28, "SOC_DELTA_REG", 1 },
+		{ 0x29, "JEITA_SOFT_COLD_REG", 1 },
+		{ 0x2a, "JEITA_SOFT_HOT_REG", 1 },
+		{ 0x2b, "VTG_MIN_REG", 1 },
+		{ 0x2e, "ESR_sys_replace", 2 },
+		{ }
+	}
+};
+
+static const struct smb1360_regset smb1360_cmd = {
+	.name	= "command",
+	.start	= 0x40,
+	.end	= 0x42,
+	.regs	= {
+		{ 0x40, "CMD_I2C_REG", 1 },
+		{ 0x41, "CMD_IL_REG", 1 },
+		{ 0x42, "CMD_CHG_REG", 1 },
+		{ }
+	}
+};
+
+static const struct smb1360_regset smb1360_status = {
+	.name	= "status",
+	.start	= 0x48,
+	.end	= 0x4f,
+	.regs	= {
+		{ 0x48, "STATUS_1_REG", 1 },
+		{ 0x4b, "STATUS_3_REG", 1 },
+		{ 0x4c, "STATUS_4_REG", 1 },
+		{ 0x4f, "REVISION_CTRL_REG", 1 },
+		{ }
+	}
+};
+
+static const struct smb1360_regset smb1360_irq_status = {
+	.name	= "irq status",
+	.start	= 0x50,
+	.end	= 0x58,
+	.regs	= {
+		{ 0x50, "IRQ_A_REG", 1 },
+		{ 0x51, "IRQ_B_REG", 1 },
+		{ 0x52, "IRQ_C_REG", 1 },
+		{ 0x53, "IRQ_D_REG", 1 },
+		{ 0x54, "IRQ_E_REG", 1 },
+		{ 0x55, "IRQ_F_REG", 1 },
+		{ 0x56, "IRQ_G_REG", 1 },
+		{ 0x57, "IRQ_H_REG", 1 },
+		{ 0x58, "IRQ_I_REG", 1 },
+		{ }
+	}
+};
+
+static const struct smb1360_regset smb1360_fg_shdw = {
+	.name	= "fg shadow",
+	.start	= 0x60,
+	.end	= 0x6f,
+	.regs	= {
+		{ 0x60, "SHDW_FG_BATT_STATUS", 1 },
+		{ 0x61, "SHDW_FG_MSYS_SOC", 1 },
+		{ 0x62, "SHDW_FG_CAPACITY", 2 },
+		{ 0x64, "Rslow_drop", 2 },
+		{ 0x66, "Latest_SOC", 1 },
+		{ 0x67, "Latest_Cutoff_SOC", 1 },
+		{ 0x68, "Latest_full_SOC", 1 },
+		{ 0x69, "SHDW_FG_VTG_NOW", 2 },
+		{ 0x6b, "SHDW_FG_CURR_NOW", 2 },
+		{ 0x6d, "SHDW_FG_BATT_TEMP", 2 },
+		{ 0x6f, "Latest_system_sbits", 1 },
+		{ }
+	}
+};
+
+static const struct smb1360_regset smb1360_fg_scratch = {
+	.name	= "fg scratch pad",
+	.start	= 0x80,
+	.end	= 0xdc,
+	.regs	= {
+		{ 0x80, "VOLTAGE_PREDICTED_REG", 2 },
+		{ 0x82, "v_cutoff_predicted", 2 },
+		{ 0x84, "v_full_predicted", 2 },
+		{ 0x86, "ocv_estimate", 2 },
+		{ 0x88, "rslow_drop", 2 },
+		{ 0x8a, "voltage_old", 2 },
+		{ 0x8c, "current_old", 2 },
+		{ 0x8e, "current_average_full", 4 },
+		{ 0x92, "temperature", 2 },
+		{ 0x94, "temp_last_track", 2 },
+		{ 0x96, "ESR_nominal", 2 },
+		{ 0x9a, "Rslow", 2 },
+		{ 0x9c, "counter_imptr", 2 },
+		{ 0x9e, "counter_pulse", 2 },
+		{ 0xa0, "IRQ_delta_prev", 1 },
+		{ 0xa1, "cap_learning_counter", 1 },
+		{ 0xa2, "Vact_int_error", 4 },
+		{ 0xa6, "SOC_cutoff", 3 },
+		{ 0xa9, "SOC_full", 3 },
+		{ 0xac, "SOC_auto_rechrge_temp", 3 },
+		{ 0xaf, "Battery_SOC", 3 },
+		{ 0xb2, "CC_SOC", 4 },
+		{ 0xb6, "SOC_filtered", 2 },
+		{ 0xb8, "SOC_Monotonic", 2 },
+		{ 0xba, "CC_TO_SOC_COEFF", 2 },
+		{ 0xbc, "NOMINAL_CAPACITY_REG", 2 },
+		{ 0xbe, "ACTUAL_CAPACITY_REG", 2 },
+		{ 0xc4, "temperature_counter", 1 },
+		{ 0xc5, "Vbatt_filtered", 3 },
+		{ 0xc8, "Ibatt_filtered", 3 },
+		{ 0xcb, "Current_CC_shadow", 2 },
+		{ 0xcf, "FG_IBATT_STANDBY_REG", 2 },
+		{ 0xd2, "FG_AUTO_RECHARGE_SOC", 1 },
+		{ 0xd3, "FG_SYS_CUTOFF_V_REG", 2 },
+		{ 0xd5, "FG_CC_TO_CV_V_REG", 2 },
+		{ 0xd7, "System_term_current", 2 },
+		{ 0xd9, "System_fake_term_current", 2 },
+		{ 0xdb, "FG_THERM_C1_COEFF_REG", 2 },
+		{ }
+	}
+};
+
+/* Note: Only very few OTP registers are known, there may be many more! */
+static const struct smb1360_regset smb1360_fg_otp = {
+	.name	= "fg otp",
+	.start	= 0x12,
+	.end	= 0x1e,
+	.regs	= {
+		{ 0x12, "JEITA_HARD_COLD_REG", 1 },
+		{ 0x13, "JEITA_HARD_HOT_REG", 1 },
+		{ 0x1d, "CURRENT_GAIN_REG", 2 },
+		{ }
+	}
+};
+
+static const struct smb1360_regset smb1360_fg_otp_backup = {
+	.name	= "fg otp backup",
+	.start	= 0xe0,
+	.end	= 0xf1,
+	.regs	= {
+		{ 0xe0, "OTP_BACKUP_REG", 16, RAW },
+		{ 0xf0, "OTP_BACKUP_WA_ALG", 2, BIG_ENDIAN },
+		{ }
+	}
+};
+
+static void smb1360_reg_dump(const struct smb1360_reg *reg, const u8 val[])
+{
+	u32 num = 0;
+	int i;
+
+	switch (reg->type) {
+	case RAW:
+		pr_info("\t<0x%02x> %s %*ph\n", reg->addr, reg->name, reg->size, val);
+		return;
+	case LITTLE_ENDIAN:
+		for (i = 0; i < reg->size; ++i) {
+			num |= val[i] << (8 * i);
+		}
+		break;
+	case BIG_ENDIAN:
+		for (i = 0; i < reg->size; ++i) {
+			num <<= 8;
+			num |= val[i];
+		}
+		break;
+	}
+
+	pr_info("\t<0x%02x> %s %0*x\n", reg->addr, reg->name, 2 * reg->size, num);
+}
+
+static void smb1360_regset_dump(struct i2c_client *client, const struct smb1360_regset *set)
+{
+	const struct smb1360_reg *reg = set->regs;
+	u8 val[U8_MAX];
+	u8 r, next;
+	int ret;
+
+	pr_info("%s:\n", set->name);
+
+	for (r = set->start; r <= set->end; r += ret) {
+		u8 len = set->end - r + 1;
+		int i = r - set->start;
+
+		ret = i2c_smbus_read_i2c_block_data(client, r, len, &val[i]);
+		pr_info("\tread %s at 0x%02x len %d, ret %d\n", set->name, r, len, ret);
+		if (ret < 0) {
+			pr_err("\tFailed to read %d %s registers at 0x%02x: %d\n",
+			       len, set->name, r, ret);
+			return;
+		}
+	}
+
+	for (r = set->start; r <= set->end;) {
+		int i = r - set->start;
+
+		if (reg->name) {
+			if (r == reg->addr) {
+				smb1360_reg_dump(reg, &val[i]);
+				r += reg->size;
+				++reg;
+				continue;
+			}
+
+			/* Dump until next documented reg */
+			next = reg->addr;
+		} else {
+			/* No more documented regs, dump remaining regs */
+			next = set->end + 1;
+		}
+
+		pr_info("\t<0x%02x> %*ph\n", r, next - r, &val[i]);
+		r = next;
+	}
+}
+
+void smb1360_dump(struct i2c_client *client)
+{
+	smb1360_regset_dump(client, &smb1360_cfg);
+	smb1360_regset_dump(client, &smb1360_fg_cfg);
+	smb1360_regset_dump(client, &smb1360_cmd);
+	smb1360_regset_dump(client, &smb1360_status);
+	smb1360_regset_dump(client, &smb1360_irq_status);
+	smb1360_regset_dump(client, &smb1360_fg_shdw);
+}
+
+/* Should be called with smb1360_enable_fg_access() */
+void smb1360_dump_fg_scratch(struct i2c_client *client)
+{
+	smb1360_regset_dump(client, &smb1360_fg_scratch);
+}
+
+/* Should be called with smb1360_enable_fg_access() and FG I2C client */
+void smb1360_dump_fg(struct i2c_client *fg_client)
+{
+	smb1360_regset_dump(fg_client, &smb1360_fg_otp);
+	smb1360_regset_dump(fg_client, &smb1360_fg_otp_backup);
+	pr_info("\n");
+}
diff --git a/drivers/power/supply/smb1360.c b/drivers/power/supply/smb1360.c
new file mode 100644
index 000000000000..4555d910c934
--- /dev/null
+++ b/drivers/power/supply/smb1360.c
@@ -0,0 +1,1880 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Register definitions taken from drivers/power/smb1360-charger-fg.c
+ * Copyright (c) 2013-2015 The Linux Foundation. All rights reserved.
+ *
+ * TODO:
+ *  - Investigate using common battery device tree properties
+ *    (e.g. voltage-{min,max}-design-microvolt)
+ *  - Implement more power supply properties, e.g.
+ *    - POWER_SUPPLY_PROP_TEMP_{,ALERT_}{MIN,MAX}
+ *    - POWER_SUPPLY_PROP_CAPACITY_ALERT_{MIN,MAX}
+ *    - POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT
+ */
+
+#ifdef CONFIG_SMB1360_DEBUG
+#define DEBUG
+#endif
+
+#include <linux/completion.h>
+#include <linux/extcon-provider.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/power_supply.h>
+#include <linux/regmap.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+
+/* Charger Registers */
+#define CFG_BATT_CHG_REG		0x00
+#define CHG_ITERM_MASK			GENMASK(2, 0)
+#define RECHG_MV_MASK			GENMASK(6, 5)
+#define RECHG_MV_SHIFT			5
+#define OTG_CURRENT_MASK		GENMASK(4, 3)
+#define OTG_CURRENT_SHIFT		3
+
+#define CFG_BATT_CHG_ICL_REG		0x05
+#define AC_INPUT_ICL_PIN_BIT		BIT(7)
+#define AC_INPUT_PIN_HIGH_BIT		BIT(6)
+#define RESET_STATE_USB_500		BIT(5)
+#define INPUT_CURR_LIM_MASK		GENMASK(3, 0)
+
+#define CFG_GLITCH_FLT_REG		0x06
+#define AICL_ENABLED_BIT		BIT(0)
+#define INPUT_UV_GLITCH_FLT_20MS_BIT	BIT(7)
+
+#define CFG_CHG_MISC_REG		0x7
+#define CHG_EN_BY_PIN_BIT		BIT(7)
+#define CHG_EN_ACTIVE_LOW_BIT		BIT(6)
+#define PRE_TO_FAST_REQ_CMD_BIT		BIT(5)
+#define CFG_BAT_OV_ENDS_CHG_CYC		BIT(4)
+#define CHG_CURR_TERM_DIS_BIT		BIT(3)
+#define CFG_AUTO_RECHG_DIS_BIT		BIT(2)
+#define CFG_CHG_INHIBIT_EN_BIT		BIT(0)
+
+#define CFG_CHG_FUNC_CTRL_REG		0x08
+#define CHG_RECHG_THRESH_FG_SRC_BIT	BIT(1)
+
+#define CFG_STAT_CTRL_REG		0x09
+#define CHG_STAT_IRQ_ONLY_BIT		BIT(4)
+#define CHG_TEMP_CHG_ERR_BLINK_BIT	BIT(3)
+#define CHG_STAT_ACTIVE_HIGH_BIT	BIT(1)
+#define CHG_STAT_DISABLE_BIT		BIT(0)
+
+#define CFG_SFY_TIMER_CTRL_REG		0x0A
+#define SAFETY_TIME_DISABLE_BIT		BIT(5)
+#define SAFETY_TIME_MINUTES_SHIFT	2
+#define SAFETY_TIME_MINUTES_MASK	GENMASK(3, 2)
+
+#define CFG_BATT_MISSING_REG		0x0D
+#define BATT_MISSING_SRC_THERM_BIT	BIT(1)
+
+#define CFG_FG_BATT_CTRL_REG		0x0E
+#define CFG_FG_OTP_BACK_UP_ENABLE	BIT(7)
+#define BATT_ID_ENABLED_BIT		BIT(5)
+#define CHG_BATT_ID_FAIL		BIT(4)
+#define BATT_ID_FAIL_SELECT_PROFILE	BIT(3)
+#define BATT_PROFILE_SELECT_MASK	GENMASK(3, 0)
+#define BATT_PROFILEA_MASK		0x0
+#define BATT_PROFILEB_MASK		0xF
+
+#define IRQ_CFG_REG			0x0F
+#define IRQ_INTERNAL_TEMPERATURE_BIT	BIT(0)
+#define IRQ_AICL_DONE_BIT		BIT(1)
+#define IRQ_DCIN_UV_BIT			BIT(2)
+#define IRQ_BAT_HOT_COLD_SOFT_BIT	BIT(6)
+#define IRQ_HOT_COLD_HARD_BIT		BIT(7)
+
+#define IRQ2_CFG_REG			0x10
+#define IRQ2_VBAT_LOW_BIT		BIT(0)
+#define IRQ2_BATT_MISSING_BIT		BIT(1)
+#define IRQ2_POWER_OK_BIT		BIT(2)
+#define IRQ2_CHG_PHASE_CHANGE_BIT	BIT(4)
+#define IRQ2_CHG_ERR_BIT		BIT(6)
+#define IRQ2_SAFETY_TIMER_BIT		BIT(7)
+
+#define IRQ3_CFG_REG			0x11
+#define IRQ3_SOC_FULL_BIT		BIT(0)
+#define IRQ3_SOC_EMPTY_BIT		BIT(1)
+#define IRQ3_SOC_MAX_BIT		BIT(2)
+#define IRQ3_SOC_MIN_BIT		BIT(3)
+#define IRQ3_SOC_CHANGE_BIT		BIT(4)
+#define IRQ3_FG_ACCESS_OK_BIT		BIT(6)
+
+#define CHG_CURRENT_REG			0x13
+#define FASTCHG_CURR_MASK		GENMASK(4, 2)
+#define FASTCHG_CURR_SHIFT		2
+
+#define CHG_CMP_CFG			0x14
+#define JEITA_COMP_CURR_MASK		GENMASK(3, 0)
+#define JEITA_COMP_EN_MASK		GENMASK(7, 4)
+#define JEITA_COMP_EN_SHIFT		4
+#define JEITA_COMP_EN_BIT		GENMASK(7, 4)
+
+#define BATT_CHG_FLT_VTG_REG		0x15
+#define VFLOAT_MASK			GENMASK(6, 0)
+
+#define CFG_FVC_REG			0x16
+#define FLT_VTG_COMP_MASK		GENMASK(6, 0)
+
+#define SHDN_CTRL_REG			0x1A
+#define SHDN_CMD_USE_BIT		BIT(1)
+#define SHDN_CMD_POLARITY_BIT		BIT(2)
+
+/* Command Registers */
+#define CMD_I2C_REG			0x40
+#define ALLOW_VOLATILE_BIT		BIT(6)
+#define FG_ACCESS_ENABLED_BIT		BIT(5)
+#define FG_RESET_BIT			BIT(4)
+#define CYCLE_STRETCH_CLEAR_BIT		BIT(3)
+
+#define CMD_IL_REG			0x41
+#define USB_CTRL_MASK			GENMASK(1, 0)
+#define USB_100_BIT			0x01
+#define USB_500_BIT			0x00
+#define USB_AC_BIT			0x02
+#define SHDN_CMD_BIT			BIT(7)
+
+#define CMD_CHG_REG			0x42
+#define CMD_CHG_EN			BIT(1)
+#define CMD_OTG_EN_BIT			BIT(0)
+
+/* Status Registers */
+#define STATUS_1_REG			0x48
+#define AICL_CURRENT_STATUS_MASK	GENMASK(6, 0)
+#define AICL_LIMIT_1500MA		0xF
+
+#define STATUS_3_REG			0x4B
+#define CHG_HOLD_OFF_BIT		BIT(3)
+#define CHG_TYPE_MASK			GENMASK(2, 1)
+#define CHG_TYPE_SHIFT			1
+#define BATT_NOT_CHG_VAL		0x0
+#define BATT_PRE_CHG_VAL		0x1
+#define BATT_FAST_CHG_VAL		0x2
+#define BATT_TAPER_CHG_VAL		0x3
+
+#define STATUS_4_REG			0x4C
+#define CYCLE_STRETCH_ACTIVE_BIT	BIT(5)
+
+#define REVISION_CTRL_REG		0x4F
+#define DEVICE_REV_MASK			GENMASK(3, 0)
+
+/* IRQ Status Registers */
+#define IRQ_REG				0x50
+
+#define IRQ_A_REG			0x50
+#define IRQ_A_HOT_HARD_BIT		BIT(6)
+#define IRQ_A_COLD_HARD_BIT		BIT(4)
+#define IRQ_A_HOT_SOFT_BIT		BIT(2)
+#define IRQ_A_COLD_SOFT_BIT		BIT(0)
+
+#define IRQ_B_REG			0x51
+#define IRQ_B_BATT_TERMINAL_BIT		BIT(6)
+#define IRQ_B_BATT_MISSING_BIT		BIT(4)
+#define IRQ_B_VBAT_LOW_BIT		BIT(2)
+#define IRQ_B_CHG_HOT_BIT		BIT(0)
+
+#define IRQ_C_REG			0x52
+#define IRQ_C_FAST_CHG_BIT		BIT(6)
+#define IRQ_C_RECHARGE_BIT		BIT(4)
+#define IRQ_C_TAPER_BIT			BIT(2)
+#define IRQ_C_CHG_TERM_BIT		BIT(0)
+
+#define IRQ_D_REG			0x53
+#define IRQ_D_BATTERY_OV_BIT		BIT(6)
+#define IRQ_D_AICL_DONE_BIT		BIT(4)
+#define IRQ_D_SAFETY_TIMEOUT_BIT	BIT(2)
+#define IRQ_D_PRECHG_TIMEOUT_BIT	BIT(0)
+
+#define IRQ_E_REG			0x54
+#define IRQ_E_INHIBIT_BIT		BIT(6)
+#define IRQ_E_USBIN_OV_BIT		BIT(2)
+#define IRQ_E_USBIN_UV_BIT		BIT(0)
+
+#define IRQ_F_REG			0x55
+#define IRQ_F_OTG_OC_BIT		BIT(6)
+#define IRQ_F_OTG_FAIL_BIT		BIT(4)
+#define IRQ_F_POWER_OK_BIT		BIT(0)
+
+#define IRQ_G_REG			0x56
+#define IRQ_G_WD_TIMEOUT_BIT		BIT(4)
+#define IRQ_G_CHG_ERROR_BIT		BIT(2)
+#define IRQ_G_SOC_CHANGE_BIT		BIT(0)
+
+#define IRQ_H_REG			0x57
+#define IRQ_H_FULL_SOC_BIT		BIT(6)
+#define IRQ_H_EMPTY_SOC_BIT		BIT(4)
+#define IRQ_H_MAX_SOC_BIT		BIT(2)
+#define IRQ_H_MIN_SOC_BIT		BIT(0)
+
+#define IRQ_I_REG			0x58
+#define IRQ_I_BATT_ID_RESULT_BIT	GENMASK(6, 4)
+#define IRQ_I_BATT_ID_SHIFT		4
+#define IRQ_I_BATT_ID_COMPLETE_BIT	BIT(4)
+#define IRQ_I_FG_DATA_RECOVERY_BIT	BIT(2)
+#define IRQ_I_FG_ACCESS_ALLOWED_BIT	BIT(0)
+
+/* FG registers - IRQ config register */
+#define SOC_MAX_REG			0x24
+#define SOC_MIN_REG			0x25
+#define VTG_EMPTY_REG			0x26
+#define SOC_DELTA_REG			0x28
+#define JEITA_SOFT_COLD_REG		0x29
+#define JEITA_SOFT_HOT_REG		0x2A
+#define VTG_MIN_REG			0x2B
+
+#define SOC_DELTA_VAL			1
+#define SOC_MIN_VAL			15
+
+/* FG SHADOW registers */
+#define SHDW_FG_ESR_ACTUAL		0x20
+#define SHDW_FG_BATT_STATUS		0x60
+#define BATTERY_PROFILE_BIT		BIT(0)
+#define SHDW_FG_MSYS_SOC		0x61
+#define SHDW_FG_CAPACITY		0x62
+#define SHDW_FG_VTG_NOW			0x69
+#define SHDW_FG_CURR_NOW		0x6B
+#define SHDW_FG_BATT_TEMP		0x6D
+
+/* FG scratchpad registers */
+#define VOLTAGE_PREDICTED_REG		0x80
+#define CC_TO_SOC_COEFF			0xBA
+#define NOMINAL_CAPACITY_REG		0xBC
+#define ACTUAL_CAPACITY_REG		0xBE
+#define FG_IBATT_STANDBY_REG		0xCF
+#define FG_AUTO_RECHARGE_SOC		0xD2
+#define FG_SYS_CUTOFF_V_REG		0xD3
+#define FG_CC_TO_CV_V_REG		0xD5
+#define FG_ITERM_REG			0xD9
+#define FG_THERM_C1_COEFF_REG		0xDB
+
+/* Constants */
+#define SMB1360_REV_1			0x01
+
+#define FG_RESET_THRESHOLD_MV		15
+
+#define MIN_FLOAT_MV			3460
+#define MAX_FLOAT_MV			4730
+#define VFLOAT_STEP_MV			10
+
+#define MIN_RECHG_MV			50
+#define MAX_RECHG_MV			300
+
+#define SMB1360_FG_ACCESS_TIMEOUT_MS	15000
+#define SMB1360_POWERON_DELAY_MS	2000
+#define SMB1360_FG_RESET_DELAY_MS	1500
+
+/* FG registers (on different I2C address) */
+#define FG_I2C_CFG_MASK			GENMASK(1, 0)
+#define FG_CFG_I2C_ADDR			0x1
+#define FG_PROFILE_A_ADDR		0x2
+#define FG_PROFILE_B_ADDR		0x3
+
+#define CURRENT_GAIN_LSB_REG		0x1D
+#define CURRENT_GAIN_MSB_REG		0x1E
+
+#define OTP_WRITABLE_REG_1		0xE0
+#define OTP_WRITABLE_REG_2		0xE1
+#define OTP_WRITABLE_REG_3		0xE2
+#define OTP_WRITABLE_REG_4		0xE3
+#define OTP_WRITABLE_REG_5		0xE4
+#define OTP_WRITABLE_REG_6		0xE5
+#define OTP_WRITABLE_REG_7		0xE6
+#define OTP_WRITABLE_REG_8		0xE7
+#define OTP_WRITABLE_REG_9		0xE8
+#define OTP_WRITABLE_REG_10		0xE9
+#define OTP_WRITABLE_REG_11		0xEA
+#define OTP_WRITABLE_REG_12		0xEB
+#define OTP_WRITABLE_REG_13		0xEC
+#define OTP_WRITABLE_REG_14		0xED
+#define OTP_WRITABLE_REG_15		0xEE
+#define OTP_WRITABLE_REG_16		0xEF
+#define OTP_BACKUP_MAP_REG		0xF0
+#define CURRENT_GAIN_BITMAP		0x5000
+#define HARD_JEITA_BITMAP		0x0500
+#define RSLOW_BITMAP			0x00AA
+
+#define RSLOW_0				0x54
+#define RSLOW_1				0x55
+#define RSLOW_2				0x56
+#define RSLOW_3				0x57
+
+#define OTP_HARD_COLD_REG_ADDR		0x12
+#define OTP_HARD_HOT_REG_ADDR		0x13
+#define OTP_GAIN_FIRST_HALF_REG_ADDR	0x1D
+#define OTP_GAIN_SECOND_HALF_REG_ADDR	0x1E
+
+#define TEMP_THRE_SET(x) (((x) + 300) / 10)
+
+enum {
+	BATTERY_PROFILE_A,
+	BATTERY_PROFILE_B,
+	BATTERY_PROFILE_MAX,
+};
+
+enum {
+	IRQ_A, IRQ_B, IRQ_C, IRQ_D, IRQ_E, IRQ_F, IRQ_G, IRQ_H, IRQ_I,
+	IRQ_COUNT
+};
+
+static const unsigned int smb1360_usb_extcon_cable[] = {
+	EXTCON_USB,
+	EXTCON_NONE,
+};
+
+struct smb1360 {
+	struct device		*dev;
+	struct regmap		*regmap;
+	struct regmap		*fg_regmap;
+	struct power_supply	*psy;
+	struct extcon_dev	*edev;
+	struct regulator_dev	*otg_vreg;
+	struct completion	fg_mem_access_granted;
+	struct delayed_work	delayed_init_work;
+
+	unsigned int revision;
+	u8 irqstat[IRQ_COUNT];
+
+	bool shdn_after_pwroff;
+	bool rsense_10mohm;
+	bool initialized;
+
+	int float_voltage;
+};
+
+static enum power_supply_property smb1360_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP
+};
+
+#define EXPONENT_MASK		0xF800
+#define MANTISSA_MASK		0x3FF
+#define SIGN_MASK		0x400
+#define EXPONENT_SHIFT		11
+#define SIGN_SHIFT		10
+#define MICRO_UNIT		1000000ULL
+static s64 float_decode(u16 reg)
+{
+	s64 final_val, exponent_val, mantissa_val;
+	int exponent, mantissa, n;
+	bool sign;
+
+	exponent = (reg & EXPONENT_MASK) >> EXPONENT_SHIFT;
+	mantissa = (reg & MANTISSA_MASK);
+	sign = !!(reg & SIGN_MASK);
+
+	mantissa_val = mantissa * MICRO_UNIT;
+
+	n = exponent - 15;
+	if (n < 0)
+		exponent_val = MICRO_UNIT >> -n;
+	else
+		exponent_val = MICRO_UNIT << n;
+
+	n = n - 10;
+	if (n < 0)
+		mantissa_val >>= -n;
+	else
+		mantissa_val <<= n;
+
+	final_val = exponent_val + mantissa_val;
+
+	if (sign)
+		final_val *= -1;
+
+	return final_val;
+}
+
+#define MAX_MANTISSA (1023 * 1000000ULL)
+static unsigned int float_encode(s64 float_val)
+{
+	int exponent = 0, sign = 0;
+	unsigned int final_val = 0;
+
+	if (float_val == 0)
+		return 0;
+
+	if (float_val < 0) {
+		sign = 1;
+		float_val = -float_val;
+	}
+
+	/* Reduce large mantissa until it fits into 10 bit */
+	while (float_val >= MAX_MANTISSA) {
+		exponent++;
+		float_val >>= 1;
+	}
+
+	/* Increase small mantissa to improve precision */
+	while (float_val < MAX_MANTISSA && exponent > -25) {
+		exponent--;
+		float_val <<= 1;
+	}
+
+	exponent = exponent + 25;
+
+	/* Convert mantissa from micro-units to units */
+	float_val = div_s64((float_val + MICRO_UNIT), (int)MICRO_UNIT);
+
+	if (float_val == 1024) {
+		exponent--;
+		float_val <<= 1;
+	}
+
+	float_val -= 1024;
+
+	/* Ensure that resulting number is within range */
+	if (float_val > MANTISSA_MASK)
+		float_val = MANTISSA_MASK;
+
+	/* Convert to 5 bit exponent, 11 bit mantissa */
+	final_val = (float_val & MANTISSA_MASK) | (sign << SIGN_SHIFT) |
+		((exponent << EXPONENT_SHIFT) & EXPONENT_MASK);
+
+	return final_val;
+}
+
+static int smb1360_update_le16(struct smb1360 *smb, u8 reg, const char *prop, s16 scale)
+{
+	int ret;
+	u32 temp;
+	__le16 val;
+
+	if (device_property_read_u32(smb->dev, prop, &temp))
+		return 0;
+
+	if (scale > 0)
+		temp = div_u64(temp * S16_MAX, scale);
+	else if (scale < 0)
+		temp = div_s64(temp * S16_MAX, scale);
+
+	val = cpu_to_le16(temp);
+	ret = regmap_raw_write(smb->regmap, reg, &val, sizeof(val));
+	if (ret)
+		dev_err(smb->dev, "writing %s failed: %d\n", prop, ret);
+	return ret;
+}
+
+static int smb1360_read_voltage(struct smb1360 *smb, u8 reg,
+				int *voltage)
+{
+	__le16 val;
+	int ret;
+
+	ret = regmap_raw_read(smb->regmap, reg, &val, sizeof(val));
+	if (ret)
+		return ret;
+
+	*voltage = div_u64(le16_to_cpu(val) * 5000000ULL, S16_MAX);
+	return 0;
+}
+
+static int smb1360_get_prop_batt_status(struct smb1360 *smb,
+					union power_supply_propval *val)
+{
+	unsigned int reg, chg_type;
+	int ret;
+
+	if (smb->irqstat[IRQ_C] & IRQ_C_CHG_TERM_BIT) {
+		val->intval = POWER_SUPPLY_STATUS_FULL;
+		return 0;
+	}
+
+	ret = regmap_read(smb->regmap, STATUS_3_REG, &reg);
+	if (ret) {
+		val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+		return ret;
+	}
+
+	if (reg & CHG_HOLD_OFF_BIT) {
+		val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		return 0;
+	}
+
+	chg_type = (reg & CHG_TYPE_MASK) >> CHG_TYPE_SHIFT;
+	if (chg_type == BATT_NOT_CHG_VAL) {
+		val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		return 0;
+	}
+
+	val->intval = POWER_SUPPLY_STATUS_CHARGING;
+	return 0;
+}
+
+static int smb1360_get_prop_charge_type(struct smb1360 *smb,
+					union power_supply_propval *val)
+{
+	int ret;
+	unsigned int reg;
+
+	ret = regmap_read(smb->regmap, STATUS_3_REG, &reg);
+	if (ret) {
+		val->intval = POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+		return ret;
+	}
+
+	switch ((reg & CHG_TYPE_MASK) >> CHG_TYPE_SHIFT) {
+	case BATT_NOT_CHG_VAL:
+		val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		break;
+	case BATT_FAST_CHG_VAL:
+	case BATT_TAPER_CHG_VAL:
+		val->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;
+		break;
+	case BATT_PRE_CHG_VAL:
+		val->intval = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;
+		break;
+	default:
+		val->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;
+		break;
+	}
+
+	return 0;
+}
+
+static int smb1360_get_prop_batt_health(struct smb1360 *smb,
+					union power_supply_propval *val)
+{
+	if (smb->irqstat[IRQ_A] & IRQ_A_HOT_HARD_BIT)
+		val->intval = POWER_SUPPLY_HEALTH_HOT;
+	else if (smb->irqstat[IRQ_A] & IRQ_A_HOT_SOFT_BIT)
+		val->intval = POWER_SUPPLY_HEALTH_WARM;
+	else if (smb->irqstat[IRQ_A] & IRQ_A_COLD_HARD_BIT)
+		val->intval = POWER_SUPPLY_HEALTH_COLD;
+	else if (smb->irqstat[IRQ_A] & IRQ_A_COLD_SOFT_BIT)
+		val->intval = POWER_SUPPLY_HEALTH_COOL;
+	else
+		val->intval = POWER_SUPPLY_HEALTH_GOOD;
+
+	return 0;
+}
+
+static int smb1360_get_prop_current_now(struct smb1360 *smb,
+					union power_supply_propval *val)
+{
+	__le16 temp;
+	int ret;
+
+	ret = regmap_raw_read(smb->regmap, SHDW_FG_CURR_NOW, &temp, sizeof(temp));
+	if (ret)
+		return ret;
+
+	val->intval = -(div_s64(((s16)le16_to_cpu(temp)) * 2500, S16_MAX) * 1000);
+
+	return 0;
+}
+
+static int smb1360_get_prop_chg_full_design(struct smb1360 *smb,
+					    union power_supply_propval *val)
+{
+	__le16 fcc_mah;
+	int ret;
+
+	ret = regmap_raw_read(smb->regmap, SHDW_FG_CAPACITY, &fcc_mah, sizeof(fcc_mah));
+	if (ret)
+		return ret;
+
+	val->intval = le16_to_cpu(fcc_mah) * 1000;
+	return 0;
+}
+
+static int smb1360_get_prop_batt_capacity(struct smb1360 *smb,
+					  union power_supply_propval *val)
+{
+	int ret, soc = 0;
+	unsigned int reg;
+
+	if (smb->irqstat[IRQ_H] & IRQ_H_EMPTY_SOC_BIT) {
+		val->intval = 0;
+		return 0;
+	}
+
+	ret = regmap_read(smb->regmap, SHDW_FG_MSYS_SOC, &reg);
+	if (ret)
+		return ret;
+
+	soc = DIV_ROUND_CLOSEST(reg * 100, U8_MAX);
+	val->intval = clamp(soc, 0, 100);
+
+	return 0;
+}
+
+static int smb1360_get_prop_batt_temp(struct smb1360 *smb,
+				      union power_supply_propval *val)
+{
+	__le16 temp;
+	int ret;
+
+	ret = regmap_raw_read(smb->regmap, SHDW_FG_BATT_TEMP, &temp, sizeof(temp));
+	if (ret)
+		return ret;
+
+	temp = div_u64(le16_to_cpu(temp) * 625, 10000UL); /* temperature in K */
+	val->intval = (temp - 273) * 10; /* temperature in decideg */
+
+	return 0;
+}
+
+static int smb1360_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct smb1360 *smb = power_supply_get_drvdata(psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		return smb1360_get_prop_batt_status(smb, val);
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		return smb1360_get_prop_charge_type(smb, val);
+	case POWER_SUPPLY_PROP_HEALTH:
+		return smb1360_get_prop_batt_health(smb, val);
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = !(smb->irqstat[IRQ_E] & IRQ_E_USBIN_UV_BIT);
+		return 0;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		return smb1360_read_voltage(smb, SHDW_FG_VTG_NOW, &val->intval);
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		return smb1360_get_prop_current_now(smb, val);
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		return smb1360_get_prop_chg_full_design(smb, val);
+	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:
+		val->intval = smb->float_voltage * 1000;
+		return 0;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		return smb1360_get_prop_batt_capacity(smb, val);
+	case POWER_SUPPLY_PROP_TEMP:
+		return smb1360_get_prop_batt_temp(smb, val);
+	default:
+		return -EINVAL;
+	}
+}
+
+static irqreturn_t smb1360_irq(int irq, void *data)
+{
+	struct smb1360 *smb = data;
+	int ret;
+
+	ret = regmap_raw_read(smb->regmap, IRQ_REG, smb->irqstat, sizeof(smb->irqstat));
+	if (ret < 0)
+		return IRQ_NONE;
+
+	extcon_set_state_sync(smb->edev, EXTCON_USB,
+			      !(smb->irqstat[IRQ_E] & IRQ_E_USBIN_UV_BIT));
+
+	if (smb->irqstat[IRQ_F] & (IRQ_F_OTG_FAIL_BIT | IRQ_F_OTG_OC_BIT)) {
+		dev_warn(smb->dev, "otg error: %d\n", smb->irqstat[IRQ_F]);
+		regulator_disable_regmap(smb->otg_vreg);
+	}
+
+	if (smb->irqstat[IRQ_I] & IRQ_I_FG_ACCESS_ALLOWED_BIT)
+		complete_all(&smb->fg_mem_access_granted);
+
+	if (smb->initialized)
+		power_supply_changed(smb->psy);
+
+	return IRQ_HANDLED;
+}
+
+static const struct regulator_ops smb1360_regulator_ops = {
+	.is_enabled		= regulator_is_enabled_regmap,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.get_current_limit	= regulator_get_current_limit_regmap,
+	.set_current_limit	= regulator_set_current_limit_regmap,
+};
+
+static const unsigned int smb1360_otg_current_limits[] = {
+	350000, 550000, 950000, 1500000
+};
+
+static const struct regulator_desc smb1360_regulator_desc = {
+	.name			= "usb_otg_vbus",
+	.of_match		= "usb-otg-vbus",
+	.ops			= &smb1360_regulator_ops,
+	.type			= REGULATOR_VOLTAGE,
+	.owner			= THIS_MODULE,
+	.enable_reg		= CMD_CHG_REG,
+	.enable_mask		= CMD_OTG_EN_BIT,
+	.enable_val		= CMD_OTG_EN_BIT,
+	.fixed_uV		= 5000000,
+	.n_voltages		= 1,
+	.curr_table		= smb1360_otg_current_limits,
+	.n_current_limits	= ARRAY_SIZE(smb1360_otg_current_limits),
+	.csel_reg		= CFG_BATT_CHG_REG,
+	.csel_mask		= OTG_CURRENT_MASK,
+};
+
+static int smb1360_register_vbus_regulator(struct smb1360 *smb)
+{
+	struct regulator_config cfg = {
+		.dev = smb->dev,
+	};
+
+	smb->otg_vreg = devm_regulator_register(smb->dev,
+						&smb1360_regulator_desc, &cfg);
+	if (IS_ERR(smb->otg_vreg)) {
+		dev_err(smb->dev, "can't register regulator: %pe\n", smb->otg_vreg);
+		return PTR_ERR(smb->otg_vreg);
+	}
+
+	return 0;
+}
+
+static int smb1360_enable_fg_access(struct smb1360 *smb)
+{
+	unsigned int reg;
+	int ret;
+
+	ret = regmap_read(smb->regmap, IRQ_I_REG, &reg);
+	if (ret || reg & IRQ_I_FG_ACCESS_ALLOWED_BIT)
+		goto err;
+
+	/* request FG access */
+	ret = regmap_set_bits(smb->regmap, CMD_I2C_REG, FG_ACCESS_ENABLED_BIT);
+	if (ret)
+		goto err;
+
+	ret = wait_for_completion_timeout(&smb->fg_mem_access_granted,
+					  msecs_to_jiffies(SMB1360_FG_ACCESS_TIMEOUT_MS));
+
+	if (ret == 0) {
+		/* Clear the FG access bit if request failed */
+		dev_err(smb->dev, "enable FG access timed out\n");
+		regmap_clear_bits(smb->regmap, CMD_I2C_REG, FG_ACCESS_ENABLED_BIT);
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+
+err:
+	dev_err(smb->dev, "failed to enable fg access: %d\n", ret);
+	return ret;
+}
+
+static int smb1360_disable_fg_access(struct smb1360 *smb)
+{
+	int ret;
+
+	ret = regmap_clear_bits(smb->regmap, CMD_I2C_REG, FG_ACCESS_ENABLED_BIT);
+	if (ret)
+		dev_err(smb->dev, "couldn't disable FG access: %d\n", ret);
+
+	reinit_completion(&smb->fg_mem_access_granted);
+
+	return ret;
+}
+
+static int smb1360_force_fg_reset(struct smb1360 *smb)
+{
+	int ret;
+
+	dev_dbg(smb->dev, "forcing FG reset!\n");
+
+	ret = regmap_set_bits(smb->regmap, CMD_I2C_REG, FG_RESET_BIT);
+	if (ret) {
+		dev_err(smb->dev, "couldn't reset FG: %d\n", ret);
+		return ret;
+	}
+
+	msleep(SMB1360_FG_RESET_DELAY_MS);
+
+	ret = regmap_clear_bits(smb->regmap, CMD_I2C_REG, FG_RESET_BIT);
+	if (ret)
+		dev_err(smb->dev, "couldn't un-reset FG: %d\n", ret);
+
+	return ret;
+}
+
+static int smb1360_fg_reset(struct smb1360 *smb)
+{
+	int ret, temp, v_predicted, v_now;
+	u32 val;
+
+	if (!device_property_read_bool(smb->dev, "qcom,fg-reset-at-pon"))
+		return 0;
+
+	ret = smb1360_enable_fg_access(smb);
+	if (ret)
+		return ret;
+
+	ret = smb1360_read_voltage(smb, VOLTAGE_PREDICTED_REG, &v_predicted);
+	if (ret)
+		goto disable_fg_access;
+	ret = smb1360_read_voltage(smb, SHDW_FG_VTG_NOW, &v_now);
+	if (ret)
+		goto disable_fg_access;
+
+	if (device_property_read_u32(smb->dev, "qcom,fg-reset-threshold-mv", &val))
+		val = FG_RESET_THRESHOLD_MV;
+
+	temp = abs(v_predicted - v_now);
+	dev_dbg(smb->dev, "FG reset: predicted: %d, now: %d, delta: %d, threshold: %d\n",
+		v_predicted, v_now, temp, val);
+	if (temp >= val) {
+		/* delay for the FG access to settle */
+		msleep(1500);
+
+		ret = smb1360_force_fg_reset(smb);
+		if (ret)
+			goto disable_fg_access;
+	}
+
+disable_fg_access:
+	smb1360_disable_fg_access(smb);
+	return ret;
+}
+
+static int smb1360_check_batt_profile(struct smb1360 *smb)
+{
+	u32 profile, loaded_profile;
+	unsigned int val;
+	int ret, timeout;
+
+	if (device_property_read_u32(smb->dev, "qcom,battery-profile", &profile))
+		return 0;
+
+	if (profile > 1) {
+		dev_err(smb->dev, "invalid battery profile: %d\n", profile);
+		return -EINVAL;
+	}
+
+	ret = regmap_read(smb->regmap, SHDW_FG_BATT_STATUS, &val);
+	if (ret)
+		return ret;
+
+	loaded_profile = !!(val & BATTERY_PROFILE_BIT);
+	dev_dbg(smb->dev, "profile: %d, loaded_profile: %d\n", profile, loaded_profile);
+
+	if (loaded_profile == profile)
+		return 0;
+
+	ret = regmap_update_bits(smb->regmap, CFG_FG_BATT_CTRL_REG,
+				 BATT_PROFILE_SELECT_MASK,
+				 profile ? BATT_PROFILEB_MASK : BATT_PROFILEA_MASK);
+	if (ret)
+		return ret;
+
+	ret = smb1360_enable_fg_access(smb);
+	if (ret)
+		return ret;
+
+	/* delay after handshaking for profile-switch to continue */
+	msleep(1500);
+
+	ret = smb1360_force_fg_reset(smb);
+	if (ret) {
+		smb1360_disable_fg_access(smb);
+		return ret;
+	}
+	ret = smb1360_disable_fg_access(smb);
+	if (ret)
+		return ret;
+
+	for (timeout = 0; timeout < 10; ++timeout) {
+		/* delay for profile to change */
+		msleep(500);
+		ret = regmap_read(smb->regmap, SHDW_FG_BATT_STATUS, &val);
+		if (ret)
+			return ret;
+
+		loaded_profile = !!(val & BATTERY_PROFILE_BIT);
+		if (loaded_profile == profile)
+			return 0;
+	}
+
+	return -ETIMEDOUT;
+}
+
+static int smb1360_adjust_otp_current_gain(struct smb1360 *smb)
+{
+	int ret;
+	u8 val[4];
+	__le16 current_gain;
+	u16 current_gain_encoded;
+
+	ret = regmap_raw_read(smb->fg_regmap, CURRENT_GAIN_LSB_REG,
+			      &current_gain, sizeof(current_gain));
+	if (ret)
+		return ret;
+
+	current_gain_encoded = le16_to_cpu(current_gain);
+	current_gain_encoded = float_encode(MICRO_UNIT + (2 * float_decode(current_gain_encoded)));
+
+	val[0] = OTP_GAIN_FIRST_HALF_REG_ADDR;
+	val[1] = current_gain_encoded & 0xFF;
+	val[2] = OTP_GAIN_SECOND_HALF_REG_ADDR;
+	val[3] = (current_gain_encoded & 0xFF00) >> 8;
+
+	return regmap_raw_write(smb->fg_regmap, OTP_WRITABLE_REG_1, val, ARRAY_SIZE(val));
+}
+
+static int smb1360_set_otp_hard_jeita_threshold(struct smb1360 *smb)
+{
+	u8 val[4];
+	s32 hot, cold;
+
+	if (device_property_read_u32(smb->dev, "qcom,otp-hot-bat-decidegc", &hot))
+		return -EINVAL;
+	if (device_property_read_u32(smb->dev, "qcom,otp-cold-bat-decidegc", &cold))
+		return -EINVAL;
+
+	val[0] = OTP_HARD_HOT_REG_ADDR;
+	val[1] = TEMP_THRE_SET(hot);
+	val[2] = OTP_HARD_COLD_REG_ADDR;
+	val[3] = TEMP_THRE_SET(cold);
+
+	if (val[1] < 0 || val[3] < 0)
+		return -EINVAL;
+
+	return regmap_raw_write(smb->fg_regmap, OTP_WRITABLE_REG_5, val, ARRAY_SIZE(val));
+}
+
+static int smb1360_set_otp_rslow(struct smb1360 *smb)
+{
+	u8 seq[] = { RSLOW_0, 0x0, RSLOW_1, 0x0, RSLOW_2, 0x0, RSLOW_3, 0x0 };
+	u8 val[4];
+	int i;
+
+	if (device_property_read_u8_array(smb->dev, "qcom,otp-rslow-config", val, 4))
+		return -EINVAL;
+
+	for (i = 0; i < 4; i++)
+		seq[i * 2 + 1] = val[i];
+
+	return regmap_raw_write(smb->fg_regmap, OTP_WRITABLE_REG_9, seq, ARRAY_SIZE(seq));
+}
+
+static int smb1360_reconf_otp(struct smb1360 *smb)
+{
+	bool hard_jeita = device_property_read_bool(smb->dev, "qcom,otp-hard-jeita-config");
+	bool otp_rslow = device_property_present(smb->dev, "qcom,otp-rslow-config");
+	u16 backup_map = 0;
+	__be16 val;
+	int ret;
+
+	if (!smb->rsense_10mohm && !hard_jeita && !otp_rslow)
+		return 0;
+
+	ret = smb1360_enable_fg_access(smb);
+	if (ret)
+		return ret;
+
+	if (smb->rsense_10mohm) {
+		ret = smb1360_adjust_otp_current_gain(smb);
+		if (ret)
+			dev_err(smb->dev,
+				"couldn't reconfigure gain for lower resistance: %d\n", ret);
+		else
+			backup_map |= CURRENT_GAIN_BITMAP;
+	}
+
+	if (hard_jeita) {
+		ret = smb1360_set_otp_hard_jeita_threshold(smb);
+		if (ret)
+			dev_err(smb->dev, "unable to modify otp hard jeita: %d\n", ret);
+		else
+			backup_map |= HARD_JEITA_BITMAP;
+	}
+
+	if (otp_rslow) {
+		ret = smb1360_set_otp_rslow(smb);
+		if (ret)
+			dev_err(smb->dev, "unable to modify otp rslow: %d\n", ret);
+		else
+			backup_map |= RSLOW_BITMAP;
+	}
+
+	val = cpu_to_be16(backup_map);
+	ret = regmap_raw_write(smb->fg_regmap, OTP_BACKUP_MAP_REG, &val, sizeof(val));
+	if (ret)
+		goto out;
+
+	ret = regmap_set_bits(smb->regmap, CFG_FG_BATT_CTRL_REG, CFG_FG_OTP_BACK_UP_ENABLE);
+	if (ret)
+		dev_err(smb->dev, "failed to enable OTP back-up: %d\n", ret);
+
+out:
+	return smb1360_disable_fg_access(smb);
+}
+
+static int smb1360_update_bounds(struct smb1360 *smb)
+{
+	unsigned int val;
+	int ret;
+
+	/* REV_1 does not allow access to FG config registers */
+	if (smb->revision == SMB1360_REV_1)
+		return 0;
+
+	val = abs(((SOC_DELTA_VAL * U8_MAX) / 100) - 1);
+	ret = regmap_write(smb->regmap, SOC_DELTA_REG, val);
+	if (ret)
+		return ret;
+
+	val = DIV_ROUND_CLOSEST(SOC_MIN_VAL * U8_MAX, 100);
+	ret = regmap_write(smb->regmap, SOC_MIN_REG, val);
+	if (ret)
+		return ret;
+
+	if (device_property_read_u32(smb->dev, "qcom,fg-voltage-min-mv", &val) == 0) {
+		val = (val - 2500) * U8_MAX;
+		val = DIV_ROUND_UP(val, 2500);
+		ret = regmap_write(smb->regmap, VTG_MIN_REG, val);
+		if (ret)
+			return ret;
+	}
+
+	if (device_property_read_u32(smb->dev, "qcom,fg-voltage-empty-mv", &val) == 0) {
+		val = (val - 2500) * U8_MAX;
+		val = DIV_ROUND_UP(val, 2500);
+		ret = regmap_write(smb->regmap, VTG_EMPTY_REG, val);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int smb1360_update_autorecharge_soc_threshold(struct smb1360 *smb)
+{
+	int ret;
+	u32 val;
+
+	if (device_property_read_u32(smb->dev, "qcom,fg-auto-recharge-soc", &val))
+		return 0;
+
+	ret = regmap_set_bits(smb->regmap, CFG_CHG_FUNC_CTRL_REG,
+			      CHG_RECHG_THRESH_FG_SRC_BIT);
+	if (ret)
+		return ret;
+
+	val = DIV_ROUND_UP(val * U8_MAX, 100);
+	return regmap_write(smb->regmap, FG_AUTO_RECHARGE_SOC, val);
+}
+
+static int smb1360_fg_config(struct smb1360 *smb)
+{
+	int ret;
+
+	ret = smb1360_enable_fg_access(smb);
+	if (ret)
+		return ret;
+
+	ret = smb1360_update_le16(smb, ACTUAL_CAPACITY_REG, "qcom,fg-batt-capacity-mah", 0);
+	if (ret)
+		goto disable_fg_access;
+
+	ret = smb1360_update_le16(smb, NOMINAL_CAPACITY_REG, "qcom,fg-batt-capacity-mah", 0);
+	if (ret)
+		goto disable_fg_access;
+
+	ret = smb1360_update_le16(smb, CC_TO_SOC_COEFF, "qcom,fg-cc-soc-coeff", 0);
+	if (ret)
+		goto disable_fg_access;
+
+	ret = smb1360_update_le16(smb, FG_SYS_CUTOFF_V_REG, "qcom,fg-cutoff-voltage-mv", 5000);
+	if (ret)
+		goto disable_fg_access;
+
+	ret = smb1360_update_le16(smb, FG_ITERM_REG, "qcom,fg-iterm-ma", -2500);
+	if (ret)
+		goto disable_fg_access;
+
+	ret = smb1360_update_le16(smb, FG_IBATT_STANDBY_REG, "qcom,fg-ibatt-standby-ma", 2500);
+	if (ret)
+		goto disable_fg_access;
+
+	ret = smb1360_update_le16(smb, FG_CC_TO_CV_V_REG, "qcom,fg-cc-to-cv-mv", 5000);
+	if (ret)
+		goto disable_fg_access;
+
+	ret = smb1360_update_le16(smb, FG_THERM_C1_COEFF_REG, "qcom,thermistor-c1-coeff", 0);
+	if (ret)
+		goto disable_fg_access;
+
+	ret = smb1360_update_autorecharge_soc_threshold(smb);
+	if (ret) {
+		dev_err(smb->dev, "smb1360_update_autorecharge_soc_threshold failed\n");
+		goto disable_fg_access;
+	}
+
+disable_fg_access:
+	smb1360_disable_fg_access(smb);
+	return ret;
+}
+
+static int smb1360_check_cycle_stretch(struct smb1360 *smb)
+{
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(smb->regmap, STATUS_4_REG, &val);
+	if (ret)
+		return ret;
+
+	if (!(val & CYCLE_STRETCH_ACTIVE_BIT))
+		return 0;
+
+	ret = regmap_set_bits(smb->regmap, CMD_I2C_REG, CYCLE_STRETCH_CLEAR_BIT);
+	if (ret)
+		dev_err(smb->dev, "unable to clear cycle stretch: %d\n", ret);
+
+	return ret;
+}
+
+#ifdef CONFIG_SMB1360_DEBUG
+extern void smb1360_dump(struct i2c_client *client);
+extern void smb1360_dump_fg_scratch(struct i2c_client *fg_client);
+extern void smb1360_dump_fg(struct i2c_client *client);
+
+static void smb1360_dump_fg_access(struct smb1360 *smb)
+{
+	struct i2c_client *client = to_i2c_client(smb->dev);
+	struct i2c_client *fg_client = to_i2c_client(regmap_get_device(smb->fg_regmap));
+	int ret;
+
+	ret = smb1360_enable_fg_access(smb);
+	if (ret)
+		return;
+
+	smb1360_dump_fg_scratch(client);
+	smb1360_dump_fg(fg_client);
+
+	smb1360_disable_fg_access(smb);
+	smb1360_check_cycle_stretch(smb);
+}
+#else
+static inline void smb1360_dump(struct i2c_client *client) {}
+static inline void smb1360_dump_fg_access(struct smb1360 *smb) {}
+#endif
+
+static int smb1360_delayed_hw_init(struct smb1360 *smb)
+{
+	int ret;
+
+	/* Dump initial FG registers */
+	smb1360_dump_fg_access(smb);
+
+	ret = smb1360_check_batt_profile(smb);
+	if (ret) {
+		dev_err(smb->dev, "unable to modify battery profile: %d\n", ret);
+		return ret;
+	}
+
+	ret = smb1360_reconf_otp(smb);
+	if (ret) {
+		dev_err(smb->dev, "couldn't reconfigure OTP: %d\n", ret);
+		return ret;
+	}
+
+	ret = smb1360_fg_reset(smb);
+	if (ret)
+		dev_err(smb->dev, "smb1360_fg_reset failed: %d\n", ret);
+
+	ret = smb1360_update_bounds(smb);
+	if (ret) {
+		dev_err(smb->dev, "couldn't configure SOC/voltage bounds: %d\n", ret);
+		return ret;
+	}
+
+	ret = smb1360_fg_config(smb);
+	if (ret) {
+		dev_err(smb->dev, "couldn't configure FG: %d\n", ret);
+		return ret;
+	}
+
+	ret = smb1360_check_cycle_stretch(smb);
+	if (ret) {
+		dev_err(smb->dev, "Unable to check cycle-stretch\n");
+		return ret;
+	}
+
+	ret = regmap_set_bits(smb->regmap, CMD_CHG_REG, CMD_CHG_EN);
+	if (ret) {
+		dev_err(smb->dev, "couldn't enable battery charging: %d\n", ret);
+		return ret;
+	}
+
+	/* Dump final registers */
+	smb1360_dump(to_i2c_client(smb->dev));
+	smb1360_dump_fg_access(smb);
+
+	return 0;
+}
+
+static void smb1360_delayed_init_work_fn(struct work_struct *work)
+{
+	int ret = 0;
+	struct smb1360 *smb = container_of(work, struct smb1360,
+					   delayed_init_work.work);
+
+	ret = smb1360_delayed_hw_init(smb);
+	if (!ret) {
+		power_supply_changed(smb->psy);
+		smb->initialized = true;
+	} else if (ret == -ETIMEDOUT) {
+		ret = smb1360_force_fg_reset(smb);
+		if (ret)
+			return;
+		schedule_delayed_work(&smb->delayed_init_work, 0);
+	}
+}
+
+static int smb1360_set_shutdown(struct smb1360 *smb, bool shutdown)
+{
+	int ret = 0;
+	unsigned int val = 0;
+	bool polarity;
+
+	ret = regmap_read(smb->regmap, SHDN_CTRL_REG, &val);
+	if (ret < 0) {
+		dev_err(smb->dev, "couldn't read SHDN_CTRL_REG: %d\n", ret);
+		return ret;
+	}
+
+	if (!(val & SHDN_CMD_USE_BIT))
+		return 0;
+
+	polarity = !!(val & SHDN_CMD_POLARITY_BIT);
+	val = (polarity == shutdown) ? SHDN_CMD_BIT : 0;
+
+	ret = regmap_update_bits(smb->regmap, CMD_IL_REG, SHDN_CMD_BIT, val);
+	if (ret < 0)
+		dev_err(smb->dev, "couldn't update shutdown: %d\n", ret);
+
+	return ret;
+}
+
+static inline int smb1360_poweroff(struct smb1360 *smb)
+{
+	return smb1360_set_shutdown(smb, true);
+}
+
+static inline int smb1360_poweron(struct smb1360 *smb)
+{
+	return smb1360_set_shutdown(smb, false);
+}
+
+static int smb1360_float_voltage_set(struct smb1360 *smb)
+{
+	u32 val;
+	int ret;
+
+	if (device_property_read_u32(smb->dev, "qcom,float-voltage-mv", &val)) {
+		/* Read float voltage from registers */
+		ret = regmap_read(smb->regmap, BATT_CHG_FLT_VTG_REG, &val);
+		if (ret)
+			return ret;
+
+		val &= VFLOAT_MASK;
+		smb->float_voltage = (val * VFLOAT_STEP_MV) + MIN_FLOAT_MV;
+		return 0;
+	}
+
+	if (val < MIN_FLOAT_MV || val > MAX_FLOAT_MV)
+		return -EINVAL;
+
+	smb->float_voltage = val;
+	val = (val - MIN_FLOAT_MV) / VFLOAT_STEP_MV;
+
+	return regmap_update_bits(smb->regmap,
+				  BATT_CHG_FLT_VTG_REG, VFLOAT_MASK, val);
+}
+
+static int smb1360_iterm_set(struct smb1360 *smb)
+{
+	int ret, iterm_ma;
+	u8 val;
+
+	if (device_property_read_bool(smb->dev, "qcom,iterm-disabled"))
+		return regmap_set_bits(smb->regmap, CFG_CHG_MISC_REG,
+				       CHG_CURR_TERM_DIS_BIT);
+
+	if (device_property_read_u32(smb->dev, "qcom,iterm-ma", &iterm_ma))
+		return 0;
+
+	if (smb->rsense_10mohm)
+		iterm_ma = iterm_ma / 2;
+
+	val = clamp(iterm_ma, 25, 200);
+	val = DIV_ROUND_UP(val, 25) - 1;
+
+	ret = regmap_update_bits(smb->regmap, CFG_BATT_CHG_REG,
+				 CHG_ITERM_MASK, val);
+	if (ret)
+		return ret;
+
+	ret = regmap_clear_bits(smb->regmap, CFG_CHG_MISC_REG,
+				CHG_CURR_TERM_DIS_BIT);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int smb1360_safety_time_set(struct smb1360 *smb)
+{
+	static const int chg_time[] = { 192, 384, 768, 1536, };
+	int ret, i;
+
+	u32 val;
+	u8 mask, data;
+
+	if (device_property_read_u32(smb->dev, "qcom,charging-timeout", &val))
+		return 0;
+
+	if (val > chg_time[ARRAY_SIZE(chg_time) - 1])
+		return -EINVAL;
+
+	mask = SAFETY_TIME_DISABLE_BIT;
+	data = SAFETY_TIME_DISABLE_BIT;
+
+	if (val != 0) {
+		mask = SAFETY_TIME_DISABLE_BIT | SAFETY_TIME_MINUTES_MASK;
+
+		for (i = 0; i < ARRAY_SIZE(chg_time); i++) {
+			if (val <= chg_time[i]) {
+				data = i << SAFETY_TIME_MINUTES_SHIFT;
+				break;
+			}
+		}
+	}
+
+	ret = regmap_update_bits(smb->regmap,
+				 CFG_SFY_TIMER_CTRL_REG, mask, data);
+	if (ret < 0) {
+		dev_err(smb->dev, "couldn't update safety timer: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int smb1360_recharge_threshold_set(struct smb1360 *smb)
+{
+	u32 val;
+
+	if (device_property_read_u32(smb->dev, "qcom,recharge-thresh-mv", &val))
+		return 0;
+
+	if (device_property_read_bool(smb->dev, "qcom,recharge-disabled") &&
+	    device_property_read_bool(smb->dev, "qcom,chg-inhibit-disabled")) {
+		dev_err(smb->dev, "recharge: both disabled and mv set\n");
+		return -EINVAL;
+	}
+
+	if (val < MIN_RECHG_MV || val > MAX_RECHG_MV)
+		return -EINVAL;
+
+	val = (val / 100) << RECHG_MV_SHIFT;
+
+	return regmap_update_bits(smb->regmap,
+				  CFG_BATT_CHG_REG, RECHG_MV_MASK, val);
+}
+
+static int smb1360_update_temp_tresh(struct smb1360 *smb, u8 reg, const char *prop)
+{
+	int ret;
+	s32 temp;
+
+	if (device_property_read_u32(smb->dev, prop, &temp))
+		return 0;
+
+	ret = regmap_write(smb->regmap, reg, TEMP_THRE_SET(temp));
+	if (ret)
+		dev_err(smb->dev, "writing %s failed: %d\n", prop, ret);
+	return ret;
+}
+
+static int smb1360_find_fastchg_current(struct smb1360 *smb, int current_ma)
+{
+	static const int fastchg_current[] = {
+		450, 600, 750, 900, 1050, 1200, 1350, 1500,
+	};
+	int i;
+
+	for (i = ARRAY_SIZE(fastchg_current) - 1; i >= 0; i--) {
+		if (fastchg_current[i] <= current_ma)
+			return i;
+	}
+
+	dev_err(smb->dev, "cannot find fastchg current %d\n", current_ma);
+	return -EINVAL;
+}
+
+static int smb1360_set_fastchg_current(struct smb1360 *smb, int fastchg_current)
+{
+	int i;
+	int ret;
+
+	/*
+	 * The sensing resistor for smb1360 would usually be 20 milli-ohms but
+	 * on some devices 10 milli-ohms are installed, changing the measured
+	 * value by a factor of 2. To allow a max. throughput of e.g. 900 mA
+	 * into the battery, those devices need to set the fastcharge current
+	 * in fact to 450 mA to get that behavior.
+	 */
+	if (smb->rsense_10mohm)
+		fastchg_current /= 2;
+
+	i = smb1360_find_fastchg_current(smb, fastchg_current);
+	if (i < 0)
+		return i;
+
+	ret = regmap_update_bits(smb->regmap, CHG_CURRENT_REG,
+				 FASTCHG_CURR_MASK, i << FASTCHG_CURR_SHIFT);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+
+static int smb1360_jeita_init(struct smb1360 *smb)
+{
+	int ret;
+	unsigned int tmp;
+	u32 comp_volt, comp_curr;
+
+	ret = smb1360_update_temp_tresh(smb, JEITA_SOFT_COLD_REG, "qcom,cool-bat-decidegc");
+	if (ret)
+		return ret;
+	ret = smb1360_update_temp_tresh(smb, JEITA_SOFT_HOT_REG, "qcom,warm-bat-decidegc");
+	if (ret)
+		return ret;
+
+	if (!device_property_read_bool(smb->dev, "qcom,soft-jeita-config"))
+		return 0;
+
+	if (device_property_read_u32(smb->dev, "qcom,soft-jeita-comp-voltage-mv", &comp_volt) ||
+	    device_property_read_u32(smb->dev, "qcom,soft-jeita-comp-current-ma", &comp_curr)) {
+		dev_err(smb->dev, "qcom,soft-jeita-comp-{voltage,current} required for soft JEITA\n");
+		return -EINVAL;
+	}
+
+	if (comp_volt >= smb->float_voltage) {
+		dev_err(smb->dev, "JEITA compensation voltage larger than float voltage\n");
+		return -EINVAL;
+	}
+
+	tmp = (smb->float_voltage - comp_volt) / 10;
+	ret = regmap_update_bits(smb->regmap, CFG_FVC_REG, FLT_VTG_COMP_MASK, tmp);
+	if (ret)
+		return ret;
+
+	ret = smb1360_find_fastchg_current(smb, comp_curr);
+	if (ret < 0)
+		return ret;
+
+	/* Write compensation current and enable JEITA compensation */
+	return regmap_write(smb->regmap, CHG_CMP_CFG, ret | JEITA_COMP_EN_BIT);
+}
+
+static int smb1360_configure_irq(struct smb1360 *smb)
+{
+	int ret;
+
+	/* enabling only interesting interrupts */
+	ret = regmap_write(smb->regmap, IRQ_CFG_REG,
+			   IRQ_INTERNAL_TEMPERATURE_BIT
+			   | IRQ_DCIN_UV_BIT
+			   | IRQ_BAT_HOT_COLD_SOFT_BIT
+			   | IRQ_HOT_COLD_HARD_BIT);
+	if (ret) {
+		dev_err(smb->dev, "couldn't set irq1: %d\n", ret);
+		return ret;
+	}
+
+	ret = regmap_write(smb->regmap, IRQ2_CFG_REG,
+			   IRQ2_VBAT_LOW_BIT
+			   | IRQ2_BATT_MISSING_BIT
+			   | IRQ2_POWER_OK_BIT
+			   | IRQ2_CHG_PHASE_CHANGE_BIT
+			   | IRQ2_CHG_ERR_BIT
+			   | IRQ2_SAFETY_TIMER_BIT);
+	if (ret) {
+		dev_err(smb->dev, "couldn't set irq2: %d\n", ret);
+		return ret;
+	}
+
+	ret = regmap_write(smb->regmap, IRQ3_CFG_REG,
+			   IRQ3_SOC_FULL_BIT
+			   | IRQ3_SOC_EMPTY_BIT
+			   | IRQ3_SOC_MAX_BIT
+			   | IRQ3_SOC_MIN_BIT
+			   | IRQ3_SOC_CHANGE_BIT
+			   | IRQ3_FG_ACCESS_OK_BIT);
+	if (ret)
+		dev_err(smb->dev, "couldn't set irq3: %d\n", ret);
+
+	return ret;
+}
+
+static int smb1360_hw_init(struct i2c_client *client)
+{
+	struct smb1360 *smb = i2c_get_clientdata(client);
+	int ret;
+	u8 val;
+
+	ret = regmap_set_bits(smb->regmap, CMD_I2C_REG, ALLOW_VOLATILE_BIT);
+	if (ret < 0) {
+		dev_err(smb->dev, "couldn't configure volatile: %d\n", ret);
+		return ret;
+	}
+
+	/* Bring SMB1360 out of shutdown, if it was enabled by default */
+	ret = smb1360_poweron(smb);
+	if (ret < 0) {
+		dev_err(smb->dev, "smb1360 power on failed\n");
+		return ret;
+	}
+
+	/* en chg by cmd reg, en chg by writing bit 1, en auto pre to fast */
+	ret = regmap_clear_bits(smb->regmap, CFG_CHG_MISC_REG,
+				CHG_EN_BY_PIN_BIT | CHG_EN_ACTIVE_LOW_BIT
+				| PRE_TO_FAST_REQ_CMD_BIT);
+	if (ret < 0)
+		return ret;
+
+	/* USB/AC pin settings */
+	ret = regmap_update_bits(smb->regmap, CFG_BATT_CHG_ICL_REG,
+				 AC_INPUT_ICL_PIN_BIT | AC_INPUT_PIN_HIGH_BIT,
+				 AC_INPUT_PIN_HIGH_BIT);
+	if (ret < 0)
+		return ret;
+
+	/* AICL enable and set input-uv glitch flt to 20ms */
+	ret = regmap_set_bits(smb->regmap, CFG_GLITCH_FLT_REG,
+			      AICL_ENABLED_BIT | INPUT_UV_GLITCH_FLT_20MS_BIT);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * TODO: This is a temporary solution
+	 * Set input current limit to 800 mA. This is a compromise between
+	 * charging speed (when attached to a wall charger) and supply voltage
+	 * drop (when attached to a PC). To implement correctly, this should
+	 * be decided in runtime based on connector type detection.
+	 */
+	ret = regmap_update_bits(smb->regmap, CFG_BATT_CHG_ICL_REG,
+				 INPUT_CURR_LIM_MASK, 0x06);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * TODO: This is a temporary solution
+	 * Set the fastcharge current to 900 mA. That's the maximal current
+	 * that acctually goes into the battery. It mainly comes into play
+	 * when using parallel-charging, where a secondary charger chip is
+	 * used to increase the charging speed. To implement correctly, this
+	 * should be decided in runtime based on connector type detection.
+	 */
+	ret = smb1360_set_fastchg_current(smb, 900);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * TODO: This is a temporary solution
+	 * Set the USB charging current bit to AC instead of default USB_500.
+	 * To implement correctly, this should be decided in runtime based on
+	 * connector type detection.
+	 */
+	ret = regmap_update_bits(smb->regmap, CMD_IL_REG, USB_CTRL_MASK,
+				 USB_AC_BIT);
+	if (ret < 0)
+		return ret;
+
+	ret = smb1360_float_voltage_set(smb);
+	if (ret < 0)
+		return ret;
+
+	ret = smb1360_iterm_set(smb);
+	if (ret < 0)
+		return ret;
+
+	ret = smb1360_safety_time_set(smb);
+	if (ret < 0)
+		return ret;
+
+	ret = smb1360_recharge_threshold_set(smb);
+	if (ret)
+		return ret;
+
+	/* Always stop charging on over-voltage condition */
+	val = CFG_BAT_OV_ENDS_CHG_CYC;
+	if (device_property_read_bool(smb->dev, "qcom,recharge-disabled"))
+		val |= CFG_AUTO_RECHG_DIS_BIT;
+	if (!device_property_read_bool(smb->dev, "qcom,chg-inhibit-disabled"))
+		val |= CFG_CHG_INHIBIT_EN_BIT;
+
+	ret = regmap_update_bits(smb->regmap, CFG_CHG_MISC_REG,
+				 CFG_BAT_OV_ENDS_CHG_CYC
+				 | CFG_AUTO_RECHG_DIS_BIT
+				 | CFG_CHG_INHIBIT_EN_BIT, val);
+	if (ret) {
+		dev_err(smb->dev, "couldn't set bat_ov_ends_charge/rechg/chg_inhibit: %d\n", ret);
+		return ret;
+	}
+
+	ret = smb1360_jeita_init(smb);
+	if (ret) {
+		dev_err(smb->dev, "couldn't init jeita: %d\n", ret);
+		return ret;
+	}
+
+	/* interrupt enabling - active low */
+	if (client->irq) {
+		ret = regmap_update_bits(smb->regmap, CFG_STAT_CTRL_REG,
+					 CHG_STAT_IRQ_ONLY_BIT
+					 | CHG_STAT_ACTIVE_HIGH_BIT
+					 | CHG_STAT_DISABLE_BIT
+					 | CHG_TEMP_CHG_ERR_BLINK_BIT,
+					 CHG_STAT_IRQ_ONLY_BIT);
+		if (ret < 0) {
+			dev_err(smb->dev, "couldn't set irq: %d\n", ret);
+			return ret;
+		}
+
+		ret = smb1360_configure_irq(smb);
+		if (ret < 0) {
+			dev_err(smb->dev, "couldn't configure irq: %d\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int smb1360_parse_properties(struct smb1360 *smb)
+{
+	struct device *dev = smb->dev;
+
+	smb->shdn_after_pwroff = device_property_read_bool(dev, "qcom,shdn-after-pwroff");
+	smb->rsense_10mohm = device_property_read_bool(dev, "qcom,rsense-10mohm");
+
+	return 0;
+}
+
+static const struct regmap_config smb1360_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+};
+
+static const struct power_supply_desc smb1360_battery_desc = {
+	.name			= "smb1360-battery",
+	.type			= POWER_SUPPLY_TYPE_BATTERY,
+	.get_property		= smb1360_get_property,
+	.properties		= smb1360_props,
+	.num_properties		= ARRAY_SIZE(smb1360_props),
+};
+
+static int smb1360_probe(struct i2c_client *client)
+{
+	int ret;
+	struct power_supply_config psy_cfg = {};
+	struct device *dev = &client->dev;
+	struct i2c_client *fg_client;
+	struct smb1360 *smb;
+	u16 fg_address;
+
+	if (client->addr & FG_I2C_CFG_MASK) {
+		dev_err(&client->dev, "invalid i2c address: %#x\n", client->addr);
+		return -EINVAL;
+	}
+
+	smb = devm_kzalloc(&client->dev, sizeof(*smb), GFP_KERNEL);
+	if (!smb)
+		return -EINVAL;
+
+	smb->dev = dev;
+
+	smb->regmap = devm_regmap_init_i2c(client, &smb1360_regmap_config);
+	if (IS_ERR(smb->regmap)) {
+		dev_err(&client->dev, "failed to init regmap\n");
+		return -EINVAL;
+	}
+
+	INIT_DELAYED_WORK(&smb->delayed_init_work,
+			  smb1360_delayed_init_work_fn);
+	init_completion(&smb->fg_mem_access_granted);
+
+	ret = regmap_read(smb->regmap, REVISION_CTRL_REG, &smb->revision);
+	if (ret) {
+		dev_err(smb->dev, "couldn't read revision: %d\n", ret);
+		return ret;
+	}
+	smb->revision &= DEVICE_REV_MASK;
+	dev_dbg(smb->dev, "device revision: %d\n", smb->revision);
+
+	fg_address = client->addr | FG_CFG_I2C_ADDR;
+	fg_client = devm_i2c_new_dummy_device(dev, client->adapter, fg_address);
+	if (IS_ERR(fg_client)) {
+		dev_err(&client->dev, "failed to init fg i2c client\n");
+		return -EINVAL;
+	}
+
+	smb->fg_regmap = devm_regmap_init_i2c(fg_client, &smb1360_regmap_config);
+	if (IS_ERR(smb->fg_regmap)) {
+		dev_err(&client->dev, "failed to init fg regmap\n");
+		return -EINVAL;
+	}
+
+	ret = smb1360_parse_properties(smb);
+	if (ret) {
+		dev_err(&client->dev, "error parsing device tree: %d\n", ret);
+		return ret;
+	}
+
+	device_init_wakeup(smb->dev, 1);
+	i2c_set_clientdata(client, smb);
+
+	/* Dump initial registers */
+	smb1360_dump(client);
+
+	ret = smb1360_hw_init(client);
+	if (ret < 0) {
+		dev_err(&client->dev, "unable to initialize hw: %d\n", ret);
+		return ret;
+	}
+
+	ret = regmap_raw_read(smb->regmap, IRQ_REG, smb->irqstat, sizeof(smb->irqstat));
+	if (ret < 0) {
+		dev_err(&client->dev, "unable to determine init status: %d\n", ret);
+		return ret;
+	}
+
+	smb->edev = devm_extcon_dev_allocate(dev, smb1360_usb_extcon_cable);
+	if (IS_ERR(smb->edev))
+		return PTR_ERR(smb->edev);
+
+	ret = devm_extcon_dev_register(dev, smb->edev);
+	if (ret < 0)
+		return ret;
+
+	extcon_set_state_sync(smb->edev, EXTCON_USB,
+			      !(smb->irqstat[IRQ_E] & IRQ_E_USBIN_UV_BIT));
+
+	ret = smb1360_register_vbus_regulator(smb);
+	if (ret < 0)
+		return ret;
+
+	psy_cfg.drv_data = smb;
+	smb->psy = devm_power_supply_register(&client->dev, &smb1360_battery_desc,
+					      &psy_cfg);
+	if (IS_ERR(smb->psy)) {
+		dev_err(&client->dev, "failed to register power supply\n");
+		ret = PTR_ERR(smb->psy);
+		return ret;
+	}
+
+	if (client->irq) {
+		ret = devm_request_threaded_irq(&client->dev, client->irq, NULL,
+						smb1360_irq, IRQF_ONESHOT,
+						NULL, smb);
+		if (ret) {
+			dev_err(&client->dev,
+				"request irq %d failed\n", client->irq);
+			return ret;
+		}
+
+		enable_irq_wake(client->irq);
+	}
+
+	schedule_delayed_work(&smb->delayed_init_work,
+			      msecs_to_jiffies(SMB1360_POWERON_DELAY_MS));
+
+	return 0;
+}
+
+static void smb1360_shutdown(struct i2c_client *client)
+{
+	int ret;
+	struct smb1360 *smb = i2c_get_clientdata(client);
+
+	ret = regulator_disable_regmap(smb->otg_vreg);
+	if (ret)
+		dev_err(smb->dev, "couldn't disable OTG: %d\n", ret);
+
+	if (smb->shdn_after_pwroff) {
+		ret = smb1360_poweroff(smb);
+		if (ret)
+			dev_err(smb->dev, "couldn't shutdown: %d\n", ret);
+	}
+}
+
+static int smb1360_suspend(struct device *dev)
+{
+	int ret;
+	struct smb1360 *smb = dev_get_drvdata(dev);
+
+	ret = regmap_write(smb->regmap, IRQ_CFG_REG, IRQ_DCIN_UV_BIT
+						| IRQ_BAT_HOT_COLD_SOFT_BIT
+						| IRQ_HOT_COLD_HARD_BIT);
+	if (ret < 0)
+		dev_err(smb->dev, "couldn't set irq_cfg: %d\n", ret);
+
+	ret = regmap_write(smb->regmap, IRQ2_CFG_REG, IRQ2_BATT_MISSING_BIT
+						| IRQ2_VBAT_LOW_BIT
+						| IRQ2_POWER_OK_BIT);
+	if (ret < 0)
+		dev_err(smb->dev, "couldn't set irq2_cfg: %d\n", ret);
+
+	ret = regmap_write(smb->regmap, IRQ3_CFG_REG, IRQ3_SOC_FULL_BIT
+					| IRQ3_SOC_MIN_BIT
+					| IRQ3_SOC_EMPTY_BIT);
+	if (ret < 0)
+		dev_err(smb->dev, "couldn't set irq3_cfg: %d\n", ret);
+
+	return 0;
+}
+
+static int smb1360_resume(struct device *dev)
+{
+	int ret;
+	struct smb1360 *smb = dev_get_drvdata(dev);
+
+	ret = smb1360_configure_irq(smb);
+	if (ret)
+		return ret;
+
+	power_supply_changed(smb->psy);
+
+	return 0;
+}
+
+static const struct dev_pm_ops smb1360_pm_ops = {
+	.resume = smb1360_resume,
+	.suspend = smb1360_suspend,
+};
+
+#ifdef CONFIG_OF
+static const struct of_device_id smb1360_match_table[] = {
+	{ .compatible = "qcom,smb1360" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, smb1360_match_table);
+#endif
+
+static struct i2c_driver smb1360_driver = {
+	.driver	= {
+		.name = "smb1360",
+		.of_match_table = of_match_ptr(smb1360_match_table),
+		.pm = &smb1360_pm_ops,
+	},
+	.probe = smb1360_probe,
+	.shutdown = smb1360_shutdown,
+};
+
+module_i2c_driver(smb1360_driver);
+
+MODULE_DESCRIPTION("SMB1360 Charger and Fuel Gauge");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/soc/qcom/Kconfig b/drivers/soc/qcom/Kconfig
index 74b9121240f8..fe0134a5dd0c 100644
--- a/drivers/soc/qcom/Kconfig
+++ b/drivers/soc/qcom/Kconfig
@@ -62,6 +62,14 @@ config QCOM_MDT_LOADER
 	tristate
 	select QCOM_SCM
 
+config QCOM_MEMSHARE_QMI_SERVICE
+       select QCOM_QMI_HELPERS
+       tristate "Qualcomm QMI Shared Memory Service (MEMSHARE)"
+       help
+	  This service provides additional memory regions on request from
+	  remote processors. On some platforms it is used for GPS by
+	  the location service in the modem subsystem.
+
 config QCOM_OCMEM
 	tristate "Qualcomm On Chip Memory (OCMEM) driver"
 	depends on ARCH_QCOM
diff --git a/drivers/soc/qcom/Makefile b/drivers/soc/qcom/Makefile
index acbca2ab5cc2..8f4508e5bc17 100644
--- a/drivers/soc/qcom/Makefile
+++ b/drivers/soc/qcom/Makefile
@@ -6,6 +6,8 @@ obj-$(CONFIG_QCOM_GENI_SE) +=	qcom-geni-se.o
 obj-$(CONFIG_QCOM_COMMAND_DB) += cmd-db.o
 obj-$(CONFIG_QCOM_GSBI)	+=	qcom_gsbi.o
 obj-$(CONFIG_QCOM_MDT_LOADER)	+= mdt_loader.o
+obj-$(CONFIG_QCOM_MEMSHARE_QMI_SERVICE) += qcom_memshare.o
+qcom_memshare-y := memshare.o memshare_qmi_msg.o
 obj-$(CONFIG_QCOM_OCMEM)	+= ocmem.o
 obj-$(CONFIG_QCOM_PD_MAPPER)	+= qcom_pd_mapper.o
 obj-$(CONFIG_QCOM_PDR_HELPERS)	+= pdr_interface.o
diff --git a/drivers/soc/qcom/memshare.c b/drivers/soc/qcom/memshare.c
new file mode 100644
index 000000000000..e8648fe2f68f
--- /dev/null
+++ b/drivers/soc/qcom/memshare.c
@@ -0,0 +1,502 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/net.h>
+#include <linux/soc/qcom/qmi.h>
+
+#include "memshare_qmi_msg.h"
+
+#define MEMSHARE_MAX_CLIENTS 10
+
+struct memshare_client {
+	u32 id;
+	u32 proc_id;
+	u32 qrtr_node;
+	u32 size;
+	phys_addr_t phy_addr;
+};
+
+struct memshare {
+	struct device *dev;
+	struct qmi_handle qmi;
+	unsigned int client_cnt;
+	struct memshare_client *legacy_client;
+	struct memshare_client *clients[MEMSHARE_MAX_CLIENTS];
+};
+
+static struct memshare_client *memshare_get_client(struct memshare *share, u32 id, u32 proc_id)
+{
+	int i;
+
+	for (i = 0; i < share->client_cnt; i++)
+		if (share->clients[i]->id == id && share->clients[i]->proc_id == proc_id)
+			return share->clients[i];
+
+	return NULL;
+}
+
+static void memshare_alloc_req_handler(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,
+				       struct qmi_txn *txn, const void *data)
+{
+	struct memshare *share = container_of(qmi, struct memshare, qmi);
+	const struct mem_alloc_req_msg_v01 *req = data;
+	struct mem_alloc_resp_msg_v01 resp = { .resp = QMI_RESULT_FAILURE_V01 };
+	struct memshare_client *client = share->legacy_client;
+	int ret;
+
+	dev_dbg(share->dev,
+		"alloc_req: num_bytes=%d, block_alignment_valid=%d, block_alignment=%d, node=%d\n",
+		req->num_bytes,
+		req->block_alignment_valid,
+		req->block_alignment,
+		sq->sq_node
+	);
+
+	if (!client) {
+		dev_err(share->dev, "Unknown request from legacy client (size=%d, node=%d)\n",
+			req->num_bytes, sq->sq_node);
+		goto send_response;
+	}
+
+	if (sq->sq_node != client->qrtr_node) {
+		dev_err(share->dev, "Request from node %d but %d expected\n",
+			sq->sq_node, client->qrtr_node);
+		goto send_response;
+	}
+
+	if (client->size && client->size != req->num_bytes) {
+		dev_err(share->dev, "Got a request with wrong size (size=%d)\n",
+			req->num_bytes);
+		goto send_response;
+	}
+
+	if (req->block_alignment_valid)
+		if (client->phy_addr % MEM_BLOCK_ALIGN_TO_BYTES(req->block_alignment) != 0)
+			dev_warn(share->dev, "Memory region is not aligned by %d bytes\n",
+				 MEM_BLOCK_ALIGN_TO_BYTES(req->block_alignment));
+
+	if (!client->phy_addr) {
+		dev_info(share->dev,
+			 "Client sent a request but no memory is configured (size=%d, node=%d)\n",
+			 req->num_bytes, sq->sq_node);
+		goto send_response;
+	}
+
+	resp.resp = QMI_RESULT_SUCCESS_V01;
+	resp.handle_valid = true;
+	resp.handle = client->phy_addr;
+	resp.num_bytes_valid = true;
+	resp.num_bytes = client->size;
+
+send_response:
+	ret = qmi_send_response(qmi, sq, txn, MEM_ALLOC_MSG_V01, MEM_MAX_MSG_LEN_V01,
+				mem_alloc_resp_msg_data_v01_ei, &resp);
+	if (ret < 0)
+		dev_err(share->dev, "Failed to send response: %d\n", ret);
+}
+
+static void memshare_free_req_handler(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,
+				      struct qmi_txn *txn, const void *data)
+{
+	struct memshare *share = container_of(qmi, struct memshare, qmi);
+	const struct mem_free_req_msg_v01 *req = data;
+	struct mem_free_resp_msg_v01 resp = { .resp = QMI_RESULT_FAILURE_V01 };
+	struct memshare_client *client = share->legacy_client;
+	int ret;
+
+	dev_dbg(share->dev, "free_req: node=%d\n", sq->sq_node);
+
+	if (!client) {
+		dev_err(share->dev, "Unknown request from legacy client\n");
+		goto send_response;
+	}
+
+	if (sq->sq_node != client->qrtr_node) {
+		dev_err(share->dev, "Request from node %d but %d expected\n",
+			sq->sq_node, client->qrtr_node);
+		goto send_response;
+	}
+
+	if (client->phy_addr != req->handle) {
+		dev_err(share->dev, "Got a request with wrong address\n");
+		goto send_response;
+	}
+
+	resp.resp = QMI_RESULT_SUCCESS_V01;
+
+send_response:
+	ret = qmi_send_response(qmi, sq, txn, MEM_FREE_MSG_V01, MEM_MAX_MSG_LEN_V01,
+				mem_free_resp_msg_data_v01_ei, &resp);
+	if (ret < 0)
+		dev_err(share->dev, "Failed to send response: %d\n", ret);
+}
+
+static void memshare_alloc_generic_req_handler(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,
+					       struct qmi_txn *txn, const void *data)
+{
+	struct memshare *share = container_of(qmi, struct memshare, qmi);
+	const struct mem_alloc_generic_req_msg_v01 *req = data;
+	struct mem_alloc_generic_resp_msg_v01 *resp;
+	struct memshare_client *client;
+	int ret;
+
+	resp = kzalloc(sizeof(*resp), GFP_KERNEL);
+	if (!resp)
+		return;
+
+	resp->resp.result = QMI_RESULT_FAILURE_V01;
+	resp->resp.error = QMI_ERR_INTERNAL_V01;
+
+	dev_dbg(share->dev,
+		"alloc_generic_req: num_bytes=%d, client_id=%d, proc_id=%d, sequence_id=%d, "
+		"alloc_contiguous_valid=%d, alloc_contiguous=%d, block_alignment_valid=%d, "
+		"block_alignment=%d, node=%d\n",
+		req->num_bytes,
+		req->client_id,
+		req->proc_id,
+		req->sequence_id,
+		req->alloc_contiguous_valid,
+		req->alloc_contiguous,
+		req->block_alignment_valid,
+		req->block_alignment,
+		sq->sq_node
+	);
+
+	client = memshare_get_client(share, req->client_id, req->proc_id);
+	if (!client) {
+		dev_err(share->dev,
+			"Got a request from unknown client (id=%d, proc=%d, size=%d, node=%d)\n",
+			req->client_id, req->proc_id, req->num_bytes, sq->sq_node);
+		goto send_response;
+	}
+
+	if (sq->sq_node != client->qrtr_node) {
+		dev_err(share->dev, "Request from node %d but %d expected\n",
+			sq->sq_node, client->qrtr_node);
+		goto send_response;
+	}
+
+	if (!client->phy_addr) {
+		dev_info(share->dev,
+			 "Client sent a request but no memory is configured "
+			 "(id=%d, proc=%d, size=%d, node=%d)\n",
+			 req->client_id, req->proc_id, req->num_bytes, sq->sq_node);
+		goto send_response;
+	}
+
+	if (client->size != req->num_bytes) {
+		dev_err(share->dev,
+			"Got a request with wrong size (id=%d, proc=%d, size=%d)\n",
+			req->client_id, req->proc_id, req->num_bytes);
+		goto send_response;
+	}
+
+	if (req->block_alignment_valid)
+		if (client->phy_addr % MEM_BLOCK_ALIGN_TO_BYTES(req->block_alignment) != 0)
+			dev_warn(share->dev, "Memory region is not aligned by %d bytes\n",
+				 MEM_BLOCK_ALIGN_TO_BYTES(req->block_alignment));
+
+	resp->resp.result = QMI_RESULT_SUCCESS_V01;
+	resp->resp.error = QMI_ERR_NONE_V01;
+	resp->sequence_id_valid = true;
+	resp->sequence_id = req->sequence_id;
+	resp->dhms_mem_alloc_addr_info_valid = true;
+	resp->dhms_mem_alloc_addr_info_len = 1;
+	resp->dhms_mem_alloc_addr_info[0].phy_addr = client->phy_addr;
+	resp->dhms_mem_alloc_addr_info[0].num_bytes = client->size;
+
+send_response:
+	ret = qmi_send_response(qmi, sq, txn, MEM_ALLOC_GENERIC_MSG_V01, MEM_MAX_MSG_LEN_V01,
+				mem_alloc_generic_resp_msg_data_v01_ei, resp);
+	if (ret < 0)
+		dev_err(share->dev, "Failed to send response: %d\n", ret);
+
+	kfree(resp);
+}
+
+static void memshare_free_generic_req_handler(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,
+					      struct qmi_txn *txn, const void *data)
+{
+	struct memshare *share = container_of(qmi, struct memshare, qmi);
+	const struct mem_free_generic_req_msg_v01 *req = data;
+	struct mem_free_generic_resp_msg_v01 resp = {
+		.resp.result = QMI_RESULT_FAILURE_V01,
+		.resp.error = QMI_ERR_INTERNAL_V01,
+	};
+	struct memshare_client *client;
+	int ret;
+
+	dev_dbg(share->dev,
+		"free_generic_req: dhms_mem_alloc_addr_info_len=%d, client_id_valid=%d, "
+		"client_id=%d, proc_id_valid=%d, proc_id=%d, node=%d\n",
+		req->dhms_mem_alloc_addr_info_len,
+		req->client_id_valid,
+		req->client_id,
+		req->proc_id_valid,
+		req->proc_id,
+		sq->sq_node
+	);
+
+	if (req->dhms_mem_alloc_addr_info_len != 1) {
+		dev_err(share->dev, "addr_info_len = %d is unexpected\n",
+			req->dhms_mem_alloc_addr_info_len);
+		goto send_response;
+	}
+
+	if (!req->client_id_valid || !req->proc_id_valid) {
+		dev_err(share->dev, "Got a request from unknown client\n");
+		goto send_response;
+	}
+
+	client = memshare_get_client(share, req->client_id, req->proc_id);
+	if (!client) {
+		dev_err(share->dev, "Got a request from unknown client (id=%d, proc=%d)\n",
+			req->client_id, req->proc_id);
+		goto send_response;
+	}
+
+	if (req->dhms_mem_alloc_addr_info[0].phy_addr != client->phy_addr) {
+		dev_err(share->dev, "Client sent invalid handle\n");
+		goto send_response;
+	}
+
+	if (sq->sq_node != client->qrtr_node) {
+		dev_err(share->dev, "Request from node %d but %d expected\n",
+			sq->sq_node, client->qrtr_node);
+		goto send_response;
+	}
+
+	resp.resp.result = QMI_RESULT_SUCCESS_V01;
+	resp.resp.error = QMI_ERR_NONE_V01;
+
+send_response:
+	ret = qmi_send_response(qmi, sq, txn, MEM_FREE_GENERIC_MSG_V01, MEM_MAX_MSG_LEN_V01,
+				mem_free_generic_resp_msg_data_v01_ei, &resp);
+	if (ret < 0)
+		dev_err(share->dev, "Failed to send response: %d\n", ret);
+}
+
+static void memshare_query_size_req_handler(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,
+					    struct qmi_txn *txn, const void *data)
+{
+	struct memshare *share = container_of(qmi, struct memshare, qmi);
+	const struct mem_query_size_req_msg_v01 *req = data;
+	struct mem_query_size_rsp_msg_v01 resp = {
+		.resp.result = QMI_RESULT_FAILURE_V01,
+		.resp.error = QMI_ERR_INTERNAL_V01,
+	};
+	struct memshare_client *client;
+	int ret;
+
+	dev_dbg(share->dev,
+		"query_size_req: client_id=%d, proc_id_valid=%d, proc_id=%d, node=%d\n",
+		req->client_id,
+		req->proc_id_valid,
+		req->proc_id,
+		sq->sq_node
+	);
+
+	client = memshare_get_client(share, req->client_id, req->proc_id);
+	if (!client) {
+		dev_err(share->dev, "Got a request from unknown client (id=%d, proc=%d)\n",
+			req->client_id, req->proc_id);
+		goto send_response;
+	}
+
+	if (sq->sq_node != client->qrtr_node) {
+		dev_err(share->dev, "Request from node %d but %d expected\n",
+			sq->sq_node, client->qrtr_node);
+		goto send_response;
+	}
+
+	if (!client->phy_addr)
+		goto send_response;
+
+	resp.resp.result = QMI_RESULT_SUCCESS_V01;
+	resp.resp.error = QMI_ERR_NONE_V01;
+	resp.size_valid = true;
+	resp.size = client->size;
+
+send_response:
+	ret = qmi_send_response(qmi, sq, txn, MEM_QUERY_SIZE_MSG_V01, MEM_MAX_MSG_LEN_V01,
+				mem_query_size_resp_msg_data_v01_ei, &resp);
+	if (ret < 0)
+		dev_err(share->dev, "Failed to send response: %d\n", ret);
+}
+
+static struct qmi_msg_handler memshare_handlers[] = {
+	{
+		.type = QMI_REQUEST,
+		.msg_id = MEM_ALLOC_MSG_V01,
+		.ei = mem_alloc_req_msg_data_v01_ei,
+		.decoded_size = sizeof(struct mem_alloc_req_msg_v01),
+		.fn = memshare_alloc_req_handler,
+	},
+	{
+		.type = QMI_REQUEST,
+		.msg_id = MEM_FREE_MSG_V01,
+		.ei = mem_free_req_msg_data_v01_ei,
+		.decoded_size = sizeof(struct mem_free_req_msg_v01),
+		.fn = memshare_free_req_handler,
+	},
+	{
+		.type = QMI_REQUEST,
+		.msg_id = MEM_ALLOC_GENERIC_MSG_V01,
+		.ei = mem_alloc_generic_req_msg_data_v01_ei,
+		.decoded_size = sizeof(struct mem_alloc_generic_req_msg_v01),
+		.fn = memshare_alloc_generic_req_handler,
+	},
+	{
+		.type = QMI_REQUEST,
+		.msg_id = MEM_FREE_GENERIC_MSG_V01,
+		.ei = mem_free_generic_req_msg_data_v01_ei,
+		.decoded_size = sizeof(struct mem_free_generic_req_msg_v01),
+		.fn = memshare_free_generic_req_handler,
+	},
+	{
+		.type = QMI_REQUEST,
+		.msg_id = MEM_QUERY_SIZE_MSG_V01,
+		.ei = mem_query_size_req_msg_data_v01_ei,
+		.decoded_size = sizeof(struct mem_query_size_req_msg_v01),
+		.fn = memshare_query_size_req_handler,
+	},
+	{ /* sentinel */ }
+};
+
+static int memshare_probe_dt(struct memshare *share)
+{
+	struct device_node *np = share->dev->of_node;
+	struct device_node *proc_node = NULL, *client_node = NULL, *mem_node = NULL;
+	struct reserved_mem *rmem;
+	int ret = 0;
+	u32 proc_id, qrtr_node;
+	struct memshare_client *client;
+	phandle legacy_client = 0;
+
+	ret = of_property_read_u32(np, "qcom,legacy-client", &legacy_client);
+	if (ret && ret != -EINVAL)
+		return ret;
+
+	for_each_available_child_of_node(np, proc_node) {
+		ret = of_property_read_u32(proc_node, "reg", &proc_id);
+		if (ret)
+			goto error;
+
+		ret = of_property_read_u32(proc_node, "qcom,qrtr-node", &qrtr_node);
+		if (ret)
+			goto error;
+
+		for_each_available_child_of_node(proc_node, client_node) {
+			if (share->client_cnt >= MEMSHARE_MAX_CLIENTS) {
+				ret = -EINVAL;
+				goto error;
+			}
+
+			client = devm_kzalloc(share->dev, sizeof(*client), GFP_KERNEL);
+			if (!client) {
+				ret = -ENOMEM;
+				goto error;
+			}
+
+			ret = of_property_read_u32(client_node, "reg", &client->id);
+			if (ret)
+				goto error;
+
+			client->proc_id = proc_id;
+			client->qrtr_node = qrtr_node;
+
+			mem_node = of_parse_phandle(client_node, "memory-region", 0);
+			if (mem_node) {
+				rmem = of_reserved_mem_lookup(mem_node);
+				of_node_put(mem_node);
+				if (!rmem) {
+					dev_err(share->dev, "unable to resolve memory-region\n");
+					ret = -EINVAL;
+					goto error;
+				}
+
+				client->phy_addr = rmem->base;
+				client->size = rmem->size;
+			}
+
+			if (client_node->phandle == legacy_client)
+				share->legacy_client = client;
+
+			share->clients[share->client_cnt] = client;
+			share->client_cnt++;
+		}
+	}
+
+	return 0;
+
+error:
+	of_node_put(client_node);
+	of_node_put(proc_node);
+	return ret;
+}
+
+static int memshare_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct memshare *share;
+	int ret;
+
+	share = devm_kzalloc(&pdev->dev, sizeof(*share), GFP_KERNEL);
+	if (!share)
+		return -ENOMEM;
+
+	share->dev = dev;
+	dev_set_drvdata(&pdev->dev, share);
+
+	ret = qmi_handle_init(&share->qmi, MEM_MAX_MSG_LEN_V01, NULL, memshare_handlers);
+	if (ret < 0)
+		return ret;
+
+	ret = memshare_probe_dt(share);
+	if (ret < 0)
+		goto error;
+
+	ret = qmi_add_server(&share->qmi, MEM_SERVICE_SVC_ID,
+			     MEM_SERVICE_VER, MEM_SERVICE_INS_ID);
+	if (ret < 0)
+		goto error;
+
+	return 0;
+
+error:
+	qmi_handle_release(&share->qmi);
+	return ret;
+}
+
+static void memshare_remove(struct platform_device *pdev)
+{
+	struct memshare *share = dev_get_drvdata(&pdev->dev);
+
+	qmi_handle_release(&share->qmi);
+}
+
+static const struct of_device_id memshare_of_match[] = {
+	{ .compatible = "qcom,memshare", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, memshare_of_match);
+
+static struct platform_driver memshare_driver = {
+	.probe = memshare_probe,
+	.remove = memshare_remove,
+	.driver = {
+		.name = "qcom-memshare",
+		.of_match_table = of_match_ptr(memshare_of_match),
+	},
+};
+module_platform_driver(memshare_driver);
+
+MODULE_DESCRIPTION("Qualcomm Memory Share Service");
+MODULE_AUTHOR("Nikita Travkin <nikitos.tr@gmail.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/soc/qcom/memshare_qmi_msg.c b/drivers/soc/qcom/memshare_qmi_msg.c
new file mode 100644
index 000000000000..0cbccaaa7994
--- /dev/null
+++ b/drivers/soc/qcom/memshare_qmi_msg.c
@@ -0,0 +1,370 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2013-2015, 2017-2018, The Linux Foundation. All rights reserved.
+
+#include <linux/stddef.h>
+#include <linux/soc/qcom/qmi.h>
+
+#include "memshare_qmi_msg.h"
+
+struct qmi_elem_info mem_alloc_req_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_req_msg_v01, num_bytes),
+		.tlv_type       = 0x01,
+		.offset         = offsetof(struct mem_alloc_req_msg_v01, num_bytes),
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_req_msg_v01, block_alignment_valid),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_alloc_req_msg_v01, block_alignment_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_req_msg_v01, block_alignment),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_alloc_req_msg_v01, block_alignment),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_alloc_resp_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_SIGNED_2_BYTE_ENUM,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_resp_msg_v01, resp),
+		.tlv_type       = 0x01,
+		.offset         = offsetof(struct mem_alloc_resp_msg_v01, resp),
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_resp_msg_v01, handle_valid),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_alloc_resp_msg_v01, handle_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_8_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_resp_msg_v01, handle),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_alloc_resp_msg_v01, handle),
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_resp_msg_v01, num_bytes_valid),
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_alloc_resp_msg_v01, num_bytes_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_resp_msg_v01, num_bytes),
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_alloc_resp_msg_v01, num_bytes),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_free_req_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_UNSIGNED_8_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_free_req_msg_v01, handle),
+		.tlv_type       = 0x01,
+		.offset         = offsetof(struct mem_free_req_msg_v01, handle),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_free_resp_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_SIGNED_2_BYTE_ENUM,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_free_resp_msg_v01, resp),
+		.tlv_type       = 0x01,
+		.offset         = offsetof(struct mem_free_resp_msg_v01, resp),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info dhms_mem_alloc_addr_info_type_v01_ei[] = {
+	{
+		.data_type      = QMI_UNSIGNED_8_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct dhms_mem_alloc_addr_info_type_v01, phy_addr),
+		.tlv_type       = QMI_COMMON_TLV_TYPE,
+		.offset         = offsetof(struct dhms_mem_alloc_addr_info_type_v01, phy_addr),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct dhms_mem_alloc_addr_info_type_v01, num_bytes),
+		.tlv_type       = QMI_COMMON_TLV_TYPE,
+		.offset         = offsetof(struct dhms_mem_alloc_addr_info_type_v01, num_bytes),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_alloc_generic_req_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_req_msg_v01, num_bytes),
+		.tlv_type       = 0x01,
+		.offset         = offsetof(struct mem_alloc_generic_req_msg_v01, num_bytes),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_req_msg_v01, client_id),
+		.tlv_type       = 0x02,
+		.offset         = offsetof(struct mem_alloc_generic_req_msg_v01, client_id),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_req_msg_v01, proc_id),
+		.tlv_type       = 0x03,
+		.offset         = offsetof(struct mem_alloc_generic_req_msg_v01, proc_id),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_req_msg_v01, sequence_id),
+		.tlv_type       = 0x04,
+		.offset         = offsetof(struct mem_alloc_generic_req_msg_v01, sequence_id),
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_req_msg_v01,
+					       alloc_contiguous_valid),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_alloc_generic_req_msg_v01,
+					   alloc_contiguous_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_1_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_req_msg_v01,
+					       alloc_contiguous),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_alloc_generic_req_msg_v01, alloc_contiguous),
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_req_msg_v01,
+					       block_alignment_valid),
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_alloc_generic_req_msg_v01,
+					   block_alignment_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_req_msg_v01,
+					       block_alignment),
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_alloc_generic_req_msg_v01, block_alignment),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_alloc_generic_resp_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_STRUCT,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_resp_msg_v01, resp),
+		.tlv_type       = 0x02,
+		.offset         = offsetof(struct mem_alloc_generic_resp_msg_v01, resp),
+		.ei_array	= qmi_response_type_v01_ei,
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_resp_msg_v01,
+					       sequence_id_valid),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_alloc_generic_resp_msg_v01, sequence_id_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_resp_msg_v01, sequence_id),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_alloc_generic_resp_msg_v01, sequence_id),
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_resp_msg_v01,
+					       dhms_mem_alloc_addr_info_valid),
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_alloc_generic_resp_msg_v01,
+					   dhms_mem_alloc_addr_info_valid),
+	},
+	{
+		.data_type	= QMI_DATA_LEN,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_resp_msg_v01,
+					       dhms_mem_alloc_addr_info_len),
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_alloc_generic_resp_msg_v01,
+					   dhms_mem_alloc_addr_info_len),
+	},
+	{
+		.data_type      = QMI_STRUCT,
+		.elem_len       = MAX_ARR_CNT_V01,
+		.elem_size      = sizeof_field(struct mem_alloc_generic_resp_msg_v01,
+					       dhms_mem_alloc_addr_info),
+		.array_type     = VAR_LEN_ARRAY,
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_alloc_generic_resp_msg_v01,
+					   dhms_mem_alloc_addr_info),
+		.ei_array       = dhms_mem_alloc_addr_info_type_v01_ei,
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_free_generic_req_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_DATA_LEN,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_free_generic_req_msg_v01,
+					       dhms_mem_alloc_addr_info_len),
+		.tlv_type       = 0x01,
+		.offset         = offsetof(struct mem_free_generic_req_msg_v01,
+					   dhms_mem_alloc_addr_info_len),
+	},
+	{
+		.data_type      = QMI_STRUCT,
+		.elem_len       = MAX_ARR_CNT_V01,
+		.elem_size      = sizeof_field(struct mem_free_generic_req_msg_v01,
+					       dhms_mem_alloc_addr_info),
+		.array_type     = VAR_LEN_ARRAY,
+		.tlv_type       = 0x01,
+		.offset         = offsetof(struct mem_free_generic_req_msg_v01,
+					   dhms_mem_alloc_addr_info),
+		.ei_array	= dhms_mem_alloc_addr_info_type_v01_ei,
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_free_generic_req_msg_v01, client_id_valid),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_free_generic_req_msg_v01, client_id_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_free_generic_req_msg_v01, client_id),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_free_generic_req_msg_v01, client_id),
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_free_generic_req_msg_v01, proc_id_valid),
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_free_generic_req_msg_v01, proc_id_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_free_generic_req_msg_v01, proc_id),
+		.tlv_type       = 0x11,
+		.offset         = offsetof(struct mem_free_generic_req_msg_v01, proc_id),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_free_generic_resp_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_STRUCT,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_free_generic_resp_msg_v01, resp),
+		.tlv_type       = 0x02,
+		.offset         = offsetof(struct mem_free_generic_resp_msg_v01, resp),
+		.ei_array	= qmi_response_type_v01_ei,
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_query_size_req_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_query_size_req_msg_v01, client_id),
+		.tlv_type       = 0x01,
+		.offset         = offsetof(struct mem_query_size_req_msg_v01, client_id),
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_query_size_req_msg_v01, proc_id_valid),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_query_size_req_msg_v01, proc_id_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_query_size_req_msg_v01, proc_id),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_query_size_req_msg_v01, proc_id),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
+
+struct qmi_elem_info mem_query_size_resp_msg_data_v01_ei[] = {
+	{
+		.data_type      = QMI_STRUCT,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_query_size_rsp_msg_v01, resp),
+		.tlv_type       = 0x02,
+		.offset         = offsetof(struct mem_query_size_rsp_msg_v01, resp),
+		.ei_array	= qmi_response_type_v01_ei,
+	},
+	{
+		.data_type      = QMI_OPT_FLAG,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_query_size_rsp_msg_v01, size_valid),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_query_size_rsp_msg_v01, size_valid),
+	},
+	{
+		.data_type      = QMI_UNSIGNED_4_BYTE,
+		.elem_len       = 1,
+		.elem_size      = sizeof_field(struct mem_query_size_rsp_msg_v01, size),
+		.tlv_type       = 0x10,
+		.offset         = offsetof(struct mem_query_size_rsp_msg_v01, size),
+	},
+	{
+		.data_type      = QMI_EOTI,
+	},
+};
diff --git a/drivers/soc/qcom/memshare_qmi_msg.h b/drivers/soc/qcom/memshare_qmi_msg.h
new file mode 100644
index 000000000000..c436330a0713
--- /dev/null
+++ b/drivers/soc/qcom/memshare_qmi_msg.h
@@ -0,0 +1,228 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2013-2015, 2017-2018, The Linux Foundation. All rights reserved. */
+
+#ifndef HEAP_MEM_EXT_SERVICE_01_H
+#define HEAP_MEM_EXT_SERVICE_01_H
+
+#include <linux/types.h>
+#include <linux/soc/qcom/qmi.h>
+
+#define MEM_SERVICE_SVC_ID 0x00000034
+#define MEM_SERVICE_INS_ID 1
+#define MEM_SERVICE_VER 1
+
+/* Service Message Definition */
+#define MEM_ALLOC_MSG_V01 0x0020
+#define MEM_FREE_MSG_V01 0x0021
+#define MEM_ALLOC_GENERIC_MSG_V01 0x0022
+#define MEM_FREE_GENERIC_MSG_V01 0x0023
+#define MEM_QUERY_SIZE_MSG_V01 0x0024
+
+#define MEM_MAX_MSG_LEN_V01 255
+#define MAX_ARR_CNT_V01 64
+
+#define MEM_BLOCK_ALIGN_TO_BYTES(x) (2 << (x)) /* 0..11 */
+
+/**
+ * Unless stated otherwise, any property X that is paired with X_valid
+ * property is an optional property. Other properties are mandatory.
+ */
+
+/**
+ * struct dhms_mem_alloc_addr_info_type_v01 - Element of memory block array.
+ * @phy_addr: Physical address of memory block.
+ * @num_bytes: Size of memory block.
+ */
+struct dhms_mem_alloc_addr_info_type_v01 {
+	u64 phy_addr;
+	u32 num_bytes;
+};
+
+/**
+ * struct mem_alloc_req_msg_v01 - Legacy memory allocation request.
+ * @num_bytes: Requested size.
+ * @block_alignment_valid: Must be set to true if block_alignment is being passed.
+ * @block_alignment: The block alignment for the memory block to be allocated.
+ *
+ * Request Message.
+ * This command is used for getting the multiple physically contiguous memory
+ * blocks from the server memory subsystem.
+ */
+struct mem_alloc_req_msg_v01 {
+	u32 num_bytes;
+	u8 block_alignment_valid;
+	u32 block_alignment;
+};
+
+/**
+ * struct mem_alloc_resp_msg_v01 - Response for legacy allocation memory request.
+ * @resp: Result Code. The result of the requested memory operation.
+ * @handle_valid: Must be set to true if handle is being passed.
+ * @handle: Memory Block Handle. The physical address of the memory allocated on the HLOS.
+ * @num_bytes_valid: Must be set to true if num_bytes is being passed.
+ * @num_bytes: Memory block size. The number of bytes actually allocated for the request.
+ *             This value can be smaller than the size requested in QMI_DHMS_MEM_ALLOC_REQ_MSG.
+ *
+ * Response Message.
+ * This command is used for getting the multiple physically contiguous memory
+ * blocks from the server memory subsystem
+ */
+struct mem_alloc_resp_msg_v01 {
+	u16 resp;
+	u8 handle_valid;
+	u64 handle;
+	u8 num_bytes_valid;
+	u32 num_bytes;
+};
+
+/**
+ * struct mem_free_req_msg_v01 - Legacy memory free request.
+ * @handle: Physical address of memory to be freed.
+ *
+ * Request Message.
+ * This command is used for releasing the multiple physically contiguous memory
+ * blocks to the server memory subsystem.
+ */
+struct mem_free_req_msg_v01 {
+	u64 handle;
+};
+
+/**
+ * struct mem_free_resp_msg_v01 - Response for legacy memory free request.
+ * @resp: Result of the requested memory operation.
+ *
+ * Response Message.
+ * This command is used for releasing the multiple physically contiguous memory
+ * blocks to the server memory subsystem.
+ */
+struct mem_free_resp_msg_v01 {
+	u16 resp;
+};
+
+/**
+ * struct mem_alloc_generic_req_msg_v01 - Memory allocation request.
+ * @num_bytes: Requested size.
+ * @client_id: Client ID.
+ * @proc_id: Peripheral ID.
+ * @sequence_id: Sequence ID.
+ * @alloc_contiguous_valid: Must be set to true if alloc_contiguous is being passed.
+ * @alloc_contiguous: alloc_contiguous is used to identify that clients are requesting
+ *                    for contiguous or non contiguous memory, default is contiguous.
+ *                    0 = non contiguous else contiguous.
+ * @block_alignment_valid: Must be set to true if block_alignment is being passed.
+ * @block_alignment: The block alignment for the memory block to be allocated.
+ *
+ * Request Message.
+ * This command is used for getting the multiple physically contiguous memory
+ * blocks from the server memory subsystem
+ */
+struct mem_alloc_generic_req_msg_v01 {
+	u32 num_bytes;
+	u32 client_id;
+	u32 proc_id;
+	u32 sequence_id;
+	u8 alloc_contiguous_valid;
+	u8 alloc_contiguous;
+	u8 block_alignment_valid;
+	u32 block_alignment;
+};
+
+/**
+ * struct mem_alloc_generic_resp_msg_v01 - Response for memory allocation request.
+ * @resp: Result Code. The result of the requested memory operation.
+ * @sequence_id_valid: Must be set to true if sequence_id is being passed.
+ * @sequence_id: Sequence ID. This property is marked as mandatory.
+ * @dhms_mem_alloc_addr_info_valid: Must be set to true if handle is being passed.
+ * @dhms_mem_alloc_addr_info_len: Handle Size.
+ * @dhms_mem_alloc_addr_info: Memory Block Handle. The physical address of the
+ *                            memory allocated on the HLOS.
+ *
+ * Response Message.
+ * This command is used for getting the multiple physically contiguous memory
+ * blocks from the server memory subsystem
+ */
+struct mem_alloc_generic_resp_msg_v01 {
+	struct qmi_response_type_v01 resp;
+	u8 sequence_id_valid;
+	u32 sequence_id;
+	u8 dhms_mem_alloc_addr_info_valid;
+	u8 dhms_mem_alloc_addr_info_len;
+	struct dhms_mem_alloc_addr_info_type_v01 dhms_mem_alloc_addr_info[MAX_ARR_CNT_V01];
+};
+
+/**
+ * struct mem_free_generic_req_msg_v01 - Memory free request.
+ * @dhms_mem_alloc_addr_info_len: Must be set to # of elments in array.
+ * @dhms_mem_alloc_addr_info: Physical address and size of the memory allocated
+ *                            on the HLOS to be freed.
+ * @client_id_valid: Must be set to true if client_id is being passed.
+ * @client_id: Client ID.
+ * @proc_id_valid: Must be set to true if proc_id is being passed.
+ * @proc_id: Peripheral ID.
+ *
+ * Request Message.
+ * This command is used for releasing the multiple physically contiguous memory
+ * blocks to the server memory subsystem
+ */
+struct mem_free_generic_req_msg_v01 {
+	u8 dhms_mem_alloc_addr_info_len;
+	struct dhms_mem_alloc_addr_info_type_v01 dhms_mem_alloc_addr_info[MAX_ARR_CNT_V01];
+	u8 client_id_valid;
+	u32 client_id;
+	u8 proc_id_valid;
+	u32 proc_id;
+};
+
+/**
+ * struct mem_free_generic_resp_msg_v01 - Response for memory free request.
+ * @resp: Result of the requested memory operation.
+ *
+ * Response Message.
+ * This command is used for releasing the multiple physically contiguous memory
+ * blocks to the server memory subsystem
+ */
+struct mem_free_generic_resp_msg_v01 {
+	struct qmi_response_type_v01 resp;
+};
+
+/**
+ * struct mem_query_size_req_msg_v01 - Size query request.
+ * @client_id: Client ID.
+ * @proc_id_valid: proc_id_valid must be set to true if proc_id is being passed.
+ * @proc_id: Proc ID.
+ *
+ * Request Message.
+ */
+struct mem_query_size_req_msg_v01 {
+	u32 client_id;
+	u8 proc_id_valid;
+	u32 proc_id;
+};
+
+/**
+ * struct mem_query_size_rsp_msg_v01 - Response for Size query request.
+ * @resp: Result Code.
+ * @size_valid: size_valid must be set to true if size is being passed.
+ * @size: Size.
+ *
+ * Response Message.
+ */
+struct mem_query_size_rsp_msg_v01 {
+	struct qmi_response_type_v01 resp;
+	u8 size_valid;
+	u32 size;
+};
+
+/* Message structure definitions defined in "memshare_qmi_msg.c" */
+extern struct qmi_elem_info mem_alloc_req_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_alloc_resp_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_free_req_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_free_resp_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_alloc_generic_req_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_alloc_generic_resp_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_free_generic_req_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_free_generic_resp_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_query_size_req_msg_data_v01_ei[];
+extern struct qmi_elem_info mem_query_size_resp_msg_data_v01_ei[];
+
+#endif
diff --git a/drivers/thermal/qcom/tsens.c b/drivers/thermal/qcom/tsens.c
index 0b4421bf4785..374923a02c3e 100644
--- a/drivers/thermal/qcom/tsens.c
+++ b/drivers/thermal/qcom/tsens.c
@@ -968,17 +968,22 @@ int __init init_common(struct tsens_priv *priv)
 		ret = PTR_ERR(priv->rf[TSENS_EN]);
 		goto err_put_device;
 	}
-	/* in VER_0 TSENS need to be explicitly enabled */
-	if (tsens_version(priv) == VER_0)
-		regmap_field_write(priv->rf[TSENS_EN], 1);
 
-	ret = regmap_field_read(priv->rf[TSENS_EN], &enabled);
-	if (ret)
-		goto err_put_device;
-	if (!enabled) {
-		dev_err(dev, "%s: device not enabled\n", __func__);
-		ret = -ENODEV;
-		goto err_put_device;
+	if (!priv->srot_locked) {
+		/* in VER_0 TSENS need to be explicitly enabled */
+		if (tsens_version(priv) == VER_0)
+			regmap_field_write(priv->rf[TSENS_EN], 1);
+
+		ret = regmap_field_read(priv->rf[TSENS_EN], &enabled);
+		if (ret)
+			goto err_put_device;
+		if (!enabled) {
+			dev_err(dev, "%s: device not enabled\n", __func__);
+			ret = -ENODEV;
+			goto err_put_device;
+		}
+	} else {
+		dev_warn(dev, FW_BUG "SROT is locked, assuming TSENS is enabled\n");
 	}
 
 	priv->rf[SENSOR_EN] = devm_regmap_field_alloc(dev, priv->srot_map,
@@ -1322,6 +1327,7 @@ static int tsens_probe(struct platform_device *pdev)
 	}
 	priv->feat = data->feat;
 	priv->fields = data->fields;
+	priv->srot_locked = of_property_read_bool(np, "qcom,srot-locked");
 
 	platform_set_drvdata(pdev, priv);
 
diff --git a/drivers/thermal/qcom/tsens.h b/drivers/thermal/qcom/tsens.h
index cab39de045b1..e9c281cf652b 100644
--- a/drivers/thermal/qcom/tsens.h
+++ b/drivers/thermal/qcom/tsens.h
@@ -572,6 +572,7 @@ struct tsens_priv {
 	struct regmap			*tm_map;
 	struct regmap			*srot_map;
 	u32				tm_offset;
+	bool				srot_locked;
 
 	/* lock for upper/lower threshold interrupts */
 	spinlock_t			ul_lock;
diff --git a/include/drm/drm_modeset_helper_vtables.h b/include/drm/drm_modeset_helper_vtables.h
index ec59015aec3c..1fc8c232891f 100644
--- a/include/drm/drm_modeset_helper_vtables.h
+++ b/include/drm/drm_modeset_helper_vtables.h
@@ -839,6 +839,9 @@ struct drm_encoder_helper_funcs {
 	int (*atomic_check)(struct drm_encoder *encoder,
 			    struct drm_crtc_state *crtc_state,
 			    struct drm_connector_state *conn_state);
+
+	/* Call .enable()/.disable() etc after bridge enable/post_disable. */
+	bool late_enable;
 };
 
 /**
diff --git a/include/dt-bindings/soc/qcom,memshare.h b/include/dt-bindings/soc/qcom,memshare.h
new file mode 100644
index 000000000000..4cef1ef75d09
--- /dev/null
+++ b/include/dt-bindings/soc/qcom,memshare.h
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __DT_QCOM_MEMSHARE_H__
+#define __DT_QCOM_MEMSHARE_H__
+
+#define MEMSHARE_PROC_MPSS_V01 0
+#define MEMSHARE_PROC_ADSP_V01 1
+#define MEMSHARE_PROC_WCNSS_V01 2
+
+#endif /* __DT_QCOM_MEMSHARE_H__ */
diff --git a/include/dt-bindings/sound/qcom,q6voice.h b/include/dt-bindings/sound/qcom,q6voice.h
new file mode 100644
index 000000000000..fe5aa3a3fce4
--- /dev/null
+++ b/include/dt-bindings/sound/qcom,q6voice.h
@@ -0,0 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __DT_BINDINGS_Q6_VOICE_H__
+#define __DT_BINDINGS_Q6_VOICE_H__
+
+#define	CS_VOICE        0
+
+#endif /* __DT_BINDINGS_Q6_VOICE_H__ */
diff --git a/kernel/configs/pmos.config b/kernel/configs/pmos.config
new file mode 100644
index 000000000000..c2f61c502395
--- /dev/null
+++ b/kernel/configs/pmos.config
@@ -0,0 +1,288 @@
+# CONFIG_LOCALVERSION_AUTO is not set
+
+CONFIG_BLK_DEV_DM=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CGROUPS=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_XTS=y
+CONFIG_DEVTMPFS=y
+CONFIG_DM_CRYPT=m
+CONFIG_EXT4_FS=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_MD=y
+CONFIG_SYSVIPC=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_UEVENT_HELPER=y
+CONFIG_USER_NS=y
+CONFIG_VT=y
+CONFIG_FW_LOADER_COMPRESS=y
+CONFIG_FW_LOADER_COMPRESS_ZSTD=y
+
+# Anbox / Waydroid
+CONFIG_ANDROID_BINDER_IPC=y
+# CONFIG_ANDROID_BINDERFS is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_VLAN_FILTERING=y
+CONFIG_CGROUP_BPF=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_FUSE_FS=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XTABLES=m
+CONFIG_PSI=y
+CONFIG_SQUASHFS=m
+CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU=y
+CONFIG_SQUASHFS_FILE_DIRECT=y
+CONFIG_SQUASHFS_XATTR=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_TUN=m
+CONFIG_VETH=m
+CONFIG_VLAN_8021Q=m
+
+# iwd
+CONFIG_ASYMMETRIC_KEY_TYPE=y
+CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
+#ONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_CBC=m
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_MD5=m
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_USER_API=m
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+CONFIG_KEYS=y
+CONFIG_KEY_DH_OPERATIONS=y
+CONFIG_PKCS7_MESSAGE_PARSER=y
+CONFIG_PKCS8_PRIVATE_KEY_PARSER=m
+CONFIG_X509_CERTIFICATE_PARSER=y
+CONFIG_RFKILL=y
+
+# nftables
+CONFIG_NETFILTER=y
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_NAT=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_REJECT_IPV4=m
+CONFIG_NF_REJECT_IPV6=m
+CONFIG_NF_TABLES=m
+CONFIG_NF_TABLES_INET=y
+CONFIG_NF_TABLES_IPV4=y
+CONFIG_NF_TABLES_IPV6=y
+CONFIG_NFT_CT=m
+CONFIG_NFT_LIMIT=m
+CONFIG_NFT_LOG=m
+CONFIG_NFT_MASQ=m
+CONFIG_NFT_NAT=m
+CONFIG_NFT_REJECT=m
+CONFIG_NFT_COMPAT=m
+
+# /usr/share/docker/contrib/check-config.sh (from Gentoo)
+# Missing dependency?
+CONFIG_NET_SCHED=y
+
+# Generally Necessary:
+CONFIG_NAMESPACES=y
+CONFIG_NET_NS=y
+CONFIG_PID_NS=y
+CONFIG_IPC_NS=y
+CONFIG_UTS_NS=y
+#ONFIG_CGROUPS=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CPUSETS=y
+#ONFIG_KEYS=y
+#ONFIG_VETH=m
+#ONFIG_BRIDGE=m
+CONFIG_BRIDGE_NETFILTER=m
+#ONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_IPVS=m
+CONFIG_NETFILTER_XT_MARK=m
+#ONFIG_IP_NF_NAT=m
+CONFIG_NF_NAT=m
+CONFIG_POSIX_MQUEUE=y
+
+# Optional Features:
+#ONFIG_USER_NS=y
+CONFIG_SECCOMP=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_BLK_CGROUP=y
+CONFIG_BLK_DEV_THROTTLING=y
+CONFIG_CGROUP_PERF=y
+CONFIG_NET_CLS_CGROUP=m
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_FAIR_GROUP_SCHED=y
+#ONFIG_RT_GROUP_SCHED=y
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_VS=m
+CONFIG_IP_VS_NFCT=y
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_RR=m
+#ONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_VXLAN=m
+#ONFIG_BRIDGE_VLAN_FILTERING=y
+CONFIG_IPVLAN=m
+CONFIG_MACVLAN=m
+CONFIG_DUMMY=m
+#ONFIG_BLK_DEV_DM=m
+CONFIG_DM_THIN_PROVISIONING=m
+CONFIG_OVERLAY_FS=m
+
+# lxc
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+
+# ZRAM
+CONFIG_ZRAM=m
+CONFIG_ZRAM_BACKEND_LZ4=y
+CONFIG_ZRAM_BACKEND_ZSTD=y
+CONFIG_ZRAM_DEF_COMP_ZSTD=y
+CONFIG_SWAP=y
+
+# netboot
+CONFIG_BLK_DEV_NBD=m
+
+# WireGuard
+CONFIG_WIREGUARD=m
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+#ONFIG_NF_TABLES=m
+#ONFIG_NF_TABLES_IPV4=y
+#ONFIG_NF_TABLES_IPV6=y
+#ONFIG_NFT_CT=m
+CONFIG_NFT_FIB_IPV4=m
+CONFIG_NFT_FIB_IPV6=m
+CONFIG_NF_CONNTRACK_MARK=y
+
+# File systems
+CONFIG_BTRFS_FS=m
+CONFIG_EXFAT_FS=m
+#ONFIG_EXT4_FS=y
+CONFIG_F2FS_FS=m
+CONFIG_F2FS_FS_COMPRESSION=y
+CONFIG_UDF_FS=m
+CONFIG_XFS_FS=m
+
+# Community
+CONFIG_BINFMT_MISC=m
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_CIFS=m
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_UCLAMP_TASK=y
+CONFIG_UCLAMP_TASK_GROUP=y
+CONFIG_DM_INTEGRITY=m
+
+# Input
+CONFIG_HIDRAW=y
+CONFIG_INPUT_UINPUT=m
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_XPAD=m
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_JOYSTICK_XPAD_LEDS=y
+CONFIG_UHID=m
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_HIDDEV=y
+CONFIG_USB_PRINTER=m
+
+# USB
+CONFIG_DRM_UDL=m
+CONFIG_SND_USB_AUDIO=m
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_STORAGE=y
+CONFIG_USB_RTL8152=m
+CONFIG_USB_USBNET=m
+
+# USB Gadget
+CONFIG_U_SERIAL_CONSOLE=y
+CONFIG_USB_CONFIGFS=m
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_OBEX=y
+CONFIG_USB_CONFIGFS_NCM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_EEM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_UAC1=y
+CONFIG_USB_CONFIGFS_F_UAC2=y
+CONFIG_USB_CONFIGFS_F_MIDI=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_CONFIGFS_F_UVC=y
+CONFIG_USB_CONFIGFS_F_PRINTER=y
+
+# LED triggers
+CONFIG_LEDS_TRIGGER_ACTIVITY=m
+CONFIG_LEDS_TRIGGER_AUDIO=m
+CONFIG_LEDS_TRIGGER_BACKLIGHT=m
+CONFIG_LEDS_TRIGGER_CAMERA=m
+CONFIG_LEDS_TRIGGER_GPIO=m
+CONFIG_LEDS_TRIGGER_NETDEV=m
+CONFIG_LEDS_TRIGGER_ONESHOT=m
+CONFIG_LEDS_TRIGGER_PATTERN=m
+CONFIG_LEDS_TRIGGER_TRANSIENT=m
+CONFIG_LEDS_TRIGGER_TTY=m
+
+# Bluetooth devices
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=m
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=m
+
+# EFI
+CONFIG_EFI=y
+CONFIG_EFI_ZBOOT=y
+CONFIG_FB_EFI=y
+CONFIG_VFAT_FS=y
+CONFIG_NLS_ASCII=y
+CONFIG_PSTORE=y
+CONFIG_EFI_VARS_PSTORE=y
+CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE=y
+
+# libcamera
+CONFIG_DMABUF_HEAPS=y
+CONFIG_DMABUF_HEAPS_CMA=y
+CONFIG_UDMABUF=y
+
+# enable uvcvideo for basic USB webcam/HDMI-dongle support
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+
+# Debug
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_DYNAMIC_FTRACE=y
diff --git a/sound/soc/codecs/msm8916-wcd-analog.c b/sound/soc/codecs/msm8916-wcd-analog.c
index 9ca381812975..b0934faa785c 100644
--- a/sound/soc/codecs/msm8916-wcd-analog.c
+++ b/sound/soc/codecs/msm8916-wcd-analog.c
@@ -10,6 +10,7 @@
 #include <linux/of.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
+#include <linux/gpio/consumer.h>
 #include <sound/soc.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
@@ -297,6 +298,7 @@ struct pm8916_wcd_analog_priv {
 	struct snd_soc_component *component;
 	struct regulator_bulk_data supplies[ARRAY_SIZE(supply_names)];
 	struct snd_soc_jack *jack;
+	struct snd_soc_jack_gpio jack_gpio;
 	bool hphl_jack_type_normally_open;
 	bool gnd_jack_type_normally_open;
 	/* Voltage threshold when internal current source of 100uA is used */
@@ -479,7 +481,7 @@ static void pm8916_wcd_setup_mbhc(struct pm8916_wcd_analog_priv *wcd)
 	struct snd_soc_component *component = wcd->component;
 	bool micbias_enabled = false;
 	u32 plug_type = 0;
-	u32 int_en_mask;
+	u32 int_en_mask = 0;
 
 	snd_soc_component_write(component, CDC_A_MBHC_DET_CTL_1,
 		      CDC_A_MBHC_DET_CTL_L_DET_EN |
@@ -514,7 +516,8 @@ static void pm8916_wcd_setup_mbhc(struct pm8916_wcd_analog_priv *wcd)
 
 	pm8916_mbhc_configure_bias(wcd, micbias_enabled);
 
-	int_en_mask = MBHC_SWITCH_INT;
+	if (!wcd->jack_gpio.report)
+		int_en_mask |= MBHC_SWITCH_INT;
 	if (wcd->mbhc_btn_enabled)
 		int_en_mask |= MBHC_BUTTON_PRESS_DET | MBHC_BUTTON_RELEASE_DET;
 
@@ -979,6 +982,22 @@ static int pm8916_wcd_analog_set_jack(struct snd_soc_component *component,
 {
 	struct pm8916_wcd_analog_priv *wcd = snd_soc_component_get_drvdata(component);
 
+	if (wcd->jack_gpio.report && wcd->jack != jack) {
+		int ret;
+
+		if (wcd->jack)
+			snd_soc_jack_free_gpios(wcd->jack, 1, &wcd->jack_gpio);
+
+		if (jack) {
+			ret = snd_soc_jack_add_gpiods(component->dev, jack,
+						      1, &wcd->jack_gpio);
+			if (ret)
+				dev_err(component->dev,
+					"Failed to add GPIO to jack: %d\n",
+					ret);
+		}
+	}
+
 	wcd->jack = jack;
 
 	return 0;
@@ -1040,15 +1059,10 @@ static irqreturn_t mbhc_btn_press_irq_handler(int irq, void *arg)
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t pm8916_mbhc_switch_irq_handler(int irq, void *arg)
+static int pm8916_wcd_analog_switch_check(struct pm8916_wcd_analog_priv *priv, bool ins)
 {
-	struct pm8916_wcd_analog_priv *priv = arg;
 	struct snd_soc_component *component = priv->component;
-	bool ins = false;
-
-	if (snd_soc_component_read(component, CDC_A_MBHC_DET_CTL_1) &
-				CDC_A_MBHC_DET_CTL_MECH_DET_TYPE_MASK)
-		ins = true;
+	int report;
 
 	/* Set the detection type appropriately */
 	snd_soc_component_update_bits(component, CDC_A_MBHC_DET_CTL_1,
@@ -1072,23 +1086,46 @@ static irqreturn_t pm8916_mbhc_switch_irq_handler(int irq, void *arg)
 		 * a headset.
 		 */
 		if (priv->mbhc_btn0_released)
-			snd_soc_jack_report(priv->jack,
-					    SND_JACK_HEADSET, hs_jack_mask);
+			report = SND_JACK_HEADSET;
 		else
-			snd_soc_jack_report(priv->jack,
-					    SND_JACK_HEADPHONE, hs_jack_mask);
+			report = SND_JACK_HEADPHONE;
 
 		priv->detect_accessory_type = false;
 
 	} else { /* removal */
-		snd_soc_jack_report(priv->jack, 0, hs_jack_mask);
+		report = 0;
 		priv->detect_accessory_type = true;
 		priv->mbhc_btn0_released = false;
 	}
 
+	return report;
+}
+
+static irqreturn_t pm8916_mbhc_switch_irq_handler(int irq, void *arg)
+{
+	struct pm8916_wcd_analog_priv *priv = arg;
+	struct snd_soc_component *component = priv->component;
+	bool ins = false;
+	int report;
+
+	if (snd_soc_component_read(component, CDC_A_MBHC_DET_CTL_1) &
+				CDC_A_MBHC_DET_CTL_MECH_DET_TYPE_MASK)
+		ins = true;
+
+	report = pm8916_wcd_analog_switch_check(priv, ins);
+	snd_soc_jack_report(priv->jack, report, hs_jack_mask);
+
 	return IRQ_HANDLED;
 }
 
+static int pm8916_wcd_analog_jack_status_check(void *data)
+{
+	struct pm8916_wcd_analog_priv *wcd = data;
+	bool ins = gpiod_get_value_cansleep(wcd->jack_gpio.desc);
+
+	return pm8916_wcd_analog_switch_check(wcd, ins);
+}
+
 static struct snd_soc_dai_driver pm8916_wcd_analog_dai[] = {
 	[0] = {
 	       .name = "pm8916_wcd_analog_pdm_rx",
@@ -1207,18 +1244,27 @@ static int pm8916_wcd_analog_spmi_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	irq = platform_get_irq_byname(pdev, "mbhc_switch_int");
-	if (irq < 0)
-		return irq;
+	if (gpiod_count(dev, "jack") > 0) {
+		priv->jack_gpio.name = "jack";
+		priv->jack_gpio.report = hs_jack_mask;
+		priv->jack_gpio.debounce_time = 100;
+		priv->jack_gpio.jack_status_check =
+			pm8916_wcd_analog_jack_status_check;
+		priv->jack_gpio.data = priv;
+	} else {
+		irq = platform_get_irq_byname(pdev, "mbhc_switch_int");
+		if (irq < 0)
+			return irq;
 
-	ret = devm_request_threaded_irq(dev, irq, NULL,
-			       pm8916_mbhc_switch_irq_handler,
-			       IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |
-			       IRQF_ONESHOT,
-			       "mbhc switch irq", priv);
-	if (ret) {
-		dev_err(dev, "cannot request mbhc switch irq\n");
-		return ret;
+		ret = devm_request_threaded_irq(dev, irq, NULL,
+				       pm8916_mbhc_switch_irq_handler,
+				       IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |
+				       IRQF_ONESHOT,
+				       "mbhc switch irq", priv);
+		if (ret) {
+			dev_err(dev, "cannot request mbhc switch irq\n");
+			return ret;
+		}
 	}
 
 	if (priv->mbhc_btn_enabled) {
diff --git a/sound/soc/qcom/Kconfig b/sound/soc/qcom/Kconfig
index ca7a30ebd26a..28fb7fce6bcf 100644
--- a/sound/soc/qcom/Kconfig
+++ b/sound/soc/qcom/Kconfig
@@ -140,6 +140,14 @@ config SND_SOC_QDSP6
 	 audio drivers. This includes q6asm, q6adm,
 	 q6afe interfaces to DSP using apr.
 
+config SND_SOC_QDSP6_Q6VOICE_DAI
+	tristate
+
+config SND_SOC_QDSP6_Q6VOICE
+	tristate "QDSP6 Q6Voice audio driver"
+	depends on SND_SOC_QDSP6
+	select SND_SOC_QDSP6_Q6VOICE_DAI
+
 config SND_SOC_MSM8996
 	tristate "SoC Machine driver for MSM8996 and APQ8096 boards"
 	depends on QCOM_APR
diff --git a/sound/soc/qcom/qdsp6/Makefile b/sound/soc/qcom/qdsp6/Makefile
index 26b7c55c9c11..473266a98716 100644
--- a/sound/soc/qcom/qdsp6/Makefile
+++ b/sound/soc/qcom/qdsp6/Makefile
@@ -11,6 +11,9 @@ obj-$(CONFIG_SND_SOC_QDSP6_ADM) += q6adm.o
 obj-$(CONFIG_SND_SOC_QDSP6_ROUTING) += q6routing.o
 obj-$(CONFIG_SND_SOC_QDSP6_ASM) += q6asm.o
 obj-$(CONFIG_SND_SOC_QDSP6_ASM_DAI) += q6asm-dai.o
+obj-$(CONFIG_SND_SOC_QDSP6_Q6VOICE) += q6cvp.o q6cvs.o q6mvm.o q6voice-common.o
+obj-$(CONFIG_SND_SOC_QDSP6_Q6VOICE) += q6voice.o
+obj-$(CONFIG_SND_SOC_QDSP6_Q6VOICE_DAI) += q6voice-dai.o
 
 obj-$(CONFIG_SND_SOC_QDSP6_APM) += snd-q6apm.o
 obj-$(CONFIG_SND_SOC_QDSP6_APM_DAI) += q6apm-dai.o
diff --git a/sound/soc/qcom/qdsp6/q6cvp.c b/sound/soc/qcom/qdsp6/q6cvp.c
new file mode 100644
index 000000000000..3549d3f14c91
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6cvp.c
@@ -0,0 +1,153 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2012-2017, The Linux Foundation. All rights reserved.
+// Copyright (c) 2020, Stephan Gerhold
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/soc/qcom/apr.h>
+#include "q6cvp.h"
+#include "q6voice-common.h"
+
+#define VSS_IVOCPROC_DIRECTION_RX	0
+#define VSS_IVOCPROC_DIRECTION_TX	1
+#define VSS_IVOCPROC_DIRECTION_RX_TX	2
+
+#define VSS_IVOCPROC_PORT_ID_NONE	0xFFFF
+
+#define VSS_IVOCPROC_TOPOLOGY_ID_NONE			0x00010F70
+#define VSS_IVOCPROC_TOPOLOGY_ID_TX_SM_ECNS		0x00010F71
+#define VSS_IVOCPROC_TOPOLOGY_ID_TX_DM_FLUENCE		0x00010F72
+
+#define VSS_IVOCPROC_TOPOLOGY_ID_RX_DEFAULT		0x00010F77
+
+#define VSS_IVOCPROC_VOCPROC_MODE_EC_INT_MIXING		0x00010F7C
+#define VSS_IVOCPROC_VOCPROC_MODE_EC_EXT_MIXING		0x00010F7D
+
+#define VSS_ICOMMON_CAL_NETWORK_ID_NONE			0x0001135E
+
+#define VSS_IVOCPROC_CMD_ENABLE				0x000100C6
+#define VSS_IVOCPROC_CMD_DISABLE			0x000110E1
+
+#define VSS_IVOCPROC_CMD_CREATE_FULL_CONTROL_SESSION_V2	0x000112BF
+
+struct vss_ivocproc_cmd_create_full_control_session_v2_cmd {
+	struct apr_hdr hdr;
+
+	/*
+	 * Vocproc direction. The supported values:
+	 * VSS_IVOCPROC_DIRECTION_RX
+	 * VSS_IVOCPROC_DIRECTION_TX
+	 * VSS_IVOCPROC_DIRECTION_RX_TX
+	 */
+	u16 direction;
+
+	/*
+	 * Tx device port ID to which the vocproc connects. If a port ID is
+	 * not being supplied, set this to #VSS_IVOCPROC_PORT_ID_NONE.
+	 */
+	u16 tx_port_id;
+
+	/*
+	 * Tx path topology ID. If a topology ID is not being supplied, set
+	 * this to #VSS_IVOCPROC_TOPOLOGY_ID_NONE.
+	 */
+	u32 tx_topology_id;
+
+	/*
+	 * Rx device port ID to which the vocproc connects. If a port ID is
+	 * not being supplied, set this to #VSS_IVOCPROC_PORT_ID_NONE.
+	 */
+	u16 rx_port_id;
+
+	/*
+	 * Rx path topology ID. If a topology ID is not being supplied, set
+	 * this to #VSS_IVOCPROC_TOPOLOGY_ID_NONE.
+	 */
+	u32 rx_topology_id;
+
+	/* Voice calibration profile ID. */
+	u32 profile_id;
+
+	/*
+	 * Vocproc mode. The supported values:
+	 * VSS_IVOCPROC_VOCPROC_MODE_EC_INT_MIXING
+	 * VSS_IVOCPROC_VOCPROC_MODE_EC_EXT_MIXING
+	 */
+	u32 vocproc_mode;
+
+	/*
+	 * Port ID to which the vocproc connects for receiving echo
+	 * cancellation reference signal. If a port ID is not being supplied,
+	 * set this to #VSS_IVOCPROC_PORT_ID_NONE. This parameter value is
+	 * ignored when the vocproc_mode parameter is set to
+	 * VSS_IVOCPROC_VOCPROC_MODE_EC_INT_MIXING.
+	 */
+	u16 ec_ref_port_id;
+
+	/*
+	 * Session name string used to identify a session that can be shared
+	 * with passive controllers (optional).
+	 */
+	char name[20];
+} __packed;
+
+struct q6voice_session *q6cvp_session_create(enum q6voice_path_type path,
+					     u16 tx_port, u16 rx_port)
+{
+	struct vss_ivocproc_cmd_create_full_control_session_v2_cmd cmd;
+
+	cmd.hdr.pkt_size = sizeof(cmd);
+	cmd.hdr.opcode = VSS_IVOCPROC_CMD_CREATE_FULL_CONTROL_SESSION_V2;
+
+	/* TODO: Implement calibration */
+	cmd.tx_topology_id = VSS_IVOCPROC_TOPOLOGY_ID_TX_SM_ECNS;
+	cmd.rx_topology_id = VSS_IVOCPROC_TOPOLOGY_ID_RX_DEFAULT;
+
+	cmd.direction = VSS_IVOCPROC_DIRECTION_RX_TX;
+	cmd.tx_port_id = tx_port;
+	cmd.rx_port_id = rx_port;
+	cmd.profile_id = VSS_ICOMMON_CAL_NETWORK_ID_NONE;
+	cmd.vocproc_mode = VSS_IVOCPROC_VOCPROC_MODE_EC_INT_MIXING;
+	cmd.ec_ref_port_id = VSS_IVOCPROC_PORT_ID_NONE;
+
+	return q6voice_session_create(Q6VOICE_SERVICE_CVP, path, &cmd.hdr);
+}
+EXPORT_SYMBOL_GPL(q6cvp_session_create);
+
+int q6cvp_enable(struct q6voice_session *cvp, bool state)
+{
+	struct apr_pkt cmd;
+
+	cmd.hdr.pkt_size = APR_HDR_SIZE;
+	cmd.hdr.opcode = state ? VSS_IVOCPROC_CMD_ENABLE : VSS_IVOCPROC_CMD_DISABLE;
+
+	return q6voice_common_send(cvp, &cmd.hdr);
+}
+EXPORT_SYMBOL_GPL(q6cvp_enable);
+
+static int q6cvp_probe(struct apr_device *adev)
+{
+	return q6voice_common_probe(adev, Q6VOICE_SERVICE_CVP);
+}
+
+static const struct of_device_id q6cvp_device_id[]  = {
+	{ .compatible = "qcom,q6cvp" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, q6cvp_device_id);
+
+static struct apr_driver qcom_q6cvp_driver = {
+	.probe = q6cvp_probe,
+	.remove = q6voice_common_remove,
+	.callback = q6voice_common_callback,
+	.driver = {
+		.name = "qcom-q6cvp",
+		.of_match_table = of_match_ptr(q6cvp_device_id),
+	},
+};
+
+module_apr_driver(qcom_q6cvp_driver);
+
+MODULE_AUTHOR("Stephan Gerhold <stephan@gerhold.net>");
+MODULE_DESCRIPTION("Q6 Core Voice Processor");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/qcom/qdsp6/q6cvp.h b/sound/soc/qcom/qdsp6/q6cvp.h
new file mode 100644
index 000000000000..2381a3cfe078
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6cvp.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _Q6_CVP_H
+#define _Q6_CVP_H
+
+#include "q6voice.h"
+
+struct q6voice_session;
+
+struct q6voice_session *q6cvp_session_create(enum q6voice_path_type path,
+					     u16 tx_port, u16 rx_port);
+int q6cvp_enable(struct q6voice_session *cvp, bool enable);
+
+#endif /*_Q6_CVP_H */
diff --git a/sound/soc/qcom/qdsp6/q6cvs.c b/sound/soc/qcom/qdsp6/q6cvs.c
new file mode 100644
index 000000000000..440715870a04
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6cvs.c
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2012-2017, The Linux Foundation. All rights reserved.
+// Copyright (c) 2020, Stephan Gerhold
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/soc/qcom/apr.h>
+#include "q6cvs.h"
+#include "q6voice-common.h"
+
+static int q6cvs_probe(struct apr_device *adev)
+{
+	return q6voice_common_probe(adev, Q6VOICE_SERVICE_CVS);
+}
+
+static const struct of_device_id q6cvs_device_id[]  = {
+	{ .compatible = "qcom,q6cvs" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, q6cvs_device_id);
+
+static struct apr_driver qcom_q6cvs_driver = {
+	.probe = q6cvs_probe,
+	.remove = q6voice_common_remove,
+	.callback = q6voice_common_callback,
+	.driver = {
+		.name = "qcom-q6cvs",
+		.of_match_table = of_match_ptr(q6cvs_device_id),
+	},
+};
+
+module_apr_driver(qcom_q6cvs_driver);
+
+MODULE_AUTHOR("Stephan Gerhold <stephan@gerhold.net>");
+MODULE_DESCRIPTION("Q6 Core Voice Stream");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/qcom/qdsp6/q6cvs.h b/sound/soc/qcom/qdsp6/q6cvs.h
new file mode 100644
index 000000000000..5c204682c764
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6cvs.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _Q6_CVS_H
+#define _Q6_CVS_H
+
+#include "q6voice.h"
+
+struct q6voice_session;
+
+#endif /*_Q6_CVS_H */
diff --git a/sound/soc/qcom/qdsp6/q6mvm.c b/sound/soc/qcom/qdsp6/q6mvm.c
new file mode 100644
index 000000000000..f1f8d520ba0d
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6mvm.c
@@ -0,0 +1,160 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2012-2017, The Linux Foundation. All rights reserved.
+// Copyright (c) 2020, Stephan Gerhold
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/soc/qcom/apr.h>
+#include "q6mvm.h"
+#include "q6voice-common.h"
+
+#define VSS_IMVM_CMD_CREATE_PASSIVE_CONTROL_SESSION	0x000110FF
+
+struct vss_imvm_cmd_create_control_session_cmd {
+	struct apr_hdr hdr;
+
+	/* A variable-sized stream name. */
+	char name[20];
+} __packed;
+
+#define VSS_IMVM_CMD_SET_POLICY_DUAL_CONTROL		0x00011327
+
+/* This command is required to let MVM know who is in control of session. */
+struct vss_imvm_cmd_set_policy_dual_control_cmd {
+	struct apr_hdr hdr;
+
+	/* Set to TRUE to enable modem state machine control */
+	bool enable;
+} __packed;
+
+#define VSS_IMVM_CMD_ATTACH_VOCPROC			0x0001123E
+#define VSS_IMVM_CMD_DETACH_VOCPROC			0x0001123F
+
+/*
+ * Attach/detach a vocproc to the MVM.
+ * The MVM will symmetrically connect/disconnect this vocproc
+ * to/from all the streams currently attached to it.
+ */
+struct vss_imvm_cmd_attach_vocproc_cmd {
+	struct apr_hdr hdr;
+
+	/* Handle of vocproc being attached. */
+	u16 handle;
+} __packed;
+
+#define VSS_IMVM_CMD_START_VOICE			0x00011190
+#define VSS_IMVM_CMD_STOP_VOICE				0x00011192
+
+static inline const char *q6mvm_session_name(enum q6voice_path_type path)
+{
+	switch (path) {
+	case Q6VOICE_PATH_VOICE:
+		return "default modem voice";
+	default:
+		return NULL;
+	}
+}
+
+static int q6mvm_set_dual_control(struct q6voice_session *mvm)
+{
+	struct vss_imvm_cmd_set_policy_dual_control_cmd cmd;
+
+	cmd.hdr.pkt_size = sizeof(cmd);
+	cmd.hdr.opcode = VSS_IMVM_CMD_SET_POLICY_DUAL_CONTROL;
+
+	cmd.enable = true;
+
+	return q6voice_common_send(mvm, &cmd.hdr);
+}
+
+struct q6voice_session *q6mvm_session_create(enum q6voice_path_type path)
+{
+	struct vss_imvm_cmd_create_control_session_cmd cmd;
+	struct q6voice_session *mvm;
+	const char *session_name;
+	int ret;
+
+	cmd.hdr.pkt_size = sizeof(cmd);
+	cmd.hdr.opcode = VSS_IMVM_CMD_CREATE_PASSIVE_CONTROL_SESSION;
+
+	session_name = q6mvm_session_name(path);
+	if (session_name)
+		strscpy(cmd.name, session_name, sizeof(cmd.name));
+
+	mvm = q6voice_session_create(Q6VOICE_SERVICE_MVM, path, &cmd.hdr);
+	if (IS_ERR(mvm))
+		return mvm;
+
+	ret = q6mvm_set_dual_control(mvm);
+	if (ret) {
+		dev_err(mvm->dev, "failed to set dual control: %d\n", ret);
+		q6voice_session_release(mvm);
+		return ERR_PTR(ret);
+	}
+
+	return mvm;
+}
+EXPORT_SYMBOL_GPL(q6mvm_session_create);
+
+int q6mvm_attach(struct q6voice_session *mvm, struct q6voice_session *cvp,
+		 bool state)
+{
+	struct vss_imvm_cmd_attach_vocproc_cmd cmd;
+
+	cmd.hdr.pkt_size = sizeof(cmd);
+	cmd.hdr.opcode = state ? VSS_IMVM_CMD_ATTACH_VOCPROC : VSS_IMVM_CMD_DETACH_VOCPROC;
+
+	cmd.handle = cvp->handle;
+
+	return q6voice_common_send(mvm, &cmd.hdr);
+}
+EXPORT_SYMBOL_GPL(q6mvm_attach);
+
+int q6mvm_start(struct q6voice_session *mvm, bool state)
+{
+	struct apr_pkt cmd;
+
+	cmd.hdr.pkt_size = APR_HDR_SIZE;
+	cmd.hdr.opcode = state ? VSS_IMVM_CMD_START_VOICE : VSS_IMVM_CMD_STOP_VOICE;
+
+	return q6voice_common_send(mvm, &cmd.hdr);
+}
+EXPORT_SYMBOL_GPL(q6mvm_start);
+
+static int q6mvm_probe(struct apr_device *adev)
+{
+	int ret;
+
+	ret = q6voice_common_probe(adev, Q6VOICE_SERVICE_MVM);
+	if (ret)
+		return ret;
+
+	return of_platform_populate(adev->dev.of_node, NULL, NULL, &adev->dev);
+}
+
+static void q6mvm_remove(struct apr_device *adev)
+{
+	of_platform_depopulate(&adev->dev);
+	q6voice_common_remove(adev);
+}
+
+static const struct of_device_id q6mvm_device_id[]  = {
+	{ .compatible = "qcom,q6mvm" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, q6mvm_device_id);
+
+static struct apr_driver qcom_q6mvm_driver = {
+	.probe = q6mvm_probe,
+	.remove = q6mvm_remove,
+	.callback = q6voice_common_callback,
+	.driver = {
+		.name = "qcom-q6mvm",
+		.of_match_table = of_match_ptr(q6mvm_device_id),
+	},
+};
+
+module_apr_driver(qcom_q6mvm_driver);
+MODULE_DESCRIPTION("Q6 Multimode Voice Manager");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/qcom/qdsp6/q6mvm.h b/sound/soc/qcom/qdsp6/q6mvm.h
new file mode 100644
index 000000000000..51279eddb89b
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6mvm.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _Q6_MVM_H
+#define _Q6_MVM_H
+
+#include "q6voice.h"
+
+struct q6voice_session;
+
+struct q6voice_session *q6mvm_session_create(enum q6voice_path_type path);
+
+int q6mvm_attach(struct q6voice_session *mvm, struct q6voice_session *cvp,
+		 bool state);
+int q6mvm_start(struct q6voice_session *mvm, bool state);
+
+#endif /*_Q6_MVM_H */
diff --git a/sound/soc/qcom/qdsp6/q6voice-common.c b/sound/soc/qcom/qdsp6/q6voice-common.c
new file mode 100644
index 000000000000..f821d619e16a
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6voice-common.c
@@ -0,0 +1,272 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2020, Stephan Gerhold
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/soc/qcom/apr.h>
+#include "q6voice-common.h"
+
+#define APRV2_IBASIC_CMD_DESTROY_SESSION	0x0001003C
+
+#define TIMEOUT_MS	300
+
+struct q6voice_service {
+	struct apr_device *adev;
+	enum q6voice_service_type type;
+
+	/* Protect sessions array */
+	spinlock_t lock;
+	struct q6voice_session *sessions[Q6VOICE_PATH_COUNT];
+};
+
+/* Protect q6voice_services */
+static DEFINE_SPINLOCK(q6voice_services_lock);
+static struct q6voice_service *q6voice_services[Q6VOICE_SERVICE_COUNT] = {0};
+
+int q6voice_common_probe(struct apr_device *adev, enum q6voice_service_type type)
+{
+	struct device *dev = &adev->dev;
+	struct q6voice_service *svc, *current_svc;
+	unsigned long flags;
+
+	if (type >= Q6VOICE_SERVICE_COUNT)
+		return -EINVAL;
+
+	svc = devm_kzalloc(dev, sizeof(*svc), GFP_KERNEL);
+	if (!svc)
+		return -ENOMEM;
+
+	svc->adev = adev;
+	svc->type = type;
+	spin_lock_init(&svc->lock);
+
+	dev_set_drvdata(dev, svc);
+
+	spin_lock_irqsave(&q6voice_services_lock, flags);
+	current_svc = q6voice_services[type];
+	if (!current_svc)
+		q6voice_services[type] = svc;
+	spin_unlock_irqrestore(&q6voice_services_lock, flags);
+
+	return current_svc ? -EEXIST : 0;
+}
+EXPORT_SYMBOL_GPL(q6voice_common_probe);
+
+void q6voice_common_remove(struct apr_device *adev)
+{
+	struct q6voice_service *svc = dev_get_drvdata(&adev->dev);
+	enum q6voice_service_type type = svc->type;
+	unsigned long flags;
+
+	spin_lock_irqsave(&q6voice_services_lock, flags);
+	if (q6voice_services[type] == svc)
+		q6voice_services[type] = NULL;
+	spin_unlock_irqrestore(&q6voice_services_lock, flags);
+
+	/* TODO: Should probably free up sessions here??? */
+}
+EXPORT_SYMBOL_GPL(q6voice_common_remove);
+
+static void q6voice_session_free(struct kref *ref)
+{
+	struct q6voice_session *s = container_of(ref, struct q6voice_session,
+						 refcount);
+
+	kfree(s);
+}
+
+static int q6voice_session_destroy(struct q6voice_session *s)
+{
+	struct apr_pkt cmd;
+
+	cmd.hdr.pkt_size = APR_HDR_SIZE;
+	cmd.hdr.opcode = APRV2_IBASIC_CMD_DESTROY_SESSION;
+
+	return q6voice_common_send(s, &cmd.hdr);
+}
+
+void q6voice_session_release(struct q6voice_session *s)
+{
+	struct q6voice_service *svc = s->svc;
+	unsigned long flags;
+
+	if (s->handle)
+		q6voice_session_destroy(s);
+
+	spin_lock_irqsave(&svc->lock, flags);
+	if (svc->sessions[s->port] == s)
+		svc->sessions[s->port] = NULL;
+	spin_unlock_irqrestore(&svc->lock, flags);
+
+	kref_put(&s->refcount, q6voice_session_free);
+}
+EXPORT_SYMBOL_GPL(q6voice_session_release);
+
+struct q6voice_session *
+q6voice_session_create(enum q6voice_service_type type,
+		       enum q6voice_path_type path, struct apr_hdr *hdr)
+{
+	struct q6voice_service *svc;
+	struct q6voice_session *s;
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&q6voice_services_lock, flags);
+	svc = q6voice_services[type];
+	spin_unlock_irqrestore(&q6voice_services_lock, flags);
+	if (!svc)
+		return ERR_PTR(-ENODEV);
+
+	s = kzalloc(sizeof(*s), GFP_KERNEL);
+	if (!s)
+		return ERR_PTR(-ENOMEM);
+
+	s->dev = &svc->adev->dev;
+	s->svc = svc;
+	s->port = path;
+
+	kref_init(&s->refcount);
+	spin_lock_init(&s->lock);
+	init_waitqueue_head(&s->wait);
+
+	spin_lock_irqsave(&svc->lock, flags);
+	if (svc->sessions[path]) {
+		spin_unlock_irqrestore(&svc->lock, flags);
+		kfree(s);
+		return ERR_PTR(-EBUSY);
+	}
+	svc->sessions[path] = s;
+	spin_unlock_irqrestore(&svc->lock, flags);
+
+	dev_dbg(s->dev, "create session\n");
+
+	ret = q6voice_common_send(s, hdr);
+	if (ret)
+		goto err;
+
+	if (!s->handle) {
+		dev_warn(s->dev, "failed to receive handle\n");
+		ret = -EIO;
+		goto err;
+	}
+
+	dev_dbg(s->dev, "handle: %d\n", s->handle);
+
+	return s;
+
+err:
+	q6voice_session_release(s);
+	return ERR_PTR(ret);
+}
+EXPORT_SYMBOL_GPL(q6voice_session_create);
+
+static void q6voice_session_callback(struct q6voice_session *s,
+				     struct apr_resp_pkt *data)
+{
+	struct aprv2_ibasic_rsp_result_t *result = data->payload;
+	unsigned long flags;
+
+	if (data->hdr.opcode != APR_BASIC_RSP_RESULT)
+		return; /* Not handled here */
+
+	dev_dbg(s->dev, "basic result: opcode %#x, status: %#x\n",
+		result->opcode, result->status);
+
+	spin_lock_irqsave(&s->lock, flags);
+	if (result->opcode != s->expected_opcode) {
+		spin_unlock_irqrestore(&s->lock, flags);
+		dev_warn(s->dev, "unexpected reply for opcode %#x (status: %#x)\n",
+			 result->opcode, result->status);
+		return;
+	}
+
+	if (!s->handle) {
+		s->handle = data->hdr.src_port;
+	} else if (s->handle != data->hdr.src_port) {
+		spin_unlock_irqrestore(&s->lock, flags);
+		dev_warn(s->dev, "unexpected reply for session %#x (!= %#x)\n",
+			 data->hdr.src_port, s->handle);
+		return;
+	}
+
+	s->result = result->status;
+	s->expected_opcode = 0;
+	spin_unlock_irqrestore(&s->lock, flags);
+
+	wake_up(&s->wait);
+}
+
+int q6voice_common_callback(struct apr_device *adev, struct apr_resp_pkt *data)
+{
+	struct device *dev = &adev->dev;
+	struct q6voice_service *v = dev_get_drvdata(dev);
+	struct q6voice_session *s;
+	unsigned long flags;
+
+	dev_dbg(dev, "callback: %#x\n", data->hdr.opcode);
+
+	if (data->hdr.dest_port >= Q6VOICE_PATH_COUNT) {
+		dev_warn(dev, "callback() called for unhandled/invalid path: %d\n",
+			 data->hdr.dest_port);
+		return 0;
+	}
+
+	spin_lock_irqsave(&v->lock, flags);
+	s = v->sessions[data->hdr.dest_port];
+	if (s)
+		kref_get(&s->refcount);
+	spin_unlock_irqrestore(&v->lock, flags);
+
+	if (s) {
+		q6voice_session_callback(s, data);
+		kref_put(&s->refcount, q6voice_session_free);
+	} else {
+		dev_warn(dev, "callback() called for inactive path: %d\n",
+			 data->hdr.dest_port);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(q6voice_common_callback);
+
+int q6voice_common_send(struct q6voice_session *s, struct apr_hdr *hdr)
+{
+	unsigned long flags;
+	int ret;
+
+	hdr->hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
+				       APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
+	hdr->src_port = s->port;
+	hdr->dest_port = s->handle;
+	hdr->token = 0;
+
+	spin_lock_irqsave(&s->lock, flags);
+	s->expected_opcode = hdr->opcode;
+	s->result = 0;
+	spin_unlock_irqrestore(&s->lock, flags);
+
+	ret = apr_send_pkt(s->svc->adev, (struct apr_pkt *)hdr);
+	if (ret < 0)
+		return ret;
+
+	ret = wait_event_timeout(s->wait, (s->expected_opcode == 0),
+				 msecs_to_jiffies(TIMEOUT_MS));
+	if (!ret) {
+		s->expected_opcode = 0;
+		return -ETIMEDOUT;
+	}
+
+	if (s->result > 0) {
+		dev_err(s->dev, "command %#x failed with error %d\n",
+			hdr->opcode, s->result);
+		return -EIO;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(q6voice_common_send);
+
+MODULE_AUTHOR("Stephan Gerhold <stephan@gerhold.net>");
+MODULE_DESCRIPTION("Q6Voice common session management");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/qcom/qdsp6/q6voice-common.h b/sound/soc/qcom/qdsp6/q6voice-common.h
new file mode 100644
index 000000000000..6fb3c9560b2e
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6voice-common.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _Q6_VOICE_COMMON_H
+#define _Q6_VOICE_COMMON_H
+
+#include <linux/soc/qcom/apr.h>
+#include "q6voice.h"
+
+enum q6voice_service_type {
+	Q6VOICE_SERVICE_MVM,
+	Q6VOICE_SERVICE_CVP,
+	Q6VOICE_SERVICE_CVS,
+	Q6VOICE_SERVICE_COUNT
+};
+
+struct q6voice_service;
+
+struct q6voice_session {
+	struct device *dev;
+	struct q6voice_service *svc;
+	struct kref refcount;
+
+	u16 port;
+	u16 handle;
+
+	wait_queue_head_t wait;
+
+	/* Protect expected_opcode and result */
+	spinlock_t lock;
+	u32 expected_opcode;
+	u32 result;
+};
+
+int q6voice_common_probe(struct apr_device *adev, enum q6voice_service_type type);
+void q6voice_common_remove(struct apr_device *adev);
+
+int q6voice_common_callback(struct apr_device *adev, struct apr_resp_pkt *data);
+int q6voice_common_send(struct q6voice_session *s, struct apr_hdr *hdr);
+
+struct q6voice_session *q6voice_session_create(enum q6voice_service_type type,
+					       enum q6voice_path_type path,
+					       struct apr_hdr *hdr);
+void q6voice_session_release(struct q6voice_session *s);
+
+#endif /*_Q6_VOICE_COMMON_H */
diff --git a/sound/soc/qcom/qdsp6/q6voice-dai.c b/sound/soc/qcom/qdsp6/q6voice-dai.c
new file mode 100644
index 000000000000..f3ae9d75f82b
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6voice-dai.c
@@ -0,0 +1,256 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2012-2017, The Linux Foundation. All rights reserved.
+// Copyright (c) 2020, Stephan Gerhold
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <sound/soc.h>
+#include <dt-bindings/sound/qcom,q6afe.h>
+#include <dt-bindings/sound/qcom,q6voice.h>
+#include "q6voice.h"
+
+#define DRV_NAME	"q6voice-dai"
+
+static int q6voice_dai_startup(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	struct q6voice *v = snd_soc_dai_get_drvdata(dai);
+
+	return q6voice_start(v, Q6VOICE_PATH_VOICE, substream->stream);
+}
+
+static void q6voice_dai_shutdown(struct snd_pcm_substream *substream,
+				 struct snd_soc_dai *dai)
+{
+	struct q6voice *v = snd_soc_dai_get_drvdata(dai);
+
+	q6voice_stop(v, Q6VOICE_PATH_VOICE, substream->stream);
+}
+
+static struct snd_soc_dai_ops q6voice_dai_ops = {
+	.startup = q6voice_dai_startup,
+	.shutdown = q6voice_dai_shutdown,
+};
+
+static struct snd_soc_dai_driver q6voice_dais[] = {
+	{
+		.id = CS_VOICE,
+		.name = "CS-VOICE",
+		/* The constraints here are not really meaningful... */
+		.playback = {
+			.stream_name =	"CS-VOICE Playback",
+			.formats =	SNDRV_PCM_FMTBIT_S16_LE,
+			.rates =	SNDRV_PCM_RATE_8000,
+			.rate_min =	8000,
+			.rate_max =	8000,
+			.channels_min =	1,
+			.channels_max =	1,
+		},
+		.capture = {
+			.stream_name =	"CS-VOICE Capture",
+			.formats =	SNDRV_PCM_FMTBIT_S16_LE,
+			.rates =	SNDRV_PCM_RATE_8000,
+			.rate_min =	8000,
+			.rate_max =	8000,
+			.channels_min =	1,
+			.channels_max =	1,
+		},
+		.ops = &q6voice_dai_ops,
+	},
+};
+
+/* FIXME: Use codec2codec instead */
+static struct snd_pcm_hardware q6voice_dai_hardware = {
+	.info =			SNDRV_PCM_INFO_INTERLEAVED,
+	.buffer_bytes_max =	4096 * 2,
+	.period_bytes_min =	2048,
+	.period_bytes_max =	4096,
+	.periods_min =		2,
+	.periods_max =		4,
+	.fifo_size =		0,
+};
+
+static int q6voice_dai_open(struct snd_soc_component *component,
+			    struct snd_pcm_substream *substream)
+{
+	substream->runtime->hw = q6voice_dai_hardware;
+	return 0;
+}
+
+static int q6voice_get_mixer(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);
+	struct snd_soc_component *c = snd_soc_dapm_to_component(dapm);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct q6voice *v = snd_soc_component_get_drvdata(c);
+	bool capture = !!mc->shift;
+
+	ucontrol->value.integer.value[0] =
+		q6voice_get_port(v, Q6VOICE_PATH_VOICE, capture) == mc->reg;
+	return 0;
+}
+
+static int q6voice_put_mixer(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);
+	struct snd_soc_component *c = snd_soc_dapm_to_component(dapm);
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct q6voice *v = snd_soc_component_get_drvdata(c);
+	bool val = !!ucontrol->value.integer.value[0];
+	bool capture = !!mc->shift;
+
+	if (val)
+		q6voice_set_port(v, Q6VOICE_PATH_VOICE, capture, mc->reg);
+	else if (q6voice_get_port(v, Q6VOICE_PATH_VOICE, capture) == mc->reg)
+		q6voice_set_port(v, Q6VOICE_PATH_VOICE, capture, 0);
+
+	snd_soc_dapm_mixer_update_power(dapm, kcontrol, val, NULL);
+	return 1;
+}
+
+static const struct snd_kcontrol_new voice_tx_mixer_controls[] = {
+	SOC_SINGLE_EXT("PRI_MI2S_TX", PRIMARY_MI2S_TX, 1, 1, 0,
+		       q6voice_get_mixer, q6voice_put_mixer),
+	SOC_SINGLE_EXT("SEC_MI2S_TX", SECONDARY_MI2S_TX, 1, 1, 0,
+		       q6voice_get_mixer, q6voice_put_mixer),
+	SOC_SINGLE_EXT("TERT_MI2S_TX", TERTIARY_MI2S_TX, 1, 1, 0,
+		       q6voice_get_mixer, q6voice_put_mixer),
+	SOC_SINGLE_EXT("QUAT_MI2S_TX", QUATERNARY_MI2S_TX, 1, 1, 0,
+		       q6voice_get_mixer, q6voice_put_mixer),
+	SOC_SINGLE_EXT("QUIN_MI2S_TX", QUINARY_MI2S_TX, 1, 1, 0,
+		       q6voice_get_mixer, q6voice_put_mixer),
+};
+
+static const struct snd_kcontrol_new primary_mi2s_rx_mixer_controls[] = {
+	SOC_SINGLE_EXT("CS-Voice", PRIMARY_MI2S_RX, 0, 1, 0,
+		       q6voice_get_mixer, q6voice_put_mixer)
+};
+
+static const struct snd_kcontrol_new secondary_mi2s_rx_mixer_controls[] = {
+	SOC_SINGLE_EXT("CS-Voice", SECONDARY_MI2S_RX, 0, 1, 0,
+		       q6voice_get_mixer, q6voice_put_mixer)
+};
+
+static const struct snd_kcontrol_new tertiary_mi2s_rx_mixer_controls[] = {
+	SOC_SINGLE_EXT("CS-Voice", TERTIARY_MI2S_RX, 0, 1, 0,
+		       q6voice_get_mixer, q6voice_put_mixer)
+};
+
+static const struct snd_kcontrol_new quaternary_mi2s_rx_mixer_controls[] = {
+	SOC_SINGLE_EXT("CS-Voice", QUATERNARY_MI2S_RX, 0, 1, 0,
+		       q6voice_get_mixer, q6voice_put_mixer)
+};
+
+static const struct snd_kcontrol_new quinary_mi2s_rx_mixer_controls[] = {
+	SOC_SINGLE_EXT("CS-Voice", QUINARY_MI2S_RX, 0, 1, 0,
+		       q6voice_get_mixer, q6voice_put_mixer)
+};
+
+static const struct snd_soc_dapm_widget q6voice_dapm_widgets[] = {
+	SND_SOC_DAPM_AIF_IN("CS-VOICE_DL1", "CS-VOICE Playback", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("CS-VOICE_UL1", "CS-VOICE Capture", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_MIXER("CS-Voice Capture Mixer", SND_SOC_NOPM, 0, 0,
+			   voice_tx_mixer_controls,
+			   ARRAY_SIZE(voice_tx_mixer_controls)),
+	SND_SOC_DAPM_MIXER("PRI_MI2S_RX Voice Mixer", SND_SOC_NOPM, 0, 0,
+			   primary_mi2s_rx_mixer_controls,
+			   ARRAY_SIZE(primary_mi2s_rx_mixer_controls)),
+	SND_SOC_DAPM_MIXER("SEC_MI2S_RX Voice Mixer", SND_SOC_NOPM, 0, 0,
+			   secondary_mi2s_rx_mixer_controls,
+			   ARRAY_SIZE(secondary_mi2s_rx_mixer_controls)),
+	SND_SOC_DAPM_MIXER("TERT_MI2S_RX Voice Mixer", SND_SOC_NOPM, 0, 0,
+			   tertiary_mi2s_rx_mixer_controls,
+			   ARRAY_SIZE(tertiary_mi2s_rx_mixer_controls)),
+	SND_SOC_DAPM_MIXER("QUAT_MI2S_RX Voice Mixer", SND_SOC_NOPM, 0, 0,
+			   quaternary_mi2s_rx_mixer_controls,
+			   ARRAY_SIZE(quaternary_mi2s_rx_mixer_controls)),
+	SND_SOC_DAPM_MIXER("QUIN_MI2S_RX Voice Mixer", SND_SOC_NOPM, 0, 0,
+			   quinary_mi2s_rx_mixer_controls,
+			   ARRAY_SIZE(quinary_mi2s_rx_mixer_controls)),
+};
+
+static const struct snd_soc_dapm_route q6voice_dapm_routes[] = {
+	{ "CS-Voice Capture Mixer",	"PRI_MI2S_TX",	"PRI_MI2S_TX" },
+	{ "CS-Voice Capture Mixer",	"SEC_MI2S_TX",	"SEC_MI2S_TX" },
+	{ "CS-Voice Capture Mixer",	"TERT_MI2S_TX",	"TERT_MI2S_TX" },
+	{ "CS-Voice Capture Mixer",	"QUAT_MI2S_TX",	"QUAT_MI2S_TX" },
+	{ "CS-Voice Capture Mixer",	"QUIN_MI2S_TX",	"QUIN_MI2S_TX" },
+	{ "CS-VOICE_UL1",		NULL,		"CS-Voice Capture Mixer" },
+
+	{ "PRI_MI2S_RX Voice Mixer",	"CS-Voice",	"CS-VOICE_DL1" },
+	{ "SEC_MI2S_RX Voice Mixer",	"CS-Voice",	"CS-VOICE_DL1" },
+	{ "TERT_MI2S_RX Voice Mixer",	"CS-Voice",	"CS-VOICE_DL1" },
+	{ "QUAT_MI2S_RX Voice Mixer",	"CS-Voice",	"CS-VOICE_DL1" },
+	{ "QUIN_MI2S_RX Voice Mixer",	"CS-Voice",	"CS-VOICE_DL1" },
+	{ "PRI_MI2S_RX",		NULL,		"PRI_MI2S_RX Voice Mixer" },
+	{ "SEC_MI2S_RX",		NULL,		"SEC_MI2S_RX Voice Mixer" },
+	{ "TERT_MI2S_RX",		NULL,		"TERT_MI2S_RX Voice Mixer" },
+	{ "QUAT_MI2S_RX",		NULL,		"QUAT_MI2S_RX Voice Mixer" },
+	{ "QUIN_MI2S_RX",		NULL,		"QUIN_MI2S_RX Voice Mixer" },
+};
+
+static unsigned int q6voice_reg_read(struct snd_soc_component *component,
+				     unsigned int reg)
+{
+	/* default value */
+	return 0;
+}
+
+static int q6voice_reg_write(struct snd_soc_component *component,
+			     unsigned int reg, unsigned int val)
+{
+	/* dummy */
+	return 0;
+}
+
+static const struct snd_soc_component_driver q6voice_dai_component = {
+	.name = DRV_NAME,
+	.open = q6voice_dai_open,
+
+	.dapm_widgets = q6voice_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(q6voice_dapm_widgets),
+	.dapm_routes = q6voice_dapm_routes,
+	.num_dapm_routes = ARRAY_SIZE(q6voice_dapm_routes),
+	.read = q6voice_reg_read,
+	.write = q6voice_reg_write,
+
+	/* Needs to probe after q6afe */
+	.probe_order = SND_SOC_COMP_ORDER_LATE,
+};
+
+static int q6voice_dai_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct q6voice *v;
+
+	v = q6voice_create(dev);
+	if (IS_ERR(v))
+		return PTR_ERR(v);
+
+	dev_set_drvdata(dev, v);
+
+	return devm_snd_soc_register_component(dev, &q6voice_dai_component,
+					       q6voice_dais,
+					       ARRAY_SIZE(q6voice_dais));
+}
+
+static const struct of_device_id q6voice_dai_device_id[] = {
+	{ .compatible = "qcom,q6voice-dais" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, q6voice_dai_device_id);
+
+static struct platform_driver q6voice_dai_platform_driver = {
+	.driver = {
+		.name = "q6voice-dai",
+		.of_match_table = of_match_ptr(q6voice_dai_device_id),
+	},
+	.probe = q6voice_dai_probe,
+};
+module_platform_driver(q6voice_dai_platform_driver);
+
+MODULE_AUTHOR("Stephan Gerhold <stephan@gerhold.net>");
+MODULE_DESCRIPTION("Q6Voice DAI driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/qcom/qdsp6/q6voice.c b/sound/soc/qcom/qdsp6/q6voice.c
new file mode 100644
index 000000000000..d5751905a731
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6voice.c
@@ -0,0 +1,265 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2012-2017, The Linux Foundation. All rights reserved.
+// Copyright (c) 2020, Stephan Gerhold
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include "q6afe.h"
+#include "q6cvp.h"
+#include "q6cvs.h"
+#include "q6mvm.h"
+#include "q6voice-common.h"
+
+struct q6voice_path_runtime {
+	struct q6voice_session *sessions[Q6VOICE_SERVICE_COUNT];
+	unsigned int started;
+};
+
+struct q6voice_path {
+	struct q6voice *v;
+
+	enum q6voice_path_type type;
+	int tx_port, rx_port;
+	/* Serialize access to voice path session */
+	struct mutex lock;
+	struct q6voice_path_runtime *runtime;
+};
+
+struct q6voice {
+	struct device *dev;
+	struct q6voice_path paths[Q6VOICE_PATH_COUNT];
+};
+
+static int q6voice_path_start(struct q6voice_path *p)
+{
+	struct device *dev = p->v->dev;
+	struct q6voice_session *mvm, *cvp;
+	int ret;
+
+	dev_dbg(dev, "start path %d\n", p->type);
+
+	mvm = p->runtime->sessions[Q6VOICE_SERVICE_MVM];
+	if (!mvm) {
+		mvm = q6mvm_session_create(p->type);
+		if (IS_ERR(mvm))
+			return PTR_ERR(mvm);
+		p->runtime->sessions[Q6VOICE_SERVICE_MVM] = mvm;
+	}
+
+	cvp = p->runtime->sessions[Q6VOICE_SERVICE_CVP];
+	if (!cvp) {
+		cvp = q6cvp_session_create(p->type,
+					   q6afe_get_port_id(p->tx_port),
+					   q6afe_get_port_id(p->rx_port));
+		if (IS_ERR(cvp))
+			return PTR_ERR(cvp);
+		p->runtime->sessions[Q6VOICE_SERVICE_CVP] = cvp;
+	}
+
+	ret = q6cvp_enable(cvp, true);
+	if (ret) {
+		dev_err(dev, "failed to enable cvp: %d\n", ret);
+		goto cvp_err;
+	}
+
+	ret = q6mvm_attach(mvm, cvp, true);
+	if (ret) {
+		dev_err(dev, "failed to attach cvp to mvm: %d\n", ret);
+		goto attach_err;
+	}
+
+	ret = q6mvm_start(mvm, true);
+	if (ret) {
+		dev_err(dev, "failed to start voice: %d\n", ret);
+		goto start_err;
+	}
+
+	return ret;
+
+start_err:
+	q6mvm_start(mvm, false);
+attach_err:
+	q6mvm_attach(mvm, cvp, false);
+cvp_err:
+	q6cvp_enable(cvp, false);
+	return ret;
+}
+
+int q6voice_start(struct q6voice *v, enum q6voice_path_type path, bool capture)
+{
+	struct q6voice_path *p = &v->paths[path];
+	int ret = 0;
+
+	mutex_lock(&p->lock);
+	if (!p->runtime) {
+		p->runtime = kzalloc(sizeof(*p), GFP_KERNEL);
+		if (!p->runtime) {
+			ret = -ENOMEM;
+			goto out;
+		}
+	}
+
+	if (p->runtime->started & BIT(capture)) {
+		ret = -EALREADY;
+		goto out;
+	}
+
+	p->runtime->started |= BIT(capture);
+
+	/* FIXME: For now we only start if both RX/TX are active */
+	if (p->runtime->started != 3)
+		goto out;
+
+	ret = q6voice_path_start(p);
+	if (ret) {
+		p->runtime->started &= ~BIT(capture);
+		dev_err(v->dev, "failed to start path %d: %d\n", path, ret);
+		goto out;
+	}
+
+out:
+	mutex_unlock(&p->lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(q6voice_start);
+
+static void q6voice_path_stop(struct q6voice_path *p)
+{
+	struct device *dev = p->v->dev;
+	struct q6voice_session *mvm = p->runtime->sessions[Q6VOICE_SERVICE_MVM];
+	struct q6voice_session *cvp = p->runtime->sessions[Q6VOICE_SERVICE_CVP];
+	int ret;
+
+	dev_dbg(dev, "stop path %d\n", p->type);
+
+	ret = q6mvm_start(mvm, false);
+	if (ret)
+		dev_err(dev, "failed to stop voice: %d\n", ret);
+
+	ret = q6mvm_attach(mvm, cvp, false);
+	if (ret)
+		dev_err(dev, "failed to detach cvp from mvm: %d\n", ret);
+
+	ret = q6cvp_enable(cvp, false);
+	if (ret)
+		dev_err(dev, "failed to disable cvp: %d\n", ret);
+}
+
+static void q6voice_path_destroy(struct q6voice_path *p)
+{
+	struct q6voice_path_runtime *runtime = p->runtime;
+	enum q6voice_service_type svc;
+
+	for (svc = 0; svc < Q6VOICE_SERVICE_COUNT; ++svc) {
+		if (runtime->sessions[svc])
+			q6voice_session_release(runtime->sessions[svc]);
+	}
+
+	p->runtime = NULL;
+	kfree(runtime);
+}
+
+int q6voice_stop(struct q6voice *v, enum q6voice_path_type path, bool capture)
+{
+	struct q6voice_path *p = &v->paths[path];
+	int ret = 0;
+
+	mutex_lock(&p->lock);
+	if (!p->runtime || !(p->runtime->started & BIT(capture)))
+		goto out;
+
+	if (p->runtime->started == 3)
+		q6voice_path_stop(p);
+
+	p->runtime->started &= ~BIT(capture);
+
+	if (p->runtime->started == 0)
+		q6voice_path_destroy(p);
+
+out:
+	mutex_unlock(&p->lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(q6voice_stop);
+
+static void q6voice_free(void *data)
+{
+	struct q6voice *v = data;
+	enum q6voice_path_type path;
+
+	for (path = 0; path < Q6VOICE_PATH_COUNT; ++path) {
+		struct q6voice_path *p = &v->paths[path];
+
+		mutex_lock(&p->lock);
+		if (p->runtime) {
+			dev_warn(v->dev,
+				 "q6voice_remove() called while path %d is active\n",
+				 path);
+
+			if (p->runtime->started == 3)
+				q6voice_path_stop(p);
+			q6voice_path_destroy(p);
+		}
+		mutex_unlock(&p->lock);
+		mutex_destroy(&p->lock);
+	}
+}
+
+struct q6voice *q6voice_create(struct device *dev)
+{
+	struct q6voice *v;
+	enum q6voice_path_type path;
+	int ret;
+
+	v = devm_kzalloc(dev, sizeof(*v), GFP_KERNEL);
+	if (!v)
+		return ERR_PTR(-ENOMEM);
+
+	v->dev = dev;
+
+	for (path = 0; path < Q6VOICE_PATH_COUNT; ++path) {
+		struct q6voice_path *p = &v->paths[path];
+
+		p->v = v;
+		p->type = path;
+		mutex_init(&p->lock);
+	}
+
+	ret = devm_add_action(dev, q6voice_free, v);
+	if (ret)
+		return ERR_PTR(ret);
+
+	return v;
+}
+EXPORT_SYMBOL_GPL(q6voice_create);
+
+int q6voice_get_port(struct q6voice *v, enum q6voice_path_type path,
+		     bool capture)
+{
+	struct q6voice_path *p = &v->paths[path];
+
+	if (capture)
+		return p->tx_port;
+	else
+		return p->rx_port;
+}
+EXPORT_SYMBOL_GPL(q6voice_get_port);
+
+void q6voice_set_port(struct q6voice *v, enum q6voice_path_type path,
+		      bool capture, int index)
+{
+	struct q6voice_path *p = &v->paths[path];
+
+	if (capture)
+		p->tx_port = index;
+	else
+		p->rx_port = index;
+}
+EXPORT_SYMBOL_GPL(q6voice_set_port);
+
+MODULE_AUTHOR("Stephan Gerhold <stephan@gerhold.net>");
+MODULE_DESCRIPTION("Q6Voice driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/qcom/qdsp6/q6voice.h b/sound/soc/qcom/qdsp6/q6voice.h
new file mode 100644
index 000000000000..5b2d2dd679b3
--- /dev/null
+++ b/sound/soc/qcom/qdsp6/q6voice.h
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _Q6_VOICE_H
+#define _Q6_VOICE_H
+
+enum q6voice_path_type {
+	Q6VOICE_PATH_VOICE	= 0,
+	/* TODO: Q6VOICE_PATH_VOIP	= 1, */
+	/* TODO: Q6VOICE_PATH_VOLTE	= 2, */
+	/* TODO: Q6VOICE_PATH_VOICE2	= 3, */
+	/* TODO: Q6VOICE_PATH_QCHAT	= 4, */
+	/* TODO: Q6VOICE_PATH_VOWLAN	= 5, */
+	/* TODO: Q6VOICE_PATH_VOICEMMODE1	= 6, */
+	/* TODO: Q6VOICE_PATH_VOICEMMODE2	= 7, */
+	Q6VOICE_PATH_COUNT
+};
+
+struct q6voice;
+
+struct q6voice *q6voice_create(struct device *dev);
+int q6voice_start(struct q6voice *v, enum q6voice_path_type path, bool capture);
+int q6voice_stop(struct q6voice *v, enum q6voice_path_type path, bool capture);
+
+int q6voice_get_port(struct q6voice *v, enum q6voice_path_type path,
+		     bool capture);
+void q6voice_set_port(struct q6voice *v, enum q6voice_path_type path,
+		      bool capture, int index);
+
+#endif /*_Q6_VOICE_H */
